/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/Users/liuyun/code/sdk/webim/webrtc";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(1);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var Util = (__webpack_require__(2).default);
var Call = __webpack_require__(6);

var emedia = __webpack_require__(3);

window.WebIM = typeof WebIM !== 'undefined' ? WebIM : {};
WebIM.WebRTC = WebIM.WebRTC || {};
WebIM.WebRTC.Call = Call;
WebIM.WebRTC.Util = Util;

WebIM.__alreadyOpenMedias = [];

if ( true && typeof module.exports === 'object') {
    module.exports = WebIM.WebRTC;
} else if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
        return WebIM.WebRTC;
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}


// /**
//  * 判断是否支持pranswer
//  */
// if (/Firefox/.test(navigator.userAgent)) {
//     //WebIM.WebRTC.supportPRAnswer = (navigator.userAgent.split("Chrome/")[1].split(".")[0] >= 50) ? true : false;
//     WebIM.WebRTC.supportPRAnswer = false;
// }else{
//     WebIM.WebRTC.supportPRAnswer = true;
// }
WebIM.WebRTC.supportPRAnswer = emedia.supportPRAnswer;

console && console.warn('Webrtc version', 'Git.e4f0006');

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var easemob_emedia__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var easemob_emedia__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(easemob_emedia__WEBPACK_IMPORTED_MODULE_0__);

/* harmony default export */ __webpack_exports__["default"] = (easemob_emedia__WEBPACK_IMPORTED_MODULE_0__["util"]);

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

//var emedia = require('/Users/DATA/WORK.HOME/projects/CO./EASEMOB_2016.05.03~/EMedia/webrtc/dist/EMedia_sdk-dev');
var emedia = __webpack_require__(4);
module.exports = emedia;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;var require;(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/Users/DATA/WORK.HOME/projects/CO./EASEMOB_2016.05.03~/EMedia";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 13);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */,
/* 1 */,
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

var adapter;

if (!!document.documentMode) {
    // Detect IE (6-11)
    var hasMatch = /\brv[ :]+(\d+)/g.exec(navigator.userAgent) || [];

    var webrtcDetectedBrowser = 'IE';
    var webrtcDetectedVersion = parseInt(hasMatch[1], 10);
    var webrtcMinimumVersion = 9;
    var webrtcDetectedType = 'plugin';
    var webrtcDetectedDCSupport = 'SCTP';

    if (!webrtcDetectedVersion) {
        hasMatch = /\bMSIE[ :]+(\d+)/g.exec(navigator.userAgent) || [];

        webrtcDetectedVersion = parseInt(hasMatch[1] || '0', 10);
    }

    //adapter = require('./adapter.ie');
    logger.error("adapter.ie not required");

    adapter.__browser = webrtcDetectedBrowser;
    adapter.__browserVersion = webrtcDetectedVersion;

    //adapter = require('./Temasys.wrapper'); //6.0.3
} else {
    adapter = __webpack_require__(3); //6.2.0
    wrapAttachMediaStream();
}

adapter.__browser = adapter.__browser || adapter.browserDetails.browser; // firefox chrome safari
adapter.__browserVersion = adapter.__browserVersion || adapter.browserDetails.version;

console && typeof console.info === "function" && console.info("Current browser", adapter.__browser, adapter.__browserVersion);

if ("Not a supported browser." === adapter.__browser) {
    throw "Not a supported browser";
}

module.exports = adapter;

function wrapAttachMediaStream() {
    function _attachMediaStream(element, stream) {
        element.srcObject = stream;
    }

    /**
     * muted undefined, stream _located true 时muted
     *
     * @param element
     * @param stream
     * @param muted
     * @returns {*}
     */
    function easemobAttachMediaStream(element, stream, muted, _fun) {
        function mute() {
            muted = !!(muted === undefined ? stream._located : muted);

            //为了解决某些手机mute造成本地图像卡的问题
            element.muted = false;
            if (muted !== element.muted) {
                element.muted = true;
            }
        }

        _fun || (_fun = window.__attachMediaStream) || (_fun = _attachMediaStream);

        if (!element) {
            return;
        }

        if (!stream) {
            _fun(element, stream);
            return;
        }

        if (!element.srcObject) {
            mute();
            _fun(element, stream);
            return element;
        }

        if (element.srcObject._located //old stream 也是 _located
        && stream._located && element.srcObject.id === stream.id) {
            return element.srcObject;
        }

        mute();
        _fun(element, stream);

        return element;
    }

    if (window.attachMediaStream && window.attachMediaStream._wrapped !== true) {
        window.__attachMediaStream = window.attachMediaStream;
    }

    window.attachMediaStream = easemobAttachMediaStream;
    window.attachMediaStream._wrapped = true;
    console && typeof console.info === "function" && console.info("Wrap the attachMediaStream ", adapter.__browser, adapter.__browserVersion);
}

/***/ }),
/* 3 */
/***/ (function(module, exports) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//6.2.0
(function (f) {
    if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === "object" && typeof module !== "undefined") {
        module.exports = f();
    } else if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else { var g; }
})(function () {
    var define, module, exports;return function e(t, n, r) {
        function s(o, u) {
            if (!n[o]) {
                if (!t[o]) {
                    var a = typeof require == "function" && require;if (!u && a) return require(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
                }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                    var n = t[o][1][e];return s(n ? n : e);
                }, l, l.exports, e, t, n, r);
            }return n[o].exports;
        }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
            s(r[o]);
        }return s;
    }({ 1: [function (require, module, exports) {
            /*
             *  Version: 6.2.0
             *
             *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
             *
             *  Use of this source code is governed by a BSD-style license
             *  that can be found in the LICENSE file in the root of the source
             *  tree.
             */
            /* eslint-env node */
            'use strict';

            var SDPUtils = require('sdp');

            function fixStatsType(stat) {
                return {
                    inboundrtp: 'inbound-rtp',
                    outboundrtp: 'outbound-rtp',
                    candidatepair: 'candidate-pair',
                    localcandidate: 'local-candidate',
                    remotecandidate: 'remote-candidate'
                }[stat.type] || stat.type;
            }

            function writeMediaSection(transceiver, caps, type, stream, dtlsRole) {
                var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

                // Map ICE parameters (ufrag, pwd) to SDP.
                sdp += SDPUtils.writeIceParameters(transceiver.iceGatherer.getLocalParameters());

                // Map DTLS parameters to SDP.
                sdp += SDPUtils.writeDtlsParameters(transceiver.dtlsTransport.getLocalParameters(), type === 'offer' ? 'actpass' : dtlsRole || 'active');

                sdp += 'a=mid:' + transceiver.mid + '\r\n';

                if (transceiver.rtpSender && transceiver.rtpReceiver) {
                    sdp += 'a=sendrecv\r\n';
                } else if (transceiver.rtpSender) {
                    sdp += 'a=sendonly\r\n';
                } else if (transceiver.rtpReceiver) {
                    sdp += 'a=recvonly\r\n';
                } else {
                    sdp += 'a=inactive\r\n';
                }

                if (transceiver.rtpSender) {
                    var trackId = transceiver.rtpSender._initialTrackId || transceiver.rtpSender.track.id;
                    transceiver.rtpSender._initialTrackId = trackId;
                    // spec.
                    var msid = 'msid:' + (stream ? stream.id : '-') + ' ' + trackId + '\r\n';
                    sdp += 'a=' + msid;
                    // for Chrome. Legacy should no longer be required.
                    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc + ' ' + msid;

                    // RTX
                    if (transceiver.sendEncodingParameters[0].rtx) {
                        sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc + ' ' + msid;
                        sdp += 'a=ssrc-group:FID ' + transceiver.sendEncodingParameters[0].ssrc + ' ' + transceiver.sendEncodingParameters[0].rtx.ssrc + '\r\n';
                    }
                }
                // FIXME: this should be written by writeRtpDescription.
                sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc + ' cname:' + SDPUtils.localCName + '\r\n';
                if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
                    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc + ' cname:' + SDPUtils.localCName + '\r\n';
                }
                return sdp;
            }

            // Edge does not like
            // 1) stun: filtered after 14393 unless ?transport=udp is present
            // 2) turn: that does not have all of turn:host:port?transport=udp
            // 3) turn: with ipv6 addresses
            // 4) turn: occurring muliple times
            function filterIceServers(iceServers, edgeVersion) {
                var hasTurn = false;
                iceServers = JSON.parse(JSON.stringify(iceServers));
                return iceServers.filter(function (server) {
                    if (server && (server.urls || server.url)) {
                        var urls = server.urls || server.url;
                        if (server.url && !server.urls) {
                            console.warn('RTCIceServer.url is deprecated! Use urls instead.');
                        }
                        var isString = typeof urls === 'string';
                        if (isString) {
                            urls = [urls];
                        }
                        urls = urls.filter(function (url) {
                            var validTurn = url.indexOf('turn:') === 0 && url.indexOf('transport=udp') !== -1 && url.indexOf('turn:[') === -1 && !hasTurn;

                            if (validTurn) {
                                hasTurn = true;
                                return true;
                            }
                            return url.indexOf('stun:') === 0 && edgeVersion >= 14393 && url.indexOf('?transport=udp') === -1;
                        });

                        delete server.url;
                        server.urls = isString ? urls[0] : urls;
                        return !!urls.length;
                    }
                });
            }

            // Determines the intersection of local and remote capabilities.
            function getCommonCapabilities(localCapabilities, remoteCapabilities) {
                var commonCapabilities = {
                    codecs: [],
                    headerExtensions: [],
                    fecMechanisms: []
                };

                var findCodecByPayloadType = function findCodecByPayloadType(pt, codecs) {
                    pt = parseInt(pt, 10);
                    for (var i = 0; i < codecs.length; i++) {
                        if (codecs[i].payloadType === pt || codecs[i].preferredPayloadType === pt) {
                            return codecs[i];
                        }
                    }
                };

                var rtxCapabilityMatches = function rtxCapabilityMatches(lRtx, rRtx, lCodecs, rCodecs) {
                    var lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs);
                    var rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs);
                    return lCodec && rCodec && lCodec.name.toLowerCase() === rCodec.name.toLowerCase();
                };

                localCapabilities.codecs.forEach(function (lCodec) {
                    for (var i = 0; i < remoteCapabilities.codecs.length; i++) {
                        var rCodec = remoteCapabilities.codecs[i];
                        if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() && lCodec.clockRate === rCodec.clockRate) {
                            if (lCodec.name.toLowerCase() === 'rtx' && lCodec.parameters && rCodec.parameters.apt) {
                                // for RTX we need to find the local rtx that has a apt
                                // which points to the same local codec as the remote one.
                                if (!rtxCapabilityMatches(lCodec, rCodec, localCapabilities.codecs, remoteCapabilities.codecs)) {
                                    continue;
                                }
                            }
                            rCodec = JSON.parse(JSON.stringify(rCodec)); // deepcopy
                            // number of channels is the highest common number of channels
                            rCodec.numChannels = Math.min(lCodec.numChannels, rCodec.numChannels);
                            // push rCodec so we reply with offerer payload type
                            commonCapabilities.codecs.push(rCodec);

                            // determine common feedback mechanisms
                            rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function (fb) {
                                for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {
                                    if (lCodec.rtcpFeedback[j].type === fb.type && lCodec.rtcpFeedback[j].parameter === fb.parameter) {
                                        return true;
                                    }
                                }
                                return false;
                            });
                            // FIXME: also need to determine .parameters
                            //  see https://github.com/openpeer/ortc/issues/569
                            break;
                        }
                    }
                });

                localCapabilities.headerExtensions.forEach(function (lHeaderExtension) {
                    for (var i = 0; i < remoteCapabilities.headerExtensions.length; i++) {
                        var rHeaderExtension = remoteCapabilities.headerExtensions[i];
                        if (lHeaderExtension.uri === rHeaderExtension.uri) {
                            commonCapabilities.headerExtensions.push(rHeaderExtension);
                            break;
                        }
                    }
                });

                // FIXME: fecMechanisms
                return commonCapabilities;
            }

            // is action=setLocalDescription with type allowed in signalingState
            function isActionAllowedInSignalingState(action, type, signalingState) {
                return {
                    offer: {
                        setLocalDescription: ['stable', 'have-local-offer'],
                        setRemoteDescription: ['stable', 'have-remote-offer']
                    },
                    answer: {
                        setLocalDescription: ['have-remote-offer', 'have-local-pranswer'],
                        setRemoteDescription: ['have-local-offer', 'have-remote-pranswer']
                    }
                }[type][action].indexOf(signalingState) !== -1;
            }

            function maybeAddCandidate(iceTransport, candidate) {
                // Edge's internal representation adds some fields therefore
                // not all fieldѕ are taken into account.
                var alreadyAdded = iceTransport.getRemoteCandidates().find(function (remoteCandidate) {
                    return candidate.foundation === remoteCandidate.foundation && candidate.ip === remoteCandidate.ip && candidate.port === remoteCandidate.port && candidate.priority === remoteCandidate.priority && candidate.protocol === remoteCandidate.protocol && candidate.type === remoteCandidate.type;
                });
                if (!alreadyAdded) {
                    iceTransport.addRemoteCandidate(candidate);
                }
                return !alreadyAdded;
            }

            function makeError(name, description) {
                var e = new Error(description);
                e.name = name;
                // legacy error codes from https://heycam.github.io/webidl/#idl-DOMException-error-names
                e.code = {
                    NotSupportedError: 9,
                    InvalidStateError: 11,
                    InvalidAccessError: 15,
                    TypeError: undefined,
                    OperationError: undefined
                }[name];
                return e;
            }

            module.exports = function (window, edgeVersion) {
                // https://w3c.github.io/mediacapture-main/#mediastream
                // Helper function to add the track to the stream and
                // dispatch the event ourselves.
                function addTrackToStreamAndFireEvent(track, stream) {
                    stream.addTrack(track);
                    stream.dispatchEvent(new window.MediaStreamTrackEvent('addtrack', { track: track }));
                }

                function removeTrackFromStreamAndFireEvent(track, stream) {
                    stream.removeTrack(track);
                    stream.dispatchEvent(new window.MediaStreamTrackEvent('removetrack', { track: track }));
                }

                function fireAddTrack(pc, track, receiver, streams) {
                    var trackEvent = new Event('track');
                    trackEvent.track = track;
                    trackEvent.receiver = receiver;
                    trackEvent.transceiver = { receiver: receiver };
                    trackEvent.streams = streams;
                    window.setTimeout(function () {
                        pc._dispatchEvent('track', trackEvent);
                    });
                }

                var RTCPeerConnection = function RTCPeerConnection(config) {
                    var pc = this;

                    var _eventTarget = document.createDocumentFragment();
                    ['addEventListener', 'removeEventListener', 'dispatchEvent'].forEach(function (method) {
                        pc[method] = _eventTarget[method].bind(_eventTarget);
                    });

                    this.canTrickleIceCandidates = null;

                    this.needNegotiation = false;

                    this.localStreams = [];
                    this.remoteStreams = [];

                    this.localDescription = null;
                    this.remoteDescription = null;

                    this.signalingState = 'stable';
                    this.iceConnectionState = 'new';
                    this.connectionState = 'new';
                    this.iceGatheringState = 'new';

                    config = JSON.parse(JSON.stringify(config || {}));

                    this.usingBundle = config.bundlePolicy === 'max-bundle';
                    if (config.rtcpMuxPolicy === 'negotiate') {
                        throw makeError('NotSupportedError', 'rtcpMuxPolicy \'negotiate\' is not supported');
                    } else if (!config.rtcpMuxPolicy) {
                        config.rtcpMuxPolicy = 'require';
                    }

                    switch (config.iceTransportPolicy) {
                        case 'all':
                        case 'relay':
                            break;
                        default:
                            config.iceTransportPolicy = 'all';
                            break;
                    }

                    switch (config.bundlePolicy) {
                        case 'balanced':
                        case 'max-compat':
                        case 'max-bundle':
                            break;
                        default:
                            config.bundlePolicy = 'balanced';
                            break;
                    }

                    config.iceServers = filterIceServers(config.iceServers || [], edgeVersion);

                    this._iceGatherers = [];
                    if (config.iceCandidatePoolSize) {
                        for (var i = config.iceCandidatePoolSize; i > 0; i--) {
                            this._iceGatherers.push(new window.RTCIceGatherer({
                                iceServers: config.iceServers,
                                gatherPolicy: config.iceTransportPolicy
                            }));
                        }
                    } else {
                        config.iceCandidatePoolSize = 0;
                    }

                    this._config = config;

                    // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...
                    // everything that is needed to describe a SDP m-line.
                    this.transceivers = [];

                    this._sdpSessionId = SDPUtils.generateSessionId();
                    this._sdpSessionVersion = 0;

                    this._dtlsRole = undefined; // role for a=setup to use in answers.

                    this._isClosed = false;
                };

                // set up event handlers on prototype
                RTCPeerConnection.prototype.onicecandidate = null;
                RTCPeerConnection.prototype.onaddstream = null;
                RTCPeerConnection.prototype.ontrack = null;
                RTCPeerConnection.prototype.onremovestream = null;
                RTCPeerConnection.prototype.onsignalingstatechange = null;
                RTCPeerConnection.prototype.oniceconnectionstatechange = null;
                RTCPeerConnection.prototype.onconnectionstatechange = null;
                RTCPeerConnection.prototype.onicegatheringstatechange = null;
                RTCPeerConnection.prototype.onnegotiationneeded = null;
                RTCPeerConnection.prototype.ondatachannel = null;

                RTCPeerConnection.prototype._dispatchEvent = function (name, event) {
                    if (this._isClosed) {
                        return;
                    }
                    this.dispatchEvent(event);
                    if (typeof this['on' + name] === 'function') {
                        this['on' + name](event);
                    }
                };

                RTCPeerConnection.prototype._emitGatheringStateChange = function () {
                    var event = new Event('icegatheringstatechange');
                    this._dispatchEvent('icegatheringstatechange', event);
                };

                RTCPeerConnection.prototype.getConfiguration = function () {
                    return this._config;
                };

                RTCPeerConnection.prototype.getLocalStreams = function () {
                    return this.localStreams;
                };

                RTCPeerConnection.prototype.getRemoteStreams = function () {
                    return this.remoteStreams;
                };

                // internal helper to create a transceiver object.
                // (which is not yet the same as the WebRTC 1.0 transceiver)
                RTCPeerConnection.prototype._createTransceiver = function (kind, doNotAdd) {
                    var hasBundleTransport = this.transceivers.length > 0;
                    var transceiver = {
                        track: null,
                        iceGatherer: null,
                        iceTransport: null,
                        dtlsTransport: null,
                        localCapabilities: null,
                        remoteCapabilities: null,
                        rtpSender: null,
                        rtpReceiver: null,
                        kind: kind,
                        mid: null,
                        sendEncodingParameters: null,
                        recvEncodingParameters: null,
                        stream: null,
                        associatedRemoteMediaStreams: [],
                        wantReceive: true
                    };
                    if (this.usingBundle && hasBundleTransport) {
                        transceiver.iceTransport = this.transceivers[0].iceTransport;
                        transceiver.dtlsTransport = this.transceivers[0].dtlsTransport;
                    } else {
                        var transports = this._createIceAndDtlsTransports();
                        transceiver.iceTransport = transports.iceTransport;
                        transceiver.dtlsTransport = transports.dtlsTransport;
                    }
                    if (!doNotAdd) {
                        this.transceivers.push(transceiver);
                    }
                    return transceiver;
                };

                RTCPeerConnection.prototype.addTrack = function (track, stream) {
                    if (this._isClosed) {
                        throw makeError('InvalidStateError', 'Attempted to call addTrack on a closed peerconnection.');
                    }

                    var alreadyExists = this.transceivers.find(function (s) {
                        return s.track === track;
                    });

                    if (alreadyExists) {
                        throw makeError('InvalidAccessError', 'Track already exists.');
                    }

                    var transceiver;
                    for (var i = 0; i < this.transceivers.length; i++) {
                        if (!this.transceivers[i].track && this.transceivers[i].kind === track.kind) {
                            transceiver = this.transceivers[i];
                        }
                    }
                    if (!transceiver) {
                        transceiver = this._createTransceiver(track.kind);
                    }

                    this._maybeFireNegotiationNeeded();

                    if (this.localStreams.indexOf(stream) === -1) {
                        this.localStreams.push(stream);
                    }

                    transceiver.track = track;
                    transceiver.stream = stream;
                    transceiver.rtpSender = new window.RTCRtpSender(track, transceiver.dtlsTransport);
                    return transceiver.rtpSender;
                };

                RTCPeerConnection.prototype.addStream = function (stream) {
                    var pc = this;
                    if (edgeVersion >= 15025) {
                        stream.getTracks().forEach(function (track) {
                            pc.addTrack(track, stream);
                        });
                    } else {
                        // Clone is necessary for local demos mostly, attaching directly
                        // to two different senders does not work (build 10547).
                        // Fixed in 15025 (or earlier)
                        var clonedStream = stream.clone();
                        stream.getTracks().forEach(function (track, idx) {
                            var clonedTrack = clonedStream.getTracks()[idx];
                            track.addEventListener('enabled', function (event) {
                                clonedTrack.enabled = event.enabled;
                            });
                        });
                        clonedStream.getTracks().forEach(function (track) {
                            pc.addTrack(track, clonedStream);
                        });
                    }
                };

                RTCPeerConnection.prototype.removeTrack = function (sender) {
                    if (this._isClosed) {
                        throw makeError('InvalidStateError', 'Attempted to call removeTrack on a closed peerconnection.');
                    }

                    if (!(sender instanceof window.RTCRtpSender)) {
                        throw new TypeError('Argument 1 of RTCPeerConnection.removeTrack ' + 'does not implement interface RTCRtpSender.');
                    }

                    var transceiver = this.transceivers.find(function (t) {
                        return t.rtpSender === sender;
                    });

                    if (!transceiver) {
                        throw makeError('InvalidAccessError', 'Sender was not created by this connection.');
                    }
                    var stream = transceiver.stream;

                    transceiver.rtpSender.stop();
                    transceiver.rtpSender = null;
                    transceiver.track = null;
                    transceiver.stream = null;

                    // remove the stream from the set of local streams
                    var localStreams = this.transceivers.map(function (t) {
                        return t.stream;
                    });
                    if (localStreams.indexOf(stream) === -1 && this.localStreams.indexOf(stream) > -1) {
                        this.localStreams.splice(this.localStreams.indexOf(stream), 1);
                    }

                    this._maybeFireNegotiationNeeded();
                };

                RTCPeerConnection.prototype.removeStream = function (stream) {
                    var pc = this;
                    stream.getTracks().forEach(function (track) {
                        var sender = pc.getSenders().find(function (s) {
                            return s.track === track;
                        });
                        if (sender) {
                            pc.removeTrack(sender);
                        }
                    });
                };

                RTCPeerConnection.prototype.getSenders = function () {
                    return this.transceivers.filter(function (transceiver) {
                        return !!transceiver.rtpSender;
                    }).map(function (transceiver) {
                        return transceiver.rtpSender;
                    });
                };

                RTCPeerConnection.prototype.getReceivers = function () {
                    return this.transceivers.filter(function (transceiver) {
                        return !!transceiver.rtpReceiver;
                    }).map(function (transceiver) {
                        return transceiver.rtpReceiver;
                    });
                };

                RTCPeerConnection.prototype._createIceGatherer = function (sdpMLineIndex, usingBundle) {
                    var pc = this;
                    if (usingBundle && sdpMLineIndex > 0) {
                        return this.transceivers[0].iceGatherer;
                    } else if (this._iceGatherers.length) {
                        return this._iceGatherers.shift();
                    }
                    var iceGatherer = new window.RTCIceGatherer({
                        iceServers: this._config.iceServers,
                        gatherPolicy: this._config.iceTransportPolicy
                    });
                    Object.defineProperty(iceGatherer, 'state', { value: 'new', writable: true });

                    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = [];
                    this.transceivers[sdpMLineIndex].bufferCandidates = function (event) {
                        var end = !event.candidate || Object.keys(event.candidate).length === 0;
                        // polyfill since RTCIceGatherer.state is not implemented in
                        // Edge 10547 yet.
                        iceGatherer.state = end ? 'completed' : 'gathering';
                        if (pc.transceivers[sdpMLineIndex].bufferedCandidateEvents !== null) {
                            pc.transceivers[sdpMLineIndex].bufferedCandidateEvents.push(event);
                        }
                    };
                    iceGatherer.addEventListener('localcandidate', this.transceivers[sdpMLineIndex].bufferCandidates);
                    return iceGatherer;
                };

                // start gathering from an RTCIceGatherer.
                RTCPeerConnection.prototype._gather = function (mid, sdpMLineIndex) {
                    var pc = this;
                    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
                    if (iceGatherer.onlocalcandidate) {
                        return;
                    }
                    var bufferedCandidateEvents = this.transceivers[sdpMLineIndex].bufferedCandidateEvents;
                    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = null;
                    iceGatherer.removeEventListener('localcandidate', this.transceivers[sdpMLineIndex].bufferCandidates);
                    iceGatherer.onlocalcandidate = function (evt) {
                        if (pc.usingBundle && sdpMLineIndex > 0) {
                            // if we know that we use bundle we can drop candidates with
                            // ѕdpMLineIndex > 0. If we don't do this then our state gets
                            // confused since we dispose the extra ice gatherer.
                            return;
                        }
                        var event = new Event('icecandidate');
                        event.candidate = { sdpMid: mid, sdpMLineIndex: sdpMLineIndex };

                        var cand = evt.candidate;
                        // Edge emits an empty object for RTCIceCandidateComplete‥
                        var end = !cand || Object.keys(cand).length === 0;
                        if (end) {
                            // polyfill since RTCIceGatherer.state is not implemented in
                            // Edge 10547 yet.
                            if (iceGatherer.state === 'new' || iceGatherer.state === 'gathering') {
                                iceGatherer.state = 'completed';
                            }
                        } else {
                            if (iceGatherer.state === 'new') {
                                iceGatherer.state = 'gathering';
                            }
                            // RTCIceCandidate doesn't have a component, needs to be added
                            cand.component = 1;
                            // also the usernameFragment. TODO: update SDP to take both variants.
                            cand.ufrag = iceGatherer.getLocalParameters().usernameFragment;

                            var serializedCandidate = SDPUtils.writeCandidate(cand);
                            event.candidate = Object.assign(event.candidate, SDPUtils.parseCandidate(serializedCandidate));

                            event.candidate.candidate = serializedCandidate;
                            event.candidate.toJSON = function () {
                                return {
                                    candidate: event.candidate.candidate,
                                    sdpMid: event.candidate.sdpMid,
                                    sdpMLineIndex: event.candidate.sdpMLineIndex,
                                    usernameFragment: event.candidate.usernameFragment
                                };
                            };
                        }

                        // update local description.
                        var sections = SDPUtils.getMediaSections(pc.localDescription.sdp);
                        if (!end) {
                            sections[event.candidate.sdpMLineIndex] += 'a=' + event.candidate.candidate + '\r\n';
                        } else {
                            sections[event.candidate.sdpMLineIndex] += 'a=end-of-candidates\r\n';
                        }
                        pc.localDescription.sdp = SDPUtils.getDescription(pc.localDescription.sdp) + sections.join('');
                        var complete = pc.transceivers.every(function (transceiver) {
                            return transceiver.iceGatherer && transceiver.iceGatherer.state === 'completed';
                        });

                        if (pc.iceGatheringState !== 'gathering') {
                            pc.iceGatheringState = 'gathering';
                            pc._emitGatheringStateChange();
                        }

                        // Emit candidate. Also emit null candidate when all gatherers are
                        // complete.
                        if (!end) {
                            pc._dispatchEvent('icecandidate', event);
                        }
                        if (complete) {
                            pc._dispatchEvent('icecandidate', new Event('icecandidate'));
                            pc.iceGatheringState = 'complete';
                            pc._emitGatheringStateChange();
                        }
                    };

                    // emit already gathered candidates.
                    window.setTimeout(function () {
                        bufferedCandidateEvents.forEach(function (e) {
                            iceGatherer.onlocalcandidate(e);
                        });
                    }, 0);
                };

                // Create ICE transport and DTLS transport.
                RTCPeerConnection.prototype._createIceAndDtlsTransports = function () {
                    var pc = this;
                    var iceTransport = new window.RTCIceTransport(null);
                    iceTransport.onicestatechange = function () {
                        pc._updateIceConnectionState();
                        pc._updateConnectionState();
                    };

                    var dtlsTransport = new window.RTCDtlsTransport(iceTransport);
                    dtlsTransport.ondtlsstatechange = function () {
                        pc._updateConnectionState();
                    };
                    dtlsTransport.onerror = function () {
                        // onerror does not set state to failed by itself.
                        Object.defineProperty(dtlsTransport, 'state', { value: 'failed', writable: true });
                        pc._updateConnectionState();
                    };

                    return {
                        iceTransport: iceTransport,
                        dtlsTransport: dtlsTransport
                    };
                };

                // Destroy ICE gatherer, ICE transport and DTLS transport.
                // Without triggering the callbacks.
                RTCPeerConnection.prototype._disposeIceAndDtlsTransports = function (sdpMLineIndex) {
                    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
                    if (iceGatherer) {
                        delete iceGatherer.onlocalcandidate;
                        delete this.transceivers[sdpMLineIndex].iceGatherer;
                    }
                    var iceTransport = this.transceivers[sdpMLineIndex].iceTransport;
                    if (iceTransport) {
                        delete iceTransport.onicestatechange;
                        delete this.transceivers[sdpMLineIndex].iceTransport;
                    }
                    var dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport;
                    if (dtlsTransport) {
                        delete dtlsTransport.ondtlsstatechange;
                        delete dtlsTransport.onerror;
                        delete this.transceivers[sdpMLineIndex].dtlsTransport;
                    }
                };

                // Start the RTP Sender and Receiver for a transceiver.
                RTCPeerConnection.prototype._transceive = function (transceiver, send, recv) {
                    var params = getCommonCapabilities(transceiver.localCapabilities, transceiver.remoteCapabilities);
                    if (send && transceiver.rtpSender) {
                        params.encodings = transceiver.sendEncodingParameters;
                        params.rtcp = {
                            cname: SDPUtils.localCName,
                            compound: transceiver.rtcpParameters.compound
                        };
                        if (transceiver.recvEncodingParameters.length) {
                            params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;
                        }
                        transceiver.rtpSender.send(params);
                    }
                    if (recv && transceiver.rtpReceiver && params.codecs.length > 0) {
                        // remove RTX field in Edge 14942
                        if (transceiver.kind === 'video' && transceiver.recvEncodingParameters && edgeVersion < 15019) {
                            transceiver.recvEncodingParameters.forEach(function (p) {
                                delete p.rtx;
                            });
                        }
                        if (transceiver.recvEncodingParameters.length) {
                            params.encodings = transceiver.recvEncodingParameters;
                        } else {
                            params.encodings = [{}];
                        }
                        params.rtcp = {
                            compound: transceiver.rtcpParameters.compound
                        };
                        if (transceiver.rtcpParameters.cname) {
                            params.rtcp.cname = transceiver.rtcpParameters.cname;
                        }
                        if (transceiver.sendEncodingParameters.length) {
                            params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;
                        }
                        transceiver.rtpReceiver.receive(params);
                    }
                };

                RTCPeerConnection.prototype.setLocalDescription = function (description) {
                    var pc = this;

                    // Note: pranswer is not supported.
                    if (['offer', 'answer'].indexOf(description.type) === -1) {
                        return Promise.reject(makeError('TypeError', 'Unsupported type "' + description.type + '"'));
                    }

                    if (!isActionAllowedInSignalingState('setLocalDescription', description.type, pc.signalingState) || pc._isClosed) {
                        return Promise.reject(makeError('InvalidStateError', 'Can not set local ' + description.type + ' in state ' + pc.signalingState));
                    }

                    var sections;
                    var sessionpart;
                    if (description.type === 'offer') {
                        // VERY limited support for SDP munging. Limited to:
                        // * changing the order of codecs
                        sections = SDPUtils.splitSections(description.sdp);
                        sessionpart = sections.shift();
                        sections.forEach(function (mediaSection, sdpMLineIndex) {
                            var caps = SDPUtils.parseRtpParameters(mediaSection);
                            pc.transceivers[sdpMLineIndex].localCapabilities = caps;
                        });

                        pc.transceivers.forEach(function (transceiver, sdpMLineIndex) {
                            pc._gather(transceiver.mid, sdpMLineIndex);
                        });
                    } else if (description.type === 'answer') {
                        sections = SDPUtils.splitSections(pc.remoteDescription.sdp);
                        sessionpart = sections.shift();
                        var isIceLite = SDPUtils.matchPrefix(sessionpart, 'a=ice-lite').length > 0;
                        sections.forEach(function (mediaSection, sdpMLineIndex) {
                            var transceiver = pc.transceivers[sdpMLineIndex];
                            var iceGatherer = transceiver.iceGatherer;
                            var iceTransport = transceiver.iceTransport;
                            var dtlsTransport = transceiver.dtlsTransport;
                            var localCapabilities = transceiver.localCapabilities;
                            var remoteCapabilities = transceiver.remoteCapabilities;

                            // treat bundle-only as not-rejected.
                            var rejected = SDPUtils.isRejected(mediaSection) && SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;

                            if (!rejected && !transceiver.rejected) {
                                var remoteIceParameters = SDPUtils.getIceParameters(mediaSection, sessionpart);
                                var remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection, sessionpart);
                                if (isIceLite) {
                                    remoteDtlsParameters.role = 'server';
                                }

                                if (!pc.usingBundle || sdpMLineIndex === 0) {
                                    pc._gather(transceiver.mid, sdpMLineIndex);
                                    if (iceTransport.state === 'new') {
                                        iceTransport.start(iceGatherer, remoteIceParameters, isIceLite ? 'controlling' : 'controlled');
                                    }
                                    if (dtlsTransport.state === 'new') {
                                        dtlsTransport.start(remoteDtlsParameters);
                                    }
                                }

                                // Calculate intersection of capabilities.
                                var params = getCommonCapabilities(localCapabilities, remoteCapabilities);

                                // Start the RTCRtpSender. The RTCRtpReceiver for this
                                // transceiver has already been started in setRemoteDescription.
                                pc._transceive(transceiver, params.codecs.length > 0, false);
                            }
                        });
                    }

                    pc.localDescription = {
                        type: description.type,
                        sdp: description.sdp
                    };
                    if (description.type === 'offer') {
                        pc._updateSignalingState('have-local-offer');
                    } else {
                        pc._updateSignalingState('stable');
                    }

                    return Promise.resolve();
                };

                RTCPeerConnection.prototype.setRemoteDescription = function (description) {
                    var pc = this;

                    // Note: pranswer is not supported.
                    if (['offer', 'answer'].indexOf(description.type) === -1) {
                        return Promise.reject(makeError('TypeError', 'Unsupported type "' + description.type + '"'));
                    }

                    if (!isActionAllowedInSignalingState('setRemoteDescription', description.type, pc.signalingState) || pc._isClosed) {
                        return Promise.reject(makeError('InvalidStateError', 'Can not set remote ' + description.type + ' in state ' + pc.signalingState));
                    }

                    var streams = {};
                    pc.remoteStreams.forEach(function (stream) {
                        streams[stream.id] = stream;
                    });
                    var receiverList = [];
                    var sections = SDPUtils.splitSections(description.sdp);
                    var sessionpart = sections.shift();
                    var isIceLite = SDPUtils.matchPrefix(sessionpart, 'a=ice-lite').length > 0;
                    var usingBundle = SDPUtils.matchPrefix(sessionpart, 'a=group:BUNDLE ').length > 0;
                    pc.usingBundle = usingBundle;
                    var iceOptions = SDPUtils.matchPrefix(sessionpart, 'a=ice-options:')[0];
                    if (iceOptions) {
                        pc.canTrickleIceCandidates = iceOptions.substr(14).split(' ').indexOf('trickle') >= 0;
                    } else {
                        pc.canTrickleIceCandidates = false;
                    }

                    sections.forEach(function (mediaSection, sdpMLineIndex) {
                        var lines = SDPUtils.splitLines(mediaSection);
                        var kind = SDPUtils.getKind(mediaSection);
                        // treat bundle-only as not-rejected.
                        var rejected = SDPUtils.isRejected(mediaSection) && SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;
                        var protocol = lines[0].substr(2).split(' ')[2];

                        var direction = SDPUtils.getDirection(mediaSection, sessionpart);
                        var remoteMsid = SDPUtils.parseMsid(mediaSection);

                        var mid = SDPUtils.getMid(mediaSection) || SDPUtils.generateIdentifier();

                        // Reject datachannels which are not implemented yet.
                        if (kind === 'application' && protocol === 'DTLS/SCTP' || rejected) {
                            // TODO: this is dangerous in the case where a non-rejected m-line
                            //     becomes rejected.
                            pc.transceivers[sdpMLineIndex] = {
                                mid: mid,
                                kind: kind,
                                rejected: true
                            };
                            return;
                        }

                        if (!rejected && pc.transceivers[sdpMLineIndex] && pc.transceivers[sdpMLineIndex].rejected) {
                            // recycle a rejected transceiver.
                            pc.transceivers[sdpMLineIndex] = pc._createTransceiver(kind, true);
                        }

                        var transceiver;
                        var iceGatherer;
                        var iceTransport;
                        var dtlsTransport;
                        var rtpReceiver;
                        var sendEncodingParameters;
                        var recvEncodingParameters;
                        var localCapabilities;

                        var track;
                        // FIXME: ensure the mediaSection has rtcp-mux set.
                        var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);
                        var remoteIceParameters;
                        var remoteDtlsParameters;
                        if (!rejected) {
                            remoteIceParameters = SDPUtils.getIceParameters(mediaSection, sessionpart);
                            remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection, sessionpart);
                            remoteDtlsParameters.role = 'client';
                        }
                        recvEncodingParameters = SDPUtils.parseRtpEncodingParameters(mediaSection);

                        var rtcpParameters = SDPUtils.parseRtcpParameters(mediaSection);

                        var isComplete = SDPUtils.matchPrefix(mediaSection, 'a=end-of-candidates', sessionpart).length > 0;
                        var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:').map(function (cand) {
                            return SDPUtils.parseCandidate(cand);
                        }).filter(function (cand) {
                            return cand.component === 1;
                        });

                        // Check if we can use BUNDLE and dispose transports.
                        if ((description.type === 'offer' || description.type === 'answer') && !rejected && usingBundle && sdpMLineIndex > 0 && pc.transceivers[sdpMLineIndex]) {
                            pc._disposeIceAndDtlsTransports(sdpMLineIndex);
                            pc.transceivers[sdpMLineIndex].iceGatherer = pc.transceivers[0].iceGatherer;
                            pc.transceivers[sdpMLineIndex].iceTransport = pc.transceivers[0].iceTransport;
                            pc.transceivers[sdpMLineIndex].dtlsTransport = pc.transceivers[0].dtlsTransport;
                            if (pc.transceivers[sdpMLineIndex].rtpSender) {
                                pc.transceivers[sdpMLineIndex].rtpSender.setTransport(pc.transceivers[0].dtlsTransport);
                            }
                            if (pc.transceivers[sdpMLineIndex].rtpReceiver) {
                                pc.transceivers[sdpMLineIndex].rtpReceiver.setTransport(pc.transceivers[0].dtlsTransport);
                            }
                        }
                        if (description.type === 'offer' && !rejected) {
                            transceiver = pc.transceivers[sdpMLineIndex] || pc._createTransceiver(kind);
                            transceiver.mid = mid;

                            if (!transceiver.iceGatherer) {
                                transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex, usingBundle);
                            }

                            if (cands.length && transceiver.iceTransport.state === 'new') {
                                if (isComplete && (!usingBundle || sdpMLineIndex === 0)) {
                                    transceiver.iceTransport.setRemoteCandidates(cands);
                                } else {
                                    cands.forEach(function (candidate) {
                                        maybeAddCandidate(transceiver.iceTransport, candidate);
                                    });
                                }
                            }

                            localCapabilities = window.RTCRtpReceiver.getCapabilities(kind);

                            // filter RTX until additional stuff needed for RTX is implemented
                            // in adapter.js
                            if (edgeVersion < 15019) {
                                localCapabilities.codecs = localCapabilities.codecs.filter(function (codec) {
                                    return codec.name !== 'rtx';
                                });
                            }

                            sendEncodingParameters = transceiver.sendEncodingParameters || [{
                                ssrc: (2 * sdpMLineIndex + 2) * 1001
                            }];

                            // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams
                            var isNewTrack = false;
                            if (direction === 'sendrecv' || direction === 'sendonly') {
                                isNewTrack = !transceiver.rtpReceiver;
                                rtpReceiver = transceiver.rtpReceiver || new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);

                                if (isNewTrack) {
                                    var stream;
                                    track = rtpReceiver.track;
                                    // FIXME: does not work with Plan B.
                                    if (remoteMsid && remoteMsid.stream === '-') {
                                        // no-op. a stream id of '-' means: no associated stream.
                                    } else if (remoteMsid) {
                                        if (!streams[remoteMsid.stream]) {
                                            streams[remoteMsid.stream] = new window.MediaStream();
                                            Object.defineProperty(streams[remoteMsid.stream], 'id', {
                                                get: function get() {
                                                    return remoteMsid.stream;
                                                }
                                            });
                                        }
                                        Object.defineProperty(track, 'id', {
                                            get: function get() {
                                                return remoteMsid.track;
                                            }
                                        });
                                        stream = streams[remoteMsid.stream];
                                    } else {
                                        if (!streams.default) {
                                            streams.default = new window.MediaStream();
                                        }
                                        stream = streams.default;
                                    }
                                    if (stream) {
                                        addTrackToStreamAndFireEvent(track, stream);
                                        transceiver.associatedRemoteMediaStreams.push(stream);
                                    }
                                    receiverList.push([track, rtpReceiver, stream]);
                                }
                            } else if (transceiver.rtpReceiver && transceiver.rtpReceiver.track) {
                                transceiver.associatedRemoteMediaStreams.forEach(function (s) {
                                    var nativeTrack = s.getTracks().find(function (t) {
                                        return t.id === transceiver.rtpReceiver.track.id;
                                    });
                                    if (nativeTrack) {
                                        removeTrackFromStreamAndFireEvent(nativeTrack, s);
                                    }
                                });
                                transceiver.associatedRemoteMediaStreams = [];
                            }

                            transceiver.localCapabilities = localCapabilities;
                            transceiver.remoteCapabilities = remoteCapabilities;
                            transceiver.rtpReceiver = rtpReceiver;
                            transceiver.rtcpParameters = rtcpParameters;
                            transceiver.sendEncodingParameters = sendEncodingParameters;
                            transceiver.recvEncodingParameters = recvEncodingParameters;

                            // Start the RTCRtpReceiver now. The RTPSender is started in
                            // setLocalDescription.
                            pc._transceive(pc.transceivers[sdpMLineIndex], false, isNewTrack);
                        } else if (description.type === 'answer' && !rejected) {
                            transceiver = pc.transceivers[sdpMLineIndex];
                            iceGatherer = transceiver.iceGatherer;
                            iceTransport = transceiver.iceTransport;
                            dtlsTransport = transceiver.dtlsTransport;
                            rtpReceiver = transceiver.rtpReceiver;
                            sendEncodingParameters = transceiver.sendEncodingParameters;
                            localCapabilities = transceiver.localCapabilities;

                            pc.transceivers[sdpMLineIndex].recvEncodingParameters = recvEncodingParameters;
                            pc.transceivers[sdpMLineIndex].remoteCapabilities = remoteCapabilities;
                            pc.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters;

                            if (cands.length && iceTransport.state === 'new') {
                                if ((isIceLite || isComplete) && (!usingBundle || sdpMLineIndex === 0)) {
                                    iceTransport.setRemoteCandidates(cands);
                                } else {
                                    cands.forEach(function (candidate) {
                                        maybeAddCandidate(transceiver.iceTransport, candidate);
                                    });
                                }
                            }

                            if (!usingBundle || sdpMLineIndex === 0) {
                                if (iceTransport.state === 'new') {
                                    iceTransport.start(iceGatherer, remoteIceParameters, 'controlling');
                                }
                                if (dtlsTransport.state === 'new') {
                                    dtlsTransport.start(remoteDtlsParameters);
                                }
                            }

                            pc._transceive(transceiver, direction === 'sendrecv' || direction === 'recvonly', direction === 'sendrecv' || direction === 'sendonly');

                            // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams
                            if (rtpReceiver && (direction === 'sendrecv' || direction === 'sendonly')) {
                                track = rtpReceiver.track;
                                if (remoteMsid) {
                                    if (!streams[remoteMsid.stream]) {
                                        streams[remoteMsid.stream] = new window.MediaStream();
                                    }
                                    addTrackToStreamAndFireEvent(track, streams[remoteMsid.stream]);
                                    receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]);
                                } else {
                                    if (!streams.default) {
                                        streams.default = new window.MediaStream();
                                    }
                                    addTrackToStreamAndFireEvent(track, streams.default);
                                    receiverList.push([track, rtpReceiver, streams.default]);
                                }
                            } else {
                                // FIXME: actually the receiver should be created later.
                                delete transceiver.rtpReceiver;
                            }
                        }
                    });

                    if (pc._dtlsRole === undefined) {
                        pc._dtlsRole = description.type === 'offer' ? 'active' : 'passive';
                    }

                    pc.remoteDescription = {
                        type: description.type,
                        sdp: description.sdp
                    };
                    if (description.type === 'offer') {
                        pc._updateSignalingState('have-remote-offer');
                    } else {
                        pc._updateSignalingState('stable');
                    }
                    Object.keys(streams).forEach(function (sid) {
                        var stream = streams[sid];
                        if (stream.getTracks().length) {
                            if (pc.remoteStreams.indexOf(stream) === -1) {
                                pc.remoteStreams.push(stream);
                                var event = new Event('addstream');
                                event.stream = stream;
                                window.setTimeout(function () {
                                    pc._dispatchEvent('addstream', event);
                                });
                            }

                            receiverList.forEach(function (item) {
                                var track = item[0];
                                var receiver = item[1];
                                if (stream.id !== item[2].id) {
                                    return;
                                }
                                fireAddTrack(pc, track, receiver, [stream]);
                            });
                        }
                    });
                    receiverList.forEach(function (item) {
                        if (item[2]) {
                            return;
                        }
                        fireAddTrack(pc, item[0], item[1], []);
                    });

                    // check whether addIceCandidate({}) was called within four seconds after
                    // setRemoteDescription.
                    window.setTimeout(function () {
                        if (!(pc && pc.transceivers)) {
                            return;
                        }
                        pc.transceivers.forEach(function (transceiver) {
                            if (transceiver.iceTransport && transceiver.iceTransport.state === 'new' && transceiver.iceTransport.getRemoteCandidates().length > 0) {
                                console.warn('Timeout for addRemoteCandidate. Consider sending ' + 'an end-of-candidates notification');
                                transceiver.iceTransport.addRemoteCandidate({});
                            }
                        });
                    }, 4000);

                    return Promise.resolve();
                };

                RTCPeerConnection.prototype.close = function () {
                    this.transceivers.forEach(function (transceiver) {
                        /* not yet
                        if (transceiver.iceGatherer) {
                        transceiver.iceGatherer.close();
                        }
                        */
                        if (transceiver.iceTransport) {
                            transceiver.iceTransport.stop();
                        }
                        if (transceiver.dtlsTransport) {
                            transceiver.dtlsTransport.stop();
                        }
                        if (transceiver.rtpSender) {
                            transceiver.rtpSender.stop();
                        }
                        if (transceiver.rtpReceiver) {
                            transceiver.rtpReceiver.stop();
                        }
                    });
                    // FIXME: clean up tracks, local streams, remote streams, etc
                    this._isClosed = true;
                    this._updateSignalingState('closed');
                };

                // Update the signaling state.
                RTCPeerConnection.prototype._updateSignalingState = function (newState) {
                    this.signalingState = newState;
                    var event = new Event('signalingstatechange');
                    this._dispatchEvent('signalingstatechange', event);
                };

                // Determine whether to fire the negotiationneeded event.
                RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function () {
                    var pc = this;
                    if (this.signalingState !== 'stable' || this.needNegotiation === true) {
                        return;
                    }
                    this.needNegotiation = true;
                    window.setTimeout(function () {
                        if (pc.needNegotiation) {
                            pc.needNegotiation = false;
                            var event = new Event('negotiationneeded');
                            pc._dispatchEvent('negotiationneeded', event);
                        }
                    }, 0);
                };

                // Update the ice connection state.
                RTCPeerConnection.prototype._updateIceConnectionState = function () {
                    var newState;
                    var states = {
                        'new': 0,
                        closed: 0,
                        checking: 0,
                        connected: 0,
                        completed: 0,
                        disconnected: 0,
                        failed: 0
                    };
                    this.transceivers.forEach(function (transceiver) {
                        states[transceiver.iceTransport.state]++;
                    });

                    newState = 'new';
                    if (states.failed > 0) {
                        newState = 'failed';
                    } else if (states.checking > 0) {
                        newState = 'checking';
                    } else if (states.disconnected > 0) {
                        newState = 'disconnected';
                    } else if (states.new > 0) {
                        newState = 'new';
                    } else if (states.connected > 0) {
                        newState = 'connected';
                    } else if (states.completed > 0) {
                        newState = 'completed';
                    }

                    if (newState !== this.iceConnectionState) {
                        this.iceConnectionState = newState;
                        var event = new Event('iceconnectionstatechange');
                        this._dispatchEvent('iceconnectionstatechange', event);
                    }
                };

                // Update the connection state.
                RTCPeerConnection.prototype._updateConnectionState = function () {
                    var newState;
                    var states = {
                        'new': 0,
                        closed: 0,
                        connecting: 0,
                        connected: 0,
                        completed: 0,
                        disconnected: 0,
                        failed: 0
                    };
                    this.transceivers.forEach(function (transceiver) {
                        states[transceiver.iceTransport.state]++;
                        states[transceiver.dtlsTransport.state]++;
                    });
                    // ICETransport.completed and connected are the same for this purpose.
                    states.connected += states.completed;

                    newState = 'new';
                    if (states.failed > 0) {
                        newState = 'failed';
                    } else if (states.connecting > 0) {
                        newState = 'connecting';
                    } else if (states.disconnected > 0) {
                        newState = 'disconnected';
                    } else if (states.new > 0) {
                        newState = 'new';
                    } else if (states.connected > 0) {
                        newState = 'connected';
                    }

                    if (newState !== this.connectionState) {
                        this.connectionState = newState;
                        var event = new Event('connectionstatechange');
                        this._dispatchEvent('connectionstatechange', event);
                    }
                };

                RTCPeerConnection.prototype.createOffer = function () {
                    var pc = this;

                    if (pc._isClosed) {
                        return Promise.reject(makeError('InvalidStateError', 'Can not call createOffer after close'));
                    }

                    var numAudioTracks = pc.transceivers.filter(function (t) {
                        return t.kind === 'audio';
                    }).length;
                    var numVideoTracks = pc.transceivers.filter(function (t) {
                        return t.kind === 'video';
                    }).length;

                    // Determine number of audio and video tracks we need to send/recv.
                    var offerOptions = arguments[0];
                    if (offerOptions) {
                        // Reject Chrome legacy constraints.
                        if (offerOptions.mandatory || offerOptions.optional) {
                            throw new TypeError('Legacy mandatory/optional constraints not supported.');
                        }
                        if (offerOptions.offerToReceiveAudio !== undefined) {
                            if (offerOptions.offerToReceiveAudio === true) {
                                numAudioTracks = 1;
                            } else if (offerOptions.offerToReceiveAudio === false) {
                                numAudioTracks = 0;
                            } else {
                                numAudioTracks = offerOptions.offerToReceiveAudio;
                            }
                        }
                        if (offerOptions.offerToReceiveVideo !== undefined) {
                            if (offerOptions.offerToReceiveVideo === true) {
                                numVideoTracks = 1;
                            } else if (offerOptions.offerToReceiveVideo === false) {
                                numVideoTracks = 0;
                            } else {
                                numVideoTracks = offerOptions.offerToReceiveVideo;
                            }
                        }
                    }

                    pc.transceivers.forEach(function (transceiver) {
                        if (transceiver.kind === 'audio') {
                            numAudioTracks--;
                            if (numAudioTracks < 0) {
                                transceiver.wantReceive = false;
                            }
                        } else if (transceiver.kind === 'video') {
                            numVideoTracks--;
                            if (numVideoTracks < 0) {
                                transceiver.wantReceive = false;
                            }
                        }
                    });

                    // Create M-lines for recvonly streams.
                    while (numAudioTracks > 0 || numVideoTracks > 0) {
                        if (numAudioTracks > 0) {
                            pc._createTransceiver('audio');
                            numAudioTracks--;
                        }
                        if (numVideoTracks > 0) {
                            pc._createTransceiver('video');
                            numVideoTracks--;
                        }
                    }

                    var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId, pc._sdpSessionVersion++);
                    pc.transceivers.forEach(function (transceiver, sdpMLineIndex) {
                        // For each track, create an ice gatherer, ice transport,
                        // dtls transport, potentially rtpsender and rtpreceiver.
                        var track = transceiver.track;
                        var kind = transceiver.kind;
                        var mid = transceiver.mid || SDPUtils.generateIdentifier();
                        transceiver.mid = mid;

                        if (!transceiver.iceGatherer) {
                            transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex, pc.usingBundle);
                        }

                        var localCapabilities = window.RTCRtpSender.getCapabilities(kind);
                        // filter RTX until additional stuff needed for RTX is implemented
                        // in adapter.js
                        if (edgeVersion < 15019) {
                            localCapabilities.codecs = localCapabilities.codecs.filter(function (codec) {
                                return codec.name !== 'rtx';
                            });
                        }
                        localCapabilities.codecs.forEach(function (codec) {
                            // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552
                            // by adding level-asymmetry-allowed=1
                            if (codec.name === 'H264' && codec.parameters['level-asymmetry-allowed'] === undefined) {
                                codec.parameters['level-asymmetry-allowed'] = '1';
                            }

                            // for subsequent offers, we might have to re-use the payload
                            // type of the last offer.
                            if (transceiver.remoteCapabilities && transceiver.remoteCapabilities.codecs) {
                                transceiver.remoteCapabilities.codecs.forEach(function (remoteCodec) {
                                    if (codec.name.toLowerCase() === remoteCodec.name.toLowerCase() && codec.clockRate === remoteCodec.clockRate) {
                                        codec.preferredPayloadType = remoteCodec.payloadType;
                                    }
                                });
                            }
                        });
                        localCapabilities.headerExtensions.forEach(function (hdrExt) {
                            var remoteExtensions = transceiver.remoteCapabilities && transceiver.remoteCapabilities.headerExtensions || [];
                            remoteExtensions.forEach(function (rHdrExt) {
                                if (hdrExt.uri === rHdrExt.uri) {
                                    hdrExt.id = rHdrExt.id;
                                }
                            });
                        });

                        // generate an ssrc now, to be used later in rtpSender.send
                        var sendEncodingParameters = transceiver.sendEncodingParameters || [{
                            ssrc: (2 * sdpMLineIndex + 1) * 1001
                        }];
                        if (track) {
                            // add RTX
                            if (edgeVersion >= 15019 && kind === 'video' && !sendEncodingParameters[0].rtx) {
                                sendEncodingParameters[0].rtx = {
                                    ssrc: sendEncodingParameters[0].ssrc + 1
                                };
                            }
                        }

                        if (transceiver.wantReceive) {
                            transceiver.rtpReceiver = new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);
                        }

                        transceiver.localCapabilities = localCapabilities;
                        transceiver.sendEncodingParameters = sendEncodingParameters;
                    });

                    // always offer BUNDLE and dispose on return if not supported.
                    if (pc._config.bundlePolicy !== 'max-compat') {
                        sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function (t) {
                            return t.mid;
                        }).join(' ') + '\r\n';
                    }
                    sdp += 'a=ice-options:trickle\r\n';

                    pc.transceivers.forEach(function (transceiver, sdpMLineIndex) {
                        sdp += writeMediaSection(transceiver, transceiver.localCapabilities, 'offer', transceiver.stream, pc._dtlsRole);
                        sdp += 'a=rtcp-rsize\r\n';

                        if (transceiver.iceGatherer && pc.iceGatheringState !== 'new' && (sdpMLineIndex === 0 || !pc.usingBundle)) {
                            transceiver.iceGatherer.getLocalCandidates().forEach(function (cand) {
                                cand.component = 1;
                                sdp += 'a=' + SDPUtils.writeCandidate(cand) + '\r\n';
                            });

                            if (transceiver.iceGatherer.state === 'completed') {
                                sdp += 'a=end-of-candidates\r\n';
                            }
                        }
                    });

                    var desc = new window.RTCSessionDescription({
                        type: 'offer',
                        sdp: sdp
                    });
                    return Promise.resolve(desc);
                };

                RTCPeerConnection.prototype.createAnswer = function () {
                    var pc = this;

                    if (pc._isClosed) {
                        return Promise.reject(makeError('InvalidStateError', 'Can not call createAnswer after close'));
                    }

                    if (!(pc.signalingState === 'have-remote-offer' || pc.signalingState === 'have-local-pranswer')) {
                        return Promise.reject(makeError('InvalidStateError', 'Can not call createAnswer in signalingState ' + pc.signalingState));
                    }

                    var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId, pc._sdpSessionVersion++);
                    if (pc.usingBundle) {
                        sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function (t) {
                            return t.mid;
                        }).join(' ') + '\r\n';
                    }
                    var mediaSectionsInOffer = SDPUtils.getMediaSections(pc.remoteDescription.sdp).length;
                    pc.transceivers.forEach(function (transceiver, sdpMLineIndex) {
                        if (sdpMLineIndex + 1 > mediaSectionsInOffer) {
                            return;
                        }
                        if (transceiver.rejected) {
                            if (transceiver.kind === 'application') {
                                sdp += 'm=application 0 DTLS/SCTP 5000\r\n';
                            } else if (transceiver.kind === 'audio') {
                                sdp += 'm=audio 0 UDP/TLS/RTP/SAVPF 0\r\n' + 'a=rtpmap:0 PCMU/8000\r\n';
                            } else if (transceiver.kind === 'video') {
                                sdp += 'm=video 0 UDP/TLS/RTP/SAVPF 120\r\n' + 'a=rtpmap:120 VP8/90000\r\n';
                            }
                            sdp += 'c=IN IP4 0.0.0.0\r\n' + 'a=inactive\r\n' + 'a=mid:' + transceiver.mid + '\r\n';
                            return;
                        }

                        // FIXME: look at direction.
                        if (transceiver.stream) {
                            var localTrack;
                            if (transceiver.kind === 'audio') {
                                localTrack = transceiver.stream.getAudioTracks()[0];
                            } else if (transceiver.kind === 'video') {
                                localTrack = transceiver.stream.getVideoTracks()[0];
                            }
                            if (localTrack) {
                                // add RTX
                                if (edgeVersion >= 15019 && transceiver.kind === 'video' && !transceiver.sendEncodingParameters[0].rtx) {
                                    transceiver.sendEncodingParameters[0].rtx = {
                                        ssrc: transceiver.sendEncodingParameters[0].ssrc + 1
                                    };
                                }
                            }
                        }

                        // Calculate intersection of capabilities.
                        var commonCapabilities = getCommonCapabilities(transceiver.localCapabilities, transceiver.remoteCapabilities);

                        var hasRtx = commonCapabilities.codecs.filter(function (c) {
                            return c.name.toLowerCase() === 'rtx';
                        }).length;
                        if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {
                            delete transceiver.sendEncodingParameters[0].rtx;
                        }

                        sdp += writeMediaSection(transceiver, commonCapabilities, 'answer', transceiver.stream, pc._dtlsRole);
                        if (transceiver.rtcpParameters && transceiver.rtcpParameters.reducedSize) {
                            sdp += 'a=rtcp-rsize\r\n';
                        }
                    });

                    var desc = new window.RTCSessionDescription({
                        type: 'answer',
                        sdp: sdp
                    });
                    return Promise.resolve(desc);
                };

                RTCPeerConnection.prototype.addIceCandidate = function (candidate) {
                    var pc = this;
                    var sections;
                    if (candidate && !(candidate.sdpMLineIndex !== undefined || candidate.sdpMid)) {
                        return Promise.reject(new TypeError('sdpMLineIndex or sdpMid required'));
                    }

                    // TODO: needs to go into ops queue.
                    return new Promise(function (resolve, reject) {
                        if (!pc.remoteDescription) {
                            return reject(makeError('InvalidStateError', 'Can not add ICE candidate without a remote description'));
                        } else if (!candidate || candidate.candidate === '') {
                            for (var j = 0; j < pc.transceivers.length; j++) {
                                if (pc.transceivers[j].rejected) {
                                    continue;
                                }
                                pc.transceivers[j].iceTransport.addRemoteCandidate({});
                                sections = SDPUtils.getMediaSections(pc.remoteDescription.sdp);
                                sections[j] += 'a=end-of-candidates\r\n';
                                pc.remoteDescription.sdp = SDPUtils.getDescription(pc.remoteDescription.sdp) + sections.join('');
                                if (pc.usingBundle) {
                                    break;
                                }
                            }
                        } else {
                            var sdpMLineIndex = candidate.sdpMLineIndex;
                            if (candidate.sdpMid) {
                                for (var i = 0; i < pc.transceivers.length; i++) {
                                    if (pc.transceivers[i].mid === candidate.sdpMid) {
                                        sdpMLineIndex = i;
                                        break;
                                    }
                                }
                            }
                            var transceiver = pc.transceivers[sdpMLineIndex];
                            if (transceiver) {
                                if (transceiver.rejected) {
                                    return resolve();
                                }
                                var cand = Object.keys(candidate.candidate).length > 0 ? SDPUtils.parseCandidate(candidate.candidate) : {};
                                // Ignore Chrome's invalid candidates since Edge does not like them.
                                if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {
                                    return resolve();
                                }
                                // Ignore RTCP candidates, we assume RTCP-MUX.
                                if (cand.component && cand.component !== 1) {
                                    return resolve();
                                }
                                // when using bundle, avoid adding candidates to the wrong
                                // ice transport. And avoid adding candidates added in the SDP.
                                if (sdpMLineIndex === 0 || sdpMLineIndex > 0 && transceiver.iceTransport !== pc.transceivers[0].iceTransport) {
                                    if (!maybeAddCandidate(transceiver.iceTransport, cand)) {
                                        return reject(makeError('OperationError', 'Can not add ICE candidate'));
                                    }
                                }

                                // update the remoteDescription.
                                var candidateString = candidate.candidate.trim();
                                if (candidateString.indexOf('a=') === 0) {
                                    candidateString = candidateString.substr(2);
                                }
                                sections = SDPUtils.getMediaSections(pc.remoteDescription.sdp);
                                sections[sdpMLineIndex] += 'a=' + (cand.type ? candidateString : 'end-of-candidates') + '\r\n';
                                pc.remoteDescription.sdp = SDPUtils.getDescription(pc.remoteDescription.sdp) + sections.join('');
                            } else {
                                return reject(makeError('OperationError', 'Can not add ICE candidate'));
                            }
                        }
                        resolve();
                    });
                };

                RTCPeerConnection.prototype.getStats = function (selector) {
                    if (selector && selector instanceof window.MediaStreamTrack) {
                        var senderOrReceiver = null;
                        this.transceivers.forEach(function (transceiver) {
                            if (transceiver.rtpSender && transceiver.rtpSender.track === selector) {
                                senderOrReceiver = transceiver.rtpSender;
                            } else if (transceiver.rtpReceiver && transceiver.rtpReceiver.track === selector) {
                                senderOrReceiver = transceiver.rtpReceiver;
                            }
                        });
                        if (!senderOrReceiver) {
                            throw makeError('InvalidAccessError', 'Invalid selector.');
                        }
                        return senderOrReceiver.getStats();
                    }

                    var promises = [];
                    this.transceivers.forEach(function (transceiver) {
                        ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport', 'dtlsTransport'].forEach(function (method) {
                            if (transceiver[method]) {
                                promises.push(transceiver[method].getStats());
                            }
                        });
                    });
                    return Promise.all(promises).then(function (allStats) {
                        var results = new Map();
                        allStats.forEach(function (stats) {
                            stats.forEach(function (stat) {
                                results.set(stat.id, stat);
                            });
                        });
                        return results;
                    });
                };

                // fix low-level stat names and return Map instead of object.
                var ortcObjects = ['RTCRtpSender', 'RTCRtpReceiver', 'RTCIceGatherer', 'RTCIceTransport', 'RTCDtlsTransport'];
                ortcObjects.forEach(function (ortcObjectName) {
                    var obj = window[ortcObjectName];
                    if (obj && obj.prototype && obj.prototype.getStats) {
                        var nativeGetstats = obj.prototype.getStats;
                        obj.prototype.getStats = function () {
                            return nativeGetstats.apply(this).then(function (nativeStats) {
                                var mapStats = new Map();
                                Object.keys(nativeStats).forEach(function (id) {
                                    nativeStats[id].type = fixStatsType(nativeStats[id]);
                                    mapStats.set(id, nativeStats[id]);
                                });
                                return mapStats;
                            });
                        };
                    }
                });

                // legacy callback shims. Should be moved to adapter.js some days.
                var methods = ['createOffer', 'createAnswer'];
                methods.forEach(function (method) {
                    var nativeMethod = RTCPeerConnection.prototype[method];
                    RTCPeerConnection.prototype[method] = function () {
                        var args = arguments;
                        if (typeof args[0] === 'function' || typeof args[1] === 'function') {
                            // legacy
                            return nativeMethod.apply(this, [arguments[2]]).then(function (description) {
                                if (typeof args[0] === 'function') {
                                    args[0].apply(null, [description]);
                                }
                            }, function (error) {
                                if (typeof args[1] === 'function') {
                                    args[1].apply(null, [error]);
                                }
                            });
                        }
                        return nativeMethod.apply(this, arguments);
                    };
                });

                methods = ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'];
                methods.forEach(function (method) {
                    var nativeMethod = RTCPeerConnection.prototype[method];
                    RTCPeerConnection.prototype[method] = function () {
                        var args = arguments;
                        if (typeof args[1] === 'function' || typeof args[2] === 'function') {
                            // legacy
                            return nativeMethod.apply(this, arguments).then(function () {
                                if (typeof args[1] === 'function') {
                                    args[1].apply(null);
                                }
                            }, function (error) {
                                if (typeof args[2] === 'function') {
                                    args[2].apply(null, [error]);
                                }
                            });
                        }
                        return nativeMethod.apply(this, arguments);
                    };
                });

                // getStats is special. It doesn't have a spec legacy method yet we support
                // getStats(something, cb) without error callbacks.
                ['getStats'].forEach(function (method) {
                    var nativeMethod = RTCPeerConnection.prototype[method];
                    RTCPeerConnection.prototype[method] = function () {
                        var args = arguments;
                        if (typeof args[1] === 'function') {
                            return nativeMethod.apply(this, arguments).then(function () {
                                if (typeof args[1] === 'function') {
                                    args[1].apply(null);
                                }
                            });
                        }
                        return nativeMethod.apply(this, arguments);
                    };
                });

                return RTCPeerConnection;
            };
        }, { "sdp": 2 }], 2: [function (require, module, exports) {
            /* eslint-env node */
            'use strict';

            // SDP helpers.

            var SDPUtils = {};

            // Generate an alphanumeric identifier for cname or mids.
            // TODO: use UUIDs instead? https://gist.github.com/jed/982883
            SDPUtils.generateIdentifier = function () {
                return Math.random().toString(36).substr(2, 10);
            };

            // The RTCP CNAME used by all peerconnections from the same JS.
            SDPUtils.localCName = SDPUtils.generateIdentifier();

            // Splits SDP into lines, dealing with both CRLF and LF.
            SDPUtils.splitLines = function (blob) {
                return blob.trim().split('\n').map(function (line) {
                    return line.trim();
                });
            };
            // Splits SDP into sessionpart and mediasections. Ensures CRLF.
            SDPUtils.splitSections = function (blob) {
                var parts = blob.split('\nm=');
                return parts.map(function (part, index) {
                    return (index > 0 ? 'm=' + part : part).trim() + '\r\n';
                });
            };

            // returns the session description.
            SDPUtils.getDescription = function (blob) {
                var sections = SDPUtils.splitSections(blob);
                return sections && sections[0];
            };

            // returns the individual media sections.
            SDPUtils.getMediaSections = function (blob) {
                var sections = SDPUtils.splitSections(blob);
                sections.shift();
                return sections;
            };

            // Returns lines that start with a certain prefix.
            SDPUtils.matchPrefix = function (blob, prefix) {
                return SDPUtils.splitLines(blob).filter(function (line) {
                    return line.indexOf(prefix) === 0;
                });
            };

            // Parses an ICE candidate line. Sample input:
            // candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
            // rport 55996"
            SDPUtils.parseCandidate = function (line) {
                var parts;
                // Parse both variants.
                if (line.indexOf('a=candidate:') === 0) {
                    parts = line.substring(12).split(' ');
                } else {
                    parts = line.substring(10).split(' ');
                }

                var candidate = {
                    foundation: parts[0],
                    component: parseInt(parts[1], 10),
                    protocol: parts[2].toLowerCase(),
                    priority: parseInt(parts[3], 10),
                    ip: parts[4],
                    port: parseInt(parts[5], 10),
                    // skip parts[6] == 'typ'
                    type: parts[7]
                };

                for (var i = 8; i < parts.length; i += 2) {
                    switch (parts[i]) {
                        case 'raddr':
                            candidate.relatedAddress = parts[i + 1];
                            break;
                        case 'rport':
                            candidate.relatedPort = parseInt(parts[i + 1], 10);
                            break;
                        case 'tcptype':
                            candidate.tcpType = parts[i + 1];
                            break;
                        case 'ufrag':
                            candidate.ufrag = parts[i + 1]; // for backward compability.
                            candidate.usernameFragment = parts[i + 1];
                            break;
                        default:
                            // extension handling, in particular ufrag
                            candidate[parts[i]] = parts[i + 1];
                            break;
                    }
                }
                return candidate;
            };

            // Translates a candidate object into SDP candidate attribute.
            SDPUtils.writeCandidate = function (candidate) {
                var sdp = [];
                sdp.push(candidate.foundation);
                sdp.push(candidate.component);
                sdp.push(candidate.protocol.toUpperCase());
                sdp.push(candidate.priority);
                sdp.push(candidate.ip);
                sdp.push(candidate.port);

                var type = candidate.type;
                sdp.push('typ');
                sdp.push(type);
                if (type !== 'host' && candidate.relatedAddress && candidate.relatedPort) {
                    sdp.push('raddr');
                    sdp.push(candidate.relatedAddress);
                    sdp.push('rport');
                    sdp.push(candidate.relatedPort);
                }
                if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
                    sdp.push('tcptype');
                    sdp.push(candidate.tcpType);
                }
                if (candidate.usernameFragment || candidate.ufrag) {
                    sdp.push('ufrag');
                    sdp.push(candidate.usernameFragment || candidate.ufrag);
                }
                return 'candidate:' + sdp.join(' ');
            };

            // Parses an ice-options line, returns an array of option tags.
            // a=ice-options:foo bar
            SDPUtils.parseIceOptions = function (line) {
                return line.substr(14).split(' ');
            };

            // Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:
            // a=rtpmap:111 opus/48000/2
            SDPUtils.parseRtpMap = function (line) {
                var parts = line.substr(9).split(' ');
                var parsed = {
                    payloadType: parseInt(parts.shift(), 10) // was: id
                };

                parts = parts[0].split('/');

                parsed.name = parts[0];
                parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
                parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
                // legacy alias, got renamed back to channels in ORTC.
                parsed.numChannels = parsed.channels;
                return parsed;
            };

            // Generate an a=rtpmap line from RTCRtpCodecCapability or
            // RTCRtpCodecParameters.
            SDPUtils.writeRtpMap = function (codec) {
                var pt = codec.payloadType;
                if (codec.preferredPayloadType !== undefined) {
                    pt = codec.preferredPayloadType;
                }
                var channels = codec.channels || codec.numChannels || 1;
                return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate + (channels !== 1 ? '/' + channels : '') + '\r\n';
            };

            // Parses an a=extmap line (headerextension from RFC 5285). Sample input:
            // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
            // a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset
            SDPUtils.parseExtmap = function (line) {
                var parts = line.substr(9).split(' ');
                return {
                    id: parseInt(parts[0], 10),
                    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
                    uri: parts[1]
                };
            };

            // Generates a=extmap line from RTCRtpHeaderExtensionParameters or
            // RTCRtpHeaderExtension.
            SDPUtils.writeExtmap = function (headerExtension) {
                return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== 'sendrecv' ? '/' + headerExtension.direction : '') + ' ' + headerExtension.uri + '\r\n';
            };

            // Parses an ftmp line, returns dictionary. Sample input:
            // a=fmtp:96 vbr=on;cng=on
            // Also deals with vbr=on; cng=on
            SDPUtils.parseFmtp = function (line) {
                var parsed = {};
                var kv;
                var parts = line.substr(line.indexOf(' ') + 1).split(';');
                for (var j = 0; j < parts.length; j++) {
                    kv = parts[j].trim().split('=');
                    parsed[kv[0].trim()] = kv[1];
                }
                return parsed;
            };

            // Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
            SDPUtils.writeFmtp = function (codec) {
                var line = '';
                var pt = codec.payloadType;
                if (codec.preferredPayloadType !== undefined) {
                    pt = codec.preferredPayloadType;
                }
                if (codec.parameters && Object.keys(codec.parameters).length) {
                    var params = [];
                    Object.keys(codec.parameters).forEach(function (param) {
                        if (codec.parameters[param]) {
                            params.push(param + '=' + codec.parameters[param]);
                        } else {
                            params.push(param);
                        }
                    });
                    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
                }
                return line;
            };

            // Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
            // a=rtcp-fb:98 nack rpsi
            SDPUtils.parseRtcpFb = function (line) {
                var parts = line.substr(line.indexOf(' ') + 1).split(' ');
                return {
                    type: parts.shift(),
                    parameter: parts.join(' ')
                };
            };
            // Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
            SDPUtils.writeRtcpFb = function (codec) {
                var lines = '';
                var pt = codec.payloadType;
                if (codec.preferredPayloadType !== undefined) {
                    pt = codec.preferredPayloadType;
                }
                if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
                    // FIXME: special handling for trr-int?
                    codec.rtcpFeedback.forEach(function (fb) {
                        lines += 'a=rtcp-fb:' + pt + ' ' + fb.type + (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') + '\r\n';
                    });
                }
                return lines;
            };

            // Parses an RFC 5576 ssrc media attribute. Sample input:
            // a=ssrc:3735928559 cname:something
            SDPUtils.parseSsrcMedia = function (line) {
                var sp = line.indexOf(' ');
                var parts = {
                    ssrc: parseInt(line.substr(7, sp - 7), 10)
                };
                var colon = line.indexOf(':', sp);
                if (colon > -1) {
                    parts.attribute = line.substr(sp + 1, colon - sp - 1);
                    parts.value = line.substr(colon + 1);
                } else {
                    parts.attribute = line.substr(sp + 1);
                }
                return parts;
            };

            // Extracts the MID (RFC 5888) from a media section.
            // returns the MID or undefined if no mid line was found.
            SDPUtils.getMid = function (mediaSection) {
                var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];
                if (mid) {
                    return mid.substr(6);
                }
            };

            SDPUtils.parseFingerprint = function (line) {
                var parts = line.substr(14).split(' ');
                return {
                    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.
                    value: parts[1]
                };
            };

            // Extracts DTLS parameters from SDP media section or sessionpart.
            // FIXME: for consistency with other functions this should only
            //   get the fingerprint line as input. See also getIceParameters.
            SDPUtils.getDtlsParameters = function (mediaSection, sessionpart) {
                var lines = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=fingerprint:');
                // Note: a=setup line is ignored since we use the 'auto' role.
                // Note2: 'algorithm' is not case sensitive except in Edge.
                return {
                    role: 'auto',
                    fingerprints: lines.map(SDPUtils.parseFingerprint)
                };
            };

            // Serializes DTLS parameters to SDP.
            SDPUtils.writeDtlsParameters = function (params, setupType) {
                var sdp = 'a=setup:' + setupType + '\r\n';
                params.fingerprints.forEach(function (fp) {
                    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
                });
                return sdp;
            };
            // Parses ICE information from SDP media section or sessionpart.
            // FIXME: for consistency with other functions this should only
            //   get the ice-ufrag and ice-pwd lines as input.
            SDPUtils.getIceParameters = function (mediaSection, sessionpart) {
                var lines = SDPUtils.splitLines(mediaSection);
                // Search in session part, too.
                lines = lines.concat(SDPUtils.splitLines(sessionpart));
                var iceParameters = {
                    usernameFragment: lines.filter(function (line) {
                        return line.indexOf('a=ice-ufrag:') === 0;
                    })[0].substr(12),
                    password: lines.filter(function (line) {
                        return line.indexOf('a=ice-pwd:') === 0;
                    })[0].substr(10)
                };
                return iceParameters;
            };

            // Serializes ICE parameters to SDP.
            SDPUtils.writeIceParameters = function (params) {
                return 'a=ice-ufrag:' + params.usernameFragment + '\r\n' + 'a=ice-pwd:' + params.password + '\r\n';
            };

            // Parses the SDP media section and returns RTCRtpParameters.
            SDPUtils.parseRtpParameters = function (mediaSection) {
                var description = {
                    codecs: [],
                    headerExtensions: [],
                    fecMechanisms: [],
                    rtcp: []
                };
                var lines = SDPUtils.splitLines(mediaSection);
                var mline = lines[0].split(' ');
                for (var i = 3; i < mline.length; i++) {
                    // find all codecs from mline[3..]
                    var pt = mline[i];
                    var rtpmapline = SDPUtils.matchPrefix(mediaSection, 'a=rtpmap:' + pt + ' ')[0];
                    if (rtpmapline) {
                        var codec = SDPUtils.parseRtpMap(rtpmapline);
                        var fmtps = SDPUtils.matchPrefix(mediaSection, 'a=fmtp:' + pt + ' ');
                        // Only the first a=fmtp:<pt> is considered.
                        codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
                        codec.rtcpFeedback = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-fb:' + pt + ' ').map(SDPUtils.parseRtcpFb);
                        description.codecs.push(codec);
                        // parse FEC mechanisms from rtpmap lines.
                        switch (codec.name.toUpperCase()) {
                            case 'RED':
                            case 'ULPFEC':
                                description.fecMechanisms.push(codec.name.toUpperCase());
                                break;
                            default:
                                // only RED and ULPFEC are recognized as FEC mechanisms.
                                break;
                        }
                    }
                }
                SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function (line) {
                    description.headerExtensions.push(SDPUtils.parseExtmap(line));
                });
                // FIXME: parse rtcp.
                return description;
            };

            // Generates parts of the SDP media section describing the capabilities /
            // parameters.
            SDPUtils.writeRtpDescription = function (kind, caps) {
                var sdp = '';

                // Build the mline.
                sdp += 'm=' + kind + ' ';
                sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.
                sdp += ' UDP/TLS/RTP/SAVPF ';
                sdp += caps.codecs.map(function (codec) {
                    if (codec.preferredPayloadType !== undefined) {
                        return codec.preferredPayloadType;
                    }
                    return codec.payloadType;
                }).join(' ') + '\r\n';

                sdp += 'c=IN IP4 0.0.0.0\r\n';
                sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';

                // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
                caps.codecs.forEach(function (codec) {
                    sdp += SDPUtils.writeRtpMap(codec);
                    sdp += SDPUtils.writeFmtp(codec);
                    sdp += SDPUtils.writeRtcpFb(codec);
                });
                var maxptime = 0;
                caps.codecs.forEach(function (codec) {
                    if (codec.maxptime > maxptime) {
                        maxptime = codec.maxptime;
                    }
                });
                if (maxptime > 0) {
                    sdp += 'a=maxptime:' + maxptime + '\r\n';
                }
                sdp += 'a=rtcp-mux\r\n';

                if (caps.headerExtensions) {
                    caps.headerExtensions.forEach(function (extension) {
                        sdp += SDPUtils.writeExtmap(extension);
                    });
                }
                // FIXME: write fecMechanisms.
                return sdp;
            };

            // Parses the SDP media section and returns an array of
            // RTCRtpEncodingParameters.
            SDPUtils.parseRtpEncodingParameters = function (mediaSection) {
                var encodingParameters = [];
                var description = SDPUtils.parseRtpParameters(mediaSection);
                var hasRed = description.fecMechanisms.indexOf('RED') !== -1;
                var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;

                // filter a=ssrc:... cname:, ignore PlanB-msid
                var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(function (line) {
                    return SDPUtils.parseSsrcMedia(line);
                }).filter(function (parts) {
                    return parts.attribute === 'cname';
                });
                var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
                var secondarySsrc;

                var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID').map(function (line) {
                    var parts = line.substr(17).split(' ');
                    return parts.map(function (part) {
                        return parseInt(part, 10);
                    });
                });
                if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
                    secondarySsrc = flows[0][1];
                }

                description.codecs.forEach(function (codec) {
                    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
                        var encParam = {
                            ssrc: primarySsrc,
                            codecPayloadType: parseInt(codec.parameters.apt, 10)
                        };
                        if (primarySsrc && secondarySsrc) {
                            encParam.rtx = { ssrc: secondarySsrc };
                        }
                        encodingParameters.push(encParam);
                        if (hasRed) {
                            encParam = JSON.parse(JSON.stringify(encParam));
                            encParam.fec = {
                                ssrc: secondarySsrc,
                                mechanism: hasUlpfec ? 'red+ulpfec' : 'red'
                            };
                            encodingParameters.push(encParam);
                        }
                    }
                });
                if (encodingParameters.length === 0 && primarySsrc) {
                    encodingParameters.push({
                        ssrc: primarySsrc
                    });
                }

                // we support both b=AS and b=TIAS but interpret AS as TIAS.
                var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');
                if (bandwidth.length) {
                    if (bandwidth[0].indexOf('b=TIAS:') === 0) {
                        bandwidth = parseInt(bandwidth[0].substr(7), 10);
                    } else if (bandwidth[0].indexOf('b=AS:') === 0) {
                        // use formula from JSEP to convert b=AS to TIAS value.
                        bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95 - 50 * 40 * 8;
                    } else {
                        bandwidth = undefined;
                    }
                    encodingParameters.forEach(function (params) {
                        params.maxBitrate = bandwidth;
                    });
                }
                return encodingParameters;
            };

            // parses http://draft.ortc.org/#rtcrtcpparameters*
            SDPUtils.parseRtcpParameters = function (mediaSection) {
                var rtcpParameters = {};

                var cname;
                // Gets the first SSRC. Note that with RTX there might be multiple
                // SSRCs.
                var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(function (line) {
                    return SDPUtils.parseSsrcMedia(line);
                }).filter(function (obj) {
                    return obj.attribute === 'cname';
                })[0];
                if (remoteSsrc) {
                    rtcpParameters.cname = remoteSsrc.value;
                    rtcpParameters.ssrc = remoteSsrc.ssrc;
                }

                // Edge uses the compound attribute instead of reducedSize
                // compound is !reducedSize
                var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
                rtcpParameters.reducedSize = rsize.length > 0;
                rtcpParameters.compound = rsize.length === 0;

                // parses the rtcp-mux attrіbute.
                // Note that Edge does not support unmuxed RTCP.
                var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
                rtcpParameters.mux = mux.length > 0;

                return rtcpParameters;
            };

            // parses either a=msid: or a=ssrc:... msid lines and returns
            // the id of the MediaStream and MediaStreamTrack.
            SDPUtils.parseMsid = function (mediaSection) {
                var parts;
                var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');
                if (spec.length === 1) {
                    parts = spec[0].substr(7).split(' ');
                    return { stream: parts[0], track: parts[1] };
                }
                var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(function (line) {
                    return SDPUtils.parseSsrcMedia(line);
                }).filter(function (parts) {
                    return parts.attribute === 'msid';
                });
                if (planB.length > 0) {
                    parts = planB[0].value.split(' ');
                    return { stream: parts[0], track: parts[1] };
                }
            };

            // Generate a session ID for SDP.
            // https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1
            // recommends using a cryptographically random +ve 64-bit value
            // but right now this should be acceptable and within the right range
            SDPUtils.generateSessionId = function () {
                return Math.random().toString().substr(2, 21);
            };

            // Write boilder plate for start of SDP
            // sessId argument is optional - if not supplied it will
            // be generated randomly
            // sessVersion is optional and defaults to 2
            SDPUtils.writeSessionBoilerplate = function (sessId, sessVer) {
                var sessionId;
                var version = sessVer !== undefined ? sessVer : 2;
                if (sessId) {
                    sessionId = sessId;
                } else {
                    sessionId = SDPUtils.generateSessionId();
                }
                // FIXME: sess-id should be an NTP timestamp.
                return 'v=0\r\n' + 'o=thisisadapterortc ' + sessionId + ' ' + version + ' IN IP4 127.0.0.1\r\n' + 's=-\r\n' + 't=0 0\r\n';
            };

            SDPUtils.writeMediaSection = function (transceiver, caps, type, stream) {
                var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

                // Map ICE parameters (ufrag, pwd) to SDP.
                sdp += SDPUtils.writeIceParameters(transceiver.iceGatherer.getLocalParameters());

                // Map DTLS parameters to SDP.
                sdp += SDPUtils.writeDtlsParameters(transceiver.dtlsTransport.getLocalParameters(), type === 'offer' ? 'actpass' : 'active');

                sdp += 'a=mid:' + transceiver.mid + '\r\n';

                if (transceiver.direction) {
                    sdp += 'a=' + transceiver.direction + '\r\n';
                } else if (transceiver.rtpSender && transceiver.rtpReceiver) {
                    sdp += 'a=sendrecv\r\n';
                } else if (transceiver.rtpSender) {
                    sdp += 'a=sendonly\r\n';
                } else if (transceiver.rtpReceiver) {
                    sdp += 'a=recvonly\r\n';
                } else {
                    sdp += 'a=inactive\r\n';
                }

                if (transceiver.rtpSender) {
                    // spec.
                    var msid = 'msid:' + stream.id + ' ' + transceiver.rtpSender.track.id + '\r\n';
                    sdp += 'a=' + msid;

                    // for Chrome.
                    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc + ' ' + msid;
                    if (transceiver.sendEncodingParameters[0].rtx) {
                        sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc + ' ' + msid;
                        sdp += 'a=ssrc-group:FID ' + transceiver.sendEncodingParameters[0].ssrc + ' ' + transceiver.sendEncodingParameters[0].rtx.ssrc + '\r\n';
                    }
                }
                // FIXME: this should be written by writeRtpDescription.
                sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc + ' cname:' + SDPUtils.localCName + '\r\n';
                if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
                    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc + ' cname:' + SDPUtils.localCName + '\r\n';
                }
                return sdp;
            };

            // Gets the direction from the mediaSection or the sessionpart.
            SDPUtils.getDirection = function (mediaSection, sessionpart) {
                // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
                var lines = SDPUtils.splitLines(mediaSection);
                for (var i = 0; i < lines.length; i++) {
                    switch (lines[i]) {
                        case 'a=sendrecv':
                        case 'a=sendonly':
                        case 'a=recvonly':
                        case 'a=inactive':
                            return lines[i].substr(2);
                        default:
                        // FIXME: What should happen here?
                    }
                }
                if (sessionpart) {
                    return SDPUtils.getDirection(sessionpart);
                }
                return 'sendrecv';
            };

            SDPUtils.getKind = function (mediaSection) {
                var lines = SDPUtils.splitLines(mediaSection);
                var mline = lines[0].split(' ');
                return mline[0].substr(2);
            };

            SDPUtils.isRejected = function (mediaSection) {
                return mediaSection.split(' ', 2)[1] === '0';
            };

            SDPUtils.parseMLine = function (mediaSection) {
                var lines = SDPUtils.splitLines(mediaSection);
                var parts = lines[0].substr(2).split(' ');
                return {
                    kind: parts[0],
                    port: parseInt(parts[1], 10),
                    protocol: parts[2],
                    fmt: parts.slice(3).join(' ')
                };
            };

            SDPUtils.parseOLine = function (mediaSection) {
                var line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];
                var parts = line.substr(2).split(' ');
                return {
                    username: parts[0],
                    sessionId: parts[1],
                    sessionVersion: parseInt(parts[2], 10),
                    netType: parts[3],
                    addressType: parts[4],
                    address: parts[5]
                };
            };

            // Expose public methods.
            if ((typeof module === "undefined" ? "undefined" : _typeof(module)) === 'object') {
                module.exports = SDPUtils;
            }
        }, {}], 3: [function (require, module, exports) {
            (function (global) {
                /*
                *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
                *
                *  Use of this source code is governed by a BSD-style license
                *  that can be found in the LICENSE file in the root of the source
                *  tree.
                */
                /* eslint-env node */

                'use strict';

                var adapterFactory = require('./adapter_factory.js');
                module.exports = adapterFactory({ window: global.window });
            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, { "./adapter_factory.js": 4 }], 4: [function (require, module, exports) {
            /*
            *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
            *
            *  Use of this source code is governed by a BSD-style license
            *  that can be found in the LICENSE file in the root of the source
            *  tree.
            */
            /* eslint-env node */

            'use strict';

            var utils = require('./utils');
            // Shimming starts here.
            module.exports = function (dependencies, opts) {
                var window = dependencies && dependencies.window;

                var options = {
                    shimChrome: true,
                    shimFirefox: true,
                    shimEdge: true,
                    shimSafari: true
                };

                for (var key in opts) {
                    if (hasOwnProperty.call(opts, key)) {
                        options[key] = opts[key];
                    }
                }

                // Utils.
                var logging = utils.log;
                var browserDetails = utils.detectBrowser(window);

                // Uncomment the line below if you want logging to occur, including logging
                // for the switch statement below. Can also be turned on in the browser via
                // adapter.disableLog(false), but then logging from the switch statement below
                // will not appear.
                // require('./utils').disableLog(false);

                // Browser shims.
                var chromeShim = require('./chrome/chrome_shim') || null;
                var edgeShim = require('./edge/edge_shim') || null;
                var firefoxShim = require('./firefox/firefox_shim') || null;
                var safariShim = require('./safari/safari_shim') || null;
                var commonShim = require('./common_shim') || null;

                // Export to the adapter global object visible in the browser.
                var adapter = {
                    browserDetails: browserDetails,
                    commonShim: commonShim,
                    extractVersion: utils.extractVersion,
                    disableLog: utils.disableLog,
                    disableWarnings: utils.disableWarnings
                };

                // Shim browser if found.
                switch (browserDetails.browser) {
                    case 'chrome':
                        if (!chromeShim || !chromeShim.shimPeerConnection || !options.shimChrome) {
                            logging('Chrome shim is not included in this adapter release.');
                            return adapter;
                        }
                        logging('adapter.js shimming chrome.');
                        // Export to the adapter global object visible in the browser.
                        adapter.browserShim = chromeShim;
                        commonShim.shimCreateObjectURL(window);

                        chromeShim.shimGetUserMedia(window);
                        chromeShim.shimMediaStream(window);
                        chromeShim.shimSourceObject(window);
                        chromeShim.shimPeerConnection(window);
                        chromeShim.shimOnTrack(window);
                        chromeShim.shimAddTrackRemoveTrack(window);
                        chromeShim.shimGetSendersWithDtmf(window);
                        chromeShim.shimSenderReceiverGetStats(window);

                        commonShim.shimRTCIceCandidate(window);
                        commonShim.shimMaxMessageSize(window);
                        commonShim.shimSendThrowTypeError(window);
                        break;
                    case 'firefox':
                        if (!firefoxShim || !firefoxShim.shimPeerConnection || !options.shimFirefox) {
                            logging('Firefox shim is not included in this adapter release.');
                            return adapter;
                        }
                        logging('adapter.js shimming firefox.');
                        // Export to the adapter global object visible in the browser.
                        adapter.browserShim = firefoxShim;
                        commonShim.shimCreateObjectURL(window);

                        firefoxShim.shimGetUserMedia(window);
                        firefoxShim.shimSourceObject(window);
                        firefoxShim.shimPeerConnection(window);
                        firefoxShim.shimOnTrack(window);
                        firefoxShim.shimRemoveStream(window);
                        firefoxShim.shimSenderGetStats(window);
                        firefoxShim.shimReceiverGetStats(window);
                        firefoxShim.shimRTCDataChannel(window);

                        commonShim.shimRTCIceCandidate(window);
                        commonShim.shimMaxMessageSize(window);
                        commonShim.shimSendThrowTypeError(window);
                        break;
                    case 'edge':
                        if (!edgeShim || !edgeShim.shimPeerConnection || !options.shimEdge) {
                            logging('MS edge shim is not included in this adapter release.');
                            return adapter;
                        }
                        logging('adapter.js shimming edge.');
                        // Export to the adapter global object visible in the browser.
                        adapter.browserShim = edgeShim;
                        commonShim.shimCreateObjectURL(window);

                        edgeShim.shimGetUserMedia(window);
                        edgeShim.shimPeerConnection(window);
                        edgeShim.shimReplaceTrack(window);

                        // the edge shim implements the full RTCIceCandidate object.

                        commonShim.shimMaxMessageSize(window);
                        commonShim.shimSendThrowTypeError(window);
                        break;
                    case 'safari':
                        if (!safariShim || !options.shimSafari) {
                            logging('Safari shim is not included in this adapter release.');
                            return adapter;
                        }
                        logging('adapter.js shimming safari.');
                        // Export to the adapter global object visible in the browser.
                        adapter.browserShim = safariShim;
                        commonShim.shimCreateObjectURL(window);

                        safariShim.shimRTCIceServerUrls(window);
                        safariShim.shimCallbacksAPI(window);
                        safariShim.shimLocalStreamsAPI(window);
                        safariShim.shimRemoteStreamsAPI(window);
                        safariShim.shimTrackEventTransceiver(window);
                        safariShim.shimGetUserMedia(window);
                        safariShim.shimCreateOfferLegacy(window);

                        commonShim.shimRTCIceCandidate(window);
                        commonShim.shimMaxMessageSize(window);
                        commonShim.shimSendThrowTypeError(window);
                        break;
                    default:
                        logging('Unsupported browser!');
                        break;
                }

                return adapter;
            };
        }, { "./chrome/chrome_shim": 5, "./common_shim": 7, "./edge/edge_shim": 8, "./firefox/firefox_shim": 11, "./safari/safari_shim": 13, "./utils": 14 }], 5: [function (require, module, exports) {

            /*
            *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
            *
            *  Use of this source code is governed by a BSD-style license
            *  that can be found in the LICENSE file in the root of the source
            *  tree.
            */
            /* eslint-env node */
            'use strict';

            var utils = require('../utils.js');
            var logging = utils.log;

            /* iterates the stats graph recursively. */
            function walkStats(stats, base, resultSet) {
                if (!base || resultSet.has(base.id)) {
                    return;
                }
                resultSet.set(base.id, base);
                Object.keys(base).forEach(function (name) {
                    if (name.endsWith('Id')) {
                        walkStats(stats, stats.get(base[name]), resultSet);
                    } else if (name.endsWith('Ids')) {
                        base[name].forEach(function (id) {
                            walkStats(stats, stats.get(id), resultSet);
                        });
                    }
                });
            }

            /* filter getStats for a sender/receiver track. */
            function filterStats(result, track, outbound) {
                var streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';
                var filteredResult = new Map();
                if (track === null) {
                    return filteredResult;
                }
                var trackStats = [];
                result.forEach(function (value) {
                    if (value.type === 'track' && value.trackIdentifier === track.id) {
                        trackStats.push(value);
                    }
                });
                trackStats.forEach(function (trackStat) {
                    result.forEach(function (stats) {
                        if (stats.type === streamStatsType && stats.trackId === trackStat.id) {
                            walkStats(result, stats, filteredResult);
                        }
                    });
                });
                return filteredResult;
            }

            module.exports = {
                shimGetUserMedia: require('./getusermedia'),
                shimMediaStream: function shimMediaStream(window) {
                    window.MediaStream = window.MediaStream || window.webkitMediaStream;
                },

                shimOnTrack: function shimOnTrack(window) {
                    if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object' && window.RTCPeerConnection && !('ontrack' in window.RTCPeerConnection.prototype)) {
                        Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
                            get: function get() {
                                return this._ontrack;
                            },
                            set: function set(f) {
                                if (this._ontrack) {
                                    this.removeEventListener('track', this._ontrack);
                                }
                                this.addEventListener('track', this._ontrack = f);
                            }
                        });
                        var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
                        window.RTCPeerConnection.prototype.setRemoteDescription = function () {
                            var pc = this;
                            if (!pc._ontrackpoly) {
                                pc._ontrackpoly = function (e) {
                                    // onaddstream does not fire when a track is added to an existing
                                    // stream. But stream.onaddtrack is implemented so we use that.
                                    e.stream.addEventListener('addtrack', function (te) {
                                        var receiver;
                                        if (window.RTCPeerConnection.prototype.getReceivers) {
                                            receiver = pc.getReceivers().find(function (r) {
                                                return r.track && r.track.id === te.track.id;
                                            });
                                        } else {
                                            receiver = { track: te.track };
                                        }

                                        var event = new Event('track');
                                        event.track = te.track;
                                        event.receiver = receiver;
                                        event.transceiver = { receiver: receiver };
                                        event.streams = [e.stream];
                                        pc.dispatchEvent(event);
                                    });
                                    e.stream.getTracks().forEach(function (track) {
                                        var receiver;
                                        if (window.RTCPeerConnection.prototype.getReceivers) {
                                            receiver = pc.getReceivers().find(function (r) {
                                                return r.track && r.track.id === track.id;
                                            });
                                        } else {
                                            receiver = { track: track };
                                        }
                                        var event = new Event('track');
                                        event.track = track;
                                        event.receiver = receiver;
                                        event.transceiver = { receiver: receiver };
                                        event.streams = [e.stream];
                                        pc.dispatchEvent(event);
                                    });
                                };
                                pc.addEventListener('addstream', pc._ontrackpoly);
                            }
                            return origSetRemoteDescription.apply(pc, arguments);
                        };
                    } else if (!('RTCRtpTransceiver' in window)) {
                        utils.wrapPeerConnectionEvent(window, 'track', function (e) {
                            if (!e.transceiver) {
                                e.transceiver = { receiver: e.receiver };
                            }
                            return e;
                        });
                    }
                },

                shimGetSendersWithDtmf: function shimGetSendersWithDtmf(window) {
                    // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.
                    if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object' && window.RTCPeerConnection && !('getSenders' in window.RTCPeerConnection.prototype) && 'createDTMFSender' in window.RTCPeerConnection.prototype) {
                        var shimSenderWithDtmf = function shimSenderWithDtmf(pc, track) {
                            return {
                                track: track,
                                get dtmf() {
                                    if (this._dtmf === undefined) {
                                        if (track.kind === 'audio') {
                                            this._dtmf = pc.createDTMFSender(track);
                                        } else {
                                            this._dtmf = null;
                                        }
                                    }
                                    return this._dtmf;
                                },
                                _pc: pc
                            };
                        };

                        // augment addTrack when getSenders is not available.
                        if (!window.RTCPeerConnection.prototype.getSenders) {
                            window.RTCPeerConnection.prototype.getSenders = function () {
                                this._senders = this._senders || [];
                                return this._senders.slice(); // return a copy of the internal state.
                            };
                            var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
                            window.RTCPeerConnection.prototype.addTrack = function (track, stream) {
                                var pc = this;
                                var sender = origAddTrack.apply(pc, arguments);
                                if (!sender) {
                                    sender = shimSenderWithDtmf(pc, track);
                                    pc._senders.push(sender);
                                }
                                return sender;
                            };

                            var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
                            window.RTCPeerConnection.prototype.removeTrack = function (sender) {
                                var pc = this;
                                origRemoveTrack.apply(pc, arguments);
                                var idx = pc._senders.indexOf(sender);
                                if (idx !== -1) {
                                    pc._senders.splice(idx, 1);
                                }
                            };
                        }
                        var origAddStream = window.RTCPeerConnection.prototype.addStream;
                        window.RTCPeerConnection.prototype.addStream = function (stream) {
                            var pc = this;
                            pc._senders = pc._senders || [];
                            origAddStream.apply(pc, [stream]);
                            stream.getTracks().forEach(function (track) {
                                pc._senders.push(shimSenderWithDtmf(pc, track));
                            });
                        };

                        var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
                        window.RTCPeerConnection.prototype.removeStream = function (stream) {
                            var pc = this;
                            pc._senders = pc._senders || [];
                            origRemoveStream.apply(pc, [stream]);

                            stream.getTracks().forEach(function (track) {
                                var sender = pc._senders.find(function (s) {
                                    return s.track === track;
                                });
                                if (sender) {
                                    pc._senders.splice(pc._senders.indexOf(sender), 1); // remove sender
                                }
                            });
                        };
                    } else if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object' && window.RTCPeerConnection && 'getSenders' in window.RTCPeerConnection.prototype && 'createDTMFSender' in window.RTCPeerConnection.prototype && window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {
                        var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
                        window.RTCPeerConnection.prototype.getSenders = function () {
                            var pc = this;
                            var senders = origGetSenders.apply(pc, []);
                            senders.forEach(function (sender) {
                                sender._pc = pc;
                            });
                            return senders;
                        };

                        Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
                            get: function get() {
                                if (this._dtmf === undefined) {
                                    if (this.track.kind === 'audio') {
                                        this._dtmf = this._pc.createDTMFSender(this.track);
                                    } else {
                                        this._dtmf = null;
                                    }
                                }
                                return this._dtmf;
                            }
                        });
                    }
                },

                shimSenderReceiverGetStats: function shimSenderReceiverGetStats(window) {
                    if (!((typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender && window.RTCRtpReceiver)) {
                        return;
                    }

                    // shim sender stats.
                    if (!('getStats' in window.RTCRtpSender.prototype)) {
                        var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
                        if (origGetSenders) {
                            window.RTCPeerConnection.prototype.getSenders = function () {
                                var pc = this;
                                var senders = origGetSenders.apply(pc, []);
                                senders.forEach(function (sender) {
                                    sender._pc = pc;
                                });
                                return senders;
                            };
                        }

                        var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
                        if (origAddTrack) {
                            window.RTCPeerConnection.prototype.addTrack = function () {
                                var sender = origAddTrack.apply(this, arguments);
                                sender._pc = this;
                                return sender;
                            };
                        }
                        window.RTCRtpSender.prototype.getStats = function () {
                            var sender = this;
                            return this._pc.getStats().then(function (result) {
                                /* Note: this will include stats of all senders that
                                *   send a track with the same id as sender.track as
                                *   it is not possible to identify the RTCRtpSender.
                                */
                                return filterStats(result, sender.track, true);
                            });
                        };
                    }

                    // shim receiver stats.
                    if (!('getStats' in window.RTCRtpReceiver.prototype)) {
                        var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
                        if (origGetReceivers) {
                            window.RTCPeerConnection.prototype.getReceivers = function () {
                                var pc = this;
                                var receivers = origGetReceivers.apply(pc, []);
                                receivers.forEach(function (receiver) {
                                    receiver._pc = pc;
                                });
                                return receivers;
                            };
                        }
                        utils.wrapPeerConnectionEvent(window, 'track', function (e) {
                            e.receiver._pc = e.srcElement;
                            return e;
                        });
                        window.RTCRtpReceiver.prototype.getStats = function () {
                            var receiver = this;
                            return this._pc.getStats().then(function (result) {
                                return filterStats(result, receiver.track, false);
                            });
                        };
                    }

                    if (!('getStats' in window.RTCRtpSender.prototype && 'getStats' in window.RTCRtpReceiver.prototype)) {
                        return;
                    }

                    // shim RTCPeerConnection.getStats(track).
                    var origGetStats = window.RTCPeerConnection.prototype.getStats;
                    window.RTCPeerConnection.prototype.getStats = function () {
                        var pc = this;
                        if (arguments.length > 0 && arguments[0] instanceof window.MediaStreamTrack) {
                            var track = arguments[0];
                            var sender;
                            var receiver;
                            var err;
                            pc.getSenders().forEach(function (s) {
                                if (s.track === track) {
                                    if (sender) {
                                        err = true;
                                    } else {
                                        sender = s;
                                    }
                                }
                            });
                            pc.getReceivers().forEach(function (r) {
                                if (r.track === track) {
                                    if (receiver) {
                                        err = true;
                                    } else {
                                        receiver = r;
                                    }
                                }
                                return r.track === track;
                            });
                            if (err || sender && receiver) {
                                return Promise.reject(new DOMException('There are more than one sender or receiver for the track.', 'InvalidAccessError'));
                            } else if (sender) {
                                return sender.getStats();
                            } else if (receiver) {
                                return receiver.getStats();
                            }
                            return Promise.reject(new DOMException('There is no sender or receiver for the track.', 'InvalidAccessError'));
                        }
                        return origGetStats.apply(pc, arguments);
                    };
                },

                shimSourceObject: function shimSourceObject(window) {
                    var URL = window && window.URL;

                    if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object') {
                        if (window.HTMLMediaElement && !('srcObject' in window.HTMLMediaElement.prototype)) {
                            // Shim the srcObject property, once, when HTMLMediaElement is found.
                            Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {
                                get: function get() {
                                    return this._srcObject;
                                },
                                set: function set(stream) {
                                    var self = this;
                                    // Use _srcObject as a private property for this shim
                                    this._srcObject = stream;
                                    if (this.src) {
                                        URL.revokeObjectURL(this.src);
                                    }

                                    if (!stream) {
                                        this.src = '';
                                        return undefined;
                                    }
                                    this.src = URL.createObjectURL(stream);
                                    // We need to recreate the blob url when a track is added or
                                    // removed. Doing it manually since we want to avoid a recursion.
                                    stream.addEventListener('addtrack', function () {
                                        if (self.src) {
                                            URL.revokeObjectURL(self.src);
                                        }
                                        self.src = URL.createObjectURL(stream);
                                    });
                                    stream.addEventListener('removetrack', function () {
                                        if (self.src) {
                                            URL.revokeObjectURL(self.src);
                                        }
                                        self.src = URL.createObjectURL(stream);
                                    });
                                }
                            });
                        }
                    }
                },

                shimAddTrackRemoveTrackWithNative: function shimAddTrackRemoveTrackWithNative(window) {
                    // shim addTrack/removeTrack with native variants in order to make
                    // the interactions with legacy getLocalStreams behave as in other browsers.
                    // Keeps a mapping stream.id => [stream, rtpsenders...]
                    window.RTCPeerConnection.prototype.getLocalStreams = function () {
                        var pc = this;
                        this._shimmedLocalStreams = this._shimmedLocalStreams || {};
                        return Object.keys(this._shimmedLocalStreams).map(function (streamId) {
                            return pc._shimmedLocalStreams[streamId][0];
                        });
                    };

                    var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
                    window.RTCPeerConnection.prototype.addTrack = function (track, stream) {
                        if (!stream) {
                            return origAddTrack.apply(this, arguments);
                        }
                        this._shimmedLocalStreams = this._shimmedLocalStreams || {};

                        var sender = origAddTrack.apply(this, arguments);
                        if (!this._shimmedLocalStreams[stream.id]) {
                            this._shimmedLocalStreams[stream.id] = [stream, sender];
                        } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {
                            this._shimmedLocalStreams[stream.id].push(sender);
                        }
                        return sender;
                    };

                    var origAddStream = window.RTCPeerConnection.prototype.addStream;
                    window.RTCPeerConnection.prototype.addStream = function (stream) {
                        var pc = this;
                        this._shimmedLocalStreams = this._shimmedLocalStreams || {};

                        stream.getTracks().forEach(function (track) {
                            var alreadyExists = pc.getSenders().find(function (s) {
                                return s.track === track;
                            });
                            if (alreadyExists) {
                                throw new DOMException('Track already exists.', 'InvalidAccessError');
                            }
                        });
                        var existingSenders = pc.getSenders();
                        origAddStream.apply(this, arguments);
                        var newSenders = pc.getSenders().filter(function (newSender) {
                            return existingSenders.indexOf(newSender) === -1;
                        });
                        this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);
                    };

                    var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
                    window.RTCPeerConnection.prototype.removeStream = function (stream) {
                        this._shimmedLocalStreams = this._shimmedLocalStreams || {};
                        delete this._shimmedLocalStreams[stream.id];
                        return origRemoveStream.apply(this, arguments);
                    };

                    var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
                    window.RTCPeerConnection.prototype.removeTrack = function (sender) {
                        var pc = this;
                        this._shimmedLocalStreams = this._shimmedLocalStreams || {};
                        if (sender) {
                            Object.keys(this._shimmedLocalStreams).forEach(function (streamId) {
                                var idx = pc._shimmedLocalStreams[streamId].indexOf(sender);
                                if (idx !== -1) {
                                    pc._shimmedLocalStreams[streamId].splice(idx, 1);
                                }
                                if (pc._shimmedLocalStreams[streamId].length === 1) {
                                    delete pc._shimmedLocalStreams[streamId];
                                }
                            });
                        }
                        return origRemoveTrack.apply(this, arguments);
                    };
                },

                shimAddTrackRemoveTrack: function shimAddTrackRemoveTrack(window) {
                    var browserDetails = utils.detectBrowser(window);
                    // shim addTrack and removeTrack.
                    if (window.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {
                        return this.shimAddTrackRemoveTrackWithNative(window);
                    }

                    // also shim pc.getLocalStreams when addTrack is shimmed
                    // to return the original streams.
                    var origGetLocalStreams = window.RTCPeerConnection.prototype.getLocalStreams;
                    window.RTCPeerConnection.prototype.getLocalStreams = function () {
                        var pc = this;
                        var nativeStreams = origGetLocalStreams.apply(this);
                        pc._reverseStreams = pc._reverseStreams || {};
                        return nativeStreams.map(function (stream) {
                            return pc._reverseStreams[stream.id];
                        });
                    };

                    var origAddStream = window.RTCPeerConnection.prototype.addStream;
                    window.RTCPeerConnection.prototype.addStream = function (stream) {
                        var pc = this;
                        pc._streams = pc._streams || {};
                        pc._reverseStreams = pc._reverseStreams || {};

                        stream.getTracks().forEach(function (track) {
                            var alreadyExists = pc.getSenders().find(function (s) {
                                return s.track === track;
                            });
                            if (alreadyExists) {
                                throw new DOMException('Track already exists.', 'InvalidAccessError');
                            }
                        });
                        // Add identity mapping for consistency with addTrack.
                        // Unless this is being used with a stream from addTrack.
                        if (!pc._reverseStreams[stream.id]) {
                            var newStream = new window.MediaStream(stream.getTracks());
                            pc._streams[stream.id] = newStream;
                            pc._reverseStreams[newStream.id] = stream;
                            stream = newStream;
                        }
                        origAddStream.apply(pc, [stream]);
                    };

                    var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
                    window.RTCPeerConnection.prototype.removeStream = function (stream) {
                        var pc = this;
                        pc._streams = pc._streams || {};
                        pc._reverseStreams = pc._reverseStreams || {};

                        origRemoveStream.apply(pc, [pc._streams[stream.id] || stream]);
                        delete pc._reverseStreams[pc._streams[stream.id] ? pc._streams[stream.id].id : stream.id];
                        delete pc._streams[stream.id];
                    };

                    window.RTCPeerConnection.prototype.addTrack = function (track, stream) {
                        var pc = this;
                        if (pc.signalingState === 'closed') {
                            throw new DOMException('The RTCPeerConnection\'s signalingState is \'closed\'.', 'InvalidStateError');
                        }
                        var streams = [].slice.call(arguments, 1);
                        if (streams.length !== 1 || !streams[0].getTracks().find(function (t) {
                            return t === track;
                        })) {
                            // this is not fully correct but all we can manage without
                            // [[associated MediaStreams]] internal slot.
                            throw new DOMException('The adapter.js addTrack polyfill only supports a single ' + ' stream which is associated with the specified track.', 'NotSupportedError');
                        }

                        var alreadyExists = pc.getSenders().find(function (s) {
                            return s.track === track;
                        });
                        if (alreadyExists) {
                            throw new DOMException('Track already exists.', 'InvalidAccessError');
                        }

                        pc._streams = pc._streams || {};
                        pc._reverseStreams = pc._reverseStreams || {};
                        var oldStream = pc._streams[stream.id];
                        if (oldStream) {
                            // this is using odd Chrome behaviour, use with caution:
                            // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815
                            // Note: we rely on the high-level addTrack/dtmf shim to
                            // create the sender with a dtmf sender.
                            oldStream.addTrack(track);

                            // Trigger ONN async.
                            Promise.resolve().then(function () {
                                pc.dispatchEvent(new Event('negotiationneeded'));
                            });
                        } else {
                            var newStream = new window.MediaStream([track]);
                            pc._streams[stream.id] = newStream;
                            pc._reverseStreams[newStream.id] = stream;
                            pc.addStream(newStream);
                        }
                        return pc.getSenders().find(function (s) {
                            return s.track === track;
                        });
                    };

                    // replace the internal stream id with the external one and
                    // vice versa.
                    function replaceInternalStreamId(pc, description) {
                        var sdp = description.sdp;
                        Object.keys(pc._reverseStreams || []).forEach(function (internalId) {
                            var externalStream = pc._reverseStreams[internalId];
                            var internalStream = pc._streams[externalStream.id];
                            sdp = sdp.replace(new RegExp(internalStream.id, 'g'), externalStream.id);
                        });
                        return new RTCSessionDescription({
                            type: description.type,
                            sdp: sdp
                        });
                    }
                    function replaceExternalStreamId(pc, description) {
                        var sdp = description.sdp;
                        Object.keys(pc._reverseStreams || []).forEach(function (internalId) {
                            var externalStream = pc._reverseStreams[internalId];
                            var internalStream = pc._streams[externalStream.id];
                            sdp = sdp.replace(new RegExp(externalStream.id, 'g'), internalStream.id);
                        });
                        return new RTCSessionDescription({
                            type: description.type,
                            sdp: sdp
                        });
                    }
                    ['createOffer', 'createAnswer'].forEach(function (method) {
                        var nativeMethod = window.RTCPeerConnection.prototype[method];
                        window.RTCPeerConnection.prototype[method] = function () {
                            var pc = this;
                            var args = arguments;
                            var isLegacyCall = arguments.length && typeof arguments[0] === 'function';
                            if (isLegacyCall) {
                                return nativeMethod.apply(pc, [function (description) {
                                    var desc = replaceInternalStreamId(pc, description);
                                    args[0].apply(null, [desc]);
                                }, function (err) {
                                    if (args[1]) {
                                        args[1].apply(null, err);
                                    }
                                }, arguments[2]]);
                            }
                            return nativeMethod.apply(pc, arguments).then(function (description) {
                                return replaceInternalStreamId(pc, description);
                            });
                        };
                    });

                    var origSetLocalDescription = window.RTCPeerConnection.prototype.setLocalDescription;
                    window.RTCPeerConnection.prototype.setLocalDescription = function () {
                        var pc = this;
                        if (!arguments.length || !arguments[0].type) {
                            return origSetLocalDescription.apply(pc, arguments);
                        }
                        arguments[0] = replaceExternalStreamId(pc, arguments[0]);
                        return origSetLocalDescription.apply(pc, arguments);
                    };

                    // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier

                    var origLocalDescription = Object.getOwnPropertyDescriptor(window.RTCPeerConnection.prototype, 'localDescription');
                    Object.defineProperty(window.RTCPeerConnection.prototype, 'localDescription', {
                        get: function get() {
                            var pc = this;
                            var description = origLocalDescription.get.apply(this);
                            if (description.type === '') {
                                return description;
                            }
                            return replaceInternalStreamId(pc, description);
                        }
                    });

                    window.RTCPeerConnection.prototype.removeTrack = function (sender) {
                        var pc = this;
                        if (pc.signalingState === 'closed') {
                            throw new DOMException('The RTCPeerConnection\'s signalingState is \'closed\'.', 'InvalidStateError');
                        }
                        // We can not yet check for sender instanceof RTCRtpSender
                        // since we shim RTPSender. So we check if sender._pc is set.
                        if (!sender._pc) {
                            throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' + 'does not implement interface RTCRtpSender.', 'TypeError');
                        }
                        var isLocal = sender._pc === pc;
                        if (!isLocal) {
                            throw new DOMException('Sender was not created by this connection.', 'InvalidAccessError');
                        }

                        // Search for the native stream the senders track belongs to.
                        pc._streams = pc._streams || {};
                        var stream;
                        Object.keys(pc._streams).forEach(function (streamid) {
                            var hasTrack = pc._streams[streamid].getTracks().find(function (track) {
                                return sender.track === track;
                            });
                            if (hasTrack) {
                                stream = pc._streams[streamid];
                            }
                        });

                        if (stream) {
                            if (stream.getTracks().length === 1) {
                                // if this is the last track of the stream, remove the stream. This
                                // takes care of any shimmed _senders.
                                pc.removeStream(pc._reverseStreams[stream.id]);
                            } else {
                                // relying on the same odd chrome behaviour as above.
                                stream.removeTrack(sender.track);
                            }
                            pc.dispatchEvent(new Event('negotiationneeded'));
                        }
                    };
                },

                shimPeerConnection: function shimPeerConnection(window) {
                    var browserDetails = utils.detectBrowser(window);

                    // The RTCPeerConnection object.
                    if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {
                        window.RTCPeerConnection = function (pcConfig, pcConstraints) {
                            // Translate iceTransportPolicy to iceTransports,
                            // see https://code.google.com/p/webrtc/issues/detail?id=4869
                            // this was fixed in M56 along with unprefixing RTCPeerConnection.
                            logging('PeerConnection');
                            if (pcConfig && pcConfig.iceTransportPolicy) {
                                pcConfig.iceTransports = pcConfig.iceTransportPolicy;
                            }

                            return new window.webkitRTCPeerConnection(pcConfig, pcConstraints);
                        };
                        window.RTCPeerConnection.prototype = window.webkitRTCPeerConnection.prototype;
                        // wrap static methods. Currently just generateCertificate.
                        if (window.webkitRTCPeerConnection.generateCertificate) {
                            Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
                                get: function get() {
                                    return window.webkitRTCPeerConnection.generateCertificate;
                                }
                            });
                        }
                    } else {
                        // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
                        var OrigPeerConnection = window.RTCPeerConnection;
                        window.RTCPeerConnection = function (pcConfig, pcConstraints) {
                            if (pcConfig && pcConfig.iceServers) {
                                var newIceServers = [];
                                for (var i = 0; i < pcConfig.iceServers.length; i++) {
                                    var server = pcConfig.iceServers[i];
                                    if (!server.hasOwnProperty('urls') && server.hasOwnProperty('url')) {
                                        utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
                                        server = JSON.parse(JSON.stringify(server));
                                        server.urls = server.url;
                                        newIceServers.push(server);
                                    } else {
                                        newIceServers.push(pcConfig.iceServers[i]);
                                    }
                                }
                                pcConfig.iceServers = newIceServers;
                            }
                            return new OrigPeerConnection(pcConfig, pcConstraints);
                        };
                        window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
                        // wrap static methods. Currently just generateCertificate.
                        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
                            get: function get() {
                                return OrigPeerConnection.generateCertificate;
                            }
                        });
                    }

                    var origGetStats = window.RTCPeerConnection.prototype.getStats;
                    window.RTCPeerConnection.prototype.getStats = function (selector, successCallback, errorCallback) {
                        var pc = this;
                        var args = arguments;

                        // If selector is a function then we are in the old style stats so just
                        // pass back the original getStats format to avoid breaking old users.
                        if (arguments.length > 0 && typeof selector === 'function') {
                            return origGetStats.apply(this, arguments);
                        }

                        // When spec-style getStats is supported, return those when called with
                        // either no arguments or the selector argument is null.
                        if (origGetStats.length === 0 && (arguments.length === 0 || typeof arguments[0] !== 'function')) {
                            return origGetStats.apply(this, []);
                        }

                        var fixChromeStats_ = function fixChromeStats_(response) {
                            var standardReport = {};
                            var reports = response.result();
                            reports.forEach(function (report) {
                                var standardStats = {
                                    id: report.id,
                                    timestamp: report.timestamp,
                                    type: {
                                        localcandidate: 'local-candidate',
                                        remotecandidate: 'remote-candidate'
                                    }[report.type] || report.type
                                };
                                report.names().forEach(function (name) {
                                    standardStats[name] = report.stat(name);
                                });
                                standardReport[standardStats.id] = standardStats;
                            });

                            return standardReport;
                        };

                        // shim getStats with maplike support
                        var makeMapStats = function makeMapStats(stats) {
                            return new Map(Object.keys(stats).map(function (key) {
                                return [key, stats[key]];
                            }));
                        };

                        if (arguments.length >= 2) {
                            var successCallbackWrapper_ = function successCallbackWrapper_(response) {
                                args[1](makeMapStats(fixChromeStats_(response)));
                            };

                            return origGetStats.apply(this, [successCallbackWrapper_, arguments[0]]);
                        }

                        // promise-support
                        return new Promise(function (resolve, reject) {
                            origGetStats.apply(pc, [function (response) {
                                resolve(makeMapStats(fixChromeStats_(response)));
                            }, reject]);
                        }).then(successCallback, errorCallback);
                    };

                    // add promise support -- natively available in Chrome 51
                    if (browserDetails.version < 51) {
                        ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {
                            var nativeMethod = window.RTCPeerConnection.prototype[method];
                            window.RTCPeerConnection.prototype[method] = function () {
                                var args = arguments;
                                var pc = this;
                                var promise = new Promise(function (resolve, reject) {
                                    nativeMethod.apply(pc, [args[0], resolve, reject]);
                                });
                                if (args.length < 2) {
                                    return promise;
                                }
                                return promise.then(function () {
                                    args[1].apply(null, []);
                                }, function (err) {
                                    if (args.length >= 3) {
                                        args[2].apply(null, [err]);
                                    }
                                });
                            };
                        });
                    }

                    // promise support for createOffer and createAnswer. Available (without
                    // bugs) since M52: crbug/619289
                    if (browserDetails.version < 52) {
                        ['createOffer', 'createAnswer'].forEach(function (method) {
                            var nativeMethod = window.RTCPeerConnection.prototype[method];
                            window.RTCPeerConnection.prototype[method] = function () {
                                var pc = this;
                                if (arguments.length < 1 || arguments.length === 1 && _typeof(arguments[0]) === 'object') {
                                    var opts = arguments.length === 1 ? arguments[0] : undefined;
                                    return new Promise(function (resolve, reject) {
                                        nativeMethod.apply(pc, [resolve, reject, opts]);
                                    });
                                }
                                return nativeMethod.apply(this, arguments);
                            };
                        });
                    }

                    // shim implicit creation of RTCSessionDescription/RTCIceCandidate
                    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {
                        var nativeMethod = window.RTCPeerConnection.prototype[method];
                        window.RTCPeerConnection.prototype[method] = function () {
                            arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);
                            return nativeMethod.apply(this, arguments);
                        };
                    });

                    // support for addIceCandidate(null or undefined)
                    var nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;
                    window.RTCPeerConnection.prototype.addIceCandidate = function () {
                        if (!arguments[0]) {
                            if (arguments[1]) {
                                arguments[1].apply(null);
                            }
                            return Promise.resolve();
                        }
                        return nativeAddIceCandidate.apply(this, arguments);
                    };
                }
            };
        }, { "../utils.js": 14, "./getusermedia": 6 }], 6: [function (require, module, exports) {
            /*
            *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
            *
            *  Use of this source code is governed by a BSD-style license
            *  that can be found in the LICENSE file in the root of the source
            *  tree.
            */
            /* eslint-env node */
            'use strict';

            var utils = require('../utils.js');
            var logging = utils.log;

            // Expose public methods.
            module.exports = function (window) {
                var browserDetails = utils.detectBrowser(window);
                var navigator = window && window.navigator;

                var constraintsToChrome_ = function constraintsToChrome_(c) {
                    if ((typeof c === "undefined" ? "undefined" : _typeof(c)) !== 'object' || c.mandatory || c.optional) {
                        return c;
                    }
                    var cc = {};
                    Object.keys(c).forEach(function (key) {
                        if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
                            return;
                        }
                        var r = _typeof(c[key]) === 'object' ? c[key] : { ideal: c[key] };
                        if (r.exact !== undefined && typeof r.exact === 'number') {
                            r.min = r.max = r.exact;
                        }
                        var oldname_ = function oldname_(prefix, name) {
                            if (prefix) {
                                return prefix + name.charAt(0).toUpperCase() + name.slice(1);
                            }
                            return name === 'deviceId' ? 'sourceId' : name;
                        };
                        if (r.ideal !== undefined) {
                            cc.optional = cc.optional || [];
                            var oc = {};
                            if (typeof r.ideal === 'number') {
                                oc[oldname_('min', key)] = r.ideal;
                                cc.optional.push(oc);
                                oc = {};
                                oc[oldname_('max', key)] = r.ideal;
                                cc.optional.push(oc);
                            } else {
                                oc[oldname_('', key)] = r.ideal;
                                cc.optional.push(oc);
                            }
                        }
                        if (r.exact !== undefined && typeof r.exact !== 'number') {
                            cc.mandatory = cc.mandatory || {};
                            cc.mandatory[oldname_('', key)] = r.exact;
                        } else {
                            ['min', 'max'].forEach(function (mix) {
                                if (r[mix] !== undefined) {
                                    cc.mandatory = cc.mandatory || {};
                                    cc.mandatory[oldname_(mix, key)] = r[mix];
                                }
                            });
                        }
                    });
                    if (c.advanced) {
                        cc.optional = (cc.optional || []).concat(c.advanced);
                    }
                    return cc;
                };

                var shimConstraints_ = function shimConstraints_(constraints, func) {
                    if (browserDetails.version >= 61) {
                        return func(constraints);
                    }
                    constraints = JSON.parse(JSON.stringify(constraints));
                    if (constraints && _typeof(constraints.audio) === 'object') {
                        var remap = function remap(obj, a, b) {
                            if (a in obj && !(b in obj)) {
                                obj[b] = obj[a];
                                delete obj[a];
                            }
                        };
                        constraints = JSON.parse(JSON.stringify(constraints));
                        remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');
                        remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');
                        constraints.audio = constraintsToChrome_(constraints.audio);
                    }
                    if (constraints && _typeof(constraints.video) === 'object') {
                        // Shim facingMode for mobile & surface pro.
                        var face = constraints.video.facingMode;
                        face = face && ((typeof face === "undefined" ? "undefined" : _typeof(face)) === 'object' ? face : { ideal: face });
                        var getSupportedFacingModeLies = browserDetails.version < 66;

                        if (face && (face.exact === 'user' || face.exact === 'environment' || face.ideal === 'user' || face.ideal === 'environment') && !(navigator.mediaDevices.getSupportedConstraints && navigator.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {
                            delete constraints.video.facingMode;
                            var matches;
                            if (face.exact === 'environment' || face.ideal === 'environment') {
                                matches = ['back', 'rear'];
                            } else if (face.exact === 'user' || face.ideal === 'user') {
                                matches = ['front'];
                            }
                            if (matches) {
                                // Look for matches in label, or use last cam for back (typical).
                                return navigator.mediaDevices.enumerateDevices().then(function (devices) {
                                    devices = devices.filter(function (d) {
                                        return d.kind === 'videoinput';
                                    });
                                    var dev = devices.find(function (d) {
                                        return matches.some(function (match) {
                                            return d.label.toLowerCase().indexOf(match) !== -1;
                                        });
                                    });
                                    if (!dev && devices.length && matches.indexOf('back') !== -1) {
                                        dev = devices[devices.length - 1]; // more likely the back cam
                                    }
                                    if (dev) {
                                        constraints.video.deviceId = face.exact ? { exact: dev.deviceId } : { ideal: dev.deviceId };
                                    }
                                    constraints.video = constraintsToChrome_(constraints.video);
                                    logging('chrome: ' + JSON.stringify(constraints));
                                    return func(constraints);
                                });
                            }
                        }
                        constraints.video = constraintsToChrome_(constraints.video);
                    }
                    logging('chrome: ' + JSON.stringify(constraints));
                    return func(constraints);
                };

                var shimError_ = function shimError_(e) {
                    return {
                        name: {
                            PermissionDeniedError: 'NotAllowedError',
                            PermissionDismissedError: 'NotAllowedError',
                            InvalidStateError: 'NotAllowedError',
                            DevicesNotFoundError: 'NotFoundError',
                            ConstraintNotSatisfiedError: 'OverconstrainedError',
                            TrackStartError: 'NotReadableError',
                            MediaDeviceFailedDueToShutdown: 'NotAllowedError',
                            MediaDeviceKillSwitchOn: 'NotAllowedError',
                            TabCaptureError: 'AbortError',
                            ScreenCaptureError: 'AbortError',
                            DeviceCaptureError: 'AbortError'
                        }[e.name] || e.name,
                        message: e.message,
                        constraint: e.constraintName,
                        toString: function toString() {
                            return this.name + (this.message && ': ') + this.message;
                        }
                    };
                };

                var getUserMedia_ = function getUserMedia_(constraints, onSuccess, onError) {
                    shimConstraints_(constraints, function (c) {
                        navigator.webkitGetUserMedia(c, onSuccess, function (e) {
                            if (onError) {
                                onError(shimError_(e));
                            }
                        });
                    });
                };

                navigator.getUserMedia = getUserMedia_;

                // Returns the result of getUserMedia as a Promise.
                var getUserMediaPromise_ = function getUserMediaPromise_(constraints) {
                    return new Promise(function (resolve, reject) {
                        navigator.getUserMedia(constraints, resolve, reject);
                    });
                };

                if (!navigator.mediaDevices) {
                    navigator.mediaDevices = {
                        getUserMedia: getUserMediaPromise_,
                        enumerateDevices: function enumerateDevices() {
                            return new Promise(function (resolve) {
                                var kinds = { audio: 'audioinput', video: 'videoinput' };
                                return window.MediaStreamTrack.getSources(function (devices) {
                                    resolve(devices.map(function (device) {
                                        return { label: device.label,
                                            kind: kinds[device.kind],
                                            deviceId: device.id,
                                            groupId: '' };
                                    }));
                                });
                            });
                        },
                        getSupportedConstraints: function getSupportedConstraints() {
                            return {
                                deviceId: true, echoCancellation: true, facingMode: true,
                                frameRate: true, height: true, width: true
                            };
                        }
                    };
                }

                // A shim for getUserMedia method on the mediaDevices object.
                // TODO(KaptenJansson) remove once implemented in Chrome stable.
                if (!navigator.mediaDevices.getUserMedia) {
                    navigator.mediaDevices.getUserMedia = function (constraints) {
                        return getUserMediaPromise_(constraints);
                    };
                } else {
                    // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
                    // function which returns a Promise, it does not accept spec-style
                    // constraints.
                    var origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
                    navigator.mediaDevices.getUserMedia = function (cs) {
                        return shimConstraints_(cs, function (c) {
                            return origGetUserMedia(c).then(function (stream) {
                                if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {
                                    stream.getTracks().forEach(function (track) {
                                        track.stop();
                                    });
                                    throw new DOMException('', 'NotFoundError');
                                }
                                return stream;
                            }, function (e) {
                                return Promise.reject(shimError_(e));
                            });
                        });
                    };
                }

                // Dummy devicechange event methods.
                // TODO(KaptenJansson) remove once implemented in Chrome stable.
                if (typeof navigator.mediaDevices.addEventListener === 'undefined') {
                    navigator.mediaDevices.addEventListener = function () {
                        logging('Dummy mediaDevices.addEventListener called.');
                    };
                }
                if (typeof navigator.mediaDevices.removeEventListener === 'undefined') {
                    navigator.mediaDevices.removeEventListener = function () {
                        logging('Dummy mediaDevices.removeEventListener called.');
                    };
                }
            };
        }, { "../utils.js": 14 }], 7: [function (require, module, exports) {
            /*
            *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
            *
            *  Use of this source code is governed by a BSD-style license
            *  that can be found in the LICENSE file in the root of the source
            *  tree.
            */
            /* eslint-env node */
            'use strict';

            var SDPUtils = require('sdp');
            var utils = require('./utils');

            module.exports = {
                shimRTCIceCandidate: function shimRTCIceCandidate(window) {
                    // foundation is arbitrarily chosen as an indicator for full support for
                    // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface
                    if (!window.RTCIceCandidate || window.RTCIceCandidate && 'foundation' in window.RTCIceCandidate.prototype) {
                        return;
                    }

                    var NativeRTCIceCandidate = window.RTCIceCandidate;
                    window.RTCIceCandidate = function (args) {
                        // Remove the a= which shouldn't be part of the candidate string.
                        if ((typeof args === "undefined" ? "undefined" : _typeof(args)) === 'object' && args.candidate && args.candidate.indexOf('a=') === 0) {
                            args = JSON.parse(JSON.stringify(args));
                            args.candidate = args.candidate.substr(2);
                        }

                        if (args.candidate && args.candidate.length) {
                            // Augment the native candidate with the parsed fields.
                            var nativeCandidate = new NativeRTCIceCandidate(args);
                            var parsedCandidate = SDPUtils.parseCandidate(args.candidate);
                            var augmentedCandidate = Object.assign(nativeCandidate, parsedCandidate);

                            // Add a serializer that does not serialize the extra attributes.
                            augmentedCandidate.toJSON = function () {
                                return {
                                    candidate: augmentedCandidate.candidate,
                                    sdpMid: augmentedCandidate.sdpMid,
                                    sdpMLineIndex: augmentedCandidate.sdpMLineIndex,
                                    usernameFragment: augmentedCandidate.usernameFragment
                                };
                            };
                            return augmentedCandidate;
                        }
                        return new NativeRTCIceCandidate(args);
                    };
                    window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;

                    // Hook up the augmented candidate in onicecandidate and
                    // addEventListener('icecandidate', ...)
                    utils.wrapPeerConnectionEvent(window, 'icecandidate', function (e) {
                        if (e.candidate) {
                            Object.defineProperty(e, 'candidate', {
                                value: new window.RTCIceCandidate(e.candidate),
                                writable: 'false'
                            });
                        }
                        return e;
                    });
                },

                // shimCreateObjectURL must be called before shimSourceObject to avoid loop.

                shimCreateObjectURL: function shimCreateObjectURL(window) {
                    var URL = window && window.URL;

                    if (!((typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object' && window.HTMLMediaElement && 'srcObject' in window.HTMLMediaElement.prototype && URL.createObjectURL && URL.revokeObjectURL)) {
                        // Only shim CreateObjectURL using srcObject if srcObject exists.
                        return undefined;
                    }

                    var nativeCreateObjectURL = URL.createObjectURL.bind(URL);
                    var nativeRevokeObjectURL = URL.revokeObjectURL.bind(URL);
                    var streams = new Map(),
                        newId = 0;

                    URL.createObjectURL = function (stream) {
                        if ('getTracks' in stream) {
                            var url = 'polyblob:' + ++newId;
                            streams.set(url, stream);
                            utils.deprecated('URL.createObjectURL(stream)', 'elem.srcObject = stream');
                            return url;
                        }
                        return nativeCreateObjectURL(stream);
                    };
                    URL.revokeObjectURL = function (url) {
                        nativeRevokeObjectURL(url);
                        streams.delete(url);
                    };

                    var dsc = Object.getOwnPropertyDescriptor(window.HTMLMediaElement.prototype, 'src');
                    Object.defineProperty(window.HTMLMediaElement.prototype, 'src', {
                        get: function get() {
                            return dsc.get.apply(this);
                        },
                        set: function set(url) {
                            this.srcObject = streams.get(url) || null;
                            return dsc.set.apply(this, [url]);
                        }
                    });

                    var nativeSetAttribute = window.HTMLMediaElement.prototype.setAttribute;
                    window.HTMLMediaElement.prototype.setAttribute = function () {
                        if (arguments.length === 2 && ('' + arguments[0]).toLowerCase() === 'src') {
                            this.srcObject = streams.get(arguments[1]) || null;
                        }
                        return nativeSetAttribute.apply(this, arguments);
                    };
                },

                shimMaxMessageSize: function shimMaxMessageSize(window) {
                    if (window.RTCSctpTransport || !window.RTCPeerConnection) {
                        return;
                    }
                    var browserDetails = utils.detectBrowser(window);

                    if (!('sctp' in window.RTCPeerConnection.prototype)) {
                        Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {
                            get: function get() {
                                return typeof this._sctp === 'undefined' ? null : this._sctp;
                            }
                        });
                    }

                    var sctpInDescription = function sctpInDescription(description) {
                        var sections = SDPUtils.splitSections(description.sdp);
                        sections.shift();
                        return sections.some(function (mediaSection) {
                            var mLine = SDPUtils.parseMLine(mediaSection);
                            return mLine && mLine.kind === 'application' && mLine.protocol.indexOf('SCTP') !== -1;
                        });
                    };

                    var getRemoteFirefoxVersion = function getRemoteFirefoxVersion(description) {
                        // TODO: Is there a better solution for detecting Firefox?
                        var match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
                        if (match === null || match.length < 2) {
                            return -1;
                        }
                        var version = parseInt(match[1], 10);
                        // Test for NaN (yes, this is ugly)
                        return version !== version ? -1 : version;
                    };

                    var getCanSendMaxMessageSize = function getCanSendMaxMessageSize(remoteIsFirefox) {
                        // Every implementation we know can send at least 64 KiB.
                        // Note: Although Chrome is technically able to send up to 256 KiB, the
                        //       data does not reach the other peer reliably.
                        //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419
                        var canSendMaxMessageSize = 65536;
                        if (browserDetails.browser === 'firefox') {
                            if (browserDetails.version < 57) {
                                if (remoteIsFirefox === -1) {
                                    // FF < 57 will send in 16 KiB chunks using the deprecated PPID
                                    // fragmentation.
                                    canSendMaxMessageSize = 16384;
                                } else {
                                    // However, other FF (and RAWRTC) can reassemble PPID-fragmented
                                    // messages. Thus, supporting ~2 GiB when sending.
                                    canSendMaxMessageSize = 2147483637;
                                }
                            } else if (browserDetails.version < 60) {
                                // Currently, all FF >= 57 will reset the remote maximum message size
                                // to the default value when a data channel is created at a later
                                // stage. :(
                                // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831
                                canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;
                            } else {
                                // FF >= 60 supports sending ~2 GiB
                                canSendMaxMessageSize = 2147483637;
                            }
                        }
                        return canSendMaxMessageSize;
                    };

                    var getMaxMessageSize = function getMaxMessageSize(description, remoteIsFirefox) {
                        // Note: 65536 bytes is the default value from the SDP spec. Also,
                        //       every implementation we know supports receiving 65536 bytes.
                        var maxMessageSize = 65536;

                        // FF 57 has a slightly incorrect default remote max message size, so
                        // we need to adjust it here to avoid a failure when sending.
                        // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697
                        if (browserDetails.browser === 'firefox' && browserDetails.version === 57) {
                            maxMessageSize = 65535;
                        }

                        var match = SDPUtils.matchPrefix(description.sdp, 'a=max-message-size:');
                        if (match.length > 0) {
                            maxMessageSize = parseInt(match[0].substr(19), 10);
                        } else if (browserDetails.browser === 'firefox' && remoteIsFirefox !== -1) {
                            // If the maximum message size is not present in the remote SDP and
                            // both local and remote are Firefox, the remote peer can receive
                            // ~2 GiB.
                            maxMessageSize = 2147483637;
                        }
                        return maxMessageSize;
                    };

                    var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
                    window.RTCPeerConnection.prototype.setRemoteDescription = function () {
                        var pc = this;
                        pc._sctp = null;

                        if (sctpInDescription(arguments[0])) {
                            // Check if the remote is FF.
                            var isFirefox = getRemoteFirefoxVersion(arguments[0]);

                            // Get the maximum message size the local peer is capable of sending
                            var canSendMMS = getCanSendMaxMessageSize(isFirefox);

                            // Get the maximum message size of the remote peer.
                            var remoteMMS = getMaxMessageSize(arguments[0], isFirefox);

                            // Determine final maximum message size
                            var maxMessageSize;
                            if (canSendMMS === 0 && remoteMMS === 0) {
                                maxMessageSize = Number.POSITIVE_INFINITY;
                            } else if (canSendMMS === 0 || remoteMMS === 0) {
                                maxMessageSize = Math.max(canSendMMS, remoteMMS);
                            } else {
                                maxMessageSize = Math.min(canSendMMS, remoteMMS);
                            }

                            // Create a dummy RTCSctpTransport object and the 'maxMessageSize'
                            // attribute.
                            var sctp = {};
                            Object.defineProperty(sctp, 'maxMessageSize', {
                                get: function get() {
                                    return maxMessageSize;
                                }
                            });
                            pc._sctp = sctp;
                        }

                        return origSetRemoteDescription.apply(pc, arguments);
                    };
                },

                shimSendThrowTypeError: function shimSendThrowTypeError(window) {
                    if (!(window.RTCPeerConnection && 'createDataChannel' in window.RTCPeerConnection.prototype)) {
                        return;
                    }

                    // Note: Although Firefox >= 57 has a native implementation, the maximum
                    //       message size can be reset for all data channels at a later stage.
                    //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831

                    function wrapDcSend(dc, pc) {
                        var origDataChannelSend = dc.send;
                        dc.send = function () {
                            var data = arguments[0];
                            var length = data.length || data.size || data.byteLength;
                            if (dc.readyState === 'open' && pc.sctp && length > pc.sctp.maxMessageSize) {
                                throw new TypeError('Message too large (can send a maximum of ' + pc.sctp.maxMessageSize + ' bytes)');
                            }
                            return origDataChannelSend.apply(dc, arguments);
                        };
                    }
                    var origCreateDataChannel = window.RTCPeerConnection.prototype.createDataChannel;
                    window.RTCPeerConnection.prototype.createDataChannel = function () {
                        var pc = this;
                        var dataChannel = origCreateDataChannel.apply(pc, arguments);
                        wrapDcSend(dataChannel, pc);
                        return dataChannel;
                    };
                    utils.wrapPeerConnectionEvent(window, 'datachannel', function (e) {
                        wrapDcSend(e.channel, e.target);
                        return e;
                    });
                }
            };
        }, { "./utils": 14, "sdp": 2 }], 8: [function (require, module, exports) {
            /*
            *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
            *
            *  Use of this source code is governed by a BSD-style license
            *  that can be found in the LICENSE file in the root of the source
            *  tree.
            */
            /* eslint-env node */
            'use strict';

            var utils = require('../utils');
            var filterIceServers = require('./filtericeservers');
            var shimRTCPeerConnection = require('rtcpeerconnection-shim');

            module.exports = {
                shimGetUserMedia: require('./getusermedia'),
                shimPeerConnection: function shimPeerConnection(window) {
                    var browserDetails = utils.detectBrowser(window);

                    if (window.RTCIceGatherer) {
                        if (!window.RTCIceCandidate) {
                            window.RTCIceCandidate = function (args) {
                                return args;
                            };
                        }
                        if (!window.RTCSessionDescription) {
                            window.RTCSessionDescription = function (args) {
                                return args;
                            };
                        }
                        // this adds an additional event listener to MediaStrackTrack that signals
                        // when a tracks enabled property was changed. Workaround for a bug in
                        // addStream, see below. No longer required in 15025+
                        if (browserDetails.version < 15025) {
                            var origMSTEnabled = Object.getOwnPropertyDescriptor(window.MediaStreamTrack.prototype, 'enabled');
                            Object.defineProperty(window.MediaStreamTrack.prototype, 'enabled', {
                                set: function set(value) {
                                    origMSTEnabled.set.call(this, value);
                                    var ev = new Event('enabled');
                                    ev.enabled = value;
                                    this.dispatchEvent(ev);
                                }
                            });
                        }
                    }

                    // ORTC defines the DTMF sender a bit different.
                    // https://github.com/w3c/ortc/issues/714
                    if (window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {
                        Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
                            get: function get() {
                                if (this._dtmf === undefined) {
                                    if (this.track.kind === 'audio') {
                                        this._dtmf = new window.RTCDtmfSender(this);
                                    } else if (this.track.kind === 'video') {
                                        this._dtmf = null;
                                    }
                                }
                                return this._dtmf;
                            }
                        });
                    }
                    // Edge currently only implements the RTCDtmfSender, not the
                    // RTCDTMFSender alias. See http://draft.ortc.org/#rtcdtmfsender2*
                    if (window.RTCDtmfSender && !window.RTCDTMFSender) {
                        window.RTCDTMFSender = window.RTCDtmfSender;
                    }

                    var RTCPeerConnectionShim = shimRTCPeerConnection(window, browserDetails.version);
                    window.RTCPeerConnection = function (config) {
                        if (config.iceServers) {
                            config.iceServers = filterIceServers(config.iceServers);
                        }
                        return new RTCPeerConnectionShim(config);
                    };
                    window.RTCPeerConnection.prototype = RTCPeerConnectionShim.prototype;
                },
                shimReplaceTrack: function shimReplaceTrack(window) {
                    // ORTC has replaceTrack -- https://github.com/w3c/ortc/issues/614
                    if (window.RTCRtpSender && !('replaceTrack' in window.RTCRtpSender.prototype)) {
                        window.RTCRtpSender.prototype.replaceTrack = window.RTCRtpSender.prototype.setTrack;
                    }
                }
            };
        }, { "../utils": 14, "./filtericeservers": 9, "./getusermedia": 10, "rtcpeerconnection-shim": 1 }], 9: [function (require, module, exports) {
            /*
            *  Copyright (c) 2018 The WebRTC project authors. All Rights Reserved.
            *
            *  Use of this source code is governed by a BSD-style license
            *  that can be found in the LICENSE file in the root of the source
            *  tree.
            */
            /* eslint-env node */
            'use strict';

            var utils = require('../utils');
            // Edge does not like
            // 1) stun: filtered after 14393 unless ?transport=udp is present
            // 2) turn: that does not have all of turn:host:port?transport=udp
            // 3) turn: with ipv6 addresses
            // 4) turn: occurring muliple times
            module.exports = function (iceServers, edgeVersion) {
                var hasTurn = false;
                iceServers = JSON.parse(JSON.stringify(iceServers));
                return iceServers.filter(function (server) {
                    if (server && (server.urls || server.url)) {
                        var urls = server.urls || server.url;
                        if (server.url && !server.urls) {
                            utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
                        }
                        var isString = typeof urls === 'string';
                        if (isString) {
                            urls = [urls];
                        }
                        urls = urls.filter(function (url) {
                            var validTurn = url.indexOf('turn:') === 0 && url.indexOf('transport=udp') !== -1 && url.indexOf('turn:[') === -1 && !hasTurn;

                            if (validTurn) {
                                hasTurn = true;
                                return true;
                            }
                            return url.indexOf('stun:') === 0 && edgeVersion >= 14393 && url.indexOf('?transport=udp') === -1;
                        });

                        delete server.url;
                        server.urls = isString ? urls[0] : urls;
                        return !!urls.length;
                    }
                });
            };
        }, { "../utils": 14 }], 10: [function (require, module, exports) {
            /*
            *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
            *
            *  Use of this source code is governed by a BSD-style license
            *  that can be found in the LICENSE file in the root of the source
            *  tree.
            */
            /* eslint-env node */
            'use strict';

            // Expose public methods.

            module.exports = function (window) {
                var navigator = window && window.navigator;

                var shimError_ = function shimError_(e) {
                    return {
                        name: { PermissionDeniedError: 'NotAllowedError' }[e.name] || e.name,
                        message: e.message,
                        constraint: e.constraint,
                        toString: function toString() {
                            return this.name;
                        }
                    };
                };

                // getUserMedia error shim.
                var origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
                navigator.mediaDevices.getUserMedia = function (c) {
                    return origGetUserMedia(c).catch(function (e) {
                        return Promise.reject(shimError_(e));
                    });
                };
            };
        }, {}], 11: [function (require, module, exports) {
            /*
            *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
            *
            *  Use of this source code is governed by a BSD-style license
            *  that can be found in the LICENSE file in the root of the source
            *  tree.
            */
            /* eslint-env node */
            'use strict';

            var utils = require('../utils');

            module.exports = {
                shimGetUserMedia: require('./getusermedia'),
                shimOnTrack: function shimOnTrack(window) {
                    if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object' && window.RTCPeerConnection && !('ontrack' in window.RTCPeerConnection.prototype)) {
                        Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
                            get: function get() {
                                return this._ontrack;
                            },
                            set: function set(f) {
                                if (this._ontrack) {
                                    this.removeEventListener('track', this._ontrack);
                                    this.removeEventListener('addstream', this._ontrackpoly);
                                }
                                this.addEventListener('track', this._ontrack = f);
                                this.addEventListener('addstream', this._ontrackpoly = function (e) {
                                    e.stream.getTracks().forEach(function (track) {
                                        var event = new Event('track');
                                        event.track = track;
                                        event.receiver = { track: track };
                                        event.transceiver = { receiver: event.receiver };
                                        event.streams = [e.stream];
                                        this.dispatchEvent(event);
                                    }.bind(this));
                                }.bind(this));
                            }
                        });
                    }
                    if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {
                        Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
                            get: function get() {
                                return { receiver: this.receiver };
                            }
                        });
                    }
                },

                shimSourceObject: function shimSourceObject(window) {
                    // Firefox has supported mozSrcObject since FF22, unprefixed in 42.
                    if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object') {
                        if (window.HTMLMediaElement && !('srcObject' in window.HTMLMediaElement.prototype)) {
                            // Shim the srcObject property, once, when HTMLMediaElement is found.
                            Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {
                                get: function get() {
                                    return this.mozSrcObject;
                                },
                                set: function set(stream) {
                                    this.mozSrcObject = stream;
                                }
                            });
                        }
                    }
                },

                shimPeerConnection: function shimPeerConnection(window) {
                    var browserDetails = utils.detectBrowser(window);

                    if ((typeof window === "undefined" ? "undefined" : _typeof(window)) !== 'object' || !(window.RTCPeerConnection || window.mozRTCPeerConnection)) {
                        return; // probably media.peerconnection.enabled=false in about:config
                    }
                    // The RTCPeerConnection object.
                    if (!window.RTCPeerConnection) {
                        window.RTCPeerConnection = function (pcConfig, pcConstraints) {
                            if (browserDetails.version < 38) {
                                // .urls is not supported in FF < 38.
                                // create RTCIceServers with a single url.
                                if (pcConfig && pcConfig.iceServers) {
                                    var newIceServers = [];
                                    for (var i = 0; i < pcConfig.iceServers.length; i++) {
                                        var server = pcConfig.iceServers[i];
                                        if (server.hasOwnProperty('urls')) {
                                            for (var j = 0; j < server.urls.length; j++) {
                                                var newServer = {
                                                    url: server.urls[j]
                                                };
                                                if (server.urls[j].indexOf('turn') === 0) {
                                                    newServer.username = server.username;
                                                    newServer.credential = server.credential;
                                                }
                                                newIceServers.push(newServer);
                                            }
                                        } else {
                                            newIceServers.push(pcConfig.iceServers[i]);
                                        }
                                    }
                                    pcConfig.iceServers = newIceServers;
                                }
                            }
                            return new window.mozRTCPeerConnection(pcConfig, pcConstraints);
                        };
                        window.RTCPeerConnection.prototype = window.mozRTCPeerConnection.prototype;

                        // wrap static methods. Currently just generateCertificate.
                        if (window.mozRTCPeerConnection.generateCertificate) {
                            Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
                                get: function get() {
                                    return window.mozRTCPeerConnection.generateCertificate;
                                }
                            });
                        }

                        window.RTCSessionDescription = window.mozRTCSessionDescription;
                        window.RTCIceCandidate = window.mozRTCIceCandidate;
                    }

                    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.
                    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {
                        var nativeMethod = window.RTCPeerConnection.prototype[method];
                        window.RTCPeerConnection.prototype[method] = function () {
                            arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);
                            return nativeMethod.apply(this, arguments);
                        };
                    });

                    // support for addIceCandidate(null or undefined)
                    var nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;
                    window.RTCPeerConnection.prototype.addIceCandidate = function () {
                        if (!arguments[0]) {
                            if (arguments[1]) {
                                arguments[1].apply(null);
                            }
                            return Promise.resolve();
                        }
                        return nativeAddIceCandidate.apply(this, arguments);
                    };

                    // shim getStats with maplike support
                    var makeMapStats = function makeMapStats(stats) {
                        var map = new Map();
                        Object.keys(stats).forEach(function (key) {
                            map.set(key, stats[key]);
                            map[key] = stats[key];
                        });
                        return map;
                    };

                    var modernStatsTypes = {
                        inboundrtp: 'inbound-rtp',
                        outboundrtp: 'outbound-rtp',
                        candidatepair: 'candidate-pair',
                        localcandidate: 'local-candidate',
                        remotecandidate: 'remote-candidate'
                    };

                    var nativeGetStats = window.RTCPeerConnection.prototype.getStats;
                    window.RTCPeerConnection.prototype.getStats = function (selector, onSucc, onErr) {
                        return nativeGetStats.apply(this, [selector || null]).then(function (stats) {
                            if (browserDetails.version < 48) {
                                stats = makeMapStats(stats);
                            }
                            if (browserDetails.version < 53 && !onSucc) {
                                // Shim only promise getStats with spec-hyphens in type names
                                // Leave callback version alone; misc old uses of forEach before Map
                                try {
                                    stats.forEach(function (stat) {
                                        stat.type = modernStatsTypes[stat.type] || stat.type;
                                    });
                                } catch (e) {
                                    if (e.name !== 'TypeError') {
                                        throw e;
                                    }
                                    // Avoid TypeError: "type" is read-only, in old versions. 34-43ish
                                    stats.forEach(function (stat, i) {
                                        stats.set(i, Object.assign({}, stat, {
                                            type: modernStatsTypes[stat.type] || stat.type
                                        }));
                                    });
                                }
                            }
                            return stats;
                        }).then(onSucc, onErr);
                    };
                },

                shimSenderGetStats: function shimSenderGetStats(window) {
                    if (!((typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {
                        return;
                    }
                    if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {
                        return;
                    }
                    var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
                    if (origGetSenders) {
                        window.RTCPeerConnection.prototype.getSenders = function () {
                            var pc = this;
                            var senders = origGetSenders.apply(pc, []);
                            senders.forEach(function (sender) {
                                sender._pc = pc;
                            });
                            return senders;
                        };
                    }

                    var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
                    if (origAddTrack) {
                        window.RTCPeerConnection.prototype.addTrack = function () {
                            var sender = origAddTrack.apply(this, arguments);
                            sender._pc = this;
                            return sender;
                        };
                    }
                    window.RTCRtpSender.prototype.getStats = function () {
                        return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map());
                    };
                },

                shimReceiverGetStats: function shimReceiverGetStats(window) {
                    if (!((typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {
                        return;
                    }
                    if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {
                        return;
                    }
                    var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
                    if (origGetReceivers) {
                        window.RTCPeerConnection.prototype.getReceivers = function () {
                            var pc = this;
                            var receivers = origGetReceivers.apply(pc, []);
                            receivers.forEach(function (receiver) {
                                receiver._pc = pc;
                            });
                            return receivers;
                        };
                    }
                    utils.wrapPeerConnectionEvent(window, 'track', function (e) {
                        e.receiver._pc = e.srcElement;
                        return e;
                    });
                    window.RTCRtpReceiver.prototype.getStats = function () {
                        return this._pc.getStats(this.track);
                    };
                },

                shimRemoveStream: function shimRemoveStream(window) {
                    if (!window.RTCPeerConnection || 'removeStream' in window.RTCPeerConnection.prototype) {
                        return;
                    }
                    window.RTCPeerConnection.prototype.removeStream = function (stream) {
                        var pc = this;
                        utils.deprecated('removeStream', 'removeTrack');
                        this.getSenders().forEach(function (sender) {
                            if (sender.track && stream.getTracks().indexOf(sender.track) !== -1) {
                                pc.removeTrack(sender);
                            }
                        });
                    };
                },

                shimRTCDataChannel: function shimRTCDataChannel(window) {
                    // rename DataChannel to RTCDataChannel (native fix in FF60):
                    // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851
                    if (window.DataChannel && !window.RTCDataChannel) {
                        window.RTCDataChannel = window.DataChannel;
                    }
                }
            };
        }, { "../utils": 14, "./getusermedia": 12 }], 12: [function (require, module, exports) {
            /*
            *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
            *
            *  Use of this source code is governed by a BSD-style license
            *  that can be found in the LICENSE file in the root of the source
            *  tree.
            */
            /* eslint-env node */
            'use strict';

            var utils = require('../utils');
            var logging = utils.log;

            // Expose public methods.
            module.exports = function (window) {
                var browserDetails = utils.detectBrowser(window);
                var navigator = window && window.navigator;
                var MediaStreamTrack = window && window.MediaStreamTrack;

                var shimError_ = function shimError_(e) {
                    return {
                        name: {
                            InternalError: 'NotReadableError',
                            NotSupportedError: 'TypeError',
                            PermissionDeniedError: 'NotAllowedError',
                            SecurityError: 'NotAllowedError'
                        }[e.name] || e.name,
                        message: {
                            'The operation is insecure.': 'The request is not allowed by the ' + 'user agent or the platform in the current context.'
                        }[e.message] || e.message,
                        constraint: e.constraint,
                        toString: function toString() {
                            return this.name + (this.message && ': ') + this.message;
                        }
                    };
                };

                // getUserMedia constraints shim.
                var getUserMedia_ = function getUserMedia_(constraints, onSuccess, onError) {
                    var constraintsToFF37_ = function constraintsToFF37_(c) {
                        if ((typeof c === "undefined" ? "undefined" : _typeof(c)) !== 'object' || c.require) {
                            return c;
                        }
                        var require = [];
                        Object.keys(c).forEach(function (key) {
                            if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
                                return;
                            }
                            var r = c[key] = _typeof(c[key]) === 'object' ? c[key] : { ideal: c[key] };
                            if (r.min !== undefined || r.max !== undefined || r.exact !== undefined) {
                                require.push(key);
                            }
                            if (r.exact !== undefined) {
                                if (typeof r.exact === 'number') {
                                    r.min = r.max = r.exact;
                                } else {
                                    c[key] = r.exact;
                                }
                                delete r.exact;
                            }
                            if (r.ideal !== undefined) {
                                c.advanced = c.advanced || [];
                                var oc = {};
                                if (typeof r.ideal === 'number') {
                                    oc[key] = { min: r.ideal, max: r.ideal };
                                } else {
                                    oc[key] = r.ideal;
                                }
                                c.advanced.push(oc);
                                delete r.ideal;
                                if (!Object.keys(r).length) {
                                    delete c[key];
                                }
                            }
                        });
                        if (require.length) {
                            c.require = require;
                        }
                        return c;
                    };
                    constraints = JSON.parse(JSON.stringify(constraints));
                    if (browserDetails.version < 38) {
                        logging('spec: ' + JSON.stringify(constraints));
                        if (constraints.audio) {
                            constraints.audio = constraintsToFF37_(constraints.audio);
                        }
                        if (constraints.video) {
                            constraints.video = constraintsToFF37_(constraints.video);
                        }
                        logging('ff37: ' + JSON.stringify(constraints));
                    }
                    return navigator.mozGetUserMedia(constraints, onSuccess, function (e) {
                        onError(shimError_(e));
                    });
                };

                // Returns the result of getUserMedia as a Promise.
                var getUserMediaPromise_ = function getUserMediaPromise_(constraints) {
                    return new Promise(function (resolve, reject) {
                        getUserMedia_(constraints, resolve, reject);
                    });
                };

                // Shim for mediaDevices on older versions.
                if (!navigator.mediaDevices) {
                    navigator.mediaDevices = { getUserMedia: getUserMediaPromise_,
                        addEventListener: function addEventListener() {},
                        removeEventListener: function removeEventListener() {}
                    };
                }
                navigator.mediaDevices.enumerateDevices = navigator.mediaDevices.enumerateDevices || function () {
                    return new Promise(function (resolve) {
                        var infos = [{ kind: 'audioinput', deviceId: 'default', label: '', groupId: '' }, { kind: 'videoinput', deviceId: 'default', label: '', groupId: '' }];
                        resolve(infos);
                    });
                };

                if (browserDetails.version < 41) {
                    // Work around http://bugzil.la/1169665
                    var orgEnumerateDevices = navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);
                    navigator.mediaDevices.enumerateDevices = function () {
                        return orgEnumerateDevices().then(undefined, function (e) {
                            if (e.name === 'NotFoundError') {
                                return [];
                            }
                            throw e;
                        });
                    };
                }
                if (browserDetails.version < 49) {
                    var origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
                    navigator.mediaDevices.getUserMedia = function (c) {
                        return origGetUserMedia(c).then(function (stream) {
                            // Work around https://bugzil.la/802326
                            if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {
                                stream.getTracks().forEach(function (track) {
                                    track.stop();
                                });
                                throw new DOMException('The object can not be found here.', 'NotFoundError');
                            }
                            return stream;
                        }, function (e) {
                            return Promise.reject(shimError_(e));
                        });
                    };
                }
                if (!(browserDetails.version > 55 && 'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {
                    var remap = function remap(obj, a, b) {
                        if (a in obj && !(b in obj)) {
                            obj[b] = obj[a];
                            delete obj[a];
                        }
                    };

                    var nativeGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
                    navigator.mediaDevices.getUserMedia = function (c) {
                        if ((typeof c === "undefined" ? "undefined" : _typeof(c)) === 'object' && _typeof(c.audio) === 'object') {
                            c = JSON.parse(JSON.stringify(c));
                            remap(c.audio, 'autoGainControl', 'mozAutoGainControl');
                            remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');
                        }
                        return nativeGetUserMedia(c);
                    };

                    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {
                        var nativeGetSettings = MediaStreamTrack.prototype.getSettings;
                        MediaStreamTrack.prototype.getSettings = function () {
                            var obj = nativeGetSettings.apply(this, arguments);
                            remap(obj, 'mozAutoGainControl', 'autoGainControl');
                            remap(obj, 'mozNoiseSuppression', 'noiseSuppression');
                            return obj;
                        };
                    }

                    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {
                        var nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;
                        MediaStreamTrack.prototype.applyConstraints = function (c) {
                            if (this.kind === 'audio' && (typeof c === "undefined" ? "undefined" : _typeof(c)) === 'object') {
                                c = JSON.parse(JSON.stringify(c));
                                remap(c, 'autoGainControl', 'mozAutoGainControl');
                                remap(c, 'noiseSuppression', 'mozNoiseSuppression');
                            }
                            return nativeApplyConstraints.apply(this, [c]);
                        };
                    }
                }
                navigator.getUserMedia = function (constraints, onSuccess, onError) {
                    if (browserDetails.version < 44) {
                        return getUserMedia_(constraints, onSuccess, onError);
                    }
                    // Replace Firefox 44+'s deprecation warning with unprefixed version.
                    utils.deprecated('navigator.getUserMedia', 'navigator.mediaDevices.getUserMedia');
                    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
                };
            };
        }, { "../utils": 14 }], 13: [function (require, module, exports) {
            /*
            *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
            *
            *  Use of this source code is governed by a BSD-style license
            *  that can be found in the LICENSE file in the root of the source
            *  tree.
            */
            'use strict';

            var utils = require('../utils');

            module.exports = {
                shimLocalStreamsAPI: function shimLocalStreamsAPI(window) {
                    if ((typeof window === "undefined" ? "undefined" : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {
                        return;
                    }
                    if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {
                        window.RTCPeerConnection.prototype.getLocalStreams = function () {
                            if (!this._localStreams) {
                                this._localStreams = [];
                            }
                            return this._localStreams;
                        };
                    }
                    if (!('getStreamById' in window.RTCPeerConnection.prototype)) {
                        window.RTCPeerConnection.prototype.getStreamById = function (id) {
                            var result = null;
                            if (this._localStreams) {
                                this._localStreams.forEach(function (stream) {
                                    if (stream.id === id) {
                                        result = stream;
                                    }
                                });
                            }
                            if (this._remoteStreams) {
                                this._remoteStreams.forEach(function (stream) {
                                    if (stream.id === id) {
                                        result = stream;
                                    }
                                });
                            }
                            return result;
                        };
                    }
                    if (!('addStream' in window.RTCPeerConnection.prototype)) {
                        var _addTrack = window.RTCPeerConnection.prototype.addTrack;
                        window.RTCPeerConnection.prototype.addStream = function (stream) {
                            if (!this._localStreams) {
                                this._localStreams = [];
                            }
                            if (this._localStreams.indexOf(stream) === -1) {
                                this._localStreams.push(stream);
                            }
                            var pc = this;
                            stream.getTracks().forEach(function (track) {
                                _addTrack.call(pc, track, stream);
                            });
                        };

                        window.RTCPeerConnection.prototype.addTrack = function (track, stream) {
                            if (stream) {
                                if (!this._localStreams) {
                                    this._localStreams = [stream];
                                } else if (this._localStreams.indexOf(stream) === -1) {
                                    this._localStreams.push(stream);
                                }
                            }
                            return _addTrack.call(this, track, stream);
                        };
                    }
                    if (!('removeStream' in window.RTCPeerConnection.prototype)) {
                        window.RTCPeerConnection.prototype.removeStream = function (stream) {
                            if (!this._localStreams) {
                                this._localStreams = [];
                            }
                            var index = this._localStreams.indexOf(stream);
                            if (index === -1) {
                                return;
                            }
                            this._localStreams.splice(index, 1);
                            var pc = this;
                            var tracks = stream.getTracks();
                            this.getSenders().forEach(function (sender) {
                                if (tracks.indexOf(sender.track) !== -1) {
                                    pc.removeTrack(sender);
                                }
                            });
                        };
                    }
                },
                shimRemoteStreamsAPI: function shimRemoteStreamsAPI(window) {
                    if ((typeof window === "undefined" ? "undefined" : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {
                        return;
                    }
                    if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {
                        window.RTCPeerConnection.prototype.getRemoteStreams = function () {
                            return this._remoteStreams ? this._remoteStreams : [];
                        };
                    }
                    if (!('onaddstream' in window.RTCPeerConnection.prototype)) {
                        Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {
                            get: function get() {
                                return this._onaddstream;
                            },
                            set: function set(f) {
                                var pc = this;
                                if (this._onaddstream) {
                                    this.removeEventListener('addstream', this._onaddstream);
                                    this.removeEventListener('track', this._onaddstreampoly);
                                }
                                this.addEventListener('addstream', this._onaddstream = f);
                                this.addEventListener('track', this._onaddstreampoly = function (e) {
                                    e.streams.forEach(function (stream) {
                                        if (!pc._remoteStreams) {
                                            pc._remoteStreams = [];
                                        }
                                        if (pc._remoteStreams.indexOf(stream) >= 0) {
                                            return;
                                        }
                                        pc._remoteStreams.push(stream);
                                        var event = new Event('addstream');
                                        event.stream = stream;
                                        pc.dispatchEvent(event);
                                    });
                                });
                            }
                        });
                    }
                },
                shimCallbacksAPI: function shimCallbacksAPI(window) {
                    if ((typeof window === "undefined" ? "undefined" : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {
                        return;
                    }
                    var prototype = window.RTCPeerConnection.prototype;
                    var createOffer = prototype.createOffer;
                    var createAnswer = prototype.createAnswer;
                    var setLocalDescription = prototype.setLocalDescription;
                    var setRemoteDescription = prototype.setRemoteDescription;
                    var addIceCandidate = prototype.addIceCandidate;

                    prototype.createOffer = function (successCallback, failureCallback) {
                        var options = arguments.length >= 2 ? arguments[2] : arguments[0];
                        var promise = createOffer.apply(this, [options]);
                        if (!failureCallback) {
                            return promise;
                        }
                        promise.then(successCallback, failureCallback);
                        return Promise.resolve();
                    };

                    prototype.createAnswer = function (successCallback, failureCallback) {
                        var options = arguments.length >= 2 ? arguments[2] : arguments[0];
                        var promise = createAnswer.apply(this, [options]);
                        if (!failureCallback) {
                            return promise;
                        }
                        promise.then(successCallback, failureCallback);
                        return Promise.resolve();
                    };

                    var withCallback = function withCallback(description, successCallback, failureCallback) {
                        var promise = setLocalDescription.apply(this, [description]);
                        if (!failureCallback) {
                            return promise;
                        }
                        promise.then(successCallback, failureCallback);
                        return Promise.resolve();
                    };
                    prototype.setLocalDescription = withCallback;

                    withCallback = function withCallback(description, successCallback, failureCallback) {
                        var promise = setRemoteDescription.apply(this, [description]);
                        if (!failureCallback) {
                            return promise;
                        }
                        promise.then(successCallback, failureCallback);
                        return Promise.resolve();
                    };
                    prototype.setRemoteDescription = withCallback;

                    withCallback = function withCallback(candidate, successCallback, failureCallback) {
                        var promise = addIceCandidate.apply(this, [candidate]);
                        if (!failureCallback) {
                            return promise;
                        }
                        promise.then(successCallback, failureCallback);
                        return Promise.resolve();
                    };
                    prototype.addIceCandidate = withCallback;
                },
                shimGetUserMedia: function shimGetUserMedia(window) {
                    var navigator = window && window.navigator;

                    if (!navigator.getUserMedia) {
                        if (navigator.webkitGetUserMedia) {
                            navigator.getUserMedia = navigator.webkitGetUserMedia.bind(navigator);
                        } else if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                            navigator.getUserMedia = function (constraints, cb, errcb) {
                                navigator.mediaDevices.getUserMedia(constraints).then(cb, errcb);
                            }.bind(navigator);
                        }
                    }
                },
                shimRTCIceServerUrls: function shimRTCIceServerUrls(window) {
                    // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
                    var OrigPeerConnection = window.RTCPeerConnection;
                    window.RTCPeerConnection = function (pcConfig, pcConstraints) {
                        if (pcConfig && pcConfig.iceServers) {
                            var newIceServers = [];
                            for (var i = 0; i < pcConfig.iceServers.length; i++) {
                                var server = pcConfig.iceServers[i];
                                if (!server.hasOwnProperty('urls') && server.hasOwnProperty('url')) {
                                    utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
                                    server = JSON.parse(JSON.stringify(server));
                                    server.urls = server.url;
                                    delete server.url;
                                    newIceServers.push(server);
                                } else {
                                    newIceServers.push(pcConfig.iceServers[i]);
                                }
                            }
                            pcConfig.iceServers = newIceServers;
                        }
                        return new OrigPeerConnection(pcConfig, pcConstraints);
                    };
                    window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
                    // wrap static methods. Currently just generateCertificate.
                    if ('generateCertificate' in window.RTCPeerConnection) {
                        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
                            get: function get() {
                                return OrigPeerConnection.generateCertificate;
                            }
                        });
                    }
                },
                shimTrackEventTransceiver: function shimTrackEventTransceiver(window) {
                    // Add event.transceiver member over deprecated event.receiver
                    if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object' && window.RTCPeerConnection && 'receiver' in window.RTCTrackEvent.prototype &&
                    // can't check 'transceiver' in window.RTCTrackEvent.prototype, as it is
                    // defined for some reason even when window.RTCTransceiver is not.
                    !window.RTCTransceiver) {
                        Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
                            get: function get() {
                                return { receiver: this.receiver };
                            }
                        });
                    }
                },

                shimCreateOfferLegacy: function shimCreateOfferLegacy(window) {
                    var origCreateOffer = window.RTCPeerConnection.prototype.createOffer;
                    window.RTCPeerConnection.prototype.createOffer = function (offerOptions) {
                        var pc = this;
                        if (offerOptions) {
                            if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {
                                // support bit values
                                offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;
                            }
                            var audioTransceiver = pc.getTransceivers().find(function (transceiver) {
                                return transceiver.sender.track && transceiver.sender.track.kind === 'audio';
                            });
                            if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
                                if (audioTransceiver.direction === 'sendrecv') {
                                    if (audioTransceiver.setDirection) {
                                        audioTransceiver.setDirection('sendonly');
                                    } else {
                                        audioTransceiver.direction = 'sendonly';
                                    }
                                } else if (audioTransceiver.direction === 'recvonly') {
                                    if (audioTransceiver.setDirection) {
                                        audioTransceiver.setDirection('inactive');
                                    } else {
                                        audioTransceiver.direction = 'inactive';
                                    }
                                }
                            } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {
                                pc.addTransceiver('audio');
                            }

                            if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {
                                // support bit values
                                offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;
                            }
                            var videoTransceiver = pc.getTransceivers().find(function (transceiver) {
                                return transceiver.sender.track && transceiver.sender.track.kind === 'video';
                            });
                            if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
                                if (videoTransceiver.direction === 'sendrecv') {
                                    videoTransceiver.setDirection('sendonly');
                                } else if (videoTransceiver.direction === 'recvonly') {
                                    videoTransceiver.setDirection('inactive');
                                }
                            } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {
                                pc.addTransceiver('video');
                            }
                        }
                        return origCreateOffer.apply(pc, arguments);
                    };
                }
            };
        }, { "../utils": 14 }], 14: [function (require, module, exports) {
            /*
            *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
            *
            *  Use of this source code is governed by a BSD-style license
            *  that can be found in the LICENSE file in the root of the source
            *  tree.
            */
            /* eslint-env node */
            'use strict';

            var logDisabled_ = true;
            var deprecationWarnings_ = true;

            /**
             * Extract browser version out of the provided user agent string.
             *
             * @param {!string} uastring userAgent string.
             * @param {!string} expr Regular expression used as match criteria.
             * @param {!number} pos position in the version string to be returned.
             * @return {!number} browser version.
             */
            function extractVersion(uastring, expr, pos) {
                var match = uastring.match(expr);
                return match && match.length >= pos && parseInt(match[pos], 10);
            }

            // Wraps the peerconnection event eventNameToWrap in a function
            // which returns the modified event object.
            function wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {
                if (!window.RTCPeerConnection) {
                    return;
                }
                var proto = window.RTCPeerConnection.prototype;
                var nativeAddEventListener = proto.addEventListener;
                proto.addEventListener = function (nativeEventName, cb) {
                    if (nativeEventName !== eventNameToWrap) {
                        return nativeAddEventListener.apply(this, arguments);
                    }
                    var wrappedCallback = function wrappedCallback(e) {
                        cb(wrapper(e));
                    };
                    this._eventMap = this._eventMap || {};
                    this._eventMap[cb] = wrappedCallback;
                    return nativeAddEventListener.apply(this, [nativeEventName, wrappedCallback]);
                };

                var nativeRemoveEventListener = proto.removeEventListener;
                proto.removeEventListener = function (nativeEventName, cb) {
                    if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[cb]) {
                        return nativeRemoveEventListener.apply(this, arguments);
                    }
                    var unwrappedCb = this._eventMap[cb];
                    delete this._eventMap[cb];
                    return nativeRemoveEventListener.apply(this, [nativeEventName, unwrappedCb]);
                };

                Object.defineProperty(proto, 'on' + eventNameToWrap, {
                    get: function get() {
                        return this['_on' + eventNameToWrap];
                    },
                    set: function set(cb) {
                        if (this['_on' + eventNameToWrap]) {
                            this.removeEventListener(eventNameToWrap, this['_on' + eventNameToWrap]);
                            delete this['_on' + eventNameToWrap];
                        }
                        if (cb) {
                            this.addEventListener(eventNameToWrap, this['_on' + eventNameToWrap] = cb);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
            }

            // Utility methods.
            module.exports = {
                extractVersion: extractVersion,
                wrapPeerConnectionEvent: wrapPeerConnectionEvent,
                disableLog: function disableLog(bool) {
                    if (typeof bool !== 'boolean') {
                        return new Error('Argument type: ' + (typeof bool === "undefined" ? "undefined" : _typeof(bool)) + '. Please use a boolean.');
                    }
                    logDisabled_ = bool;
                    return bool ? 'adapter.js logging disabled' : 'adapter.js logging enabled';
                },

                /**
                 * Disable or enable deprecation warnings
                 * @param {!boolean} bool set to true to disable warnings.
                 */
                disableWarnings: function disableWarnings(bool) {
                    if (typeof bool !== 'boolean') {
                        return new Error('Argument type: ' + (typeof bool === "undefined" ? "undefined" : _typeof(bool)) + '. Please use a boolean.');
                    }
                    deprecationWarnings_ = !bool;
                    return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');
                },

                log: function log() {
                    if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object') {
                        if (logDisabled_) {
                            return;
                        }
                        if (typeof console !== 'undefined' && typeof console.log === 'function') {
                            console.log.apply(console, arguments);
                        }
                    }
                },

                /**
                 * Shows a deprecation warning suggesting the modern and spec-compatible API.
                 */
                deprecated: function deprecated(oldMethod, newMethod) {
                    if (!deprecationWarnings_) {
                        return;
                    }
                    console.warn(oldMethod + ' is deprecated, please use ' + newMethod + ' instead.');
                },

                /**
                 * Browser detector.
                 *
                 * @return {object} result containing browser and version
                 *     properties.
                 */
                detectBrowser: function detectBrowser(window) {
                    var navigator = window && window.navigator;

                    // Returned result object.
                    var result = {};
                    result.browser = null;
                    result.version = null;

                    // Fail early if it's not a browser
                    if (typeof window === 'undefined' || !window.navigator) {
                        result.browser = 'Not a browser.';
                        return result;
                    }

                    if (navigator.mozGetUserMedia) {
                        // Firefox.
                        result.browser = 'firefox';
                        result.version = extractVersion(navigator.userAgent, /Firefox\/(\d+)\./, 1);
                    } else if (navigator.webkitGetUserMedia) {
                        // Chrome, Chromium, Webview, Opera.
                        // Version matches Chrome/WebRTC version.
                        result.browser = 'chrome';
                        result.version = extractVersion(navigator.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
                    } else if (navigator.mediaDevices && navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)) {
                        // Edge.
                        result.browser = 'edge';
                        result.version = extractVersion(navigator.userAgent, /Edge\/(\d+).(\d+)$/, 2);
                    } else if (window.RTCPeerConnection && navigator.userAgent.match(/AppleWebKit\/(\d+)\./)) {
                        // Safari.
                        result.browser = 'safari';
                        result.version = extractVersion(navigator.userAgent, /AppleWebKit\/(\d+)\./, 1);
                    } else {
                        // Default fallthrough: not supported.
                        result.browser = 'Not a supported browser.';
                        return result;
                    }

                    return result;
                }
            };
        }, {}] }, {}, [3])(3);
});

/***/ }),
/* 4 */,
/* 5 */,
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(7)(__webpack_require__(8))

/*** EXPORTS FROM exports-loader ***/
module.exports = window.Zepto;

/***/ }),
/* 7 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
module.exports = function(src) {
	function log(error) {
		(typeof console !== "undefined")
		&& (console.error || console.log)("[Script Loader]", error);
	}

	// Check for IE =< 8
	function isIE() {
		return typeof attachEvent !== "undefined" && typeof addEventListener === "undefined";
	}

	try {
		if (typeof execScript !== "undefined" && isIE()) {
			execScript(src);
		} else if (typeof eval !== "undefined") {
			eval.call(null, src);
		} else {
			log("EvalError: No eval function available");
		}
	} catch (error) {
		log(error);
	}
}


/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports = "/* Zepto v1.2.0 - zepto event ajax form ie - zeptojs.com/license */\n(function(global, factory) {\n  if (typeof define === 'function' && define.amd)\n    define(function() { return factory(global) })\n  else\n    factory(global)\n}(this, function(window) {\n  var Zepto = (function() {\n  var undefined, key, $, classList, emptyArray = [], concat = emptyArray.concat, filter = emptyArray.filter, slice = emptyArray.slice,\n    document = window.document,\n    elementDisplay = {}, classCache = {},\n    cssNumber = { 'column-count': 1, 'columns': 1, 'font-weight': 1, 'line-height': 1,'opacity': 1, 'z-index': 1, 'zoom': 1 },\n    fragmentRE = /^\\s*<(\\w+|!)[^>]*>/,\n    singleTagRE = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,\n    tagExpanderRE = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/ig,\n    rootNodeRE = /^(?:body|html)$/i,\n    capitalRE = /([A-Z])/g,\n\n    // special attributes that should be get/set via method calls\n    methodAttributes = ['val', 'css', 'html', 'text', 'data', 'width', 'height', 'offset'],\n\n    adjacencyOperators = [ 'after', 'prepend', 'before', 'append' ],\n    table = document.createElement('table'),\n    tableRow = document.createElement('tr'),\n    containers = {\n      'tr': document.createElement('tbody'),\n      'tbody': table, 'thead': table, 'tfoot': table,\n      'td': tableRow, 'th': tableRow,\n      '*': document.createElement('div')\n    },\n    readyRE = /complete|loaded|interactive/,\n    simpleSelectorRE = /^[\\w-]*$/,\n    class2type = {},\n    toString = class2type.toString,\n    zepto = {},\n    camelize, uniq,\n    tempParent = document.createElement('div'),\n    propMap = {\n      'tabindex': 'tabIndex',\n      'readonly': 'readOnly',\n      'for': 'htmlFor',\n      'class': 'className',\n      'maxlength': 'maxLength',\n      'cellspacing': 'cellSpacing',\n      'cellpadding': 'cellPadding',\n      'rowspan': 'rowSpan',\n      'colspan': 'colSpan',\n      'usemap': 'useMap',\n      'frameborder': 'frameBorder',\n      'contenteditable': 'contentEditable'\n    },\n    isArray = Array.isArray ||\n      function(object){ return object instanceof Array }\n\n  zepto.matches = function(element, selector) {\n    if (!selector || !element || element.nodeType !== 1) return false\n    var matchesSelector = element.matches || element.webkitMatchesSelector ||\n                          element.mozMatchesSelector || element.oMatchesSelector ||\n                          element.matchesSelector\n    if (matchesSelector) return matchesSelector.call(element, selector)\n    // fall back to performing a selector:\n    var match, parent = element.parentNode, temp = !parent\n    if (temp) (parent = tempParent).appendChild(element)\n    match = ~zepto.qsa(parent, selector).indexOf(element)\n    temp && tempParent.removeChild(element)\n    return match\n  }\n\n  function type(obj) {\n    return obj == null ? String(obj) :\n      class2type[toString.call(obj)] || \"object\"\n  }\n\n  function isFunction(value) { return type(value) == \"function\" }\n  function isWindow(obj)     { return obj != null && obj == obj.window }\n  function isDocument(obj)   { return obj != null && obj.nodeType == obj.DOCUMENT_NODE }\n  function isObject(obj)     { return type(obj) == \"object\" }\n  function isPlainObject(obj) {\n    return isObject(obj) && !isWindow(obj) && Object.getPrototypeOf(obj) == Object.prototype\n  }\n\n  function likeArray(obj) {\n    var length = !!obj && 'length' in obj && obj.length,\n      type = $.type(obj)\n\n    return 'function' != type && !isWindow(obj) && (\n      'array' == type || length === 0 ||\n        (typeof length == 'number' && length > 0 && (length - 1) in obj)\n    )\n  }\n\n  function compact(array) { return filter.call(array, function(item){ return item != null }) }\n  function flatten(array) { return array.length > 0 ? $.fn.concat.apply([], array) : array }\n  camelize = function(str){ return str.replace(/-+(.)?/g, function(match, chr){ return chr ? chr.toUpperCase() : '' }) }\n  function dasherize(str) {\n    return str.replace(/::/g, '/')\n           .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')\n           .replace(/([a-z\\d])([A-Z])/g, '$1_$2')\n           .replace(/_/g, '-')\n           .toLowerCase()\n  }\n  uniq = function(array){ return filter.call(array, function(item, idx){ return array.indexOf(item) == idx }) }\n\n  function classRE(name) {\n    return name in classCache ?\n      classCache[name] : (classCache[name] = new RegExp('(^|\\\\s)' + name + '(\\\\s|$)'))\n  }\n\n  function maybeAddPx(name, value) {\n    return (typeof value == \"number\" && !cssNumber[dasherize(name)]) ? value + \"px\" : value\n  }\n\n  function defaultDisplay(nodeName) {\n    var element, display\n    if (!elementDisplay[nodeName]) {\n      element = document.createElement(nodeName)\n      document.body.appendChild(element)\n      display = getComputedStyle(element, '').getPropertyValue(\"display\")\n      element.parentNode.removeChild(element)\n      display == \"none\" && (display = \"block\")\n      elementDisplay[nodeName] = display\n    }\n    return elementDisplay[nodeName]\n  }\n\n  function children(element) {\n    return 'children' in element ?\n      slice.call(element.children) :\n      $.map(element.childNodes, function(node){ if (node.nodeType == 1) return node })\n  }\n\n  function Z(dom, selector) {\n    var i, len = dom ? dom.length : 0\n    for (i = 0; i < len; i++) this[i] = dom[i]\n    this.length = len\n    this.selector = selector || ''\n  }\n\n  // `$.zepto.fragment` takes a html string and an optional tag name\n  // to generate DOM nodes from the given html string.\n  // The generated DOM nodes are returned as an array.\n  // This function can be overridden in plugins for example to make\n  // it compatible with browsers that don't support the DOM fully.\n  zepto.fragment = function(html, name, properties) {\n    var dom, nodes, container\n\n    // A special case optimization for a single tag\n    if (singleTagRE.test(html)) dom = $(document.createElement(RegExp.$1))\n\n    if (!dom) {\n      if (html.replace) html = html.replace(tagExpanderRE, \"<$1></$2>\")\n      if (name === undefined) name = fragmentRE.test(html) && RegExp.$1\n      if (!(name in containers)) name = '*'\n\n      container = containers[name]\n      container.innerHTML = '' + html\n      dom = $.each(slice.call(container.childNodes), function(){\n        container.removeChild(this)\n      })\n    }\n\n    if (isPlainObject(properties)) {\n      nodes = $(dom)\n      $.each(properties, function(key, value) {\n        if (methodAttributes.indexOf(key) > -1) nodes[key](value)\n        else nodes.attr(key, value)\n      })\n    }\n\n    return dom\n  }\n\n  // `$.zepto.Z` swaps out the prototype of the given `dom` array\n  // of nodes with `$.fn` and thus supplying all the Zepto functions\n  // to the array. This method can be overridden in plugins.\n  zepto.Z = function(dom, selector) {\n    return new Z(dom, selector)\n  }\n\n  // `$.zepto.isZ` should return `true` if the given object is a Zepto\n  // collection. This method can be overridden in plugins.\n  zepto.isZ = function(object) {\n    return object instanceof zepto.Z\n  }\n\n  // `$.zepto.init` is Zepto's counterpart to jQuery's `$.fn.init` and\n  // takes a CSS selector and an optional context (and handles various\n  // special cases).\n  // This method can be overridden in plugins.\n  zepto.init = function(selector, context) {\n    var dom\n    // If nothing given, return an empty Zepto collection\n    if (!selector) return zepto.Z()\n    // Optimize for string selectors\n    else if (typeof selector == 'string') {\n      selector = selector.trim()\n      // If it's a html fragment, create nodes from it\n      // Note: In both Chrome 21 and Firefox 15, DOM error 12\n      // is thrown if the fragment doesn't begin with <\n      if (selector[0] == '<' && fragmentRE.test(selector))\n        dom = zepto.fragment(selector, RegExp.$1, context), selector = null\n      // If there's a context, create a collection on that context first, and select\n      // nodes from there\n      else if (context !== undefined) return $(context).find(selector)\n      // If it's a CSS selector, use it to select nodes.\n      else dom = zepto.qsa(document, selector)\n    }\n    // If a function is given, call it when the DOM is ready\n    else if (isFunction(selector)) return $(document).ready(selector)\n    // If a Zepto collection is given, just return it\n    else if (zepto.isZ(selector)) return selector\n    else {\n      // normalize array if an array of nodes is given\n      if (isArray(selector)) dom = compact(selector)\n      // Wrap DOM nodes.\n      else if (isObject(selector))\n        dom = [selector], selector = null\n      // If it's a html fragment, create nodes from it\n      else if (fragmentRE.test(selector))\n        dom = zepto.fragment(selector.trim(), RegExp.$1, context), selector = null\n      // If there's a context, create a collection on that context first, and select\n      // nodes from there\n      else if (context !== undefined) return $(context).find(selector)\n      // And last but no least, if it's a CSS selector, use it to select nodes.\n      else dom = zepto.qsa(document, selector)\n    }\n    // create a new Zepto collection from the nodes found\n    return zepto.Z(dom, selector)\n  }\n\n  // `$` will be the base `Zepto` object. When calling this\n  // function just call `$.zepto.init, which makes the implementation\n  // details of selecting nodes and creating Zepto collections\n  // patchable in plugins.\n  $ = function(selector, context){\n    return zepto.init(selector, context)\n  }\n\n  function extend(target, source, deep) {\n    for (key in source)\n      if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {\n        if (isPlainObject(source[key]) && !isPlainObject(target[key]))\n          target[key] = {}\n        if (isArray(source[key]) && !isArray(target[key]))\n          target[key] = []\n        extend(target[key], source[key], deep)\n      }\n      else if (source[key] !== undefined) target[key] = source[key]\n  }\n\n  // Copy all but undefined properties from one or more\n  // objects to the `target` object.\n  $.extend = function(target){\n    var deep, args = slice.call(arguments, 1)\n    if (typeof target == 'boolean') {\n      deep = target\n      target = args.shift()\n    }\n    args.forEach(function(arg){ extend(target, arg, deep) })\n    return target\n  }\n\n  // `$.zepto.qsa` is Zepto's CSS selector implementation which\n  // uses `document.querySelectorAll` and optimizes for some special cases, like `#id`.\n  // This method can be overridden in plugins.\n  zepto.qsa = function(element, selector){\n    var found,\n        maybeID = selector[0] == '#',\n        maybeClass = !maybeID && selector[0] == '.',\n        nameOnly = maybeID || maybeClass ? selector.slice(1) : selector, // Ensure that a 1 char tag name still gets checked\n        isSimple = simpleSelectorRE.test(nameOnly)\n    return (element.getElementById && isSimple && maybeID) ? // Safari DocumentFragment doesn't have getElementById\n      ( (found = element.getElementById(nameOnly)) ? [found] : [] ) :\n      (element.nodeType !== 1 && element.nodeType !== 9 && element.nodeType !== 11) ? [] :\n      slice.call(\n        isSimple && !maybeID && element.getElementsByClassName ? // DocumentFragment doesn't have getElementsByClassName/TagName\n          maybeClass ? element.getElementsByClassName(nameOnly) : // If it's simple, it could be a class\n          element.getElementsByTagName(selector) : // Or a tag\n          element.querySelectorAll(selector) // Or it's not simple, and we need to query all\n      )\n  }\n\n  function filtered(nodes, selector) {\n    return selector == null ? $(nodes) : $(nodes).filter(selector)\n  }\n\n  $.contains = document.documentElement.contains ?\n    function(parent, node) {\n      return parent !== node && parent.contains(node)\n    } :\n    function(parent, node) {\n      while (node && (node = node.parentNode))\n        if (node === parent) return true\n      return false\n    }\n\n  function funcArg(context, arg, idx, payload) {\n    return isFunction(arg) ? arg.call(context, idx, payload) : arg\n  }\n\n  function setAttribute(node, name, value) {\n    value == null ? node.removeAttribute(name) : node.setAttribute(name, value)\n  }\n\n  // access className property while respecting SVGAnimatedString\n  function className(node, value){\n    var klass = node.className || '',\n        svg   = klass && klass.baseVal !== undefined\n\n    if (value === undefined) return svg ? klass.baseVal : klass\n    svg ? (klass.baseVal = value) : (node.className = value)\n  }\n\n  // \"true\"  => true\n  // \"false\" => false\n  // \"null\"  => null\n  // \"42\"    => 42\n  // \"42.5\"  => 42.5\n  // \"08\"    => \"08\"\n  // JSON    => parse if valid\n  // String  => self\n  function deserializeValue(value) {\n    try {\n      return value ?\n        value == \"true\" ||\n        ( value == \"false\" ? false :\n          value == \"null\" ? null :\n          +value + \"\" == value ? +value :\n          /^[\\[\\{]/.test(value) ? $.parseJSON(value) :\n          value )\n        : value\n    } catch(e) {\n      return value\n    }\n  }\n\n  $.type = type\n  $.isFunction = isFunction\n  $.isWindow = isWindow\n  $.isArray = isArray\n  $.isPlainObject = isPlainObject\n\n  $.isEmptyObject = function(obj) {\n    var name\n    for (name in obj) return false\n    return true\n  }\n\n  $.isNumeric = function(val) {\n    var num = Number(val), type = typeof val\n    return val != null && type != 'boolean' &&\n      (type != 'string' || val.length) &&\n      !isNaN(num) && isFinite(num) || false\n  }\n\n  $.inArray = function(elem, array, i){\n    return emptyArray.indexOf.call(array, elem, i)\n  }\n\n  $.camelCase = camelize\n  $.trim = function(str) {\n    return str == null ? \"\" : String.prototype.trim.call(str)\n  }\n\n  // plugin compatibility\n  $.uuid = 0\n  $.support = { }\n  $.expr = { }\n  $.noop = function() {}\n\n  $.map = function(elements, callback){\n    var value, values = [], i, key\n    if (likeArray(elements))\n      for (i = 0; i < elements.length; i++) {\n        value = callback(elements[i], i)\n        if (value != null) values.push(value)\n      }\n    else\n      for (key in elements) {\n        value = callback(elements[key], key)\n        if (value != null) values.push(value)\n      }\n    return flatten(values)\n  }\n\n  $.each = function(elements, callback){\n    var i, key\n    if (likeArray(elements)) {\n      for (i = 0; i < elements.length; i++)\n        if (callback.call(elements[i], i, elements[i]) === false) return elements\n    } else {\n      for (key in elements)\n        if (callback.call(elements[key], key, elements[key]) === false) return elements\n    }\n\n    return elements\n  }\n\n  $.grep = function(elements, callback){\n    return filter.call(elements, callback)\n  }\n\n  if (window.JSON) $.parseJSON = JSON.parse\n\n  // Populate the class2type map\n  $.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(i, name) {\n    class2type[ \"[object \" + name + \"]\" ] = name.toLowerCase()\n  })\n\n  // Define methods that will be available on all\n  // Zepto collections\n  $.fn = {\n    constructor: zepto.Z,\n    length: 0,\n\n    // Because a collection acts like an array\n    // copy over these useful array functions.\n    forEach: emptyArray.forEach,\n    reduce: emptyArray.reduce,\n    push: emptyArray.push,\n    sort: emptyArray.sort,\n    splice: emptyArray.splice,\n    indexOf: emptyArray.indexOf,\n    concat: function(){\n      var i, value, args = []\n      for (i = 0; i < arguments.length; i++) {\n        value = arguments[i]\n        args[i] = zepto.isZ(value) ? value.toArray() : value\n      }\n      return concat.apply(zepto.isZ(this) ? this.toArray() : this, args)\n    },\n\n    // `map` and `slice` in the jQuery API work differently\n    // from their array counterparts\n    map: function(fn){\n      return $($.map(this, function(el, i){ return fn.call(el, i, el) }))\n    },\n    slice: function(){\n      return $(slice.apply(this, arguments))\n    },\n\n    ready: function(callback){\n      // need to check if document.body exists for IE as that browser reports\n      // document ready when it hasn't yet created the body element\n      if (readyRE.test(document.readyState) && document.body) callback($)\n      else document.addEventListener('DOMContentLoaded', function(){ callback($) }, false)\n      return this\n    },\n    get: function(idx){\n      return idx === undefined ? slice.call(this) : this[idx >= 0 ? idx : idx + this.length]\n    },\n    toArray: function(){ return this.get() },\n    size: function(){\n      return this.length\n    },\n    remove: function(){\n      return this.each(function(){\n        if (this.parentNode != null)\n          this.parentNode.removeChild(this)\n      })\n    },\n    each: function(callback){\n      emptyArray.every.call(this, function(el, idx){\n        return callback.call(el, idx, el) !== false\n      })\n      return this\n    },\n    filter: function(selector){\n      if (isFunction(selector)) return this.not(this.not(selector))\n      return $(filter.call(this, function(element){\n        return zepto.matches(element, selector)\n      }))\n    },\n    add: function(selector,context){\n      return $(uniq(this.concat($(selector,context))))\n    },\n    is: function(selector){\n      return this.length > 0 && zepto.matches(this[0], selector)\n    },\n    not: function(selector){\n      var nodes=[]\n      if (isFunction(selector) && selector.call !== undefined)\n        this.each(function(idx){\n          if (!selector.call(this,idx)) nodes.push(this)\n        })\n      else {\n        var excludes = typeof selector == 'string' ? this.filter(selector) :\n          (likeArray(selector) && isFunction(selector.item)) ? slice.call(selector) : $(selector)\n        this.forEach(function(el){\n          if (excludes.indexOf(el) < 0) nodes.push(el)\n        })\n      }\n      return $(nodes)\n    },\n    has: function(selector){\n      return this.filter(function(){\n        return isObject(selector) ?\n          $.contains(this, selector) :\n          $(this).find(selector).size()\n      })\n    },\n    eq: function(idx){\n      return idx === -1 ? this.slice(idx) : this.slice(idx, + idx + 1)\n    },\n    first: function(){\n      var el = this[0]\n      return el && !isObject(el) ? el : $(el)\n    },\n    last: function(){\n      var el = this[this.length - 1]\n      return el && !isObject(el) ? el : $(el)\n    },\n    find: function(selector){\n      var result, $this = this\n      if (!selector) result = $()\n      else if (typeof selector == 'object')\n        result = $(selector).filter(function(){\n          var node = this\n          return emptyArray.some.call($this, function(parent){\n            return $.contains(parent, node)\n          })\n        })\n      else if (this.length == 1) result = $(zepto.qsa(this[0], selector))\n      else result = this.map(function(){ return zepto.qsa(this, selector) })\n      return result\n    },\n    closest: function(selector, context){\n      var nodes = [], collection = typeof selector == 'object' && $(selector)\n      this.each(function(_, node){\n        while (node && !(collection ? collection.indexOf(node) >= 0 : zepto.matches(node, selector)))\n          node = node !== context && !isDocument(node) && node.parentNode\n        if (node && nodes.indexOf(node) < 0) nodes.push(node)\n      })\n      return $(nodes)\n    },\n    parents: function(selector){\n      var ancestors = [], nodes = this\n      while (nodes.length > 0)\n        nodes = $.map(nodes, function(node){\n          if ((node = node.parentNode) && !isDocument(node) && ancestors.indexOf(node) < 0) {\n            ancestors.push(node)\n            return node\n          }\n        })\n      return filtered(ancestors, selector)\n    },\n    parent: function(selector){\n      return filtered(uniq(this.pluck('parentNode')), selector)\n    },\n    children: function(selector){\n      return filtered(this.map(function(){ return children(this) }), selector)\n    },\n    contents: function() {\n      return this.map(function() { return this.contentDocument || slice.call(this.childNodes) })\n    },\n    siblings: function(selector){\n      return filtered(this.map(function(i, el){\n        return filter.call(children(el.parentNode), function(child){ return child!==el })\n      }), selector)\n    },\n    empty: function(){\n      return this.each(function(){ this.innerHTML = '' })\n    },\n    // `pluck` is borrowed from Prototype.js\n    pluck: function(property){\n      return $.map(this, function(el){ return el[property] })\n    },\n    show: function(){\n      return this.each(function(){\n        this.style.display == \"none\" && (this.style.display = '')\n        if (getComputedStyle(this, '').getPropertyValue(\"display\") == \"none\")\n          this.style.display = defaultDisplay(this.nodeName)\n      })\n    },\n    replaceWith: function(newContent){\n      return this.before(newContent).remove()\n    },\n    wrap: function(structure){\n      var func = isFunction(structure)\n      if (this[0] && !func)\n        var dom   = $(structure).get(0),\n            clone = dom.parentNode || this.length > 1\n\n      return this.each(function(index){\n        $(this).wrapAll(\n          func ? structure.call(this, index) :\n            clone ? dom.cloneNode(true) : dom\n        )\n      })\n    },\n    wrapAll: function(structure){\n      if (this[0]) {\n        $(this[0]).before(structure = $(structure))\n        var children\n        // drill down to the inmost element\n        while ((children = structure.children()).length) structure = children.first()\n        $(structure).append(this)\n      }\n      return this\n    },\n    wrapInner: function(structure){\n      var func = isFunction(structure)\n      return this.each(function(index){\n        var self = $(this), contents = self.contents(),\n            dom  = func ? structure.call(this, index) : structure\n        contents.length ? contents.wrapAll(dom) : self.append(dom)\n      })\n    },\n    unwrap: function(){\n      this.parent().each(function(){\n        $(this).replaceWith($(this).children())\n      })\n      return this\n    },\n    clone: function(){\n      return this.map(function(){ return this.cloneNode(true) })\n    },\n    hide: function(){\n      return this.css(\"display\", \"none\")\n    },\n    toggle: function(setting){\n      return this.each(function(){\n        var el = $(this)\n        ;(setting === undefined ? el.css(\"display\") == \"none\" : setting) ? el.show() : el.hide()\n      })\n    },\n    prev: function(selector){ return $(this.pluck('previousElementSibling')).filter(selector || '*') },\n    next: function(selector){ return $(this.pluck('nextElementSibling')).filter(selector || '*') },\n    html: function(html){\n      return 0 in arguments ?\n        this.each(function(idx){\n          var originHtml = this.innerHTML\n          $(this).empty().append( funcArg(this, html, idx, originHtml) )\n        }) :\n        (0 in this ? this[0].innerHTML : null)\n    },\n    text: function(text){\n      return 0 in arguments ?\n        this.each(function(idx){\n          var newText = funcArg(this, text, idx, this.textContent)\n          this.textContent = newText == null ? '' : ''+newText\n        }) :\n        (0 in this ? this.pluck('textContent').join(\"\") : null)\n    },\n    attr: function(name, value){\n      var result\n      return (typeof name == 'string' && !(1 in arguments)) ?\n        (0 in this && this[0].nodeType == 1 && (result = this[0].getAttribute(name)) != null ? result : undefined) :\n        this.each(function(idx){\n          if (this.nodeType !== 1) return\n          if (isObject(name)) for (key in name) setAttribute(this, key, name[key])\n          else setAttribute(this, name, funcArg(this, value, idx, this.getAttribute(name)))\n        })\n    },\n    removeAttr: function(name){\n      return this.each(function(){ this.nodeType === 1 && name.split(' ').forEach(function(attribute){\n        setAttribute(this, attribute)\n      }, this)})\n    },\n    prop: function(name, value){\n      name = propMap[name] || name\n      return (1 in arguments) ?\n        this.each(function(idx){\n          this[name] = funcArg(this, value, idx, this[name])\n        }) :\n        (this[0] && this[0][name])\n    },\n    removeProp: function(name){\n      name = propMap[name] || name\n      return this.each(function(){ delete this[name] })\n    },\n    data: function(name, value){\n      var attrName = 'data-' + name.replace(capitalRE, '-$1').toLowerCase()\n\n      var data = (1 in arguments) ?\n        this.attr(attrName, value) :\n        this.attr(attrName)\n\n      return data !== null ? deserializeValue(data) : undefined\n    },\n    val: function(value){\n      if (0 in arguments) {\n        if (value == null) value = \"\"\n        return this.each(function(idx){\n          this.value = funcArg(this, value, idx, this.value)\n        })\n      } else {\n        return this[0] && (this[0].multiple ?\n           $(this[0]).find('option').filter(function(){ return this.selected }).pluck('value') :\n           this[0].value)\n      }\n    },\n    offset: function(coordinates){\n      if (coordinates) return this.each(function(index){\n        var $this = $(this),\n            coords = funcArg(this, coordinates, index, $this.offset()),\n            parentOffset = $this.offsetParent().offset(),\n            props = {\n              top:  coords.top  - parentOffset.top,\n              left: coords.left - parentOffset.left\n            }\n\n        if ($this.css('position') == 'static') props['position'] = 'relative'\n        $this.css(props)\n      })\n      if (!this.length) return null\n      if (document.documentElement !== this[0] && !$.contains(document.documentElement, this[0]))\n        return {top: 0, left: 0}\n      var obj = this[0].getBoundingClientRect()\n      return {\n        left: obj.left + window.pageXOffset,\n        top: obj.top + window.pageYOffset,\n        width: Math.round(obj.width),\n        height: Math.round(obj.height)\n      }\n    },\n    css: function(property, value){\n      if (arguments.length < 2) {\n        var element = this[0]\n        if (typeof property == 'string') {\n          if (!element) return\n          return element.style[camelize(property)] || getComputedStyle(element, '').getPropertyValue(property)\n        } else if (isArray(property)) {\n          if (!element) return\n          var props = {}\n          var computedStyle = getComputedStyle(element, '')\n          $.each(property, function(_, prop){\n            props[prop] = (element.style[camelize(prop)] || computedStyle.getPropertyValue(prop))\n          })\n          return props\n        }\n      }\n\n      var css = ''\n      if (type(property) == 'string') {\n        if (!value && value !== 0)\n          this.each(function(){ this.style.removeProperty(dasherize(property)) })\n        else\n          css = dasherize(property) + \":\" + maybeAddPx(property, value)\n      } else {\n        for (key in property)\n          if (!property[key] && property[key] !== 0)\n            this.each(function(){ this.style.removeProperty(dasherize(key)) })\n          else\n            css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';'\n      }\n\n      return this.each(function(){ this.style.cssText += ';' + css })\n    },\n    index: function(element){\n      return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0])\n    },\n    hasClass: function(name){\n      if (!name) return false\n      return emptyArray.some.call(this, function(el){\n        return this.test(className(el))\n      }, classRE(name))\n    },\n    addClass: function(name){\n      if (!name) return this\n      return this.each(function(idx){\n        if (!('className' in this)) return\n        classList = []\n        var cls = className(this), newName = funcArg(this, name, idx, cls)\n        newName.split(/\\s+/g).forEach(function(klass){\n          if (!$(this).hasClass(klass)) classList.push(klass)\n        }, this)\n        classList.length && className(this, cls + (cls ? \" \" : \"\") + classList.join(\" \"))\n      })\n    },\n    removeClass: function(name){\n      return this.each(function(idx){\n        if (!('className' in this)) return\n        if (name === undefined) return className(this, '')\n        classList = className(this)\n        funcArg(this, name, idx, classList).split(/\\s+/g).forEach(function(klass){\n          classList = classList.replace(classRE(klass), \" \")\n        })\n        className(this, classList.trim())\n      })\n    },\n    toggleClass: function(name, when){\n      if (!name) return this\n      return this.each(function(idx){\n        var $this = $(this), names = funcArg(this, name, idx, className(this))\n        names.split(/\\s+/g).forEach(function(klass){\n          (when === undefined ? !$this.hasClass(klass) : when) ?\n            $this.addClass(klass) : $this.removeClass(klass)\n        })\n      })\n    },\n    scrollTop: function(value){\n      if (!this.length) return\n      var hasScrollTop = 'scrollTop' in this[0]\n      if (value === undefined) return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset\n      return this.each(hasScrollTop ?\n        function(){ this.scrollTop = value } :\n        function(){ this.scrollTo(this.scrollX, value) })\n    },\n    scrollLeft: function(value){\n      if (!this.length) return\n      var hasScrollLeft = 'scrollLeft' in this[0]\n      if (value === undefined) return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset\n      return this.each(hasScrollLeft ?\n        function(){ this.scrollLeft = value } :\n        function(){ this.scrollTo(value, this.scrollY) })\n    },\n    position: function() {\n      if (!this.length) return\n\n      var elem = this[0],\n        // Get *real* offsetParent\n        offsetParent = this.offsetParent(),\n        // Get correct offsets\n        offset       = this.offset(),\n        parentOffset = rootNodeRE.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset()\n\n      // Subtract element margins\n      // note: when an element has margin: auto the offsetLeft and marginLeft\n      // are the same in Safari causing offset.left to incorrectly be 0\n      offset.top  -= parseFloat( $(elem).css('margin-top') ) || 0\n      offset.left -= parseFloat( $(elem).css('margin-left') ) || 0\n\n      // Add offsetParent borders\n      parentOffset.top  += parseFloat( $(offsetParent[0]).css('border-top-width') ) || 0\n      parentOffset.left += parseFloat( $(offsetParent[0]).css('border-left-width') ) || 0\n\n      // Subtract the two offsets\n      return {\n        top:  offset.top  - parentOffset.top,\n        left: offset.left - parentOffset.left\n      }\n    },\n    offsetParent: function() {\n      return this.map(function(){\n        var parent = this.offsetParent || document.body\n        while (parent && !rootNodeRE.test(parent.nodeName) && $(parent).css(\"position\") == \"static\")\n          parent = parent.offsetParent\n        return parent\n      })\n    }\n  }\n\n  // for now\n  $.fn.detach = $.fn.remove\n\n  // Generate the `width` and `height` functions\n  ;['width', 'height'].forEach(function(dimension){\n    var dimensionProperty =\n      dimension.replace(/./, function(m){ return m[0].toUpperCase() })\n\n    $.fn[dimension] = function(value){\n      var offset, el = this[0]\n      if (value === undefined) return isWindow(el) ? el['inner' + dimensionProperty] :\n        isDocument(el) ? el.documentElement['scroll' + dimensionProperty] :\n        (offset = this.offset()) && offset[dimension]\n      else return this.each(function(idx){\n        el = $(this)\n        el.css(dimension, funcArg(this, value, idx, el[dimension]()))\n      })\n    }\n  })\n\n  function traverseNode(node, fun) {\n    fun(node)\n    for (var i = 0, len = node.childNodes.length; i < len; i++)\n      traverseNode(node.childNodes[i], fun)\n  }\n\n  // Generate the `after`, `prepend`, `before`, `append`,\n  // `insertAfter`, `insertBefore`, `appendTo`, and `prependTo` methods.\n  adjacencyOperators.forEach(function(operator, operatorIndex) {\n    var inside = operatorIndex % 2 //=> prepend, append\n\n    $.fn[operator] = function(){\n      // arguments can be nodes, arrays of nodes, Zepto objects and HTML strings\n      var argType, nodes = $.map(arguments, function(arg) {\n            var arr = []\n            argType = type(arg)\n            if (argType == \"array\") {\n              arg.forEach(function(el) {\n                if (el.nodeType !== undefined) return arr.push(el)\n                else if ($.zepto.isZ(el)) return arr = arr.concat(el.get())\n                arr = arr.concat(zepto.fragment(el))\n              })\n              return arr\n            }\n            return argType == \"object\" || arg == null ?\n              arg : zepto.fragment(arg)\n          }),\n          parent, copyByClone = this.length > 1\n      if (nodes.length < 1) return this\n\n      return this.each(function(_, target){\n        parent = inside ? target : target.parentNode\n\n        // convert all methods to a \"before\" operation\n        target = operatorIndex == 0 ? target.nextSibling :\n                 operatorIndex == 1 ? target.firstChild :\n                 operatorIndex == 2 ? target :\n                 null\n\n        var parentInDocument = $.contains(document.documentElement, parent)\n\n        nodes.forEach(function(node){\n          if (copyByClone) node = node.cloneNode(true)\n          else if (!parent) return $(node).remove()\n\n          parent.insertBefore(node, target)\n          if (parentInDocument) traverseNode(node, function(el){\n            if (el.nodeName != null && el.nodeName.toUpperCase() === 'SCRIPT' &&\n               (!el.type || el.type === 'text/javascript') && !el.src){\n              var target = el.ownerDocument ? el.ownerDocument.defaultView : window\n              target['eval'].call(target, el.innerHTML)\n            }\n          })\n        })\n      })\n    }\n\n    // after    => insertAfter\n    // prepend  => prependTo\n    // before   => insertBefore\n    // append   => appendTo\n    $.fn[inside ? operator+'To' : 'insert'+(operatorIndex ? 'Before' : 'After')] = function(html){\n      $(html)[operator](this)\n      return this\n    }\n  })\n\n  zepto.Z.prototype = Z.prototype = $.fn\n\n  // Export internal API functions in the `$.zepto` namespace\n  zepto.uniq = uniq\n  zepto.deserializeValue = deserializeValue\n  $.zepto = zepto\n\n  return $\n})()\n\nwindow.Zepto = Zepto\nwindow.$ === undefined && (window.$ = Zepto)\n\n;(function($){\n  var _zid = 1, undefined,\n      slice = Array.prototype.slice,\n      isFunction = $.isFunction,\n      isString = function(obj){ return typeof obj == 'string' },\n      handlers = {},\n      specialEvents={},\n      focusinSupported = 'onfocusin' in window,\n      focus = { focus: 'focusin', blur: 'focusout' },\n      hover = { mouseenter: 'mouseover', mouseleave: 'mouseout' }\n\n  specialEvents.click = specialEvents.mousedown = specialEvents.mouseup = specialEvents.mousemove = 'MouseEvents'\n\n  function zid(element) {\n    return element._zid || (element._zid = _zid++)\n  }\n  function findHandlers(element, event, fn, selector) {\n    event = parse(event)\n    if (event.ns) var matcher = matcherFor(event.ns)\n    return (handlers[zid(element)] || []).filter(function(handler) {\n      return handler\n        && (!event.e  || handler.e == event.e)\n        && (!event.ns || matcher.test(handler.ns))\n        && (!fn       || zid(handler.fn) === zid(fn))\n        && (!selector || handler.sel == selector)\n    })\n  }\n  function parse(event) {\n    var parts = ('' + event).split('.')\n    return {e: parts[0], ns: parts.slice(1).sort().join(' ')}\n  }\n  function matcherFor(ns) {\n    return new RegExp('(?:^| )' + ns.replace(' ', ' .* ?') + '(?: |$)')\n  }\n\n  function eventCapture(handler, captureSetting) {\n    return handler.del &&\n      (!focusinSupported && (handler.e in focus)) ||\n      !!captureSetting\n  }\n\n  function realEvent(type) {\n    return hover[type] || (focusinSupported && focus[type]) || type\n  }\n\n  function add(element, events, fn, data, selector, delegator, capture){\n    var id = zid(element), set = (handlers[id] || (handlers[id] = []))\n    events.split(/\\s/).forEach(function(event){\n      if (event == 'ready') return $(document).ready(fn)\n      var handler   = parse(event)\n      handler.fn    = fn\n      handler.sel   = selector\n      // emulate mouseenter, mouseleave\n      if (handler.e in hover) fn = function(e){\n        var related = e.relatedTarget\n        if (!related || (related !== this && !$.contains(this, related)))\n          return handler.fn.apply(this, arguments)\n      }\n      handler.del   = delegator\n      var callback  = delegator || fn\n      handler.proxy = function(e){\n        e = compatible(e)\n        if (e.isImmediatePropagationStopped()) return\n        e.data = data\n        var result = callback.apply(element, e._args == undefined ? [e] : [e].concat(e._args))\n        if (result === false) e.preventDefault(), e.stopPropagation()\n        return result\n      }\n      handler.i = set.length\n      set.push(handler)\n      if ('addEventListener' in element)\n        element.addEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))\n    })\n  }\n  function remove(element, events, fn, selector, capture){\n    var id = zid(element)\n    ;(events || '').split(/\\s/).forEach(function(event){\n      findHandlers(element, event, fn, selector).forEach(function(handler){\n        delete handlers[id][handler.i]\n      if ('removeEventListener' in element)\n        element.removeEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))\n      })\n    })\n  }\n\n  $.event = { add: add, remove: remove }\n\n  $.proxy = function(fn, context) {\n    var args = (2 in arguments) && slice.call(arguments, 2)\n    if (isFunction(fn)) {\n      var proxyFn = function(){ return fn.apply(context, args ? args.concat(slice.call(arguments)) : arguments) }\n      proxyFn._zid = zid(fn)\n      return proxyFn\n    } else if (isString(context)) {\n      if (args) {\n        args.unshift(fn[context], fn)\n        return $.proxy.apply(null, args)\n      } else {\n        return $.proxy(fn[context], fn)\n      }\n    } else {\n      throw new TypeError(\"expected function\")\n    }\n  }\n\n  $.fn.bind = function(event, data, callback){\n    return this.on(event, data, callback)\n  }\n  $.fn.unbind = function(event, callback){\n    return this.off(event, callback)\n  }\n  $.fn.one = function(event, selector, data, callback){\n    return this.on(event, selector, data, callback, 1)\n  }\n\n  var returnTrue = function(){return true},\n      returnFalse = function(){return false},\n      ignoreProperties = /^([A-Z]|returnValue$|layer[XY]$|webkitMovement[XY]$)/,\n      eventMethods = {\n        preventDefault: 'isDefaultPrevented',\n        stopImmediatePropagation: 'isImmediatePropagationStopped',\n        stopPropagation: 'isPropagationStopped'\n      }\n\n  function compatible(event, source) {\n    if (source || !event.isDefaultPrevented) {\n      source || (source = event)\n\n      $.each(eventMethods, function(name, predicate) {\n        var sourceMethod = source[name]\n        event[name] = function(){\n          this[predicate] = returnTrue\n          return sourceMethod && sourceMethod.apply(source, arguments)\n        }\n        event[predicate] = returnFalse\n      })\n\n      event.timeStamp || (event.timeStamp = Date.now())\n\n      if (source.defaultPrevented !== undefined ? source.defaultPrevented :\n          'returnValue' in source ? source.returnValue === false :\n          source.getPreventDefault && source.getPreventDefault())\n        event.isDefaultPrevented = returnTrue\n    }\n    return event\n  }\n\n  function createProxy(event) {\n    var key, proxy = { originalEvent: event }\n    for (key in event)\n      if (!ignoreProperties.test(key) && event[key] !== undefined) proxy[key] = event[key]\n\n    return compatible(proxy, event)\n  }\n\n  $.fn.delegate = function(selector, event, callback){\n    return this.on(event, selector, callback)\n  }\n  $.fn.undelegate = function(selector, event, callback){\n    return this.off(event, selector, callback)\n  }\n\n  $.fn.live = function(event, callback){\n    $(document.body).delegate(this.selector, event, callback)\n    return this\n  }\n  $.fn.die = function(event, callback){\n    $(document.body).undelegate(this.selector, event, callback)\n    return this\n  }\n\n  $.fn.on = function(event, selector, data, callback, one){\n    var autoRemove, delegator, $this = this\n    if (event && !isString(event)) {\n      $.each(event, function(type, fn){\n        $this.on(type, selector, data, fn, one)\n      })\n      return $this\n    }\n\n    if (!isString(selector) && !isFunction(callback) && callback !== false)\n      callback = data, data = selector, selector = undefined\n    if (callback === undefined || data === false)\n      callback = data, data = undefined\n\n    if (callback === false) callback = returnFalse\n\n    return $this.each(function(_, element){\n      if (one) autoRemove = function(e){\n        remove(element, e.type, callback)\n        return callback.apply(this, arguments)\n      }\n\n      if (selector) delegator = function(e){\n        var evt, match = $(e.target).closest(selector, element).get(0)\n        if (match && match !== element) {\n          evt = $.extend(createProxy(e), {currentTarget: match, liveFired: element})\n          return (autoRemove || callback).apply(match, [evt].concat(slice.call(arguments, 1)))\n        }\n      }\n\n      add(element, event, callback, data, selector, delegator || autoRemove)\n    })\n  }\n  $.fn.off = function(event, selector, callback){\n    var $this = this\n    if (event && !isString(event)) {\n      $.each(event, function(type, fn){\n        $this.off(type, selector, fn)\n      })\n      return $this\n    }\n\n    if (!isString(selector) && !isFunction(callback) && callback !== false)\n      callback = selector, selector = undefined\n\n    if (callback === false) callback = returnFalse\n\n    return $this.each(function(){\n      remove(this, event, callback, selector)\n    })\n  }\n\n  $.fn.trigger = function(event, args){\n    event = (isString(event) || $.isPlainObject(event)) ? $.Event(event) : compatible(event)\n    event._args = args\n    return this.each(function(){\n      // handle focus(), blur() by calling them directly\n      if (event.type in focus && typeof this[event.type] == \"function\") this[event.type]()\n      // items in the collection might not be DOM elements\n      else if ('dispatchEvent' in this) this.dispatchEvent(event)\n      else $(this).triggerHandler(event, args)\n    })\n  }\n\n  // triggers event handlers on current element just as if an event occurred,\n  // doesn't trigger an actual event, doesn't bubble\n  $.fn.triggerHandler = function(event, args){\n    var e, result\n    this.each(function(i, element){\n      e = createProxy(isString(event) ? $.Event(event) : event)\n      e._args = args\n      e.target = element\n      $.each(findHandlers(element, event.type || event), function(i, handler){\n        result = handler.proxy(e)\n        if (e.isImmediatePropagationStopped()) return false\n      })\n    })\n    return result\n  }\n\n  // shortcut methods for `.bind(event, fn)` for each event type\n  ;('focusin focusout focus blur load resize scroll unload click dblclick '+\n  'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave '+\n  'change select keydown keypress keyup error').split(' ').forEach(function(event) {\n    $.fn[event] = function(callback) {\n      return (0 in arguments) ?\n        this.bind(event, callback) :\n        this.trigger(event)\n    }\n  })\n\n  $.Event = function(type, props) {\n    if (!isString(type)) props = type, type = props.type\n    var event = document.createEvent(specialEvents[type] || 'Events'), bubbles = true\n    if (props) for (var name in props) (name == 'bubbles') ? (bubbles = !!props[name]) : (event[name] = props[name])\n    event.initEvent(type, bubbles, true)\n    return compatible(event)\n  }\n\n})(Zepto)\n\n;(function($){\n  var jsonpID = +new Date(),\n      document = window.document,\n      key,\n      name,\n      rscript = /<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi,\n      scriptTypeRE = /^(?:text|application)\\/javascript/i,\n      xmlTypeRE = /^(?:text|application)\\/xml/i,\n      jsonType = 'application/json',\n      htmlType = 'text/html',\n      blankRE = /^\\s*$/,\n      originAnchor = document.createElement('a')\n\n  originAnchor.href = window.location.href\n\n  // trigger a custom event and return false if it was cancelled\n  function triggerAndReturn(context, eventName, data) {\n    var event = $.Event(eventName)\n    $(context).trigger(event, data)\n    return !event.isDefaultPrevented()\n  }\n\n  // trigger an Ajax \"global\" event\n  function triggerGlobal(settings, context, eventName, data) {\n    if (settings.global) return triggerAndReturn(context || document, eventName, data)\n  }\n\n  // Number of active Ajax requests\n  $.active = 0\n\n  function ajaxStart(settings) {\n    if (settings.global && $.active++ === 0) triggerGlobal(settings, null, 'ajaxStart')\n  }\n  function ajaxStop(settings) {\n    if (settings.global && !(--$.active)) triggerGlobal(settings, null, 'ajaxStop')\n  }\n\n  // triggers an extra global event \"ajaxBeforeSend\" that's like \"ajaxSend\" but cancelable\n  function ajaxBeforeSend(xhr, settings) {\n    var context = settings.context\n    if (settings.beforeSend.call(context, xhr, settings) === false ||\n        triggerGlobal(settings, context, 'ajaxBeforeSend', [xhr, settings]) === false)\n      return false\n\n    triggerGlobal(settings, context, 'ajaxSend', [xhr, settings])\n  }\n  function ajaxSuccess(data, xhr, settings, deferred) {\n    var context = settings.context, status = 'success'\n    settings.success.call(context, data, status, xhr)\n    if (deferred) deferred.resolveWith(context, [data, status, xhr])\n    triggerGlobal(settings, context, 'ajaxSuccess', [xhr, settings, data])\n    ajaxComplete(status, xhr, settings)\n  }\n  // type: \"timeout\", \"error\", \"abort\", \"parsererror\"\n  function ajaxError(error, type, xhr, settings, deferred) {\n    var context = settings.context\n    settings.error.call(context, xhr, type, error)\n    if (deferred) deferred.rejectWith(context, [xhr, type, error])\n    triggerGlobal(settings, context, 'ajaxError', [xhr, settings, error || type])\n    ajaxComplete(type, xhr, settings)\n  }\n  // status: \"success\", \"notmodified\", \"error\", \"timeout\", \"abort\", \"parsererror\"\n  function ajaxComplete(status, xhr, settings) {\n    var context = settings.context\n    settings.complete.call(context, xhr, status)\n    triggerGlobal(settings, context, 'ajaxComplete', [xhr, settings])\n    ajaxStop(settings)\n  }\n\n  function ajaxDataFilter(data, type, settings) {\n    if (settings.dataFilter == empty) return data\n    var context = settings.context\n    return settings.dataFilter.call(context, data, type)\n  }\n\n  // Empty function, used as default callback\n  function empty() {}\n\n  $.ajaxJSONP = function(options, deferred){\n    if (!('type' in options)) return $.ajax(options)\n\n    var _callbackName = options.jsonpCallback,\n      callbackName = ($.isFunction(_callbackName) ?\n        _callbackName() : _callbackName) || ('Zepto' + (jsonpID++)),\n      script = document.createElement('script'),\n      originalCallback = window[callbackName],\n      responseData,\n      abort = function(errorType) {\n        $(script).triggerHandler('error', errorType || 'abort')\n      },\n      xhr = { abort: abort }, abortTimeout\n\n    if (deferred) deferred.promise(xhr)\n\n    $(script).on('load error', function(e, errorType){\n      clearTimeout(abortTimeout)\n      $(script).off().remove()\n\n      if (e.type == 'error' || !responseData) {\n        ajaxError(null, errorType || 'error', xhr, options, deferred)\n      } else {\n        ajaxSuccess(responseData[0], xhr, options, deferred)\n      }\n\n      window[callbackName] = originalCallback\n      if (responseData && $.isFunction(originalCallback))\n        originalCallback(responseData[0])\n\n      originalCallback = responseData = undefined\n    })\n\n    if (ajaxBeforeSend(xhr, options) === false) {\n      abort('abort')\n      return xhr\n    }\n\n    window[callbackName] = function(){\n      responseData = arguments\n    }\n\n    script.src = options.url.replace(/\\?(.+)=\\?/, '?$1=' + callbackName)\n    document.head.appendChild(script)\n\n    if (options.timeout > 0) abortTimeout = setTimeout(function(){\n      abort('timeout')\n    }, options.timeout)\n\n    return xhr\n  }\n\n  $.ajaxSettings = {\n    // Default type of request\n    type: 'GET',\n    // Callback that is executed before request\n    beforeSend: empty,\n    // Callback that is executed if the request succeeds\n    success: empty,\n    // Callback that is executed the the server drops error\n    error: empty,\n    // Callback that is executed on request complete (both: error and success)\n    complete: empty,\n    // The context for the callbacks\n    context: null,\n    // Whether to trigger \"global\" Ajax events\n    global: true,\n    // Transport\n    xhr: function () {\n      return new window.XMLHttpRequest()\n    },\n    // MIME types mapping\n    // IIS returns Javascript as \"application/x-javascript\"\n    accepts: {\n      script: 'text/javascript, application/javascript, application/x-javascript',\n      json:   jsonType,\n      xml:    'application/xml, text/xml',\n      html:   htmlType,\n      text:   'text/plain'\n    },\n    // Whether the request is to another domain\n    crossDomain: false,\n    // Default timeout\n    timeout: 0,\n    // Whether data should be serialized to string\n    processData: true,\n    // Whether the browser should be allowed to cache GET responses\n    cache: true,\n    //Used to handle the raw response data of XMLHttpRequest.\n    //This is a pre-filtering function to sanitize the response.\n    //The sanitized response should be returned\n    dataFilter: empty\n  }\n\n  function mimeToDataType(mime) {\n    if (mime) mime = mime.split(';', 2)[0]\n    return mime && ( mime == htmlType ? 'html' :\n      mime == jsonType ? 'json' :\n      scriptTypeRE.test(mime) ? 'script' :\n      xmlTypeRE.test(mime) && 'xml' ) || 'text'\n  }\n\n  function appendQuery(url, query) {\n    if (query == '') return url\n    return (url + '&' + query).replace(/[&?]{1,2}/, '?')\n  }\n\n  // serialize payload and append it to the URL for GET requests\n  function serializeData(options) {\n    if (options.processData && options.data && $.type(options.data) != \"string\")\n      options.data = $.param(options.data, options.traditional)\n    if (options.data && (!options.type || options.type.toUpperCase() == 'GET' || 'jsonp' == options.dataType))\n      options.url = appendQuery(options.url, options.data), options.data = undefined\n  }\n\n  $.ajax = function(options){\n    var settings = $.extend({}, options || {}),\n        deferred = $.Deferred && $.Deferred(),\n        urlAnchor, hashIndex\n    for (key in $.ajaxSettings) if (settings[key] === undefined) settings[key] = $.ajaxSettings[key]\n\n    ajaxStart(settings)\n\n    if (!settings.crossDomain) {\n      urlAnchor = document.createElement('a')\n      urlAnchor.href = settings.url\n      // cleans up URL for .href (IE only), see https://github.com/madrobby/zepto/pull/1049\n      urlAnchor.href = urlAnchor.href\n      settings.crossDomain = (originAnchor.protocol + '//' + originAnchor.host) !== (urlAnchor.protocol + '//' + urlAnchor.host)\n    }\n\n    if (!settings.url) settings.url = window.location.toString()\n    if ((hashIndex = settings.url.indexOf('#')) > -1) settings.url = settings.url.slice(0, hashIndex)\n    serializeData(settings)\n\n    var dataType = settings.dataType, hasPlaceholder = /\\?.+=\\?/.test(settings.url)\n    if (hasPlaceholder) dataType = 'jsonp'\n\n    if (settings.cache === false || (\n         (!options || options.cache !== true) &&\n         ('script' == dataType || 'jsonp' == dataType)\n        ))\n      settings.url = appendQuery(settings.url, '_=' + Date.now())\n\n    if ('jsonp' == dataType) {\n      if (!hasPlaceholder)\n        settings.url = appendQuery(settings.url,\n          settings.jsonp ? (settings.jsonp + '=?') : settings.jsonp === false ? '' : 'callback=?')\n      return $.ajaxJSONP(settings, deferred)\n    }\n\n    var mime = settings.accepts[dataType],\n        headers = { },\n        setHeader = function(name, value) { headers[name.toLowerCase()] = [name, value] },\n        protocol = /^([\\w-]+:)\\/\\//.test(settings.url) ? RegExp.$1 : window.location.protocol,\n        xhr = settings.xhr(),\n        nativeSetHeader = xhr.setRequestHeader,\n        abortTimeout\n\n    if (deferred) deferred.promise(xhr)\n\n    if (!settings.crossDomain) setHeader('X-Requested-With', 'XMLHttpRequest')\n    setHeader('Accept', mime || '*/*')\n    if (mime = settings.mimeType || mime) {\n      if (mime.indexOf(',') > -1) mime = mime.split(',', 2)[0]\n      xhr.overrideMimeType && xhr.overrideMimeType(mime)\n    }\n    if (settings.contentType || (settings.contentType !== false && settings.data && settings.type.toUpperCase() != 'GET'))\n      setHeader('Content-Type', settings.contentType || 'application/x-www-form-urlencoded')\n\n    if (settings.headers) for (name in settings.headers) setHeader(name, settings.headers[name])\n    xhr.setRequestHeader = setHeader\n\n    xhr.onreadystatechange = function(){\n      if (xhr.readyState == 4) {\n        xhr.onreadystatechange = empty\n        clearTimeout(abortTimeout)\n        var result, error = false\n        if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304 || (xhr.status == 0 && protocol == 'file:')) {\n          dataType = dataType || mimeToDataType(settings.mimeType || xhr.getResponseHeader('content-type'))\n\n          if (xhr.responseType == 'arraybuffer' || xhr.responseType == 'blob')\n            result = xhr.response\n          else {\n            result = xhr.responseText\n\n            try {\n              // http://perfectionkills.com/global-eval-what-are-the-options/\n              // sanitize response accordingly if data filter callback provided\n              result = ajaxDataFilter(result, dataType, settings)\n              if (dataType == 'script')    (1,eval)(result)\n              else if (dataType == 'xml')  result = xhr.responseXML\n              else if (dataType == 'json') result = blankRE.test(result) ? null : $.parseJSON(result)\n            } catch (e) { error = e }\n\n            if (error) return ajaxError(error, 'parsererror', xhr, settings, deferred)\n          }\n\n          ajaxSuccess(result, xhr, settings, deferred)\n        } else {\n          ajaxError(xhr.statusText || null, xhr.status ? 'error' : 'abort', xhr, settings, deferred)\n        }\n      }\n    }\n\n    if (ajaxBeforeSend(xhr, settings) === false) {\n      xhr.abort()\n      ajaxError(null, 'abort', xhr, settings, deferred)\n      return xhr\n    }\n\n    var async = 'async' in settings ? settings.async : true\n    xhr.open(settings.type, settings.url, async, settings.username, settings.password)\n\n    if (settings.xhrFields) for (name in settings.xhrFields) xhr[name] = settings.xhrFields[name]\n\n    for (name in headers) nativeSetHeader.apply(xhr, headers[name])\n\n    if (settings.timeout > 0) abortTimeout = setTimeout(function(){\n        xhr.onreadystatechange = empty\n        xhr.abort()\n        ajaxError(null, 'timeout', xhr, settings, deferred)\n      }, settings.timeout)\n\n    // avoid sending empty string (#319)\n    xhr.send(settings.data ? settings.data : null)\n    return xhr\n  }\n\n  // handle optional data/success arguments\n  function parseArguments(url, data, success, dataType) {\n    if ($.isFunction(data)) dataType = success, success = data, data = undefined\n    if (!$.isFunction(success)) dataType = success, success = undefined\n    return {\n      url: url\n    , data: data\n    , success: success\n    , dataType: dataType\n    }\n  }\n\n  $.get = function(/* url, data, success, dataType */){\n    return $.ajax(parseArguments.apply(null, arguments))\n  }\n\n  $.post = function(/* url, data, success, dataType */){\n    var options = parseArguments.apply(null, arguments)\n    options.type = 'POST'\n    return $.ajax(options)\n  }\n\n  $.getJSON = function(/* url, data, success */){\n    var options = parseArguments.apply(null, arguments)\n    options.dataType = 'json'\n    return $.ajax(options)\n  }\n\n  $.fn.load = function(url, data, success){\n    if (!this.length) return this\n    var self = this, parts = url.split(/\\s/), selector,\n        options = parseArguments(url, data, success),\n        callback = options.success\n    if (parts.length > 1) options.url = parts[0], selector = parts[1]\n    options.success = function(response){\n      self.html(selector ?\n        $('<div>').html(response.replace(rscript, \"\")).find(selector)\n        : response)\n      callback && callback.apply(self, arguments)\n    }\n    $.ajax(options)\n    return this\n  }\n\n  var escape = encodeURIComponent\n\n  function serialize(params, obj, traditional, scope){\n    var type, array = $.isArray(obj), hash = $.isPlainObject(obj)\n    $.each(obj, function(key, value) {\n      type = $.type(value)\n      if (scope) key = traditional ? scope :\n        scope + '[' + (hash || type == 'object' || type == 'array' ? key : '') + ']'\n      // handle data in serializeArray() format\n      if (!scope && array) params.add(value.name, value.value)\n      // recurse into nested objects\n      else if (type == \"array\" || (!traditional && type == \"object\"))\n        serialize(params, value, traditional, key)\n      else params.add(key, value)\n    })\n  }\n\n  $.param = function(obj, traditional){\n    var params = []\n    params.add = function(key, value) {\n      if ($.isFunction(value)) value = value()\n      if (value == null) value = \"\"\n      this.push(escape(key) + '=' + escape(value))\n    }\n    serialize(params, obj, traditional)\n    return params.join('&').replace(/%20/g, '+')\n  }\n})(Zepto)\n\n;(function($){\n  $.fn.serializeArray = function() {\n    var name, type, result = [],\n      add = function(value) {\n        if (value.forEach) return value.forEach(add)\n        result.push({ name: name, value: value })\n      }\n    if (this[0]) $.each(this[0].elements, function(_, field){\n      type = field.type, name = field.name\n      if (name && field.nodeName.toLowerCase() != 'fieldset' &&\n        !field.disabled && type != 'submit' && type != 'reset' && type != 'button' && type != 'file' &&\n        ((type != 'radio' && type != 'checkbox') || field.checked))\n          add($(field).val())\n    })\n    return result\n  }\n\n  $.fn.serialize = function(){\n    var result = []\n    this.serializeArray().forEach(function(elm){\n      result.push(encodeURIComponent(elm.name) + '=' + encodeURIComponent(elm.value))\n    })\n    return result.join('&')\n  }\n\n  $.fn.submit = function(callback) {\n    if (0 in arguments) this.bind('submit', callback)\n    else if (this.length) {\n      var event = $.Event('submit')\n      this.eq(0).trigger(event)\n      if (!event.isDefaultPrevented()) this.get(0).submit()\n    }\n    return this\n  }\n\n})(Zepto)\n\n;(function(){\n  // getComputedStyle shouldn't freak out when called\n  // without a valid element as argument\n  try {\n    getComputedStyle(undefined)\n  } catch(e) {\n    var nativeGetComputedStyle = getComputedStyle\n    window.getComputedStyle = function(element, pseudoElement){\n      try {\n        return nativeGetComputedStyle(element, pseudoElement)\n      } catch(e) {\n        return null\n      }\n    }\n  }\n})()\n  return Zepto\n}))\n"

/***/ }),
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */,
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(14);


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

//console.  emedia.__easemob_current_mservice.current


var emedia = window.emedia = window.emedia || {};

var util = emedia.util = __webpack_require__(15);
var zepto = __webpack_require__(6);

emedia.config = function (cfg) {
    cfg = util.extend({}, cfg);

    for (var key in cfg) {
        emedia.config[key] = cfg[key];
        if (key === "logLevel") {
            emedia.LOG_LEVEL = cfg[key];
        }
    }

    if (emedia.config.loglastConfrCount && !emedia._logContext) {
        emedia._logContext = new Array(emedia.config.loglastConfrCount);
        emedia._logContextIndex = -1; //代表没有日志
    }
};

emedia.config({
    autoSub: true,

    onlyEnter: false,

    reconnect: 13, //重连次数
    reconnectDelay: 3000, //重连间隔 毫秒

    getCopyIntervalMillis: 30000,
    checkConnectIntervalMillis: 1000,

    iceRebuildCount: 3,
    iceRebuildIntervalMillis: 500,

    enterTimeout: 20000,

    useRTCCfgIfServerReturn: false,
    forceUseRTCCfgIfServerReturnWhenP2P: true,

    allowRepeatAudioMixerPublish: false,

    getMediaMeterIntervalMillis: 400,
    _useRequestAnimationFrame: false,

    meterWithTrackAudioLevel: false,
    judgeTalkingByInstantGE: 0.05,

    _printSoundData: false,

    trackBufferSize: 20,
    allowSendWhenLessThan: 4,
    disableTrack: false,

    ctrlCheckIntervalMillis: 10 * 1000,
    ctrlTimeoutMillis: 30 * 1000,

    _printDebugStats: false,
    statsSeconds: 3,
    //wsorigin

    loglastConfrCount: 2,
    consoleLogger: true
});

util.logger.count();
//util.logger.info(navigator.userAgent);

(function requireWebrtcAdapter() {
    var adapter = __webpack_require__(2);
    emedia.browser = adapter.__browser; // firefox chrome safari IE
    emedia.browserVersion = adapter.__browserVersion;
})();
util.logger.info("Current browser", emedia.browser, emedia.browserVersion);

emedia.AudioContext = window.AudioContext || window.webkitAudioContext;

if (emedia.config.getMediaMeterIntervalMillis) {
    // https://stackoverflow.com/questions/46363048/onaudioprocess-not-called-on-ios11/46534088#46534088
    // There are two problems.
    // The main one is that Safari on iOS 11 seems to automatically suspend new AudioContext's that aren't created in response to a tap.
    // You can resume() them, but only in response to a tap.
    //
    // So, you have to either create it before you get the MediaStream, or else get the user to tap again later.
    try {
        if (typeof emedia.AudioContext === 'function') {
            emedia.__audioContext = new emedia.AudioContext();
            emedia.__usingWebAudio = true;
        } else {
            emedia.__usingWebAudio = false;
        }
    } catch (e) {
        emedia.__usingWebAudio = false;
    }

    // context state at this time is `undefined` in iOS8 Safari
    if (emedia.__usingWebAudio && emedia.__audioContext.state === 'suspended') {
        zepto(function () {
            var resume = function resume() {
                emedia.__audioContext.state === 'suspended' && emedia.__audioContext.resume();
                util.logger.warn("AudioContext state suspended ->", emedia.__audioContext.state);

                setTimeout(function () {
                    if (emedia.__audioContext.state === 'running') {
                        document.body.removeEventListener('touchend', resume, false);
                        document.body.removeEventListener('click', resume, false);
                    }
                }, 0);
            };

            document.body.addEventListener('touchend', resume, false);
            //document.body.addEventListener('load', resume, false);
            document.body.addEventListener('click', resume, false);
        });
    }

    if (!emedia.__usingWebAudio) {
        console.warn("'new AudioContext()' failed. can not know who talking.");
    }
    if (emedia.__audioContext && emedia.__audioContext.state === 'suspended') {
        console.warn("audioContext.state is suspended. can not know who talking. You can resume() emedia.__audioContext, but only in response to a tap.");
    }
}

if (!window.requestAnimationFrame || !emedia.config._useRequestAnimationFrame) {
    emedia.requestAnimationFrame = function (fn, timeoutMillis) {
        return setTimeout(fn, timeoutMillis || emedia.config.getMediaMeterIntervalMillis);
    };
} else {
    emedia.requestAnimationFrame = function (callback) {
        window.requestAnimationFrame(callback);
    };
}

if (!window.cancelAnimationFrame || !emedia.config._useRequestAnimationFrame) {
    emedia.cancelAnimationFrame = function (id) {
        clearTimeout(id);
    };
} else {
    emedia.cancelAnimationFrame = function (id) {
        window.cancelAnimationFrame(id);
    };
}

emedia.stopAudioTracks = function (_stream) {
    _stream && _stream.getAudioTracks().forEach(function (track) {
        track.stop();
    });
};
emedia.stopAndRemoveAudioTracks = function (_stream) {
    var tracks = [];
    _stream && _stream.getAudioTracks().forEach(function (track) {
        track.stop();
        tracks.push(track);
    });

    util.forEach(tracks, function (_index, track) {
        _stream.removeTrack(track);
    });
};

emedia.stopTracks = function (_stream) {
    try {
        var stop = function stop() {
            _stream.getTracks().forEach(function (track) {
                track.stop();
            });

            if (_stream._bindAttendee) {
                //push stream时，由于异步，在未返回成功后，退出会议，摄像头不会被关闭问题
                util.removeAttribute(_stream._bindAttendee._openedRtcMediaStreams, _stream.id);
                _stream._bindAttendee = null;
            }
            util.logger.info("stream tracks stoped. it ", _stream);
        };

        if (!_stream || _stream.active === false) {
            util.logger.debug("stream tracks had been stoped. it ", _stream && _stream.id);
            return;
        }

        stop();
        //setTimeout(stop, 300);
    } catch (e) {
        util.logger.error(e);
    }
};

emedia.enableVideoTracks = function (_stream, enabled) {
    _stream && _stream.getVideoTracks().forEach(function (track) {
        if (typeof track.enable === "function") {
            track.enable();
            track.enabled === enabled || track.enable(enabled);
            return;
        }

        track.enabled === enabled || (track.enabled = enabled);
    });
};

emedia.enableAudioTracks = function (_stream, enabled) {
    _stream && _stream.getAudioTracks().forEach(function (track) {
        if (typeof track.enable === "function") {
            track.enable();
            track.enabled === enabled || track.enable(enabled);
            return;
        }

        track.enabled === enabled || (track.enabled = enabled);
    });
};

emedia.hasEnabledTracks = function (mediaStream) {
    if (!mediaStream || typeof mediaStream.getAudioTracks !== 'function') {
        return false;
    }

    if (!mediaStream.active) {
        return false;
    }

    var tracks = mediaStream.getAudioTracks();

    if (tracks.length === 0) {
        return false;
    }

    for (var i in tracks) {
        if (typeof tracks[i].enable === "function") {
            tracks[i].enable();
        }
        if (tracks[i].enabled) {
            return true;
        }
    }

    return false;
};

emedia.fileReport = function () {
    if (!emedia._logContext) {
        return;
    }
    if (!(emedia._logContext instanceof Array)) {
        return;
    }
    if (typeof emedia._logContextIndex === 'undefined' || emedia._logContextIndex < 0) {
        return;
    }

    var start = 0;
    var end = emedia._logContextIndex;
    if (emedia._logContextIndex >= emedia._logContext.length) {
        start = emedia._logContextIndex - emedia._logContext.length + 1;
    }

    var report = "";
    for (var i = start; i <= end; i++) {
        var index = i % emedia._logContext.length;
        var oneConfrLogs = emedia._logContext[index];
        report += oneConfrLogs.join("\r\n") + "\r\n";
    }

    if (emedia._logContext.loadlogs && emedia._logContext.loadlogs instanceof Array) {
        report += "-------------------------------------------------------------\r\n";
        report += emedia._logContext.loadlogs.join("\r\n") + "\r\n";
    }

    var fileContent = report;
    var content = encodeURIComponent(fileContent);

    var link = document.createElement('a');
    link.style.display = 'none';
    link.download = 'emedia-' + new Date().toJSON() + '.log';
    link.href = 'data:text/plain;charset=utf-8,' + content;
    //link.setAttribute('download', link.download);
    //link.setAttribute('href', 'data:text/plain;charset=utf-8,' + content); //'data:attachment/file;charset=utf-8,' + content

    document.body.appendChild(link);
    link.click();
    link.parentNode.removeChild(link);
};

var Service = __webpack_require__(16);
var __event = __webpack_require__(21);

emedia.Webrtc = __webpack_require__(24);

emedia.Service = Service;
emedia.P2P = __webpack_require__(33);
// var cloneService = util.extend({}, Service).extend(Service);
emedia.XService = Service;
emedia.XServiceWithP2P = emedia.P2P(Service);

// emedia.mgr = require("./components/mgr/Manager");
// emedia.mgr = emedia.mgr.single;
emedia.mgr = __webpack_require__(34).outer;

emedia.ctrl = __webpack_require__(236);
emedia.CompositeCanvas = __webpack_require__(242);

emedia.pannel || (emedia.pannel = {});
emedia.pannel.DefaultMouseTrack = __webpack_require__(30);
emedia.pannel.MouseTrack = __webpack_require__(31);
emedia.pannel.KeyboardTrack = __webpack_require__(243);

var PCStats = emedia.PCStats = __webpack_require__(244);

emedia.helper = emedia.helper || {};

emedia.helper.PCStats = PCStats;

emedia.helper.pcstats = PCStats.echo;
emedia.helper.intervalPcstats = PCStats.intervalEcho;

emedia.helper.inboundAudio = PCStats.inboundAudio;
emedia.helper.inboundVideo = PCStats.inboundVideo;

emedia.helper.outboundAudio = PCStats.outboundAudio;
emedia.helper.outboundVideo = PCStats.outboundVideo;

emedia.event = __event;

emedia.LOG_LEVEL = 0;

emedia.isFirefox = 'firefox' === emedia.browser;
emedia.isChrome = 'chrome' === emedia.browser;
emedia.isSafari = 'safari' === emedia.browser;
emedia.isEdge = 'edge' === emedia.browser;

emedia.isElectron = /Electron/.test(navigator.userAgent);
if (emedia.isElectron) {
    try {
        __webpack_require__(245);
    } catch (e) {
        util.logger.error(e);
    }
}

emedia.isWebRTC = window.RTCPeerConnection && /^https\:$/.test(window.location.protocol);

/**
 * 判断是否支持pranswer
 */
if (emedia.isChrome || emedia.isSafari) {
    emedia.supportPRAnswer = true;
}
/**
 * 2019.02.21
 * 发现chrome72版本 对pranswer支持有问题，https://webrtc.github.io/samples/src/content/peerconnection/pr-answer 事例也不能正显示视频
 * video.srcObject [remote media stream] active: false.
 *
 * 统一设置为不支持pranswer
 *
 */
emedia.supportPRAnswer = false;

emedia.config({
    baseAcptOps: [102, 104, 105, 106, 107, 300, 302, 303, 304, 301, 204, 206, 400, 401, 1001, 100201, 100202, 100203]
    // baseAcptOps: [107, 300, 302, 303, 304, 301, 204, 206, 400, 401, 1001]
});
emedia.config({
    clientType: 'WEB',
    version: '2.1.1',

    userAgent: navigator.userAgent,

    acptOps: [100230, //远程控制
    100205, //远程抓图
    1003, //透传消息
    1004]
});

// /**
//  *  Enter 客户端携带，进入
//  *  服务端可支持，Json字符串，或Json数据
//  */
// var res = {
//     type: 'ios|android|web',
//     ver: '1.0.2',
//     agent: '', //ios android可以不传，web navigator.userAgent
//     //可缺省，缺省默认支持
//     //107 300 302 303 304 301 204 206 400 401 1001
//     ops:[
//         1003, //透传消息
//         100201, //缩放
//         100202, //聚焦
//         100203, //曝光
//         100204, //定格
//         100205 //远程抓图
//     ],
//
//     vcodes:['H264', 'VP8'] //客户端进入，可以携带，也可以不携带。携带了，就使用这个广播给其他人。
//                            // A进入，没有携带此参数，服务端通过 type ver agent 补全此字段，广播给B C
// }


module.exports = emedia;

/***/ }),
/* 15 */
/***/ (function(module, exports) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*
 * ! Math.uuid.js (v1.4) http://www.broofa.com mailto:robert@broofa.com
 *
 * Copyright (c) 2010 Robert Kieffer Dual licensed under the MIT and GPL
 * licenses.
 */

/*
 * Generate a random uuid.
 *
 * USAGE: Math.uuid(length, radix) length - the desired number of characters
 * radix - the number of allowable values for each character.
 *
 * EXAMPLES: // No arguments - returns RFC4122, version 4 ID >>> Math.uuid()
 * "92329D39-6F5C-4520-ABFC-AAB64544E172" // One argument - returns ID of the
 * specified length >>> Math.uuid(15) // 15 character ID (default base=62)
 * "VcydxgltxrVZSTV" // Two arguments - returns ID of the specified length, and
 * radix. (Radix must be <= 62) >>> Math.uuid(8, 2) // 8 character ID (base=2)
 * "01001010" >>> Math.uuid(8, 10) // 8 character ID (base=10) "47473046" >>>
 * Math.uuid(8, 16) // 8 character ID (base=16) "098F4D35"
 */
(function () {
    // Private array of chars to use
    var CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');

    Math.uuid = function (len, radix) {
        var chars = CHARS,
            uuid = [],
            i;
        radix = radix || chars.length;

        if (len) {
            // Compact form
            for (i = 0; i < len; i++) {
                uuid[i] = chars[0 | Math.random() * radix];
            }
        } else {
            // rfc4122, version 4 form
            var r;

            // rfc4122 requires these characters
            uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';
            uuid[14] = '4';

            // Fill in random data. At i==19 set the high bits of clock sequence
            // as
            // per rfc4122, sec. 4.1.5
            for (i = 0; i < 36; i++) {
                if (!uuid[i]) {
                    r = 0 | Math.random() * 16;
                    uuid[i] = chars[i == 19 ? r & 0x3 | 0x8 : r];
                }
            }
        }

        return uuid.join('');
    };

    // A more performant, but slightly bulkier, RFC4122v4 solution. We boost
    // performance
    // by minimizing calls to random()
    Math.uuidFast = function () {
        var chars = CHARS,
            uuid = new Array(36),
            rnd = 0,
            r;
        for (var i = 0; i < 36; i++) {
            if (i == 8 || i == 13 || i == 18 || i == 23) {
                uuid[i] = '-';
            } else if (i == 14) {
                uuid[i] = '4';
            } else {
                if (rnd <= 0x02) rnd = 0x2000000 + Math.random() * 0x1000000 | 0;
                r = rnd & 0xf;
                rnd = rnd >> 4;
                uuid[i] = chars[i == 19 ? r & 0x3 | 0x8 : r];
            }
        }
        return uuid.join('');
    };

    // A more compact, but less performant, RFC4122v4 solution:
    Math.uuidCompact = function () {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            var r = Math.random() * 16 | 0,
                v = c == 'x' ? r : r & 0x3 | 0x8;
            return v.toString(16);
        });
    };
})();

if (!String.prototype.startsWith) {
    String.prototype.startsWith = function (searchString, position) {
        position = position || 0;
        return this.indexOf(searchString, position) === position;
    };
}

/**
 * Util
 *
 * @constructor
 */
function Util() {}

/**
 * Function Logger
 *
 * @constructor
 */
var Logger = function Logger(tag) {
    var self = this;

    var LogLevel = {
        TRACE: 0,
        DEBUG: 1,
        INFO: 2,
        WARN: 3,
        ERROR: 4,
        FATAL: 5
    };

    var LogLevelName = ['TRACE', 'DEBUG', 'INFO', 'WARN', 'ERROR', 'FATAL'];

    this._log = function () {
        var level = arguments[0];

        level = arguments[0] = LogLevelName[level];

        emedia._logContext && sdklog.apply(null, arguments);
        if (emedia.config.consoleLogger !== true) {
            return;
        }

        if (emedia && emedia.isElectron) {
            console.log.apply(console, arguments);
            return;
        }
        if (console && level) {
            (console[level.toLowerCase()] || console.warn).apply(console, arguments);
        }
    };

    function callLog(level, args) {
        try {
            _callLog(level, args);
        } catch (e) {
            if (console) {
                if (console.error) {
                    console.error(e);
                    return;
                }
                if (console.log) {
                    console.log(e);
                    return;
                }
            }

            throw e;
        }
    }

    function _sdklog() {
        if (emedia._logContextIndex < 0) {
            return;
        }
        if (!emedia._logContext || !(emedia._logContext instanceof Array)) {
            return;
        }

        var contextIndex = emedia._logContextIndex % emedia._logContext.length;
        var logInfos = emedia._logContext[contextIndex];
        if (!logInfos || !(logInfos instanceof Array)) {
            logInfos = emedia._logContext[contextIndex] = [];
        }

        var info = [];
        info.push(emedia._logContextIndex);

        var now = new Date();
        if (now.toJSON) {
            info.push(now.toJSON());
        } else if (now.toISOString) {
            info.push(now.toISOString());
        } else {
            info.push(now + "");
        }

        for (var i = 0; i < arguments.length; i++) {
            var arg = arguments[i];

            if (typeof arg === "string") {
                info.push(arg);
                continue;
            }

            if (typeof arg.message === "string") {
                info.push(arg.message);
                continue;
            }
            if (typeof arg.message === "function") {
                info.push(arg.message());
                continue;
            }
            if (typeof arg.stack === "string") {
                info.push(arg.stack);
                continue;
            }
            if (arg.event && typeof arg.event.toString === "function") {
                info.push(arg.event.toString());
                continue;
            }
            if (arg.event && typeof arg.event.toString === "function") {
                info.push(arg.event.toString());
                continue;
            }

            if (typeof arg.candidate === "string") {
                info.push(arg.candidate);
                continue;
            }
            if (typeof arg.sdp === "string") {
                info.push(arg.sdp);
                continue;
            }

            arg && info.push(JSON.stringify(arg));
        }

        logInfos.push(info.join(' '));
    };

    function sdklog() {
        try {
            _sdklog.apply(null, arguments);
        } catch (e) {}
    };

    function _callLog(level, args) {
        if (emedia && emedia.LOG_LEVEL && level < emedia.LOG_LEVEL) {
            return;
        }

        var _args = [];

        _args.push(level);
        tag && _args.push(tag);

        for (var i = 0; i < args.length; i++) {
            _args.push(args[i] && args[i]._toString ? args[i]._toString.call(args[i]) : args[i]);
        }

        //_args.caller && _args.push(_args.caller);

        self._log.apply(self, _args);
    };

    this.log = function () {
        this._log && callLog(LogLevel.INFO, arguments);
    };

    this.trace = function () {
        this._log && callLog(LogLevel.TRACE, arguments);
    };

    this.debug = function () {
        this._log && callLog(LogLevel.DEBUG, arguments);
    };

    this.info = function () {
        this._log && callLog(LogLevel.INFO, arguments);
    };

    this.warn = function () {
        this._log && callLog(LogLevel.WARN, arguments);
    };

    this.error = function () {
        this._log && callLog(LogLevel.ERROR, arguments);
    };

    this.fatal = function () {
        this._log && callLog(LogLevel.FATAL, arguments);
    };
};

Logger.prototype.count = function () {
    if (emedia._logContext) {
        emedia._logContextIndex++;

        var contextIndex = emedia._logContextIndex % emedia._logContext.length;

        if (contextIndex === 0 && emedia._logContextIndex !== 0) {
            emedia._logContext.loadlogs = emedia._logContext[contextIndex];
        }
        emedia._logContext[contextIndex] = [];
    }
};

Util.prototype.logger = new Logger();

Util.prototype.tagLogger = function (tag) {
    return new Logger(tag);
};

/**
 * parse json
 *
 * @param jsonString
 */
Util.prototype.parseJSON = function (jsonString) {
    return JSON.parse(jsonString);
};

/**
 * json to string
 *
 * @type {Util.stringifyJSON}
 */
var stringifyJSON = Util.prototype.stringifyJSON = function (jsonObj) {
    return JSON.stringify(jsonObj);
};

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call(Object);

/**
 * check object type
 *
 * @type {Util.isPlainObject}
 */
var isPlainObject = Util.prototype.isPlainObject = function (obj) {
    var proto, Ctor;

    // Detect obvious negatives
    // Use toString instead of jQuery.type to catch host objects
    var objectString;
    if (!obj || (objectString = toString.call(obj)) !== "[object Object]" || obj.toString() === "<JSAPI-Auto Javascript Object>" || obj.toString() === "[object IFBComJavascriptObject]") {
        return false;
    }

    proto = Object.getPrototypeOf(obj);

    // Objects with no prototype (e.g., `Object.create( null )`) are plain
    if (!proto) {
        return true;
    }

    // Objects with prototype are plain iff they were constructed by a
    // global Object function
    Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
    return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
};

Util.prototype.isArray = Array.isArray;

/**
 * check empty object
 *
 * @param obj
 * @returns {boolean}
 */
Util.prototype.isEmptyObject = function (obj) {
    var name;
    for (name in obj) {
        return false;
    }
    return true;
};

Util.prototype.type = function (obj) {
    if (obj == null) {
        return obj + "";
    }
    return (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj === 'undefined' ? 'undefined' : _typeof(obj);
};

/**
 * Function extend
 *
 * @returns {*|{}}
 */
Util.prototype.extend = function () {
    var self = this;
    var options,
        name,
        src,
        copy,
        copyIsArray,
        clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;

    // Handle a deep copy situation
    if (typeof target === "boolean") {
        deep = target;

        // Skip the boolean and the target
        target = arguments[i] || {};
        i++;
    }

    // Handle case when target is a string or something (possible in deep
    // copy)
    if ((typeof target === 'undefined' ? 'undefined' : _typeof(target)) !== "object" && !self.isFunction(target)) {
        target = {};
    }

    // Extend self itself if only one argument is passed
    if (i === length) {
        target = this;
        i--;
    }

    for (; i < length; i++) {

        // Only deal with non-null/undefined values
        if ((options = arguments[i]) != null) {

            // Extend the base object
            for (name in options) {
                src = target[name];
                copy = options[name];

                // Prevent never-ending loop
                if (target === copy) {
                    continue;
                }

                // Recurse if we're merging plain objects or arrays
                if (deep && copy && (self.isPlainObject(copy) || (copyIsArray = self.isArray(copy)))) {

                    if (copyIsArray) {
                        copyIsArray = false;
                        clone = src && self.isArray(src) ? src : [];
                    } else {
                        clone = src && self.isPlainObject(src) ? src : {};
                    }

                    // Never move original objects, clone them
                    target[name] = self.extend(deep, clone, copy);

                    // Don't bring in undefined values
                } else if (copy !== undefined) {
                    target[name] = copy;
                }
            }
        }
    }

    // Return the modified object
    return target;
};

Util.prototype.removeAttribute = function (elem, key) {
    if (elem === null || elem === undefined) {
        return;
    }

    var obj = elem[key];

    // if(emedia.isSafari && obj && obj.__undefinedEQDelete){ // safari delete stream时，地址栏会有个小喇叭; 要延迟删除
    //     emedia._stream_garbages || (emedia._stream_garbages = [])
    //     emedia._stream_garbages.push(obj);
    // }
    delete elem[key];

    return obj;
};

Util.prototype.prototypeExtend_000 = Util.prototype.classExtend = function () {
    var self = this;

    function _Obj__() {
        for (var i = 0; i < arguments.length; i++) {
            var cfg = arguments[i] || {};
            self.extend(true, this, cfg);
        }

        this.__init__ && this.__init__.apply(this, arguments);
    }

    var lastConstructor;

    for (var i = 0; i < arguments.length; i++) {
        var cfg = arguments[i] || {};

        if (typeof cfg === "function") {
            if (lastConstructor) {
                cfg.constructor = lastConstructor;
                cfg.__proto__ = lastConstructor.prototype;
            } else {
                lastConstructor = cfg;
            }
        } else {
            self.extend(true, _Obj__.prototype, cfg);
        }
    }

    lastConstructor && (_Obj__.prototype.__proto__ = lastConstructor.prototype);
    lastConstructor && (_Obj__.prototype.constructor = lastConstructor);

    _Obj__.extend || (_Obj__.extend = function (_prototypeExtend) {
        return self.prototypeExtend(_Obj__, _prototypeExtend);
    });

    return _Obj__;
};

Util.prototype.prototypeExtend = Util.prototype.classExtend = function () {
    var self = this;

    function _Obj__() {
        for (var i = 0; i < arguments.length; i++) {
            var cfg = arguments[i] || {};
            self.extend(true, this, cfg);
        }

        this.__init__ && this.__init__.apply(this, arguments);
    }

    for (var i = 0; i < arguments.length; i++) {
        var cfg = arguments[i] || {};
        if (typeof cfg === "function") {
            cfg = cfg.prototype;
        }

        self.extend(true, _Obj__.prototype, cfg);
    }

    _Obj__.extend || (_Obj__.extend = function (_prototypeExtend) {
        return self.prototypeExtend(_Obj__, _prototypeExtend);
    });

    return _Obj__;
};

/**
 * get local cache
 *
 * @memberOf tool
 * @name hasLocalData
 * @param key{string}
 *            localStorage的key值
 * @return boolean
 */
Util.prototype.hasLocalStorage = function (key) {
    // null -> localStorage.removeItem时
    // '{}' -> collection.models.destroy时
    if (localStorage.getItem(key) == null || localStorage.getItem(key) == '{}') {
        return false;
    }
    return true;
};

Util.prototype.toggleClass = function (node, className) {
    if (node.hasClass(className)) {
        node.removeClass(className);
        return;
    }
    node.addClass(className);
};

/**
 * set cookie
 *
 * @param name{String}
 *
 * @param value{String}
 *
 * @param hour{Number}
 *
 * @return void
 */
Util.prototype.setCookie = function (name, value, hour) {
    var exp = new Date();
    exp.setTime(exp.getTime() + hour * 60 * 60 * 1000);
    document.cookie = name + "=" + escape(value) + ";expires=" + exp.toGMTString();
};

/**
 * read cookie
 *
 * @param name(String)
 *            cookie key
 * @return cookie value
 * @memberOf Tool
 */
Util.prototype.getCookie = function (name) {
    var arr = document.cookie.match(new RegExp("(^| )" + name + "=([^;]*)(;|$)"));
    if (arr != null) {
        return unescape(arr[2]);
    }
    return null;
};

/**
 * query parameter from url
 *
 * @name parseURL
 * @memberof C.Tools
 * @param {string}
 *
 * @return {string}
 * @type function
 * @public
 */
Util.prototype.parseURL = function (name) {
    var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)", "i");
    var r = window.location.search.substr(1).match(reg);
    if (r != null) {
        return unescape(r[2]);
    }
    return null;
};

/**
 * function(index, value){

}
 * @param obj
 */
Util.prototype.forEach = function (obj, func) {
    if (!obj) {
        return;
    }

    if (this.isArray(obj) && obj.length === 0) {
        return;
    }
    if (obj.length !== undefined && obj.length === 0) {
        return;
    }
    if (obj.length) {
        for (var i = 0; i < obj.length; i++) {
            func(i, obj[i]);
        }
        return;
    }

    if (!obj || this.isEmptyObject(obj)) {
        return;
    }

    obj = obj || {};

    var copy = this.extend(false, {}, obj);

    for (var index in copy) {
        func(index, obj[index]);
    }
};

Util.prototype.isInt = function (n) {
    return Number(n) === n && n % 1 === 0;
};

Util.prototype.isFloat = function (n) {
    return Number(n) === n && n % 1 !== 0;
};

Util.prototype.list = function () {
    var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
    return args;
};

Util.prototype.addEvent = function (element, name, func) {
    if (element.attachEvent) return element.attachEvent("on" + name, func);
    if (element.addEventListener) return element.addEventListener(name, func, false);
    throw "Handler could not be attached";
};

Util.prototype.removeEvent = function (element, name, func) {
    if (element.detachEvent) return element.detachEvent("on" + name, func);
    if (element.removeEventListener) return element.removeEventListener(name, func, false);
    throw "Handler could not be removed";
};

Util.prototype.stopEvent = function (event) {
    event.stopPropagation ? event.stopPropagation() : event.cancelBubble = true;
    event.preventDefault ? event.preventDefault() : event.returnValue = false;
};

Util.prototype.getDomPageRect = function (element) {
    var domRect = element.getBoundingClientRect();
    return {
        x: domRect.left + (window.pageXOffset || window.document.documentElement.scrollLeft),
        y: domRect.top + (window.pageYOffset || window.document.documentElement.scrollTop),
        width: domRect.width || element.offsetWidth,
        height: domRect.height || element.offsetHeight
    };
};

Util.prototype.getEventElementXY = function (event, element, scale) {
    event = event || window.event;

    var touch = event.changedTouches ? event.changedTouches[0] : event.touches ? event.touches[0] : event;

    var pageX, pageY;
    if (touch.pageX != undefined && touch.pageY != undefined) {
        pageX = touch.pageX;
        pageY = touch.pageY;
    } else if (touch.clientX != undefined && touch.clientY != undefined) {
        pageX = touch.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
        pageY = touch.clientY + document.body.scrollTop + document.documentElement.scrollTop;
    }

    var elementPageXY = this.getDomPageRect(element);

    var relativeX = pageX - elementPageXY.x;
    var relativeY = pageY - elementPageXY.y;

    (scale === 0 || scale == undefined) && (scale = 1);
    return {
        x: Math.round(Math.max(Math.min(relativeX, elementPageXY.width - 1), 0) / scale),
        y: Math.round(Math.max(Math.min(relativeY, elementPageXY.height - 1), 0) / scale),
        width: Math.round(elementPageXY.width / scale),
        height: Math.round(elementPageXY.height / scale),

        realX: relativeX,
        realY: relativeY
    };
};

Util.prototype.layoutEngine = function () {
    var engine = {
        presto: !!window.opera,
        trident: !!window.ActiveXObject && (window.XMLHttpRequest ? document.querySelectorAll ? 6 : 5 : 4),
        webkit: function () {
            try {
                return !navigator.taintEnabled && (i.Features.xpath ? i.Features.query ? 525 : 420 : 419);
            } catch (e) {
                return !1;
            }
        }(),
        gecko: !(!document.getBoxObjectFor && null == window.mozInnerScreenX) && (document.getElementsByClassName ? 19 : 18)
    };

    engine.webkit && (engine.webkit = function (e) {
        var n = (navigator.userAgent.match(/WebKit\/([0-9\.]*) /) || ["", e])[1];
        return parseFloat(n, 10);
    }(engine));

    return engine;
}();

Util.prototype.targetDOM = (typeof HTMLElement === 'undefined' ? 'undefined' : _typeof(HTMLElement)) === 'object' ? function (obj) {
    return obj instanceof HTMLElement;
} : function (obj) {
    return obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj.nodeType === 1 && typeof obj.nodeName === 'string';
};

Util.prototype.cloneCSS = function (srcElement, destElement) {
    /**
     * IE8不支持window.getComputedStyle
     * IE9~11中，window.getComputedStyle().cssText返回的总为空字符串
     * 默认的window.getComputedStyle || dom.currentStyle, 返回的css键值对中，键是驼峰命名的。
     */
    var oStyle = window.getComputedStyle && window.getComputedStyle(srcElement, null) || srcElement.currentStyle;
    for (var key in oStyle) {
        var v = oStyle[key];
        if (/^[a-z]/i.test(key) && [null, '', undefined].indexOf(v) < 0) {
            destElement.style[key] = v;
        }
    }
};

Util.prototype.canYield = function () {
    try {
        return eval("!!Function('yield true;')().next()");
    } catch (e) {
        return false;
    }
}();

module.exports = new Util();

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//Service 类，会创建session(me), 并且将current属性设置为 me; 以后方法需要此值


var _util = __webpack_require__(15);
var _ = __webpack_require__(17);

var _logger = _util.tagLogger("Service");

var Session = __webpack_require__(20);

var Attendee = __webpack_require__(22);

var __event = __webpack_require__(21);
var EventHandler = __webpack_require__(28);

var __Desktop = __webpack_require__(29);

var __desktop = new __Desktop({
    onExtLoaded: function onExtLoaded() {
        _logger.info("Share desktop ext. had loaded.");
    }
});

var __Stream = __webpack_require__(26);

var DefaultMouseTrack = __webpack_require__(30);

/**
 * {
 *  newSession:
 *  onCalling:
 *  onRinging:
 *
 *
 * }
 *
 *
 *
 */
module.exports = _util.prototypeExtend({
    __init__: function __init__() {
        var self = this;

        _logger.warn("emedia version: ", window._emediaVersion || "unkown");
        _logger.warn("UserAgent: ", navigator.userAgent);

        var urlLogLevel = _util.parseURL("__log_level___");
        if (urlLogLevel) {
            emedia.LOG_LEVEL = parseInt(urlLogLevel);
        }

        // if(self.ticket && _util.isPlainObject(self.ticket)){
        //     self.setup(self.ticket);
        // }

        self.namespace = Math.uuidFast();
        emedia.__easemob_current_mservice = self;

        if (self.useRTCCfg === undefined) {
            self.useRTCCfg = emedia.config.useRTCCfgIfServerReturn;
        }

        if (typeof self.useRTCCfg === "string") {
            self.useRTCCfg = JSON.parse(self.useRTCCfg);
        }
    },

    AVPubstream: __Stream.extend({
        __init__: function __init__() {
            var self = this;

            self.type = 0;
            self._located = true;

            self.mutedMuted = true;

            if (self.constaints) {
                self.constaints.video || (self.voff = 1);
                self.constaints.audio || (self.aoff = 1);
            }
            //self.constaints || (self.constaints = {audio: !self.aoff, video: !self.voff});
            self.constaints || (self.constaints = { audio: true, video: true });

            emedia.config.maxVideoBitrate && (self.vbitrate = emedia.config.maxVideoBitrate);
            emedia.config.maxAudioBitrate && (self.abitrate = emedia.config.maxAudioBitrate);
        }
    }),

    AudioMixerPubstream: new __Stream.extend({
        __init__: function __init__() {
            var self = this;

            self.type = 2;
            self._located = true;

            self.mutedMuted = true;

            self.constaints || (self.constaints = { audio: true, video: false });
            if (self.constaints) {
                var audio = !!self.constaints.audio;
                //self.constaints.audio = true;
                self.constaints.video || (self.constaints.video = false);

                self.constaints.video || (self.voff = 1);
                self.constaints.audio || (self.aoff = 1);

                audio === false && (self.aoff = 1);
            }

            emedia.config.maxVideoBitrate && (self.vbitrate = emedia.config.maxVideoBitrate);
            emedia.config.maxAudioBitrate && (self.abitrate = emedia.config.maxAudioBitrate);
        },

        onGotRemoteMediaStream: function onGotRemoteMediaStream(remoteMediaStream) {
            var self = this;

            if (!self.remotePlayAudioObject) {
                var _audioId = "__o_remote_play_audio_" + self.id;
                var audioObject = document.querySelector("#" + _audioId);
                if (audioObject) {
                    //audioObject.remove();
                } else {
                    audioObject = document.createElement("audio");

                    audioObject.style.display = "none";
                    audioObject.id = "__o_remote_play_audio_" + self.id;
                    audioObject.autoplay = true;
                    audioObject.playsinline = true;

                    document.body.appendChild(audioObject);
                }

                //monitorEvents && monitorEvents(audioObject);

                self.remotePlayAudioObject = audioObject;
            }

            // self.remotePlayAudioObject.autoplay = true;
            // self.remotePlayAudioObject.playsinline = true;
            self.remotePlayAudioObject.srcObject = remoteMediaStream;

            //window.__$_remoteMediaStream = remoteMediaStream;
        }
    }),

    //screenOptions ['screen', 'window', 'tab']
    ShareDesktopPubstream: __Stream.extend({
        voff: 0,

        __init__: function __init__() {
            var self = this;

            self.type = 1;
            self._located = true;

            self.mutedMuted = true;
            self.constaints = { audio: !this.aoff, video: true };

            emedia.config.maxVideoBitrate && (self.vbitrate = emedia.config.maxVideoBitrate);
            emedia.config.maxAudioBitrate && (self.abitrate = emedia.config.maxAudioBitrate);
        }
    }),

    __assertCurrent: function __assertCurrent() {
        var self = this;
        if (!self.current) {
            _logger.error("Please call emedia.service.setup(ticket)");
            throw "Please call emedia.service.setup(ticket)";
        }
        if (self.current.closed) {
            _logger.error("current closed");
            throw "current closed";
        }
    },

    hasAudioMixers: function hasAudioMixers() {
        var self = this;

        self.__assertCurrent();

        for (var sid in self.current.audioMixers) {
            var stream = self.current.audioMixers[sid];
            if (stream && stream.located()) {
                return true;
            }
        }
    },

    getMediaDevices: function getMediaDevices(kind, devices, errorCallback) {
        if (typeof kind === 'function') {
            errorCallback = devices;
            devices = kind;
            kind = undefined;
        }

        function gotDevices(deviceInfos) {
            var resultDeviceInfos = [];

            for (var i = 0; i !== deviceInfos.length; ++i) {
                var deviceInfo = deviceInfos[i];
                var deviceId = deviceInfo.deviceId;

                if (!kind) {
                    resultDeviceInfos.push(deviceInfo);
                }

                if (kind && kind === deviceInfo.kind) {
                    resultDeviceInfos.push(deviceInfo);
                } else if (deviceInfo.kind === 'audioinput') {} else if (deviceInfo.kind === 'audiooutput') {} else if (deviceInfo.kind === 'videoinput') {} else {
                    _logger.info('Some other kind of source/device: ', deviceInfo);
                }
            }

            devices && devices(resultDeviceInfos);
        };

        navigator.mediaDevices.enumerateDevices().then(gotDevices).catch(function handleError(error) {
            _logger.warn('navigator.getUserMedia error: ', error);
            errorCallback && errorCallback(error);
        });
    },

    // Attach audio output device to video element using device/sink ID.
    // sinkId deviceInfo.deviceId;
    // attachSinkId(videoElement, deviceInfo.deviceId);
    attachSinkId: function attachSinkId(videoObj, sinkId) {
        if (typeof videoObj.sinkId !== 'undefined') {
            videoObj.setSinkId(sinkId).then(function () {
                _logger.info('Success, audio output device attached: ' + sinkId);
            }).catch(function (error) {
                var errorMessage = error;
                if (error.name === 'SecurityError') {
                    errorMessage = 'You need to use HTTPS for selecting audio output ' + 'device: ' + error;
                }
                _logger.warn(errorMessage);
            });
        } else {
            _logger.warn('Browser does not support output device selection.');
        }
    },

    _stopTracks: function _stopTracks(_stream) {
        emedia.stopTracks(_stream);
        _stream && _logger.warn("Stream tracks stop. it = ", _stream);
    },
    _enableVideoTracks: function _enableVideoTracks(_stream, enabled) {
        emedia.enableVideoTracks(_stream, enabled);
    },
    _enableAudioTracks: function _enableAudioTracks(_stream, enabled) {
        emedia.enableAudioTracks(_stream, enabled);
    },

    openUserMedia: function openUserMedia(pubS) {
        _logger.debug("begin open user media", pubS);

        var self = this;

        //self.__assertCurrent();

        if (!pubS) {
            _logger.error("require pubS");
            throw "require pubS";
        }

        return {
            then: function then(success, errCallback) {
                if (pubS instanceof self.AVPubstream) {
                    self._openCamera(pubS, success, errCallback);
                } else if (pubS instanceof self.ShareDesktopPubstream) {
                    self._openSharedDesktop(pubS, success, errCallback);
                } else if (pubS instanceof self.AudioMixerPubstream) {
                    self._openCamera(pubS, success, errCallback);
                } else {
                    _logger.error("Unspported pubS");
                    throw "Unspported pubS";
                }
            }
        };
    },

    _openSharedDesktop: function _openSharedDesktop(pubS, success, errCallback) {
        var self = this;

        //self.__assertCurrent();

        function getAudioStream(pubS) {
            var audioConstaints = { audio: true };
            if (pubS.constaints) {
                if (_typeof(pubS.constaints.audio) === 'object' && pubS.constaints.audio) {} else if (!pubS.constaints.audio) {
                    audioConstaints.audio = false;
                }
            }
            self.__getUserMedia(audioConstaints, function (_user, stream) {
                var mediaStream = new MediaStream();
                mediaStream._located = true;

                stream && stream.getAudioTracks().forEach(function (track) {
                    mediaStream.addTrack(track);
                });

                pubS.localStream && pubS.localStream.getVideoTracks().forEach(function (track) {
                    mediaStream.addTrack(track);
                });

                pubS.localStream = mediaStream;

                success && success(self.current, mediaStream);
            }, errCallback);
        }

        var videoTracks;
        if (pubS._localMediaStream && (videoTracks = pubS._localMediaStream.getVideoTracks()) && videoTracks.length > 0) {
            pubS.localStream = pubS._localMediaStream;

            if (pubS.constaints.audio) {
                getAudioStream(pubS);
            } else {
                success && success(self.current, stream);
            }

            return;
        }

        //screenOptions ['screen', 'window', 'tab']
        __desktop.openDesktopMedia(pubS.screenOptions || ['screen', 'window', 'tab'], function (_event) {
            if (_event instanceof __event.OpenDesktopMedia) {
                var desktopStreamId = _event.desktopStreamId;
                _logger.warn("desktop streamId", desktopStreamId);

                var constraints = {
                    audio: false,
                    video: {
                        mandatory: _util.extend(pubS.mandatory || {}, {
                            chromeMediaSource: 'desktop',
                            chromeMediaSourceId: desktopStreamId
                            // maxWidth: window.screen.width > 1920 ? window.screen.width : 1920,
                            // maxHeight: window.screen.height > 1080 ? window.screen.height : 1080
                        }),
                        optional: []
                    }
                };

                //delete pubS.mandatory;

                self.__getUserMedia(constraints, function (_me, stream) {
                    pubS.localStream = stream;

                    if (pubS.constaints.audio) {
                        getAudioStream(pubS);
                    } else {
                        success && success(self.current, stream);
                    }
                }, errCallback);
            } else {
                self.current && self.current.onEvent(new __event.ShareDesktopExtensionNotFound({ member: self.current }));
                errCallback && errCallback(_event);
            }
        });
    },

    _openCamera: function _openCamera(pubS, success, errCallback) {
        var self = this;
        //self.__assertCurrent();

        //var constaints = pubS.constaints || {audio: !pubS.aoff, video: !pubS.voff};
        var constaints = pubS.constaints || { audio: true, video: true };

        function successCallback(_me, stream) {
            self.__controlStream(pubS, stream);

            pubS.localStream = stream;
            success && success(self.current, stream);
        }
        self.__getUserMedia(constaints, successCallback.bind(constaints), errCallback);
    },

    __controlStream: function __controlStream(pubS, stream) {
        emedia.enableVideoTracks(stream, !pubS.voff);
        emedia.enableAudioTracks(stream, !pubS.aoff);
    },

    __getUserMedia: function __getUserMedia(constaints, success, errCallback) {
        _logger.debug('Using get user media. constaints', constaints);

        var self = this;

        constaints = _util.extend({}, constaints);
        if (_typeof(constaints.audio) === 'object' && constaints.audio) {
            constaints.audio = true;
        }

        var _openstream;

        function onSuccess(stream) {
            if (self.current && !self.current.closed) {
                //push stream时，由于异步，在未返回成功后，退出会议，摄像头不会被关闭问题
                //将stream 与 Attendee绑定
                self.current._openedRtcMediaStreams[stream.id] = stream;
                stream._bindAttendee = self.current;
                _logger.info("stream bind attendee.", stream.id, self.current.ticket && self.current.ticket.id || self.current.memName);
            }

            if (emedia.isSafari) {
                emedia._isSafariYetPushedStream = true;
            }

            _openstream = stream;

            var videoTracks = stream.getVideoTracks();
            var audioTracks = stream.getAudioTracks();

            if (videoTracks.length > 0) {
                _logger.debug('Using video device: ' + videoTracks[0].label);
            }
            if (audioTracks.length > 0) {
                _logger.debug('Using audio device: ' + audioTracks[0].label);
            }

            stream._located = true;

            success && success(self.current, stream);
        }

        function onFail(e) {
            _logger.debug('[WebRTC-API] getUserMedia() error: ', e);

            emedia.stopTracks(_openstream);

            self.current && self.current.onEvent(new __event.OpenMediaError({ member: self.current, event: e }));
            errCallback && errCallback(new __event.OpenMediaError({ member: self.current, event: e }));
        }

        self.__sysGetUserMedia(constaints, onSuccess, onFail);
    },

    __sysGetUserMedia: function __sysGetUserMedia(constaints, onSuccess, onFail) {
        function getUserMedia(constaints, onSuccess, onFail) {
            navigator.mediaDevices.getUserMedia(constaints).then(onSuccess).catch(onFail);
            // navigator.mediaDevices ? navigator.mediaDevices.getUserMedia(constaints).then(onSuccess).catch(onFail)
            //     : navigator.getUserMedia(constaints, onSuccess, onFail);
        }

        if (!emedia.isSafari) {
            getUserMedia(constaints, onSuccess, onFail);
            return;
        }

        constaints = _.extend({}, constaints);

        function newStreamAndCallback() {
            var mediaStream = new MediaStream();

            constaints.audioStream && constaints.audioStream.getAudioTracks().forEach(function (track) {
                mediaStream.addTrack(track);
            });
            constaints.videoStream && constaints.videoStream.getVideoTracks().forEach(function (track) {
                mediaStream.addTrack(track);
            });
            onSuccess && onSuccess(mediaStream);
        }

        function successCallback(stream) {
            if (constaints.failed) {
                emedia.stopTracks(stream);
                return;
            }

            if (this.audio) {
                constaints.audioStream = stream;
                if (!constaints.video) {
                    newStreamAndCallback();
                    return;
                }
            }
            if (this.video) {
                constaints.videoStream = stream;
                if (!constaints.audio) {
                    newStreamAndCallback();
                    return;
                }
            }

            if (constaints.audioStream && constaints.videoStream) {
                newStreamAndCallback();
                return;
            }
        }

        function failCallback(e) {
            if (constaints.failed) {
                return;
            }

            constaints.failed = true;
            onFail(e);
        }

        if (constaints.audio) {
            var onlyAudio = { audio: constaints.audio };
            getUserMedia(onlyAudio, successCallback.bind(onlyAudio), failCallback);
        }
        if (constaints.video) {
            var onlyVideo = { video: constaints.video };
            getUserMedia(onlyVideo, successCallback.bind(onlyVideo), failCallback);
        }

        if (!constaints.video && !constaints.audio) {
            failCallback("Failed to execute 'getUserMedia' on 'MediaDevices': At least one of audio and video must be requested");
        }
        //Failed to execute 'getUserMedia' on 'MediaDevices': At least one of audio and video must be requested
    },

    setup: function setup(ticket, ext) {
        var self = this;

        _logger.count();
        _logger.debug("recv ticket", ticket, ext);

        ext = ext || {};

        var extObj = ext;
        if (_util.isPlainObject(ext)) {
            //ext 是对象， extObj 也是对象
            ext = JSON.stringify(ext);
        } else {
            //ext 是字符串， extObj 尽量转换为 对象
            try {
                extObj = JSON.parse(ext);
            } catch (e) {}
        }

        if (typeof ticket === "string") {
            ticket = JSON.parse(ticket);
        }

        var sysUserId, memName;
        sysUserId = memName = ticket.memName;

        if (self.current && !self.current.closed) {
            var __eventCalling = new __event.CurrentCalling();
            self.current.onEvent(__eventCalling);

            _logger.error("confr not close. calling...");
            throw __eventCalling;
            //return;

            //self.current.exit(0);
        }

        var TargetAttendee = self.Attendee || Attendee;
        var _Attendee = TargetAttendee.extend(EventHandler);

        var attendee = self.current = new _Attendee({
            _service: self,
            autoSub: emedia.config.autoSub,
            getCopyIntervalMillis: emedia.config.getCopyIntervalMillis,
            sysUserId: sysUserId,
            memName: memName,
            resource: self.resource,
            nickName: self.nickName,
            ticket: ticket,
            ext: ext,
            extObj: extObj,

            sessionFactory: function sessionFactory() {
                return self.newSession(this, ticket);
            }
        }, self.listeners || {});

        return attendee;
    },

    getStreamById: function getStreamById(streamId) {
        var stream = this.current && this.current._cacheStreams[streamId];
        return stream && _util.extend(false, {}, stream);
    },

    getMemberById: function getMemberById(memId) {
        var member = this.current && this.current._cacheMembers[memId];
        return member && _util.extend(false, {}, member);
    },

    exit: function exit(closeMyConfrIfICrtConfr) {
        _logger.warn("User click exit ", closeMyConfrIfICrtConfr);
        this.current && this.current.exit(closeMyConfrIfICrtConfr);
    },

    join: function join(joined, joinError) {
        _logger.debug("begin join ...");

        var self = this;

        self.__assertCurrent();
        if (self.current._memberId) {
            //已经加入会议
            _logger.warn("Had joined. igrone it");
            joined && joined(self.memId);
            return;
        } else {
            self.current._session._sessionId = undefined;
        }

        self.current.join(joined, joinError);
    },

    withpublish: function withpublish(pubS) {
        var self = this;

        if (!pubS || !pubS.localStream) {
            _logger.error("pubS null or stream not open");
            throw "pubS null or stream not open";
        }

        self.__assertCurrent();
        if (self.current._memberId) {
            //已经加入会议
            _logger.warn("Had joined. igrone it");
        } else {
            self.current._session._sessionId = undefined;
        }

        return self.current.withpublish(pubS);
    },

    push: function push(pubS, pushed, onPushError) {
        _logger.debug("begin push ...");

        var self = this;

        if (arguments.length === 2) {
            onPushError = pushed;
            pushed = undefined;
        }

        if (!pubS || !pubS.localStream) {
            _logger.error("pubS or stream open");
            throw "pubS or stream open";
        }

        self.__assertCurrent();
        self.current.push(pubS, pushed, onPushError, false);
    },

    subscribe: function subscribe(streamId, onSub, subfail, subArgs) {
        var self = this;

        _logger.info("begin subscribe ", streamId, subArgs);

        if (onSub && _util.isPlainObject(onSub)) {
            subArgs = onSub;
            onSub = subfail = undefined;
        }
        if (subfail && _util.isPlainObject(subfail)) {
            subArgs = subfail;
            subfail = onSub;
            onSub = undefined;
        }

        if (emedia.isSafari) {
            var _onSub = function _onSub() {
                try {
                    var shiftsub = subs.shift();
                    shiftsub && shiftsub.onSub && shiftsub.onSub.apply(shiftsub, arguments);
                } finally {
                    next();
                }
            };

            var _subfail = function _subfail() {
                try {
                    var shiftsub = subs.shift();
                    shiftsub && shiftsub.subfail && shiftsub.subfail.apply(shiftsub, arguments);
                } finally {
                    next();
                }
            };

            var next = function next() {
                if (subs.length > 0) {
                    self.__subscribe(subs[0].streamId, _onSub, _subfail, subs[0].subArgs);
                }
            };

            // safari 两个流同时订阅可能会出现无声音 等一等
            var sub = {
                streamId: streamId,
                onSub: onSub,
                subfail: subfail,
                subArgs: subArgs
            };

            var subs = self.__safari_subs || (self.__safari_subs = []);
            subs.push(sub);

            if (subs.length === 1) {
                next();
            }
        } else {
            self.__subscribe(streamId, onSub, subfail, subArgs);
        }
    },
    __subscribe: function __subscribe(streamId, onSub, subfail, subArgs) {
        var self = this;

        self.__assertCurrent();

        if (arguments.length == 2) {
            subfail = onSub;
            onSub = undefined;
        }

        if (onSub && _util.isPlainObject(onSub)) {
            subArgs = onSub;
            onSub = undefined;
        }
        if (subfail && _util.isPlainObject(subfail)) {
            subArgs = subfail;
            subfail = undefined;
        }

        subArgs || (subArgs = { subSVideo: true, subSAudio: true });

        var subStream = self.current._cacheStreams[streamId];
        // if(subStream && subStream.type === 2 && subArgs.subSAudio !== undefined && !subArgs.subSAudio){
        //     subfail && subfail(new __event.AudioMixerStreamNotAllowOnlySubVideo({stream: subStream}));
        //     self.current.onEvent(new __event.AudioMixerStreamNotAllowOnlySubVideo({stream: subStream}));
        //     return;
        // }

        var webrtc = self.current._getWebrtc(streamId);

        var usePreRTCPeer = webrtc && webrtc.isConnected();

        var remoteStream = usePreRTCPeer && webrtc.getRemoteStream();
        if (remoteStream && (usePreRTCPeer = remoteStream.active)) {
            var hasAudioTracks = remoteStream.getAudioTracks().length;
            var hasVideoTracks = remoteStream.getVideoTracks().length;

            if (!hasAudioTracks && subArgs.subSAudio === true) {
                usePreRTCPeer = false;
            } else if (!hasVideoTracks && subArgs.subSVideo === true) {
                usePreRTCPeer = false;
            }
        }

        _logger.info("sub stream", streamId, ", use prertcpeer =", usePreRTCPeer);

        // if(webrtc && webrtc.isConnected() && !emedia.isSafari){
        if (usePreRTCPeer) {
            self.current.subscribeStream(webrtc._rtcId, streamId, subfail, subArgs, onSub);
            onSub && onSub();
            return;
        }

        webrtc && !webrtc.closed && self.current.closeWebrtc(webrtc.getRtcId(), true, false);

        self.current.createWebrtcAndSubscribeStream(streamId, {
            onGotRemote: function onGotRemote(stream) {
                onSub && onSub(stream);
            },
            onEvent: function onEvent(_evt) {
                subfail && subfail(_evt);
            }
        }, undefined, subArgs);
    },

    closePubstream: function closePubstream(stream) {
        if (stream.located()) {
            emedia.stopTracks(stream._localMediaStream);
            emedia.stopTracks(stream.localStream);
        }
    },

    hungup: function hungup(streamId) {
        var stream = this.getStreamById(streamId);

        try {
            this._hungup(streamId);
        } finally {
            this.onHungup && stream && this.onHungup(stream);
        }
    },
    _hungup: function _hungup(streamId) {
        var self = this;

        self.__assertCurrent();

        var attendee = self.current;

        var stream = attendee._cacheStreams[streamId];
        var rtcId = stream && stream.rtcId;
        if (rtcId) {
            attendee.closeWebrtc(rtcId);

            if (stream.located()) {
                stream.type !== 1 && stream._localMediaStream && emedia.stopTracks(stream._localMediaStream);

                if (stream.remotePlayAudioObject) {
                    document.body.removeChild(stream.remotePlayAudioObject);
                }

                attendee._cacheStreams[streamId] && attendee.onRemoveStream(stream);

                _util.removeAttribute(attendee._cacheStreams, streamId);
            }
        }

        if (stream && !stream.located()) {
            attendee._linkedStreams[stream.id] && _util.removeAttribute(attendee._linkedStreams, stream.id);
            _logger.warn("Hangeup remove from _linkedStreams. stream = ", stream.id);

            stream = attendee._cacheStreams[streamId];
            if (!stream) {
                return;
            }

            var _stream = new __Stream(stream);
            stream.rtcId = _stream.rtcId = undefined;
            stream._webrtc = _stream._webrtc = undefined;
            stream.mediaStream = _stream.mediaStream = undefined;

            attendee.onUpdateStream(_stream, new _stream.Update(_stream));
        }
    },

    postMessage: function postMessage(memberIdOrStreamId, message, fail, onRsp) {
        var self = this;

        var theMessage = message;
        if (typeof message !== 'string') {
            message = JSON.stringify(message);
        }

        self.__assertCurrent();
        var attendee = self.current;

        var memberId;

        var linkedStream = attendee._linkedStreams[memberIdOrStreamId];
        if (linkedStream && linkedStream.owner) {
            memberId = linkedStream.owner.id;
        } else {
            memberId = memberIdOrStreamId;
        }

        var message = attendee.newMessage({
            op: 1003,
            memId: memberId,
            arg: message
        });

        attendee.postMessage(message, (fail || onRsp) && function (rsp) {
            onRsp && onRsp(rsp, theMessage);

            if (rsp.result != 0) {
                var _evt = new __event.RemoteControlFail({ memId: memberId, failed: rsp.result, cause: rsp.msg, type: "postMessage", postMessage: message });
                attendee.onEvent(_evt);

                fail && fail(_evt, theMessage);

                return;
            }
        });
    },

    torchRemote: function torchRemote(streamId, torch, success, fail) {
        var self = this;

        if (typeof torch === 'function') {
            fail = success;
            success = torch;
            torch = undefined;
        }

        if (torch !== undefined) {
            torch = torch ? 1 : 0;
        }

        self.__assertCurrent();
        var attendee = self.current;

        var linkedStream = attendee._linkedStreams[streamId];
        if (!linkedStream || linkedStream.located()) {
            _logger.error("not exsits or locate, not connect", streamId);
            throw streamId + " not exsits or locate, not connect";
        }

        var lastTorch = linkedStream.torch;
        var torch = torch === undefined ? !linkedStream.torch ? 1 : 0 : torch;

        var arg = {
            op2: 20,
            streamId: streamId,
            tor: torch
        };

        var message = attendee.newMessage({
            op: 1002,
            memId: linkedStream.owner.id,
            arg: JSON.stringify(arg),
            _reqOps: [100206]
        });

        linkedStream.torch = torch;

        attendee.postMessage(message, function (rsp) {
            if (rsp.result != 0) {
                var _evt = new __event.RemoteControlFail({ stream: linkedStream, failed: rsp.result, cause: rsp.msg, type: "torch_control" });
                attendee.onEvent(_evt);

                linkedStream.torch = lastTorch;

                fail && fail(_evt, linkedStream.torch);

                return;
            } else {
                success && success(linkedStream.torch);
            }
        });
    },

    freezeFrameRemote: function freezeFrameRemote(streamId, success, fail) {
        var self = this;

        self.__assertCurrent();
        var attendee = self.current;

        var linkedStream = attendee._linkedStreams[streamId];
        if (!linkedStream || linkedStream.located()) {
            _logger.error("not exsits or locate, not connect", streamId);
            throw streamId + " not exsits or locate, not connect";
        }

        var freezeFrame = !linkedStream.freezeFrame;

        var arg = {
            op2: 20,
            streamId: streamId,
            frz: freezeFrame ? 1 : 0
        };

        var message = attendee.newMessage({
            op: 1002,
            memId: linkedStream.owner.id,
            arg: JSON.stringify(arg),
            _reqOps: [100204]
        });

        linkedStream.freezeFrame = freezeFrame;

        attendee.postMessage(message, function (rsp) {
            if (rsp.result != 0) {
                var _evt = new __event.RemoteControlFail({ stream: linkedStream, failed: rsp.result, cause: rsp.msg, type: "freeze_control" });
                attendee.onEvent(_evt);

                linkedStream.freezeFrame = !linkedStream.freezeFrame;

                fail && fail(_evt, linkedStream.freezeFrame);

                return;
            } else {
                success && success(linkedStream.freezeFrame);
            }
        });
    },

    base64Img2Blob: function base64Img2Blob(code) {
        var parts = code.split(';base64,');
        var contentType = parts[0].split(':')[1];
        var raw = window.atob(parts[1]);
        var rawLength = raw.length;

        var uInt8Array = new Uint8Array(rawLength);

        for (var i = 0; i < rawLength; ++i) {
            uInt8Array[i] = raw.charCodeAt(i);
        }

        // if(emedia.isSafari){
        //     return new Blob([uInt8Array], {type:"application/octet-stream"});
        // }

        return new Blob([uInt8Array], { type: contentType });
    },

    blob2URL: function blob2URL(blob) {
        return URL.createObjectURL(blob);
    },

    imagesPngContext2URL: function imagesPngContext2URL(code) {
        var self = this;
        return self.blob2URL(self.blob2URL(code));
    },

    downloadFile: function downloadFile(fileName, content, blobs) {
        var self = this;

        var aLink = document.createElement('a');
        aLink.style.display = 'none';
        var blob = content ? self.base64Img2Blob(content) : blobs; //new Blob([content]);

        // if(typeof FileReader === 'object'){
        //     var reader = new FileReader();
        //
        //     reader.onloadend = function () {
        //         var url = reader.result;
        //         url = url.replace(/^data:[^;]*;/, 'data:attachment/file;');
        //         window.location.href = url;
        //     };
        //
        //     reader.readAsDataURL(blob);
        //     return;
        // }

        var blobUrl;
        aLink.download = fileName;
        aLink.href = blobUrl = self.blob2URL(blob);
        aLink.rel = 'noopener';
        // if(emedia.isSafari){
        //     aLink.href = aLink.href.replace(/^data:[^;]*;/, 'data:attachment/file;');
        // }

        var evt = document.createEvent("HTMLEvents");
        evt.initEvent("click", false, false); //initEvent 不加后两个参数在FF下会报错
        aLink.dispatchEvent(evt);

        document.body.appendChild(aLink);
        aLink.click();
        aLink.parentNode.removeChild(aLink);

        setTimeout(function () {
            URL.revokeObjectURL && URL.revokeObjectURL(blobUrl);
        }, 40000);
    },

    videoCaptureBase64Context2URL: function videoCaptureBase64Context2URL(videoObj) {
        var self = this;
        return self.imagesPngContext2URL(self.getCaptureBase64Context(videoObj));
    },

    getCaptureBase64Context: function getCaptureBase64Context(videoObj) {
        var canvas = document.createElement("canvas");
        var id = canvas.id = "__capture_video_" + new Date().getTime();

        canvas.width = videoObj.videoWidth;
        canvas.height = videoObj.videoHeight;

        var canvas2dContext = canvas.getContext('2d');
        canvas2dContext.drawImage(videoObj, 0, 0, canvas.width, canvas.height);

        var base64 = canvas.toDataURL('images/png');
        //console.log(base64);

        return base64;
    },

    captureVideo: function captureVideo(videoObj, storeLocal, filename) {
        var self = this;

        var base64 = self.getCaptureBase64Context(videoObj);

        if (storeLocal) {
            filename = filename || "capture_" + new Date().getTime();
            self.downloadFile(filename, base64);
            //window.location.href = base64;

            // var iframe = document.createElement("iframe");
            // iframe.id = "__capture_video_pic_dl_iframe_" + (new Date().getTime());
            // iframe.style.display = "none";
            //
            // //document.body.appendChild(iframe);
            //
            // iframe.src = base64;
            // //iframe.contentWindow.location.href = URL.createObjectURL(base64);
            //
            // setTimeout(function () {
            //     //document.body.removeChild(iframe);
            // }, 50);
        }

        return base64;
    },

    capturePictureRemote: function capturePictureRemote(streamId, rspBase64Pic, success, fail) {
        var self = this;

        self.__assertCurrent();
        var attendee = self.current;

        var linkedStream = attendee._linkedStreams[streamId];
        if (!linkedStream || linkedStream.located()) {
            _logger.error("not exsits or locate, not connect", streamId);
            throw streamId + " not exsits or locate, not connect";
        }

        var arg = {
            op2: 20,
            streamId: streamId,
            pic: 1,
            rspBase64Pic: rspBase64Pic === true
        };

        var message = attendee.newMessage({
            op: 1002,
            memId: linkedStream.owner.id,
            arg: JSON.stringify(arg),
            _reqOps: [100205]
        });

        attendee.postMessage(message, function (rsp) {
            if (rsp.result != 0) {
                var _evt = new __event.RemoteControlFail({ stream: linkedStream, failed: rsp.result, cause: rsp.msg, type: "capture_control" });
                attendee.onEvent(_evt);
                fail && fail(_evt);

                return;
            } else {
                if (!rspBase64Pic) {
                    success && success();
                    return;
                }

                if (!rsp.arg) {
                    fail && fail(new __event.RemoteControlFail({ stream: linkedStream, failed: rsp.result, cause: "Not found base64 pic" }));
                    return;
                }

                var arg = JSON.parse(rsp.arg);
                success && success(arg.pic);
            }
        });
    },

    zoomRemote: function zoomRemote(streamId, multiples, fail, success) {
        var self = this;

        self.__assertCurrent();
        var attendee = self.current;

        var linkedStream = attendee._linkedStreams[streamId];
        if (!linkedStream || linkedStream.located()) {
            _logger.error("not exsits or locate, not connect", streamId);
            throw streamId + " not exsits or locate, not connect";
        }

        linkedStream._zoom || (linkedStream._zoom = 1);

        var _zoom = linkedStream._zoom * multiples;
        if (_zoom < 1) {
            return;
        }

        linkedStream._zoom = _zoom;

        var arg = {
            op2: 20,
            streamId: streamId,
            zoom: Math.round(_zoom * 10000)
        };

        var message = attendee.newMessage({
            op: 1002,
            memId: linkedStream.owner.id,
            arg: JSON.stringify(arg),
            _reqOps: [100201]
        });

        attendee.postMessage(message, function (rsp) {
            if (rsp.result != 0) {
                var _evt = new __event.RemoteControlFail({ stream: linkedStream, failed: rsp.result, cause: rsp.msg, type: "zoom_control" });
                attendee.onEvent(_evt);
                fail && fail(_evt);

                return;
            }

            success && success();
        });
    },

    _getPosition: function getPosition(obj) {
        var topValue = 0,
            leftValue = 0;
        while (obj) {
            leftValue += obj.offsetLeft;
            topValue += obj.offsetTop;
            obj = obj.offsetParent;
        }

        return { clientX: leftValue, clientY: topValue };
    },

    eventXYAtMedia: function eventXYAtMedia(eventXY, videoTag) {
        var videoXY = _util.getDomPageRect(videoTag);

        var videoWidth = videoXY.width,
            videoHeight = videoXY.height;
        var mediaWidth = videoTag.videoWidth,
            mediaHeight = videoTag.videoHeight;

        if (mediaHeight / mediaWidth > videoHeight / videoWidth) {
            var t = mediaWidth / mediaHeight;
            mediaHeight = videoHeight;
            mediaWidth = mediaHeight * t;
        } else {
            var t = mediaHeight / mediaWidth;
            mediaWidth = videoWidth;
            mediaHeight = mediaWidth * t;
        }

        var clickXY = eventXY;

        var isRadioX, isRadioY;
        if (isRadioX = _util.isFloat(clickXY.x)) {
            //比率
            clickXY.x = clickXY.x * videoWidth;
        }
        if (isRadioY = _util.isFloat(clickXY.y)) {
            //比率
            clickXY.y = clickXY.y * videoHeight;
        }

        if (Math.abs(clickXY.x) < (videoWidth - mediaWidth) / 2 || videoWidth - Math.abs(clickXY.x) < (videoWidth - mediaWidth) / 2) {
            return;
        }
        if (Math.abs(clickXY.y) < (videoHeight - mediaHeight) / 2 || videoHeight - Math.abs(clickXY.y) < (videoHeight - mediaHeight) / 2) {
            return;
        }

        clickXY.x = clickXY.x < 0 ? Math.floor(clickXY.x + (videoWidth - mediaWidth) / 2) : Math.floor(clickXY.x - (videoWidth - mediaWidth) / 2);
        clickXY.y = clickXY.y < 0 ? Math.floor(clickXY.y + (videoHeight - mediaHeight) / 2) : Math.floor(clickXY.y - (videoHeight - mediaHeight) / 2);

        if (isRadioX) {
            clickXY.x = clickXY.x / mediaWidth;
        }
        if (isRadioY) {
            clickXY.y = clickXY.y / mediaHeight;
        }

        return { x: clickXY.x, y: clickXY.y, width: mediaWidth, height: mediaHeight };
    },

    eventXYAtVideo: function eventXYAtVideo(mediaXY, videoTag) {
        var videoXY = _util.getDomPageRect(videoTag);

        var videoWidth = videoXY.width,
            videoHeight = videoXY.height;
        var mediaWidth = videoTag.videoWidth,
            mediaHeight = videoTag.videoHeight;

        if (mediaHeight / mediaWidth > videoHeight / videoWidth) {
            var t = mediaWidth / mediaHeight;
            mediaHeight = videoHeight;
            mediaWidth = mediaHeight * t;
        } else {
            var t = mediaHeight / mediaWidth;
            mediaWidth = videoWidth;
            mediaHeight = mediaWidth * t;
        }

        var isRadioX, isRadioY;
        if (isRadioX = _util.isFloat(mediaXY.x)) {
            //比率
            mediaXY.x = mediaXY.x * mediaWidth;
        }
        if (isRadioY = _util.isFloat(mediaXY.y)) {
            //比率
            mediaXY.y = mediaXY.y * mediaHeight;
        }

        mediaXY.x = mediaXY.x < 0 ? Math.floor(mediaXY.x - (videoWidth - mediaWidth) / 2) : Math.floor(mediaXY.x + (videoWidth - mediaWidth) / 2);
        mediaXY.y = mediaXY.y < 0 ? Math.floor(mediaXY.y - (videoHeight - mediaHeight) / 2) : Math.floor(mediaXY.y + (videoHeight - mediaHeight) / 2);

        if (isRadioX) {
            mediaXY.x = mediaXY.x / videoWidth;
        }
        if (isRadioY) {
            mediaXY.y = mediaXY.y / videoHeight;
        }

        return mediaXY;
    },

    getClickXY: function getClickXY(videoTag, clickEvent) {
        var self = this;

        var e = clickEvent || window.event;
        var scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
        var scrollY = document.documentElement.scrollTop || document.body.scrollTop;
        var x = e.pageX || e.clientX + scrollX;
        var y = e.pageY || e.clientY + scrollY;

        var xy = self._getPosition(videoTag);

        _logger.info("Video tag position ", xy.clientX, ":", xy.clientY);

        var mediaWidth = videoTag.videoWidth;
        var mediaHeight = videoTag.videoHeight;

        if (mediaHeight / mediaWidth > videoTag.offsetHeight / videoTag.offsetWidth) {
            var t = mediaWidth / mediaHeight;
            mediaHeight = videoTag.offsetHeight;
            mediaWidth = mediaHeight * t;

            xy.clientX += (videoTag.offsetWidth - mediaWidth) / 2;
        } else {
            var t = mediaHeight / mediaWidth;
            mediaWidth = videoTag.offsetWidth;
            mediaHeight = mediaWidth * t;

            xy.clientY += (videoTag.offsetHeight - mediaHeight) / 2;
        }
        _logger.info("Media position ", xy.clientX, ":", xy.clientY);
        _logger.info("Media xy ", mediaWidth, ":", mediaHeight);
        _logger.info("Click position ", x, ":", y);

        return {
            mediaWidth: mediaWidth,
            mediaHeight: mediaHeight,
            x: x - xy.clientX,
            y: y - xy.clientY
        };
    },

    focusExpoRemote: function focusExpoRemote(streamId, videoTag, clickEvent, fail, success) {
        var self = this;

        var e = clickEvent || window.event;
        var scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
        var scrollY = document.documentElement.scrollTop || document.body.scrollTop;
        var x = e.pageX || e.clientX + scrollX;
        var y = e.pageY || e.clientY + scrollY;

        var xy = self._getPosition(videoTag);

        _logger.info("Video tag position ", xy.clientX, ":", xy.clientY);

        var mediaWidth = videoTag.videoWidth;
        var mediaHeight = videoTag.videoHeight;

        if (mediaHeight / mediaWidth > videoTag.offsetHeight / videoTag.offsetWidth) {
            var t = mediaWidth / mediaHeight;
            mediaHeight = videoTag.offsetHeight;
            mediaWidth = mediaHeight * t;

            xy.clientX += (videoTag.offsetWidth - mediaWidth) / 2;
        } else {
            var t = mediaHeight / mediaWidth;
            mediaWidth = videoTag.offsetWidth;
            mediaHeight = mediaWidth * t;

            xy.clientY += (videoTag.offsetHeight - mediaHeight) / 2;
        }
        _logger.info("Media position ", xy.clientX, ":", xy.clientY);
        _logger.info("Media xy ", mediaWidth, ":", mediaHeight);
        _logger.info("Click position ", x, ":", y);

        self._focusExpo(streamId, mediaWidth, mediaHeight, x - xy.clientX, y - xy.clientY, fail, success);
    },

    _focusExpo: function _focusExpo(streamId, width, height, x, y, fail, success) {
        var self = this;

        if (x <= 0 || x > width) {
            return;
        }
        if (y <= 0 || y > height) {
            return;
        }

        self.__assertCurrent();
        var attendee = self.current;

        var linkedStream = attendee._linkedStreams[streamId];
        if (!linkedStream || linkedStream.located()) {
            _logger.error("not exsits or locate, not connect", streamId);
            throw streamId + " not exsits or locate, not connect";
        }

        var arg = {
            op2: 20,
            streamId: streamId,
            focus: 1,
            expo: 1,
            x: width === 0 ? 0 : Math.round(x * 10000 / width),
            y: height === 0 ? 0 : Math.round(y * 10000 / height)
        };

        var message = attendee.newMessage({
            op: 1002,
            memId: linkedStream.owner.id,
            arg: JSON.stringify(arg),
            _reqOps: [100202, 100203]
        });

        attendee.postMessage(message, function (rsp) {
            if (rsp.result != 0) {
                var _evt = new __event.RemoteControlFail({ stream: linkedStream, failed: rsp.result, cause: rsp.msg, type: "focus_expo_control" });
                attendee.onEvent(_evt);
                fail && fail(_evt);

                return;
            } else {
                success && success();
            }
        });
    },

    _republish: function _republish(pubS, success, error) {
        _logger.info("Republish stream. it = ", pubS.id);

        var self = this;

        var webrtc;
        if (pubS.id) {
            var rtcId = self.current.__getWebrtcFor(pubS.id);
            rtcId && self.current.closeWebrtc(rtcId, true);

            webrtc = self.current._getWebrtc(pubS.id);
        }

        var _pubS;

        // if(emedia.isSafari){
        //     emedia.enableAudioTracks(false);
        //     emedia.enableVideoTracks(false);
        // }

        switch (pubS.type) {
            case 0:
                //emedia.isSafari || emedia.stopTracks(pubS._localMediaStream);
                emedia.stopTracks(pubS._localMediaStream);
                _pubS = new self.AVPubstream(pubS);

                break;
            case 1:
                //emedia.isSafari || emedia.stopAndRemoveAudioTracks(pubS._localMediaStream);
                emedia.stopAndRemoveAudioTracks(pubS._localMediaStream);
                _pubS = new self.ShareDesktopPubstream(pubS);

                break;
            case 2:
                //emedia.isSafari || emedia.stopTracks(pubS._localMediaStream);
                emedia.stopTracks(pubS._localMediaStream);
                _pubS = new self.AudioMixerPubstream(pubS);

                break;
        }

        setTimeout(function () {
            self.openUserMedia(_pubS).then(function () {
                pubS.localStream = _pubS.localStream;

                pubS.isRepublished = true;

                pubS.optimalVideoCodecs = pubS.optimalVideoCodecs || webrtc && webrtc.optimalVideoCodecs;
                self.push(pubS, success, error);
            }, error);
        }, 100);

        // if(emedia.isSafari){
        //     setTimeout(function () {
        //         switch(pubS.type) {
        //             case 0:
        //                 emedia.stopTracks(pubS._localMediaStream);
        //                 break;
        //             case 1:
        //                 emedia.stopAndRemoveAudioTracks(pubS._localMediaStream);
        //                 break;
        //             case 2:
        //                 emedia.stopTracks(pubS._localMediaStream);
        //                 break;
        //         }
        //     }, 1400);
        // }
    },

    chanageCamera: function chanageCamera(pubS, error, success) {
        var self = this;

        if (typeof pubS === 'string') {
            //id
            pubS = self.current._cacheStreams[pubS];
        } else if (pubS.id) {
            pubS = self.current._cacheStreams[pubS.id];
        }

        if (pubS.voff) {
            _logger.warn("Stream id = ", pubS.id, " voff, do not chanage camera.");
            return;
        }

        self.getMediaDevices("videoinput", function (devices) {
            if (devices.length <= 1) {
                _logger.warn("Only video input. not chanage");
                return;
            }

            var cameraIndex = pubS._cameraIndex === null || pubS._cameraIndex === undefined ? 0 : pubS._cameraIndex;
            while (cameraIndex < devices.length) {
                var lastDevice = devices[cameraIndex];
                cameraIndex = (cameraIndex + 1) % devices.length;

                var device = devices[cameraIndex];

                var videoTracks = pubS._localMediaStream.getVideoTracks();
                if (!videoTracks || videoTracks.length === 0 || device.label != videoTracks[0].label) {
                    break;
                }
            }

            var device = devices[cameraIndex];
            var deviceInfoLabel = device.label;

            _logger.warn("Stream ", pubS.id, lastDevice.label, ">>", deviceInfoLabel);

            pubS._cameraIndex = cameraIndex;

            pubS.constaints || (pubS.constaints = {});
            pubS.constaints.video = _typeof(pubS.constaints.video) === "object" ? pubS.constaints.video : {};
            pubS.constaints.video.deviceId = { exact: device.deviceId };

            self._republish(pubS, function (mediaStream) {
                success && success(mediaStream);
            }, function (_evt) {
                if (_evt instanceof emedia.event.OpenMediaError) {
                    //设备可能不支持，比如 没有摄像头，或 被禁止访问摄像头
                    pubS.constaints.video = false;
                }

                error && error(_evt);
            });
        }, error);
    },

    _republishByVideoConstaints: function _republishByVideoConstaints(pubS, videoConstaints, error, success) {
        var self = this;

        if (typeof pubS === 'string') {
            //id
            pubS = self.current._cacheStreams[pubS];
        }

        pubS = _.extend({}, pubS);

        var oldVoff = pubS.voff;
        var voff = pubS.voff = videoConstaints ? 0 : 1;

        function updateAndDisabled() {
            if (voff === oldVoff) {
                _logger.info("pubstream voff not chanage.");
                return;
            }
            emedia.enableVideoTracks(pubS.getMediaStream(), !voff);
            self.current && self.current.voff(pubS, voff);
        }

        if (_.isObject(videoConstaints) && !_.isEqual(pubS.constaints.video, videoConstaints) || videoConstaints && !pubS.constaints.video) {
            pubS.constaints.video = videoConstaints;
            self._republish(pubS, function (mediaStream) {
                updateAndDisabled();
                success && success(mediaStream);
            }, function (_evt) {
                if (_evt instanceof emedia.event.OpenMediaError) {
                    //设备可能不支持，比如 没有摄像头，或 被禁止访问摄像头
                    pubS.constaints.video = false;
                }

                error && error(_evt);
            });

            return;
        }

        updateAndDisabled();
        success && success(pubS.getMediaStream());
    },

    voff: function voff(pubS, _voff, error, success) {
        var self = this;

        if (typeof pubS === 'string') {
            //id
            pubS = self.current._cacheStreams[pubS];
        }

        var oldVoff = pubS.voff;
        _voff = _voff ? 1 : 0;
        pubS.voff = _voff;

        function updateAndDisabled() {
            if (_voff == oldVoff) {
                _logger.info("pubstream voff not chanage.");
                return;
            }
            emedia.enableVideoTracks(pubS.getMediaStream(), !_voff);
            self.current && self.current.voff(pubS, _voff);
        }

        if (!_voff && pubS.constaints && !pubS.constaints.video) {
            //error && error("When pub. only audio, voff invalidate");
            //throw "When pub. only audio, voff invalidate";

            var preVideo = pubS.constaints.video;

            pubS.constaints.video = true;
            self._republish(pubS, function (mediaStream) {
                updateAndDisabled();
                success && success(mediaStream);
            }, function (_evt) {
                if (_evt instanceof emedia.event.OpenMediaError) {
                    //设备可能不支持，比如 没有摄像头，或 被禁止访问摄像头
                    pubS.constaints.video = preVideo;
                }

                error && error(_evt);
            });

            return;
        }

        updateAndDisabled();
        success && success(pubS.getMediaStream());
    },

    aoff: function aoff(pubS, _aoff, error, success) {
        var self = this;

        if (typeof pubS === 'string') {
            //id
            pubS = self.current._cacheStreams[pubS];
        }

        var oldAoff = pubS.aoff;
        _aoff = _aoff ? 1 : 0;
        pubS.aoff = _aoff;

        function updateAndDisabled() {
            if (_aoff == oldAoff) {
                _logger.info("pubstream aoff not chanage.");
                return;
            }

            emedia.enableAudioTracks(pubS.getMediaStream(), !_aoff);
            self.current && self.current.aoff(pubS, _aoff);
        }

        if (!_aoff && pubS.constaints && !pubS.constaints.audio) {
            // error && error("When pub. only video, aoff invalidate");
            // throw "When pub. only video, aoff invalidate";

            var preAudio = pubS.constaints.audio;

            pubS.constaints.audio = true;
            self._republish(pubS, function (mediaStream) {
                updateAndDisabled();
                success && success(mediaStream);
            }, function (_evt) {
                if (_evt instanceof emedia.event.OpenMediaError) {
                    //设备可能不支持，比如 没有摄像头，或 被禁止访问摄像头
                    pubS.constaints.audio = preAudio;
                }

                error && error(_evt);
            });

            return;
        }

        updateAndDisabled();
        success && success(pubS.getMediaStream());
    },

    iceing: function iceing(streamId) {
        var self = this;

        return _util.isPlainObject(self.current._linkedStreams[streamId]);
    },

    recording: function recording(streamId) {
        var self = this;

        return _util.isPlainObject(self.current._records[streamId]);
    },

    startRecord: function startRecord(streamId, callback) {
        var self = this;

        var _stream = self.current._linkedStreams[streamId];
        if (!_stream) {
            _logger.error("not at linked streams", streamId);
            throw streamId + " not at linked streams";
        }
        if (!_stream._webrtc) {
            callback && callback(false);
        }

        self.current.startRecord(_stream, callback);
    },

    stopRecord: function stopRecord(streamId, callback) {
        var self = this;

        var _stream = self.current._records[streamId];
        if (!_stream) {
            _logger.error("not at recording streams", streamId);
            throw streamId + " not at recording streams";
        }

        self.current.stopRecord(_stream, callback);
    },

    getCurrentMembers: function getCurrentMembers() {
        var self = this;
        return self.current.getCurrentMembers();
    },

    _onCapturePicture: function _onCapturePicture(evt) {
        var self = this;

        var rspBase64Pic = evt.arg.rspBase64Pic;
        var streamId = evt.arg.streamId;
        var stream = self.current._cacheStreams[streamId];

        var base64;
        if (rspBase64Pic) {
            var htmlVideo;
            if (typeof self.getHTMLVideo !== "function" || !(htmlVideo = self.getHTMLVideo(streamId))) {
                _logger.warn("Not support capture picture. caused by htmlVideo not found");
                return;
            }

            base64 = self.getCaptureBase64Context(htmlVideo);
        } else {
            if (typeof self.onCapturePicture !== "function") {
                _logger.warn("Not support capture picture. caused by onCapturePicture not found");
                return;
            }
            self.onCapturePicture(stream);
        }

        var message = self.current.newMessage({
            op: 1001,
            tsxId: evt.tsxId,
            memId: evt.memId,
            arg: JSON.stringify(base64 ? { pic: base64 } : {}),
            result: 0
        });

        self.current.postMessage(message, function (rsp) {
            _logger.warn("Send remote control onCapturePicture response. the result = ", rsp.result, rsp.msg || "");
        });

        return true;
    },

    // _onRemotePannelControl: function (evt) {
    //
    // },

    newSession: function newSession(attendee, ticket) {
        var self = this;

        var ExtendSession = self.Session || Session;
        var session = new ExtendSession({
            ticket: ticket,
            owner: attendee,

            onTcklC: function onTcklC(evt) {
                attendee.onTcklC(evt.rtcId, evt.cands);
            },
            onAcptC: function onAcptC(evt) {
                attendee.onAcptC(evt.rtcId, evt.sdp, evt.cands);
            },
            onAnsC: function onAnsC(evt) {
                attendee.onAnsC(evt.rtcId, evt.sdp, evt.cands);
            },
            onTermC: function onTermC(evt) {
                //self.onTermC(me, evt);
                _logger.info("Server termc rtc: ", evt.rtcId, evt.message || evt.msg);

                if (evt.endReason === 21 || evt.endReason === 22) {
                    _util.forEach(attendee._cacheStreams, function (sid, _stream) {
                        if (_stream.rtcId === evt.rtcId) {
                            var _event;
                            if (evt.endReason === 21) {
                                _event = new emedia.event.SwitchVCodes({ stream: _stream, useVCodes: evt.useVCodes });
                            } else {
                                _event = new emedia.event.SubFailNotSupportVCodes({ stream: _stream });
                            }

                            attendee.onEvent(_event);
                        }
                    });
                } else {
                    attendee.closeWebrtc(evt.rtcId, false, true);
                }
            },
            onEnter: function onEnter(evt) {
                attendee.onEnter(evt.cver, evt.mem);
            },
            onExit: function onExit(evt) {
                attendee.onExit(evt.cver, evt.memId, evt.reason || 0);
            },
            onPub: function onPub(evt) {
                attendee.onPub(evt.cver, evt.memId, evt.pubS);
            },
            onUnpub: function onUnpub(evt) {
                attendee.onUnpub(evt.cver, evt.memId, evt.pubSId);
            },
            onMems: function onMems(evt) {},
            onClose: function onClose(evt) {
                attendee.onClose(evt.cver, evt.confrId);
            },
            onEvent: function onEvent(evt) {
                attendee.onEvent(evt);
            },
            onStreamControl: function onStreamControl(evt) {
                attendee.onStreamControl(evt.cver, evt.streamId, evt.voff, evt.aoff, evt.sver);
            },
            onRoleUpdate: function onRoleUpdate(evt) {
                attendee._onRoleUpdate(evt.role, evt.roleToken);
            },
            onRemoteControl: function onRemoteControl(evt) {
                if (typeof evt.arg === 'string') {
                    evt.arg = JSON.parse(evt.arg);
                }
                if (evt.arg.op2 === 20 && evt.arg.pic && self._onCapturePicture.call(self, evt)) {
                    return;
                }
                if (evt.arg.op2 === 30 && self._onRemotePannelControl) {
                    try {
                        self._onRemotePannelControl.call(self, evt);
                        return;
                    } catch (e) {
                        _logger.warn(e);
                    }
                }

                _logger.warn("Not support remote control");

                var message = attendee.newMessage({
                    op: 1001,
                    tsxId: evt.tsxId,
                    memId: evt.memId,
                    arg: JSON.stringify(evt.arg),
                    result: evt && evt.arg && evt.arg.op2 === 30 ? -405 : -507,
                    msg: "Not support the remote control."
                });

                attendee.postMessage(message, function (rsp) {
                    _logger.warn("Send remote control response. the result = ", rsp.result, rsp.msg || "");
                });
            },
            onRecvRemoteMessage: function onRecvRemoteMessage(evt) {
                attendee._onRecvRemoteMessage && attendee._onRecvRemoteMessage(evt.memId, evt.arg, evt);
            }
        });

        return session;
    },

    _judgeTalking: function _judgeTalking(meter) {
        if (!meter) {
            return false;
        }

        return meter.instant >= emedia.config.judgeTalkingByInstantGE;
    },

    graffitiVideo: function graffitiVideo(streamId, videoTag, canvasTag) {
        var self = this;

        var easemobStream = self.getStreamById(streamId);

        var mediaStream = new MediaStream();
        mediaStream._located = true;

        easemobStream._localMediaStream.getAudioTracks().forEach(function (track) {
            mediaStream.addTrack(track);
        });

        var drawStream = canvasTag.captureStream(25);
        drawStream.getVideoTracks().forEach(function (track) {
            mediaStream.addTrack(track);
        });

        videoTag.srcObject = mediaStream;

        easemobStream.localStream = mediaStream;
        easemobStream.isRepublished = true;
        easemobStream.optimalVideoCodecs = easemobStream.optimalVideoCodecs;
        self.push(easemobStream);
    },

    resetCanvas: function resetCanvas(canvasTag) {
        var set;
        if (arguments.length > 1) {
            for (var i = 0; i < arguments.length; i++) {
                set = arguments[i];

                typeof set === "function" && set(canvasTag);
                typeof set !== "function" && _util.isPlainObject(set) && _util.forEach(set, function (key, value) {
                    _logger.debug("Canvas set ", key, " = ", value);
                    canvasTag.setAttribute(key, value);
                });
            }
        }
    },

    _random: function _random(c) {
        return Math.floor(Math.random() * c);
    },
    requestFrame: function requestFrame(stream, millis) {
        var self = this;

        var _cacheStream;
        if (typeof stream === "string") {
            _cacheStream = this.current._cacheStreams[stream];
        } else if (stream.id) {
            _cacheStream = this.current._cacheStreams[stream.id];
        } else {
            return;
        }

        if (!_cacheStream) {
            return;
        }

        function _requestFrame() {
            _cacheStream.requestFrame();

            if (_cacheStream.canvas) {
                var redraw = DefaultMouseTrack.prototype.redraw.bind({ _canvasContext: _cacheStream.canvas.getContext("2d") });
                //_logger.debug(self._random(255));
                redraw(3, 3);
            }
        }

        if (!millis) {
            _requestFrame();
            return;
        }

        setTimeout(function () {
            _requestFrame();
            self.requestFrame(_cacheStream, millis);
        }, millis);
    },

    graffitiCanvas: function graffitiCanvas(withVoice, canvasTag) {
        if (_util.targetDOM(withVoice)) {
            canvasTag = withVoice;
            withVoice = false;
        }

        var self = this;

        var pubS = new self.ShareDesktopPubstream({
            voff: 0,
            aoff: withVoice ? 0 : 1
        });

        canvasTag || (canvasTag = document.createElement("canvas"));

        //canvasTag.getContext("2d", {willReadFrequently: true}); //Fixed: Firefox captureStream  NS_ERROR_NOT_INITIALIZED
        canvasTag.getContext("2d");
        pubS.canvas = canvasTag;

        var diy = function diy() {};
        diy.prototype.setCanvas = function (set) {
            this.canvasTag = canvasTag;
            self.resetCanvas(canvasTag, set);

            return this;
        };

        diy.prototype.push = function (frameRate, _onpushed) {
            var diy = this;
            diy._push(frameRate, _onpushed);
        };
        diy.prototype._push = function (frameRate, _onpushed) {
            if (typeof frameRate === "function") {
                _onpushed = frameRate;
                frameRate = undefined;
            }

            canvasTag.captureStream && (canvasTag.captureStream.enabled = true);
            var drawStream = canvasTag.captureStream(frameRate || 25);

            function pushed(stream) {
                stream.canvas = canvasTag;
                _onpushed && _onpushed(stream, canvasTag, drawStream);

                if (withVoice) {
                    //发送一帧视频
                    stream.requestFrame();
                }
            }

            function pub(pubS, pushed) {
                var mediaStream = new MediaStream();
                mediaStream._located = true;

                pubS._localMediaStream && pubS._localMediaStream.getAudioTracks().forEach(function (track) {
                    mediaStream.addTrack(track);
                });

                drawStream.getVideoTracks().forEach(function (track) {
                    mediaStream.addTrack(track);
                });

                pubS._localMediaStream = mediaStream;
                pubS.localStream = mediaStream;
                self.push(pubS, pushed);
            }

            if (withVoice) {
                self.__getUserMedia({ audio: true }, function success(_user, stream) {
                    pubS._localMediaStream = stream;
                    pub(pubS, pushed);
                });
            } else {
                pub(pubS, pushed);
            }

            return this;
        };

        return new diy();
    },

    blobRecorder: function blobRecorder(mediaStream, options, handleDataAvailable, handleStop) {
        var self = this;

        if (_util.targetDOM(mediaStream)) {
            mediaStream = mediaStream.srcObject;
        }

        options || (options = { mimeType: 'video/webm;codecs=vp9' });
        if (!MediaRecorder.isTypeSupported(options.mimeType)) {
            _logger.info(options.mimeType, ' is not Supported');
            options = { mimeType: 'video/webm;codecs=vp8' };
            if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                _logger.info(options.mimeType, ' is not Supported');
                options = { mimeType: 'video/webm' };
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    _logger.info(options.mimeType, ' is not Supported');
                    options = { mimeType: '' };
                }
            }
        }

        try {
            var mediaRecorder = new MediaRecorder(mediaStream, options);
        } catch (e) {
            _logger.error('Exception while creating MediaRecorder: ', e);
            //alert('Exception while creating MediaRecorder: ' + e + '. mimeType: ' + options.mimeType);
            return;
        }
        var recordedBlobs = [];
        mediaRecorder.onstop = handleStop || function handleStop(event) {
            _logger.info('Recorder stopped: ', event);
        };
        mediaRecorder.ondataavailable = handleDataAvailable || function (event) {
            if (event.data && event.data.size > 0) {
                recordedBlobs.push(event.data);
            }
        };
        // mediaRecorder.start(10); // collect 10ms of data
        // _logger.error('MediaRecorder started', mediaRecorder);

        function BlobRecorder() {
            this.blobs = recordedBlobs;
        }
        BlobRecorder.prototype.start = function (secornds) {
            mediaRecorder.start(secornds);
        };
        BlobRecorder.prototype.stop = function () {
            mediaRecorder.stop();
        };
        BlobRecorder.prototype.playurl = function (options) {
            var superBuffer = new Blob(this.blobs, options || { type: 'video/webm' });
            return window.URL.createObjectURL(superBuffer);
        };
        BlobRecorder.prototype.download = function (filename, options) {
            var blobs = new Blob(this.blobs, options || { type: 'video/webm' });
            self.downloadFile(filename, undefined, blobs);
        };

        return new BlobRecorder();
    }
});

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.9.1
//     http://underscorejs.org
//     (c) 2009-2018 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` (`self`) in the browser, `global`
  // on the server, or `this` in some virtual machines. We use `self`
  // instead of `window` for `WebWorker` support.
  var root = typeof self == 'object' && self.self === self && self ||
            typeof global == 'object' && global.global === global && global ||
            this ||
            {};

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype;
  var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

  // Create quick reference variables for speed access to core prototypes.
  var push = ArrayProto.push,
      slice = ArrayProto.slice,
      toString = ObjProto.toString,
      hasOwnProperty = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var nativeIsArray = Array.isArray,
      nativeKeys = Object.keys,
      nativeCreate = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for their old module API. If we're in
  // the browser, add `_` as a global object.
  // (`nodeType` is checked to ensure that `module`
  // and `exports` are not HTML elements.)
  if (typeof exports != 'undefined' && !exports.nodeType) {
    if (typeof module != 'undefined' && !module.nodeType && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.9.1';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      // The 2-argument case is omitted because we’re not using it.
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  var builtinIteratee;

  // An internal function to generate callbacks that can be applied to each
  // element in a collection, returning the desired result — either `identity`,
  // an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value) && !_.isArray(value)) return _.matcher(value);
    return _.property(value);
  };

  // External wrapper for our callback generator. Users may customize
  // `_.iteratee` if they want additional predicate/iteratee shorthand styles.
  // This abstraction hides the internal-only argCount argument.
  _.iteratee = builtinIteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // Some functions take a variable number of arguments, or a few expected
  // arguments at the beginning and then a variable number of values to operate
  // on. This helper accumulates all remaining arguments past the function’s
  // argument length (or an explicit `startIndex`), into an array that becomes
  // the last argument. Similar to ES6’s "rest parameter".
  var restArguments = function(func, startIndex) {
    startIndex = startIndex == null ? func.length - 1 : +startIndex;
    return function() {
      var length = Math.max(arguments.length - startIndex, 0),
          rest = Array(length),
          index = 0;
      for (; index < length; index++) {
        rest[index] = arguments[index + startIndex];
      }
      switch (startIndex) {
        case 0: return func.call(this, rest);
        case 1: return func.call(this, arguments[0], rest);
        case 2: return func.call(this, arguments[0], arguments[1], rest);
      }
      var args = Array(startIndex + 1);
      for (index = 0; index < startIndex; index++) {
        args[index] = arguments[index];
      }
      args[startIndex] = rest;
      return func.apply(this, args);
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var shallowProperty = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  var has = function(obj, path) {
    return obj != null && hasOwnProperty.call(obj, path);
  }

  var deepGet = function(obj, path) {
    var length = path.length;
    for (var i = 0; i < length; i++) {
      if (obj == null) return void 0;
      obj = obj[path[i]];
    }
    return length ? obj : void 0;
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object.
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = shallowProperty('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  var createReduce = function(dir) {
    // Wrap code that reassigns argument variables in a separate function than
    // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
    var reducer = function(obj, iteratee, memo, initial) {
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      if (!initial) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    };

    return function(obj, iteratee, memo, context) {
      var initial = arguments.length >= 3;
      return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
    };
  };

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey;
    var key = keyFinder(obj, predicate, context);
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = restArguments(function(obj, path, args) {
    var contextPath, func;
    if (_.isFunction(path)) {
      func = path;
    } else if (_.isArray(path)) {
      contextPath = path.slice(0, -1);
      path = path[path.length - 1];
    }
    return _.map(obj, function(context) {
      var method = func;
      if (!method) {
        if (contextPath && contextPath.length) {
          context = deepGet(context, contextPath);
        }
        if (context == null) return void 0;
        method = context[path];
      }
      return method == null ? method : method.apply(context, args);
    });
  });

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value != null && value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(v, index, list) {
        computed = iteratee(v, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = v;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value != null && value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(v, index, list) {
        computed = iteratee(v, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = v;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection.
  _.shuffle = function(obj) {
    return _.sample(obj, Infinity);
  };

  // Sample **n** random values from a collection using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);
    var length = getLength(sample);
    n = Math.max(Math.min(n, length), 0);
    var last = length - 1;
    for (var index = 0; index < n; index++) {
      var rand = _.random(index, last);
      var temp = sample[index];
      sample[index] = sample[rand];
      sample[rand] = temp;
    }
    return sample.slice(0, n);
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    var index = 0;
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, key, list) {
      return {
        value: value,
        index: index++,
        criteria: iteratee(value, key, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior, partition) {
    return function(obj, iteratee, context) {
      var result = partition ? [[], []] : {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (has(result, key)) result[key]++; else result[key] = 1;
  });

  var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (_.isString(obj)) {
      // Keep surrogate pair characters together
      return obj.match(reStrSymbol);
    }
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = group(function(result, value, pass) {
    result[pass ? 0 : 1].push(value);
  }, true);

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null || array.length < 1) return n == null ? void 0 : [];
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null || array.length < 1) return n == null ? void 0 : [];
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, Boolean);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, output) {
    output = output || [];
    var idx = output.length;
    for (var i = 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        // Flatten current level of array or arguments object.
        if (shallow) {
          var j = 0, len = value.length;
          while (j < len) output[idx++] = value[j++];
        } else {
          flatten(value, shallow, strict, output);
          idx = output.length;
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = restArguments(function(array, otherArrays) {
    return _.difference(array, otherArrays);
  });

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // The faster algorithm will not work with an iteratee if the iteratee
  // is not a one-to-one function, so providing an iteratee will disable
  // the faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted && !iteratee) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = restArguments(function(arrays) {
    return _.uniq(flatten(arrays, true, true));
  });

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      var j;
      for (j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = restArguments(function(array, rest) {
    rest = flatten(rest, true, true);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  });

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices.
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = restArguments(_.unzip);

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values. Passing by pairs is the reverse of _.pairs.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions.
  var createPredicateIndexFinder = function(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  };

  // Returns the first index on an array-like that passes a predicate test.
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions.
  var createIndexFinder = function(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
          i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  };

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    if (!step) {
      step = stop < start ? -1 : 1;
    }

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Chunk a single array into multiple arrays, each containing `count` or fewer
  // items.
  _.chunk = function(array, count) {
    if (count == null || count < 1) return [];
    var result = [];
    var i = 0, length = array.length;
    while (i < length) {
      result.push(slice.call(array, i, i += count));
    }
    return result;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments.
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = restArguments(function(func, context, args) {
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var bound = restArguments(function(callArgs) {
      return executeBound(func, bound, context, this, args.concat(callArgs));
    });
    return bound;
  });

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder by default, allowing any combination of arguments to be
  // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.
  _.partial = restArguments(function(func, boundArgs) {
    var placeholder = _.partial.placeholder;
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  });

  _.partial.placeholder = _;

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = restArguments(function(obj, keys) {
    keys = flatten(keys, false, false);
    var index = keys.length;
    if (index < 1) throw new Error('bindAll must be passed function names');
    while (index--) {
      var key = keys[index];
      obj[key] = _.bind(obj[key], obj);
    }
  });

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = restArguments(function(func, wait, args) {
    return setTimeout(function() {
      return func.apply(null, args);
    }, wait);
  });

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var timeout, context, args, result;
    var previous = 0;
    if (!options) options = {};

    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };

    var throttled = function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };

    throttled.cancel = function() {
      clearTimeout(timeout);
      previous = 0;
      timeout = context = args = null;
    };

    return throttled;
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, result;

    var later = function(context, args) {
      timeout = null;
      if (args) result = func.apply(context, args);
    };

    var debounced = restArguments(function(args) {
      if (timeout) clearTimeout(timeout);
      if (immediate) {
        var callNow = !timeout;
        timeout = setTimeout(later, wait);
        if (callNow) result = func.apply(this, args);
      } else {
        timeout = _.delay(later, wait, this, args);
      }

      return result;
    });

    debounced.cancel = function() {
      clearTimeout(timeout);
      timeout = null;
    };

    return debounced;
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  _.restArguments = restArguments;

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
    'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  var collectNonEnumProps = function(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  };

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`.
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object.
  // In contrast to _.map it returns an object.
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = _.keys(obj),
        length = keys.length,
        results = {};
    for (var index = 0; index < length; index++) {
      var currentKey = keys[index];
      results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  // The opposite of _.object.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`.
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, defaults) {
    return function(obj) {
      var length = arguments.length;
      if (defaults) obj = Object(obj);
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!defaults || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s).
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test.
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Internal pick helper function to determine if `obj` has key `key`.
  var keyInObj = function(value, key, obj) {
    return key in obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = restArguments(function(obj, keys) {
    var result = {}, iteratee = keys[0];
    if (obj == null) return result;
    if (_.isFunction(iteratee)) {
      if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);
      keys = _.allKeys(obj);
    } else {
      iteratee = keyInObj;
      keys = flatten(keys, false, false);
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  });

  // Return a copy of the object without the blacklisted properties.
  _.omit = restArguments(function(obj, keys) {
    var iteratee = keys[0], context;
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
      if (keys.length > 1) context = keys[1];
    } else {
      keys = _.map(flatten(keys, false, false), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  });

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq, deepEq;
  eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // `null` or `undefined` only equal to itself (strict comparison).
    if (a == null || b == null) return false;
    // `NaN`s are equivalent, but non-reflexive.
    if (a !== a) return b !== b;
    // Exhaust primitive checks
    var type = typeof a;
    if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
    return deepEq(a, b, aStack, bStack);
  };

  // Internal recursive comparison function for `isEqual`.
  deepEq = function(a, b, aStack, bStack) {
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN.
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
      case '[object Symbol]':
        return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError, isMap, isWeakMap, isSet, isWeakSet.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
  var nodelist = root.document && root.document.childNodes;
  if ( true && typeof Int8Array != 'object' && typeof nodelist != 'function') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return !_.isSymbol(obj) && isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`?
  _.isNaN = function(obj) {
    return _.isNumber(obj) && isNaN(obj);
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, path) {
    if (!_.isArray(path)) {
      return has(obj, path);
    }
    var length = path.length;
    for (var i = 0; i < length; i++) {
      var key = path[i];
      if (obj == null || !hasOwnProperty.call(obj, key)) {
        return false;
      }
      obj = obj[key];
    }
    return !!length;
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  // Creates a function that, when passed an object, will traverse that object’s
  // properties down the given `path`, specified as an array of keys or indexes.
  _.property = function(path) {
    if (!_.isArray(path)) {
      return shallowProperty(path);
    }
    return function(obj) {
      return deepGet(obj, path);
    };
  };

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    if (obj == null) {
      return function(){};
    }
    return function(path) {
      return !_.isArray(path) ? obj[path] : deepGet(obj, path);
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

  // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped.
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // Traverses the children of `obj` along `path`. If a child is a function, it
  // is invoked with its parent as context. Returns the value of the final
  // child, or `fallback` if any child is undefined.
  _.result = function(obj, path, fallback) {
    if (!_.isArray(path)) path = [path];
    var length = path.length;
    if (!length) {
      return _.isFunction(fallback) ? fallback.call(obj) : fallback;
    }
    for (var i = 0; i < length; i++) {
      var prop = obj == null ? void 0 : obj[path[i]];
      if (prop === void 0) {
        prop = fallback;
        i = length; // Ensure we don't continue iterating.
      }
      obj = _.isFunction(prop) ? prop.call(obj) : prop;
    }
    return obj;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate: /<%([\s\S]+?)%>/g,
    interpolate: /<%=([\s\S]+?)%>/g,
    escape: /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'": "'",
    '\\': '\\',
    '\r': 'r',
    '\n': 'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offset.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    var render;
    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var chainResult = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return chainResult(this, func.apply(_, args));
      };
    });
    return _;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return chainResult(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return chainResult(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return String(this._wrapped);
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
      return _;
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
}());

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(18), __webpack_require__(19)(module)))

/***/ }),
/* 18 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _util = __webpack_require__(15);
var _logger = _util.tagLogger("Sess");

var __event = __webpack_require__(21);

var __url_seqno = 0;

var Message = _util.prototypeExtend({
    setSessId: function setSessId(sessId) {
        sessId && (this.sessId = sessId);
        return this;
    },
    setOp: function setOp(op) {
        op && (this.op = op);

        if (op === 200) {
            this.res = {
                type: emedia.config.clientType,
                ver: emedia.config.version,
                agent: emedia.config.userAgent,
                ops: emedia.config.acptOps
            };

            //this.res = JSON.stringify(this.res);
        }

        return this;
    },
    setTsxId: function setTsxId(tsxId) {
        tsxId && (this.tsxId = tsxId);
        return this;
    },
    setTicket: function setTicket(tkt) {
        tkt && (this.tkt = tkt);
        return this;
    },
    setSdp: function setSdp(sdp) {
        sdp && (this.sdp = sdp);
        return this;
    },
    setCands: function setCands(cands) {
        cands && (this.cands = cands);
        return this;
    },
    setSubSId: function setSubSId(subSId) {
        subSId && (this.subSId = subSId);
        return this;
    },
    setMemId: function setMemId(memId) {
        memId && (this.memId = memId);
        return this;
    },
    setPubS: function setPubS(pubS) {
        pubS && (this.pubS = _util.extend(false, {}, pubS));

        var thisPubS = this.pubS;
        if (thisPubS.ext && _util.isPlainObject(thisPubS.ext)) {
            thisPubS.ext = JSON.stringify(thisPubS.ext);
        }

        thisPubS && _util.forEach(thisPubS, function (key, value) {
            if (_util.isPlainObject(value) || typeof value === 'function') {
                _util.removeAttribute(thisPubS, key);
            }
        });

        thisPubS && _util.removeAttribute(thisPubS, "localStream");
        thisPubS && _util.removeAttribute(thisPubS, "_localMediaStream");
        thisPubS && _util.removeAttribute(thisPubS, "_webrtc");

        return this;
    },
    setRtcId: function setRtcId(rtcId) {
        rtcId && (this.rtcId = rtcId);
        return this;
    },
    setCver: function setCver(cver) {
        cver && (this.cver = cver);
        return this;
    },
    setEndReason: function setEndReason(endReason) {
        endReason && (this.endReason = endReason);
        return this;
    },
    setNickName: function setNickName(nickName) {
        nickName && (this.nickName = nickName);
        return this;
    },
    setResource: function setResource(resource) {
        resource && (this.resource = resource);
        return this;
    },
    setReason: function setReason(reason) {
        reason && (this.reason = reason);
        return this;
    },
    setConfrId: function setConfrId(confrId) {
        confrId && (this.confrId = confrId);
        return this;
    },
    setVoff: function setVoff(voff) {
        typeof voff === "undefined" || (this.voff = voff ? 1 : 0);
        return this;
    },
    setAoff: function setAoff(aoff) {
        typeof aoff === "undefined" || (this.aoff = aoff ? 1 : 0);
        return this;
    },
    setFlag: function setFlag(flag) {
        flag === 0 && (this.flag = 0);
        flag === 1 && (this.flag = 1);

        return this;
    },
    setExt: function setExt(ext) {
        if (ext && _util.isPlainObject(ext)) {
            ext = JSON.stringify(ext);
        }
        ext && (this.ext = ext);
        return this;
    }
});

/**
 * {
 *   websocket:
 *   onMessage:
 *   _postMessage(Message):
 *   onError:
 * }
 *
 * reconnectCount > 0 时不上报错误（调用onWebsocketEvent）。
 * 不存在或==0 调用调用onWebsocketEvent
 * 调用onWebsocketEvent WSClose时 将会关闭
 *
 * @returns {*}
 *
 */

var __session_globalCount = emedia.__session_globalCount = 0;

function _connect(onConnected, onConnectFail, retry) {
    var self = this;

    function connectFail(cause, _evt) {
        try {
            self.onWebsocketEvent(new __event.WSClose({ url: self.thisWsUri, retry: retry, online: self.online, cause: cause, event: _evt, session: self }));
        } finally {
            onConnectFail && onConnectFail(new __event.WSClose({ url: self.thisWsUri, retry: retry, online: self.online, cause: cause, event: _evt, session: self }));
        }
    }

    function post(message) {
        if (!self.connected(self.thisWsUri)) {
            _logger.debug("current dont connect. the message = ", message);
            return;
        }

        if (_util.isPlainObject(message) && !(message instanceof Message)) {
            _logger.error("message not a Messages");
            throw "message not a Messages";
        }

        if (self.sessId && message.sessId != self.sessId) {
            _logger.warn("self.sessId && message.sessId != self.sessId", message);
            return;
        }

        self.thisWsUri === self._websocket.url && self._websocket.send(JSON.stringify(message));
        self.thisWsUri === self._websocket.url && _logger.debug("Done send: req:", message, self._websocket.url);
        self.thisWsUri === self._websocket.url || _logger.debug("Donot send(url not equal): req:", message, self._websocket.url);
    }

    function notifyNewMessage() {
        if (self.connected(self.thisWsUri)) {
            if (self._bufferedMessages.length === 0) {
                return;
            }

            var __array = [];

            var bufferedMessage;
            while (bufferedMessage = self._bufferedMessages.shift()) {
                if (!bufferedMessage.sessId && !self.sessId && bufferedMessage.op != 200) {
                    //等待Enter
                    __array.push(bufferedMessage);
                    _logger.warn("tmp store message, util enter success!", bufferedMessage);
                    continue;
                }

                if (bufferedMessage.op === 200) {
                    //200单独发送，有可能会修改session值
                    post(bufferedMessage);
                    break;
                }

                if (self.sessId && !bufferedMessage.sessId) {
                    bufferedMessage.sessId = self.sessId;
                }

                var _bufferedMessage = post(bufferedMessage);
                _bufferedMessage && __array.push(_bufferedMessage);
            }

            if (__array.length > 0) {
                Array.prototype.push.apply(self._bufferedMessages, __array);
            }
            //} else if(!retry || !self.online){
        } else if (retry === 0 || !self.online) {
            var _messageMap = _util.extend(false, {}, self._callbacks);

            var tmp = [];
            for (var tsxId in _messageMap) {
                var msg = _messageMap[tsxId];
                //if(retry > 0 && !self.online && (msg.op === 107 || msg.op === 201 || msg.op === 204 || msg.op === 206 || msg.op === 400 || msg.op === 500)) {
                if (retry > 0 && !self.online) {
                    //缓存所有消息
                    tmp.push(msg);
                    continue;
                }
                self.onMessage({ op: 1001, tsxId: tsxId, result: -9527, msg: "sdk rsp fail. retry fail or online = " + self.online });
            }

            self._bufferedMessages = self._bufferedMessages || [];

            tmp.length > 0 && Array.prototype.push.apply(self._bufferedMessages, tmp);
        } else if (!self.connected()) {
            // var _messageMap = _util.extend(false, {}, self._callbacks);
            //
            // for(var tsxId in _messageMap){
            //     var msg = _messageMap[tsxId];
            //     if(msg.op !== 102 && msg.op !== 105 && msg.op !== 1000) {
            //         continue;
            //     }
            //     self.onMessage({op: 1001, tsxId: tsxId, result: -9527, msg: "websocket disconnect", retrying: true});
            // }
        }
    }

    if (self.connected(self.thisWsUri)) {
        onConnected && onConnected(self);
        _logger.info("Session connected. dont continue connect");
        self.notifyNewMessage && self.notifyNewMessage();

        return;
    }

    if (!self.online) {
        connectFail();
        return;
    }

    self.notifyNewMessage = notifyNewMessage;

    _logger.info("Session begin connect.");

    var _websocket = self._websocket;
    if (_websocket) {
        _logger.warn("will close. websocket state", _websocket.readyState, _websocket.url, self.thisWsUri);
        _websocket.close(1000);
    }

    try {
        _logger.info("Connecting", self.thisWsUri, retry);
        _websocket = self._websocket = new WebSocket(self.thisWsUri);
    } catch (e) {
        _logger.warn(e);
        connectFail(e);

        return;
    }

    _websocket.onopen = function (evt) {
        var _url = this.url;
        if (_url !== self.thisWsUri) {
            _logger.warn("ignore the onopen. caused by websocket url not ", self.thisWsUri, _url);
            return;
        }

        try {
            _logger.info("websocket connected:", _url);
            onConnectFail && (onConnectFail = null);
            onConnected && onConnected(self);
            self.onWebsocketEvent(new __event.WSConnected({ event: evt, session: self }));
        } finally {
            //self.notifyNewMessage();
        }
    };

    _websocket.onmessage = function (evt) {
        var _url = this.url;
        if (_url !== self.thisWsUri) {
            _logger.warn("ignore recv data. caused by websocket url not ", self.thisWsUri, _url, evt.data);
            return;
        }

        _logger.debug("recv data", evt.data);

        var data = JSON.parse(evt.data);
        data && data.op == 1001 && _logger.debug("recv message: rsp:", data);
        data && data.op != 1001 && _logger.debug("recv message: evt:", data);

        self.onMessage(data);
    };

    _websocket.onclose = function (evt) {
        var _url = this.url;
        _logger.info("Disconnected:", _url, self.thisWsUri, evt);
        if (_url !== self.thisWsUri) {
            _logger.warn("ignore onclose. caused by websocket url not ", self.thisWsUri, _url);
            return;
        }

        self.notifyNewMessage();

        if (evt.code !== 1000) {
            //手动断开
            connectFail(undefined, evt);
        }
    };

    _websocket.onerror = function (evt) {
        _logger.info("On error:", evt);

        self.onWebsocketEvent(new __event.WSError({ event: evt, online: self.online, session: self, url: this.url }));
    };
}

/**
 * {
 *   ticket:
 *   reconnectCount:
 *   onError:
 *
 *   onEnter:
 *   onExit:
 *   onPub:
 *   onUnpub:
 *   onMems:
 *   onClose:
 *
 *   onInitC:
 *   onTcklC:
 *
 *
 *   newMessage:
 *   postMessage:
 * }
 *
 *
 * @private
 */
module.exports = _util.prototypeExtend({
    _events: {
        '0': 'onReqP2P',
        '1': 'onNewCfr',
        '2': 'onDelCfr',
        '3': 'onReqTkt',

        '100': 'onPing',
        '101': 'onPong',
        '102': 'onInitC',
        '103': 'onReqC',
        '104': 'onAcptC',
        '105': 'onTcklC',
        '106': 'onAnsC',
        '107': 'onTermC',

        '300': 'onEnter',
        '301': 'onExit',
        '302': 'onPub',
        '303': 'onUnpub',
        '304': 'onMems',
        '204': 'onClose',
        '400': 'onStreamControl',
        '401': 'onJoin',
        '412': 'onRoleUpdate',
        '1002': 'onRemoteControl',
        '1003': 'onRecvRemoteMessage'

        //'onServerError': 'onServerError'
    },

    __init__: function __init__() {
        var self = this;

        //self.owner = null;

        self._bufferedMessages = [];
        self._callbacks = {};

        function nowline() {
            if (navigator.onLine) {
                self.online = true;
            } else {
                self.online = false;
            }
        }

        nowline();

        // window.__easemob_checkLineIntervalId_ && clearInterval(window.__easemob_checkLineIntervalId_);
        // window.__easemob_checkLineIntervalId_ = setInterval(function () {
        //     var lastOnline = self.online;
        //     nowline();
        //     if(!lastOnline && self.online){
        //         online();
        //     }
        //     if(lastOnline && !self.online){
        //         offline();
        //     }
        // }, 500);


        function online(e) {
            self.online = true;
            _logger.warn("online online online");

            if (!self.closed) {
                self._reconnect(emedia.config.reconnect);
            }
        }

        function offline(e) {
            self.online = false;
            _logger.warn("offline offline offline");

            self.__checkConnectIntervalId && clearTimeout(self.__checkConnectIntervalId);

            self.__retryConnectIntervalId && clearTimeout(self.__retryConnectIntervalId);
            self.__retryConnectIntervalId && delete self.__retryConnectIntervalId;

            self._websocket && self._websocket.close(1000);
        }

        window.addEventListener("online", online, true);

        window.addEventListener("offline", offline, true);

        _logger.info("online status = ", self.online);
    },

    _nextWsUri: function _nextWsUri() {
        var self = this;

        var url = self.ticket.url;

        // var hostname = window.location.hostname;
        // if(hostname.endsWith("paic.com.cn")){ //pingan.com.cn -> paic.com.cn
        //     url = url.replace("pingan.com.cn", "paic.com.cn");
        // }else if(hostname.endsWith("pingan.com.cn")){ // paic.com.cn -> pingan.com.cn
        //     url = url.replace("paic.com.cn", "pingan.com.cn");
        // }
        // _logger.warn("ticket url modifiy. ", hostname, url);

        if (typeof emedia.convertWebsocketURLOfTicket === "function") {
            var oldUrl = url;
            url = emedia.convertWebsocketURLOfTicket(url);
            _logger.warn(oldUrl, "-->", url);
        }

        if (url.startsWith('/')) {
            //通过地址栏 补齐url
            if (emedia.config.wsorigin) {
                url = emedia.config.wsorigin + url;
            } else {
                var href = window.location.href;
                var proto = href.startsWith("https") ? "wss://" : "ws://";

                var startIndex = href.indexOf("://") + 3;
                var endIndex = href.indexOf("/", startIndex);
                var wsorigin = href.substring(startIndex, endIndex);

                url = proto + wsorigin + url;
            }

            _logger.warn("websocket url. update. {} -> {}", self.ticket.url, url);
        } else if (emedia.config.wsorigin) {
            _logger.warn("emedia.config.wsorigin invalidate. causeby server url {}", url);
        }

        if (url.indexOf("?") >= 0) {
            url += "&" + __url_seqno++;
        } else {
            url += "?" + __url_seqno++;
        }

        if (self.ticket.confrId) {
            url += "&" + encodeURIComponent(self.ticket.confrId);
        }
        return url;
    },

    _reconnect: function _reconnect(retry) {
        var self = this;

        function connected() {
            _logger.warn("Reconnected. at ", retry, self._websocket.url);
            self.__retryConnectIntervalId && clearTimeout(self.__retryConnectIntervalId);
            self.__retryConnectIntervalId && delete self.__retryConnectIntervalId;

            var enter = self.newMessage().setOp(200).setSessId(self._sessionId).setTicket(self.ticket).setNickName(self.nickName || self.ticket.memName).setResource(self.resource).setExt(self.owner.ext);
            self.postMessage(enter, function (rsp) {
                if (rsp.result != 0) {
                    try {
                        self.onEvent(new __event.EnterFail({
                            me: self.owner,
                            cause: new __event.RspFail({ request: enter, response: rsp }) }));
                    } finally {
                        if (rsp.result !== -9527) {
                            //-9527 客户端 自己返回，网络未通， 其他值服务端返回
                            self.onEvent(new __event.ServerRefuseEnter({ failed: rsp.result, msg: rsp.msg }));
                        }
                    }

                    return;
                }

                self.onEvent(new __event.EnterSuccess());

                self.owner.onMembers(rsp.cver, rsp.mems);
                self.owner.onStreams(rsp.cver, rsp.streams);

                self.notifyNewMessage();
            });
        }

        function failed(evt) {
            if (retry <= 0) {
                _logger.warn("Reconnect end. but fail.", evt.url, retry);
                self.__retryConnectIntervalId && delete self.__retryConnectIntervalId;

                return;
            }
            retry && (self.__retryConnectIntervalId = setTimeout(function () {
                self.connect(connected, failed, --retry);
            }, emedia.config.reconnectDelay));
        }

        self.connect(connected, failed, --retry);
    },

    __checkConnect: function __checkConnect() {
        var self = this;

        self.__checkConnectIntervalId && clearTimeout(self.__checkConnectIntervalId);

        emedia.config.checkConnectIntervalMillis && (self.__checkConnectIntervalId = setTimeout(function () {
            //_logger.trace("Check connect..");

            try {
                if (self.online && !self.connected()) {
                    self.__retryConnectIntervalId && _logger.debug("online, reconnecting...");
                    self.__retryConnectIntervalId || _logger.debug("online, but disconnect. will reconnect");
                    self.__retryConnectIntervalId || self._reconnect(emedia.config.reconnect);
                } else {
                    //self.notifyNewMessage && self.notifyNewMessage();
                }
            } finally {
                self.__checkConnect();
            }
        }, emedia.config.checkConnectIntervalMillis));
    },

    connect: function connect(onConnected, onConnectFail, retry) {
        var self = this;

        var nextUrl = self.thisWsUri = self._nextWsUri();

        typeof retry !== "undefined" && _logger.warn("begin connect... at retry = ", retry, nextUrl);

        function connected() {
            try {
                onConnected.apply(self, arguments);
            } finally {
                self.__checkConnect();
            }
        }

        function failed(evt) {
            try {
                onConnectFail.apply(self, arguments);
            } finally {
                retry || evt.url !== nextUrl || self.onEvent(new __event.ServerRefuseEnter({
                    failed: -95270, msg: "sdk reconnect fail. " + nextUrl + "|" + evt.url }));
            }
        }
        _connect.call(self, connected, failed, retry);
    },

    connected: function connected(wsUri) {
        var self = this;
        var result = self.online && self._websocket && (!wsUri || wsUri === self._websocket.url) && self._websocket.readyState == WebSocket.OPEN;
        //_logger.trace("Connected?", result, self.online, wsUri, self._websocket && self._websocket.url, self._websocket && self._websocket.readyState);

        return result;
    },

    onWebsocketEvent: function onWebsocketEvent(evt) {
        var self = this;
        self.onEvent(evt);
    },

    register: function register(listeners) {
        if ((typeof listeners === 'undefined' ? 'undefined' : _typeof(listeners)) === "object") {
            for (var event in listeners) {
                this.bind(event, listeners[event]);
            }
        }
    },

    bind: function bind(event, func) {
        var self = this;

        var onFunc;
        if (onFunc = self._events[event]) {
            self[onFunc] = func;
        } else {
            _logger.error("Not supported event = ", event);
            throw "Not supported event = " + event;
        }
    },

    getSessionId: function getSessionId() {
        return this._sessionId;
    },

    newMessage: function newMessage(cfg) {
        return new Message(cfg);
    },

    __modifyMessage: function __modifyMessage(message) {
        if (message && message.sdp) {
            if (typeof message.sdp === 'string') {
                message.sdp = _util.parseJSON(message.sdp);
            }
            message.sdp.type && (message.sdp.type = message.sdp.type.toLowerCase());
            message.cctx && (message.sdp.cctx = message.cctx);
        }
        if (message && message.cands) {
            if (typeof message.cands === 'string') {
                message.cands = _util.parseJSON(message.cands);
            }

            for (var i = 0; i < message.cands.length; i++) {
                typeof message.cands[i] === 'string' && (message.cands[i] = _util.parseJSON(message.cands[i]));

                message.cands[i].sdpMLineIndex = message.cands[i].mlineindex;
                message.cands[i].sdpMid = message.cands[i].mid;

                delete message.cands[i].mlineindex;
                delete message.cands[i].mid;

                message.cctx && (message.cands[i].cctx = message.cctx);
            }
        }

        if (message && message.mems) {
            if (!_util.isArray(message.mems)) {
                return;
            }

            var _mems = message.mems;
            message.mems = {};

            _util.forEach(_mems, function (index, _mem) {
                _mem.name && (_mem.memName = _mem.name);
                message.mems[_mem.id] = _mem;

                var acptOps = _mem.acptOps = {};
                _util.forEach(emedia.config.baseAcptOps, function (_index, _oper) {
                    acptOps[_oper] = true;
                });
                if (_mem.res) {
                    _util.forEach(_mem.res.ops, function (_index, _oper) {
                        acptOps[_oper] = true;
                    });
                }

                if (_mem && _mem.ext) {
                    try {
                        message.mems[_mem.id].ext = JSON.parse(_mem.ext);
                    } catch (e) {
                        _logger.debug(e);
                    }
                }
            });
        }

        if (message && message.mem) {
            message.mem.name && (message.mem.memName = message.mem.name);

            var acptOps = message.mem.acptOps = {};
            _util.forEach(emedia.config.baseAcptOps, function (_index, _oper) {
                acptOps[_oper] = true;
            });
            if (message.mem.res) {
                _util.forEach(message.mem.res.ops, function (_index, _oper) {
                    acptOps[_oper] = true;
                });
            }

            if (message.mem && message.mem.ext) {
                try {
                    message.mem.ext = JSON.parse(message.mem.ext);
                } catch (e) {
                    _logger.debug(e);
                }
            }
        }

        if (message && message.streams) {
            if (!_util.isArray(message.streams)) {
                return;
            }

            var _streams = message.streams;
            message.streams = {};

            _util.forEach(_streams, function (index, _stream) {
                message.streams[_stream.id] = _stream;

                if (_stream && _stream.ext) {
                    try {
                        message.streams[_stream.id].ext = JSON.parse(_stream.ext);
                    } catch (e) {
                        _logger.debug(e);
                    }
                }
            });
        }

        if (message && message.pubS) {
            if (message.pubS && message.pubS.ext) {
                try {
                    message.pubS.ext = JSON.parse(message.pubS.ext);
                } catch (e) {
                    _logger.debug(e);
                }
            }
        }

        if (message && message.ext) {
            try {
                message.ext = JSON.parse(message.ext);
            } catch (e) {
                _logger.debug(e);
            }
        }

        return message;
    },

    onMessage: function onMessage(servMessage) {
        var self = this;

        function onFunc(servMessage) {
            var onFunc;
            var event = servMessage.op;
            if ((onFunc = self._events[event]) && (onFunc = self[onFunc])) {
                onFunc.call(self, servMessage);
            } else {
                //throw "Not supported event = " + servMessage;
                _logger.warn("Not supported event = ", servMessage);
                return;
            }
        }

        if (servMessage.op != 1001 && !servMessage.sessId) {
            _logger.error("message sessId error. server evt data error");
            throw "message sessId error. server evt data error";
        }

        if (servMessage.op != 1001 && self._sessionId && self._sessionId != servMessage.sessId) {
            _logger.error("message sessId error. server and local not equal");
            throw "message sessId error. server and local not equal";
        }

        if (servMessage.op === 1004) {
            onFunc(servMessage);
            return;
        }

        servMessage = self.__modifyMessage(servMessage);

        var reqMessage = _util.removeAttribute(self._callbacks, servMessage.tsxId);
        if (reqMessage && reqMessage.op === 200) {
            self._sessionId = servMessage.sessId;

            if (servMessage.result === 0) {
                //enter 成功
                for (var index in self._bufferedMessages) {
                    var message = self._bufferedMessages[index];

                    if (!message.sessId && message.op !== 200) {
                        message.sessId = servMessage.sessId;
                    }
                }

                setTimeout(function () {
                    self.notifyNewMessage();
                }, 100);
            } else {
                var bufferedMessage;
                while (bufferedMessage = self._bufferedMessages.shift()) {
                    if (bufferedMessage.op === 200) {
                        continue;
                    }

                    self.onMessage({ op: 1001, tsxId: bufferedMessage.tsxId, result: -9527, msg: "sdk enter fail. sdk callback. enter result = " + servMessage.result });
                }
            }
        }

        if (self.owner && self.owner.closed) {
            _logger.warn("self closed. me is " + self.owner.getMemberId() + ", session_id = " + self.getSessionId() + ". drop message", servMessage);
            return;
        }

        self.onEvent(new __event.RecvResponse({ request: reqMessage, response: servMessage }));

        if (reqMessage && reqMessage.__callback__ && servMessage.op !== 1004) {
            reqMessage.__callback__(servMessage);
            return;
        }

        if (!servMessage.op || servMessage.op == 1001) {
            _logger.debug("Igron message. caused by op not found.", servMessage);
            return;
        }

        onFunc(servMessage);
    },

    __modifyMessageForPost: function __modifyMessageForPost(message) {
        if (message.cands) {
            var _cands = [];

            var cands = message.cands;
            for (var i = 0; i < cands.length; i++) {
                var _cand;

                if (i == 0) {
                    cands[i].cctx && (message.cctx = cands[i].cctx);
                }

                if (typeof cands[i] === "string") {
                    _cand = {
                        type: "candidate",
                        candidate: cands[i],
                        mlineindex: 0,
                        mid: "audio"
                        // seq: i
                    };
                } else {
                    // if (cands[i].type && cands[i].type == "candidate") {
                    //     _cands.push(cands[i]);
                    //     continue;
                    // }

                    _cand = {
                        type: "candidate",
                        candidate: cands[i].candidate,
                        mlineindex: cands[i].sdpMLineIndex,
                        mid: cands[i].sdpMid
                        // seq: i
                    };
                }

                _cands.push(JSON.stringify(_cand));
            }

            message.cands = _cands;
        }

        if (message.sdp && typeof message.sdp !== "string") {
            var _sdp = {
                type: message.sdp.type,
                sdp: message.sdp.sdp
            };

            message.sdp.cctx && (message.cctx = message.sdp.cctx);

            message.sdp = _sdp;

            message.sdp.type = message.sdp.type.toUpperCase();
            message.sdp = _util.stringifyJSON(message.sdp);
        }

        // if(message.ext && _util.isPlainObject(message.ext)){
        //     message.ext = JSON.stringify(message.ext);
        // }

        message.pubS && _util.removeAttribute(message.pubS, "_located");
        message.pubS && _util.removeAttribute(message.pubS, "mutedMuted");
        message.pubS && _util.removeAttribute(message.pubS, "mediaStream");
        message.pubS && _util.removeAttribute(message.pubS, "isRepublished");
        message.pubS && _util.removeAttribute(message.pubS, "optimalVideoCodecs");

        typeof message.post === "function" && _util.removeAttribute(message, "post");

        return message;
    },

    postMessage: function postMessage(message, callback, timeoutMillis) {
        var self = this;

        if (!message.tsxId) {
            message.tsxId = "MSG" + Date.now() + "-" + __session_globalCount++;
        }

        if (message.memId) {
            var _mem = self.owner._cacheMembers[message.memId];

            if (!_mem) {
                _logger.warn("Member not found at local. memberId = " + message.memId, message);
                callback && callback({ op: 1001, tsxId: message.tsxId, result: -507, msg: " member not found at local. memberId = " + message.memId });
                return;
            }

            var reqOps = message._reqOps;
            if (!reqOps) {
                reqOps = [];
                reqOps.push(message.op);
            }

            for (var index in reqOps) {
                var _reqOp = reqOps[index];

                if (!_mem.acptOps[_reqOp]) {
                    _logger.warn("Member not accept op " + _reqOp + ", " + message.memId, message);
                    callback && callback({ op: 1001, tsxId: message.tsxId, result: -507, msg: " member not accept op " + _reqOp + ", " + message.memId });
                    return;
                }
            }
        }
        _util.removeAttribute(message, '_reqOps');

        if (self._sessionId && self._sessionId != message.sessId) {
            _logger.warn("sessionId not excepted. self._sessionId = " + self._sessionId, message);
            callback && callback({ op: 1001, tsxId: message.tsxId, result: -9527, msg: "sessionId not excepted." });
            return;
        }
        if (self.closed) {
            _logger.warn("session closed.", message);
            callback && callback({ op: 1001, tsxId: message.tsxId, result: -9527, msg: "session closed" });
            return;
        }

        var oldMessage = _util.extend({}, message);
        message = self.__modifyMessageForPost(message);
        if (!message) {
            _logger.warn("Message drop. callback success.", message);
            callback && callback({ op: 1001, tsxId: oldMessage.tsxId, result: 0, msg: "Message drop. callback success." });
            return;
        }

        if (message.op === 200) {
            // enter 放在首位
            self._bufferedMessages.unshift(message);

            if (callback) {
                setTimeout(function () {
                    if (!self._callbacks[message.tsxId]) {
                        return;
                    }

                    _logger.error("Enter timeout. fail.");
                    self.onMessage({ op: 1001, tsxId: message.tsxId, result: -9527, msg: "enter timeout. millis = " + emedia.config.enterTimeout });
                }, emedia.config.enterTimeout);
            }
        } else {
            self._bufferedMessages.push(message);
        }

        callback && (self._callbacks[message.tsxId] = _util.extend(message, {
            __callback__: callback.bind(self.owner)
        }));

        self.notifyNewMessage && self.notifyNewMessage();

        if (timeoutMillis && callback) {
            setTimeout(function () {
                var message = self._callbacks[message.tsxId];

                if (message && message.__callback__) {
                    message.__callback__({ op: 1001, tsxId: oldMessage.tsxId, result: -408, msg: "Message request timeout." });
                }

                _util.removeAttribute(self._callbacks, message.tsxId);
            }, timeoutMillis);
        }
    },

    close: function close(reason) {
        _logger.warn("sessiong closing, reason = ", reason);

        var self = this;

        self.notifyNewMessage && self.notifyNewMessage();

        self.closed = true;

        self.seqno = 0;

        self._websocket && (reason == 0 || reason == 100 ? self._websocket.close(1000) : self._websocket.close());

        self.__retryConnectIntervalId && clearTimeout(self.__retryConnectIntervalId);
        self.__retryConnectIntervalId && delete self.__retryConnectIntervalId;

        self.__checkConnectIntervalId && clearTimeout(self.__checkConnectIntervalId);
        self.__checkConnectIntervalId && delete self.__checkConnectIntervalId;

        self.owner = null;
        //self._sessionId = null;

        self._bufferedMessages = [];
        self._callbacks = {};

        _logger.warn("session closed");
    }
});

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {


var _util = __webpack_require__(15);
var _logger = _util.logger;

/**
 * Error({
 *   hidden:
 * })
 *
 *
 *
 *
 */
var Error = _util.prototypeExtend({
    msg: "",
    __init__: function __init__() {
        this.day = new Date();
    },

    execTime: function execTime() {
        var hour = this.day.getHours();
        if (hour < 10) {
            hour = "0" + hour;
        }
        var minute = this.day.getMinutes();
        if (minute < 10) {
            minute = "0" + minute;
        }
        var second = this.day.getSeconds();
        if (second < 10) {
            second = "0" + second;
        }

        return hour + ":" + minute + ":" + second;
    }
});

var __ICEEvent = Error.extend({
    _webrtcDesc: function _webrtcDesc() {
        var webrtc = this.webrtc;

        var message = this.webrtc.getRtcId();

        return message;
    }
});

module.exports = {
    Exception: Error.extend(),

    /**
     * {retry: retry, online: self.online, event: evt, cause: e, session: self}
     */
    WSClose: Error.extend({ message: function message() {
            var message = this.execTime() + " WSClose: Websocket close (" + (this.retry || 0) + ").";

            this.online || (message += " offline.");
            this.event && (message += " wscode: " + this.event.code);
            this.cause && (message += " cause: " + this.cause.message);

            this.url && (message += " url: " + this.url);

            message += " retry: " + (this.retry || 0);

            this.session && this.session.getSessionId() && (message = message + ", sess = " + this.session.getSessionId());

            return message;
        } }),

    /**
     * {event: evt, online: self.online, session: self}
     */
    WSError: Error.extend({ message: function message() {
            var message = this.execTime() + " WSError: Websocket error. ready state:" + (this.event.srcElement && this.event.srcElement.readyState || this.event.currentTarget.readyState) + ". online = " + this.online;
            this.session && this.session.getSessionId() && (message = message + ", sess = " + this.session.getSessionId());

            this.url && (message += " url: " + this.url);

            return message;
        } }),

    /**
     * {event: evt, session: self}
     */
    WSConnected: Error.extend({ message: function message() {
            var message = this.execTime() + " WSConnected: Websocket success. ready state:" + (this.event.srcElement && this.event.srcElement.readyState || this.event.currentTarget.readyState);
            this.session && this.session.getSessionId() && (message = message + ", sess = " + this.session.getSessionId());

            return message;
        } }),

    /**
     * {webrtc: webrtc, event: webrtcEvent, state: webrtcEvent.target.iceConnectionState}
     */
    ICEChanage: __ICEEvent.extend({ message: function message() {
            return this.execTime() + " ICEChanage: " + this._webrtcDesc() + " state: " + this.state;
        } }),

    /**
     * {webrtc: webrtc, event: err}
     */
    AddIceCandError: __ICEEvent.extend({ message: function message() {
            return this.execTime() + " AddIceCandError: " + this._webrtcDesc() + ", add cand error";
        } }),

    /**
     * {webrtc: webrtc, event: event}
     */
    ICEConnectFail: __ICEEvent.extend({ message: function message() {
            return this.execTime() + " ICEConnectFail: " + this._webrtcDesc() + " failed";
        } }),

    /**
     * {webrtc: webrtc, event: event}
     */
    ICEConnected: __ICEEvent.extend({ message: function message() {
            return this.execTime() + " ICEConnected: " + this._webrtcDesc() + " connected";
        } }),

    /**
     * {webrtc: webrtc, event: event}
     */
    ICEDisconnected: __ICEEvent.extend({ message: function message() {
            return this.execTime() + " ICEDisconnected: " + this._webrtcDesc() + " disconnected";
        } }),

    /**
     * {webrtc: webrtc}
     */
    ICEClosed: __ICEEvent.extend({ message: function message() {
            return this.execTime() + " ICEClosed: " + this._webrtcDesc() + " closed";
        } }),

    /**
     * {webrtc: webrtc}
     */
    ICERemoteMediaStream: __ICEEvent.extend({ message: function message() {
            return this.execTime() + " ICERemoteMediaStream: " + this._webrtcDesc() + " got remote stream";
        } }),

    /**
     * {stream: stream, state:, msg: }
     */
    StreamState: Error.extend({ message: function message() {
            return this.execTime() + " StreamState: " + " stream " + this.stream.id + " state: " + this.state + " " + this.msg;
        },
        iceFail: function iceFail() {
            this.state = 1;
            this.msg = "network anomaly. media lost";
        }
    }),

    /**
     * {member: self.current, event: e}
     */
    OpenMediaError: Error.extend({ message: function message() {
            return this.execTime() + " OpenMediaError: " + " open media error. caused by " + this.event.toString();
        } }),

    /**
     * {reason: reason, parnter: {id: self._memberId}}
     */
    Hangup: Error.extend({ message: function message() {
            if (this.self) {
                return "hangup id = " + (this.self.id || "--") + " reason：" + (this.reason || 0);
            } else {
                return this.execTime() + " Hangup: " + (this.parnter && (this.parnter.name || this.parnter.id || " ") || "") + " hangup, reason：" + (this.reason || 0);
            }
        } }),

    /**
     * {failed: rsp.result, msg: rsp.msg}
     */
    ServerRefuseEnter: Error.extend({ message: function message() {
            return this.execTime() + " ServerRefuseEnter: " + "server refuse, cause：" + this.failed + ", msg:" + (this.msg || "");
        } }),

    /**
     * {request: req, response: rsp}
     */
    RspFail: Error.extend({
        __init__: function __init__() {
            this.day = new Date();
            this.failed = this.response.result;
            this.msg = this.response.msg || this.response.message || "--";
        },
        message: function message() {
            return this.execTime() + " RspFail: " + this.request.tsxId + ", " + (this.response.sessId || "--") + " op: " + this.request.op + ", cause: " + this.failed + " " + this.msg;
        }
    }),

    RecvResponse: Error.extend({
        __init__: function __init__() {
            this.day = new Date();
            this.failed = this.response.result;
            this.msg = this.response.msg;
            //this.request = this.response.result;
            //this.response = this.response.msg;
        },
        message: function message() {
            if (this.request) {
                return this.execTime() + " RecvResponse: " + (this.request && this.request.tsxId) + ", " + (this.response.sessId || "--") + " op: " + (this.request && this.request.op) + ", cause: " + this.failed + " " + this.msg;
            } else {
                return this.execTime() + " RecvMessage: " + (this.response && this.response.tsxId) + ", " + (this.response.sessId || "--") + " op: " + (this.response && this.response.op) + " " + this.msg;
            }
        }
    }),

    /**
     * {me: me, cause: _event_}
     */
    EnterFail: Error.extend({ message: function message() {
            return this.execTime() + " EnterFail: " + "enter fail：" + (this.cause ? this.cause.message() : "unkown");
        } }),

    EnterSuccess: Error.extend({ message: function message() {
            return this.execTime() + " EnterSuccess: " + "enter success";
        } }),

    /**
     * {streamId: rsp.streamId}
     */
    PushSuccess: Error.extend({ message: function message() {
            return this.execTime() + " PushSuccess: " + "push success, streamId = " + this.stream.id + ", " + this.stream.optimalVideoCodecs + ", webrtc = " + this.stream.rtcId;
        } }),

    /**
     * {webrtc: webrtc, pubS: pubS, me: me, cause: _event_}
     */
    PushFail: Error.extend({ message: function message() {
            return this.execTime() + " PushFail: " + "push fail, streamId = " + this.stream.id + ", " + this.stream.optimalVideoCodecs + ", webrtc = " + this.stream.rtcId + " cause：" + (this.cause ? this.cause.message ? this.cause.message() : this.cause : "unkown");
        } }),

    /**
     * {stream: stream, failed: failed, me: me, cause: cause}
     */
    RemoteControlFail: Error.extend({ message: function message() {
            return this.execTime() + " RemoteControlFail: " + (this.type || "remote control") + " fail, " + (this.stream ? this.stream.id : "") + " failed = " + this.failed + " cause：" + (this.cause ? this.cause.message ? this.cause.message() : this.cause : "unkown");
        } }),

    /**
     * {stream: stream, cause: }
     */
    SubSuccess: Error.extend({ message: function message() {
            return this.execTime() + " SubSuccess: " + "sub success, streamId = " + this.stream.id + ", " + this.stream.vcodes + ", webrtc = " + this.stream.rtcId;
        } }),

    /**
     * {stream: stream, cause: }
     */
    SubFail: Error.extend({ message: function message() {
            return this.execTime() + " SubFail: " + "sub fail, streamId = " + this.stream.id + ", " + this.stream.vcodes + ", webrtc = " + this.stream.rtcId + " cause：" + (this.cause ? this.cause.message ? this.cause.message() : this.cause : "unkown");
        } }),

    /**
     * {stream: stream, cause: }
     */
    SubFailNotSupportVCodes: Error.extend({ message: function message() {
            return this.execTime() + " SubFailNotSupportVCodes: " + "sub fail, streamId = " + this.stream.id + " cause：" + (this.cause ? this.cause.message ? this.cause.message() : this.cause : "unkown");
        } }),

    /**
     * {stream: stream, cause: }
     */
    SubFailSafariNotAllowSubBeforePub: Error.extend({ message: function message() {
            return this.execTime() + " SubFailSafariNotAllowSubBeforePub: " + "sub fail, streamId = " + this.stream.id + " cause：Safari without access to capture devices, " + "WebKit only exposes Server Reflexive and TURN ICE candidates, " + "which expose IPs that could already be gathered by websites.";
        } }),

    /**
     * {stream: stream, useVCodes: []}
     */
    SwitchVCodes: Error.extend({ message: function message() {
            return this.execTime() + " SwitchVCodes: " + "pub streamId = " + this.stream.id;
        } }),

    CurrentCalling: Error.extend({ message: function message() {
            return this.execTime() + " CurrentCalling: " + "warn! current calling...";
        } }),

    /**
     * {desktopStreamId: m.streamId}
     */
    OpenDesktopMedia: Error.extend({ message: function message() {
            return this.execTime() + " OpenDesktopMedia: " + "shared desktop, desktopStreamId = " + desktopStreamId;
        } }),

    OpenDesktopMediaAccessDenied: Error.extend({ message: function message() {
            return this.execTime() + " OpenDesktopMediaAccessDenied: " + "shared desktop not allow";
        } }),

    ShareDesktopExtensionNotFound: Error.extend({ message: function message() {
            return this.execTime() + " ShareDesktopExtensionNotFound: " + "shared desktop plugin required";
        } }),

    OtherDeviceAnswer: Error.extend({ message: function message() {
            return this.execTime() + " other device answer, webrtc = " + this.rtcId;
        } }),

    AudioMixerStreamNotAllowSub: Error.extend({ message: function message() {
            return this.execTime() + " audio mixer stream not allow sub, webrtc = " + this.rtcId + ", streamId = " + this.stream.id;
        } }),
    AudioMixerStreamNotAllowOnlySubVideo: Error.extend({ message: function message() {
            return this.execTime() + " audio mixer stream not allow only sub video, webrtc = " + this.rtcId + ", streamId = " + this.stream.id;
        } }),
    AudioMixerStreamRepeatPublish: Error.extend({ message: function message() {
            return this.execTime() + " audio mixer stream repeat publish";
        } })
};

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

var _util = __webpack_require__(15);
var _logger = _util.tagLogger("Me");

var Member = __webpack_require__(23);

var __event = __webpack_require__(21);

var Stream = __webpack_require__(26);

/**
 * 未体现 member 使用了 session。
 * 请 这样创建
 * Member({_session: sess})
 *
 *
 * close:
 * 1.服务端 踢掉
 * 2.手动点击 挂断
 * 3.enter失败！
 *
 * websocket 断开连接后，并不会 去close。因为发送消息可以实现重连，重新enter
 *
 *
 */
var Attendee = Member.extend({
    __init__: function __init__() {
        var self = this;

        self._session || self.sessionFactory && (self._session = self.sessionFactory());

        if (!self._session) {
            _logger.error("Require session");
            throw "Require session";
        }

        self._cver = 0;

        self._cacheMembers = {};
        self._cacheStreams = {};
        self._mediaMeters = {};
        self._openedRtcMediaStreams = {};

        self._linkedStreams = {};
        self._maybeNotExistStreams = {}; //与self._streams结构相同，用 存储 断网时，ice fail的stream对象。这个对象可能不存在了

        self._records = {};

        self._ices = {};
        self.audioMixers = {};

        self.closed = false;

        self._nextStreamSeqno = 0;

        self.getMediaMeterIntervalMillis = self.getMediaMeterIntervalMillis || emedia.config.getMediaMeterIntervalMillis;
    },

    getCurrentMembers: function getCurrentMembers() {
        var self = this;

        var members = [];
        _util.forEach(self._cacheMembers, function (_memId, _cacheMember) {
            var member = _util.extend(true, {}, _cacheMember);
            members.push(member);
        });

        return members;
    },

    newStream: function newStream(cfg) {
        var attendee = this;

        return new Stream(cfg, {
            __init__: function __init__() {
                var self = this;

                self.rtcId || self._webrtc && (self.rtcId = self._webrtc.getRtcId());
                self._webrtc || self.rtcId && (self._webrtc = attendee._ices[self.rtcId]);

                self.__create_id = attendee._nextStreamSeqno++;

                if (self.memId && !self.owner) {
                    self.owner = _util.extend({}, attendee._cacheMembers[self.memId]);
                    if (!self.owner && !self.located()) {
                        _logger.error("Remote stream, not owner. it = ", self.id);
                        throw "Remote stream, not owner. it = " + self.id;
                    }
                }
            }
        });
    },

    getConfrId: function getConfrId() {
        return this.ticket.confrId;
    },
    isCaller: function isCaller() {
        var self = this;
        return self.isP2P() && self.ticket.caller == self.ticket.memName;
    },
    isCallee: function isCallee() {
        var self = this;
        return self.isP2P() && self.ticket.callee == self.ticket.memName;
    },
    isP2P: function isP2P() {
        var self = this;
        return self.ticket && (self.ticket.type == "P2P" || self.ticket.type == "p2p");
    },
    isConfr: function isConfr() {
        var self = this;
        return self.ticket && (self.ticket.type == "CONFR" || self.ticket.type == "confr");
    },

    onEvent: function onEvent(evt) {},

    join: function join(joined, joinError) {
        _logger.debug("begin join ...");

        var self = this;

        var enter;

        if (self._memberId) {
            _logger.warn("Had joined. igrone it");
            joined && joined(self.memId);
            return;
        }

        function onJoinError(_event_) {
            try {
                if (_event_ instanceof __event.WSClose && _event_.retry) {
                    return;
                }

                if (!(_event_ instanceof __event.EnterFail)) {
                    _event_ = new __event.EnterFail({ //可能是 websocket 链接未成功
                        attendee: self,
                        cause: _event_
                    });
                }

                self.onEvent(_event_);
                joinError && joinError(_event_);
            } finally {}
        }

        function enterRsp(rsp) {
            if (rsp.result != 0) {
                try {
                    onJoinError(new __event.RspFail({ request: enter, response: rsp }));
                } finally {
                    if (rsp.result !== -9527) {
                        //-9527 客户端 自己返回，网络未通， 其他值服务端返回
                        self.onEvent(new __event.ServerRefuseEnter({ failed: rsp.result, msg: rsp.msg }));
                    }
                }

                return;
            }

            self.reflushSupportVCodes(rsp.vcodes);

            self.setMemberId(rsp.memId);
            self.role = rsp.role;

            self.onEvent(new __event.EnterSuccess());

            joined && joined(rsp.memId);

            try {
                self.__rtc_cfg = rsp.rtcCfg;
                if (typeof rsp.rtcCfg === 'string') {
                    self.__rtc_cfg = JSON.parse(rsp.rtcCfg);
                }
            } finally {
                self.onMembers(rsp.cver, rsp.mems);
                self.onStreams(rsp.cver, rsp.streams);
            }
        }

        function onConnected() {
            enter = self.newMessage().setOp(200).setTicket(self.ticket).setNickName(self.nickName || self.ticket.memName).setResource(self.resource).setExt(self.ext);
            self.postMessage(enter, enterRsp);
        }

        self.connect(onConnected, onJoinError);
        _logger.debug("join", self.ticket.url);
    },

    withpublish: function withpublish(pubS) {
        var self = this;

        if (!pubS || !pubS.localStream) {
            _logger.error("pubS null or stream not open");
            throw "pubS null or stream not open";
        }

        var enter;

        var openedStream = pubS && pubS.localStream;

        var webrtc;

        function then(joined, joinError) {
            if (arguments.length === 1) {
                joinError = joined;
                joined = undefined;
            }

            if (self._memberId) {
                _logger.warn("Had joined. igrone it");
                joined && joined(self.memId);
                return;
            }

            function onJoinError(_event_) {
                try {
                    if (_event_ instanceof __event.WSClose && _event_.retry) {
                        return;
                    }

                    if (!(_event_ instanceof __event.EnterFail)) {
                        _event_ = new __event.EnterFail({ //可能是 websocket 链接未成功
                            attendee: self,
                            cause: _event_
                        });
                    }

                    self.onEvent(_event_);
                    joinError && joinError(_event_);
                } finally {
                    emedia.stopTracks(openedStream);

                    webrtc && self.closeWebrtc(webrtc.getRtcId());
                }
            }

            var optimalVideoCodecs = self.getOptimalVideoCodecs();

            function enterRsp(rsp) {
                if (rsp.result != 0) {
                    try {
                        onJoinError(new __event.RspFail({ request: enter, response: rsp }));
                    } finally {
                        if (rsp.result !== -9527) {
                            //-9527 客户端 自己返回，网络未通， 其他值服务端返回
                            self.onEvent(new __event.ServerRefuseEnter({ failed: rsp.result, msg: rsp.msg }));
                        }
                    }

                    return;
                }

                self.reflushSupportVCodes(rsp.vcodes);

                self.setMemberId(rsp.memId);
                self.role = rsp.role;

                self.onEvent(new __event.EnterSuccess());

                var stream = self.newStream(pubS);
                stream._localMediaStream = pubS.localStream;
                stream.rtcId = webrtc.getRtcId();
                stream._webrtc = webrtc;
                stream.id = rsp.streamId;
                stream.csrc = rsp.csrc;
                stream.owner = { id: rsp.memId, nickName: self.nickName, name: self.sysUserId, ext: self.extObj };

                stream.optimalVideoCodecs = optimalVideoCodecs;

                joined && joined(rsp.memId, stream);
                self.onEvent(new __event.PushSuccess({ stream: stream, hidden: true })); //ice重连成功后 会 再次 onEvent PushSuccess

                rsp.sdp && self.ansC(webrtc.getRtcId(), rsp.sdp);
                rsp.cands && self.tcklC(webrtc.getRtcId(), rsp.cands);

                try {
                    self.__rtc_cfg = rsp.rtcCfg;
                    if (typeof rsp.rtcCfg === 'string') {
                        self.__rtc_cfg = JSON.parse(rsp.rtcCfg);
                    }
                    if (self.__rtc_cfg && self.__rtc_cfg.iceServers && self.__rtc_cfg.iceServers.length > 0) {
                        _logger.warn("Server rsp one rtc cfg. publish will republish");

                        self._service && setTimeout(function () {
                            self._service._republish(stream);
                        }, 200);
                    }
                } finally {
                    self.onMembers(rsp.cver, rsp.mems);
                    self.onStreams(rsp.cver, rsp.streams);
                }
            }

            function onConnected() {
                _logger.debug("enter and pubs");

                var stream = pubS.localStream;

                var offerOptions, subArgs;
                if (pubS.type === 2) {
                    offerOptions = {
                        offerToReceiveAudio: true,
                        offerToReceiveVideo: false
                    };
                    subArgs = {
                        subSVideo: false,
                        subSAudio: true
                    };
                }

                webrtc = self.createWebrtc({
                    _rtcId: pubS.rtcId,
                    optimalVideoCodecs: optimalVideoCodecs,
                    offerOptions: offerOptions,
                    subArgs: subArgs,
                    vbitrate: pubS.vbitrate || pubS.constaints && pubS.constaints.video && pubS.constaints.video.bitrate,
                    abitrate: pubS.abitrate || pubS.constaints && pubS.constaints.audio && pubS.constaints.audio.bitrate
                }, pubS.iceRebuildCount);
                self.setLocalStream(stream, webrtc.getRtcId());

                self.doOffer(webrtc.getRtcId(), function (sdp) {
                    enter = self.newMessage().setOp(200).setTicket(self.ticket).setNickName(self.nickName || self.ticket.memName).setResource(self.resource).setSdp(sdp).setRtcId(webrtc.getRtcId()).setPubS(pubS).setExt(self.ext);
                    self.postMessage(enter, enterRsp);
                });
            }

            self.connect(onConnected, onJoinError);
            _logger.debug("join", self.ticket.url);
        }

        return {
            join: then
        };
    },

    push: function push(pubS, pushed, onPushError, autoPush) {
        _logger.debug("begin push ...");

        var self = this;

        if (arguments.length === 2) {
            onPushError = pushed;
            pushed = undefined;
        }

        if (!pubS || !pubS.localStream) {
            _logger.error("pubS or stream open");
            throw "pubS or stream open";
        }

        var initC;

        var openedStream = pubS.localStream;

        var webrtc;

        function _onPushError(_event_) {
            try {
                var stream = self.newStream(pubS);
                stream._localMediaStream = pubS.localStream;
                stream._webrtc = webrtc;
                stream.rtcId = webrtc && webrtc.getRtcId();
                stream.owner = { id: self.getMemberId(), nickName: self.nickName, name: self.sysUserId, ext: self.extObj };

                var _event_ = new __event.PushFail({
                    stream: stream,
                    cause: _event_,
                    hidden: autoPush && _event_.hidden === true
                });

                self.onEvent(_event_);
                _event_.hidden || onPushError && onPushError(_event_);
            } finally {
                if (openedStream && _event_.hidden !== true) {
                    emedia.stopTracks(openedStream);
                }

                webrtc && self.closeWebrtc(webrtc.getRtcId(), _event_.hidden === true);
            }
        }

        if (!pubS.rtcId && pubS.type === 2 && !emedia.config.allowRepeatAudioMixerPublish && self._service.hasAudioMixers()) {
            _onPushError(new __event.AudioMixerStreamRepeatPublish());
            return;
        }

        var optimalVideoCodecs = pubS.optimalVideoCodecs || self.getOptimalVideoCodecs();

        function pushRsp(webrtc, rsp) {
            if (rsp.result != 0) {
                _onPushError(new __event.RspFail({ request: initC, response: rsp, hidden: rsp.retrying === true }));

                return;
            }

            var stream = self.newStream(pubS);

            stream._localMediaStream = pubS.localStream;
            stream._webrtc = webrtc;
            stream.rtcId = webrtc.getRtcId();
            stream.id = rsp.streamId;
            stream.csrc = rsp.csrc;
            stream.owner = { id: self.getMemberId(), nickName: self.nickName, name: self.sysUserId, ext: self.extObj };

            stream.optimalVideoCodecs = optimalVideoCodecs;

            stream.id && stream.type === 2 && (self.audioMixers[stream.id] = stream);

            try {
                self.onEvent(new __event.PushSuccess({ stream: stream, hidden: true })); //ice重连成功后 会 再次 onEvent PushSuccess
            } finally {
                rsp.sdp && self.ansC(webrtc.getRtcId(), rsp.sdp);
                rsp.cands && self.tcklC(webrtc.getRtcId(), rsp.cands);

                pushed && pushed(stream);
            }
        }

        function pub(pubS) {
            _logger.debug("pubs");

            var stream = pubS.localStream;

            var offerOptions, subArgs;
            if (pubS.type === 2) {
                offerOptions = {
                    offerToReceiveAudio: true,
                    offerToReceiveVideo: false
                };
                subArgs = {
                    subSVideo: false,
                    subSAudio: true
                };
            }

            webrtc = self.createWebrtc({
                _rtcId: pubS.rtcId,
                optimalVideoCodecs: optimalVideoCodecs,
                offerOptions: offerOptions,
                subArgs: subArgs,
                vbitrate: pubS.vbitrate || pubS.constaints && pubS.constaints.video && pubS.constaints.video.bitrate,
                abitrate: pubS.abitrate || pubS.constaints && pubS.constaints.audio && pubS.constaints.audio.bitrate
            }, pubS.iceRebuildCount);

            self.setLocalStream(stream, webrtc.getRtcId());

            self.doOffer(webrtc.getRtcId(), function (sdp) {
                initC = self.newMessage().setOp(102).setRtcId(webrtc.getRtcId()).setSdp(sdp).setPubS(pubS);

                self.postMessage(initC, function (rsp) {
                    pushRsp(webrtc, rsp);
                });
            });
        }

        pub(pubS);
        _logger.debug("push", self.ticket.url);
    },

    isSafari: function isSafari() {
        return (/Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent)
        );
    },

    isSafariButNotPushStream: function isSafariButNotPushStream(successOpenMedia, failOpenMedia) {
        var self = this;

        if (self.isSafari() && !emedia._isSafariYetPushedStream) {
            if (self.__tryingOpenMedia === true) {
                self.__tryingOpenMediaWaitSuceess = self.__tryingOpenMediaWaitSuceess || [];
                self.__tryingOpenMediaWaitFail = self.__tryingOpenMediaWaitFail || [];

                if (typeof successOpenMedia === "function") {
                    self.__tryingOpenMediaWaitSuceess.push(successOpenMedia);
                }
                if (typeof failOpenMedia === "function") {
                    self.__tryingOpenMediaWaitFail.push(failOpenMedia);
                }
            } else {
                self.__tryingOpenMedia = true;
                self._service.__getUserMedia({ audio: true }, function success(_user, mediaStream) {
                    emedia._isSafariYetPushedStream = true;
                    // setTimeout(function () {
                    //     emedia.stopAudioTracks(mediaStream);
                    // }, 700);
                    emedia.stopAudioTracks(mediaStream);

                    setTimeout(function () {
                        self.__tryingOpenMedia = false;
                        successOpenMedia && successOpenMedia.apply(self);
                        self.__tryingOpenMediaWaitSuceess && _util.forEach(self.__tryingOpenMediaWaitSuceess, function (index, func) {
                            func.apply(self);
                        });
                        self.__tryingOpenMediaWaitSuceess = [];
                        self.__tryingOpenMediaWaitFail = [];
                    }, 300);
                }, function (event) {
                    //emedia._isSafariYetPushedStream = false;
                    self.__tryingOpenMedia = false;
                    _logger.error("Safari must getUserMedia, gather cands. now try get audio. fail. subfail");

                    failOpenMedia && failOpenMedia.call(self, event);
                    self.__tryingOpenMediaWaitFail && _util.forEach(self.__tryingOpenMediaWaitFail, function (index, func) {
                        func.call(self, event);
                    });
                    self.__tryingOpenMediaWaitSuceess = [];
                    self.__tryingOpenMediaWaitFail = [];
                });
            }
            return true;
        }

        return false;
    },

    createWebrtcAndSubscribeStream: function createWebrtcAndSubscribeStream(streamId, callbacks, iceServerConfig, subArgs) {
        var self = this;

        callbacks || (callbacks = {});

        var subStream = self._cacheStreams[streamId];
        var subMember = self._cacheMembers[subStream.memId];

        //var stream = self.newStream(subStream);
        var stream = subStream;
        subArgs = subArgs || stream.subArgs || { subSVideo: true, subSAudio: subStream.type !== 2 }; //混音自动订阅不要订阅音频

        function _onSubFail(evt) {
            _logger.warn("sub stream error", streamId, evt);

            preSubArgs && stream._webrtc && stream._webrtc.setSubArgs(preSubArgs);
            preSubArgs && (stream.subArgs = preSubArgs);

            evt = new __event.SubFail({
                stream: stream,
                hidden: evt.hidden === true,
                cause: evt
            });

            callbacks && callbacks.onEvent && callbacks.onEvent(evt);
            self.onEvent && self.onEvent(evt);
        }

        var pubStreamVCodes = subStream.vcodes || [];
        var pubMemberSupportVCodes = subMember && subMember.vcodes || [];
        var selfSupportVCodes = self.supportVCodes;

        var optimalVideoCodecs = self._getOptimalVideoCodecsSubset(pubStreamVCodes, pubMemberSupportVCodes, selfSupportVCodes);

        // if(!stream.voff && subArgs.subSVideo && optimalVideoCodecs.length == 0){ // 订阅视频 但是 没有相同的 视频编码格式。失败
        //     _onSubFail(_util.extend(new __event.SubFail(), new __event.SubFailNotSupportVCodes({
        //         stream: stream
        //     })));
        //     return;
        // }

        subArgs = subArgs || stream.subArgs;

        var preSubArgs = stream.subArgs;

        var withoutVideo = !(stream.vcodes && stream.vcodes.length > 0);
        emedia.isSafari && (withoutVideo = withoutVideo || !!stream.voff);

        var offerOptions = {
            offerToReceiveAudio: true,
            offerToReceiveVideo: subArgs.subSVideo && !withoutVideo
        };

        if (!offerOptions.offerToReceiveAudio && !offerOptions.offerToReceiveVideo) {
            _logger.warn("offerToReceiveAudio == false and offerToReceiveVideo == false");
        }

        var webrtc = self.createWebrtc({
            iceServerConfig: iceServerConfig,
            optimalVideoCodecs: optimalVideoCodecs,
            offerOptions: offerOptions,

            onGotMediaStream: function onGotMediaStream(remoteMediaStream) {
                var evt = new __event.SubSuccess({
                    stream: stream,
                    hidden: true
                });

                callbacks.onGotRemote && callbacks.onGotRemote(stream);
                self.onEvent && self.onEvent(evt);
            }
        }, stream.iceRebuildCount);
        var rtcId = webrtc.getRtcId();

        _logger.warn(rtcId, " sub stream ", streamId, optimalVideoCodecs);

        stream._webrtc = webrtc;
        stream.rtcId = rtcId;
        stream.owner = _util.extend({}, subMember);

        subArgs && stream._webrtc && stream._webrtc.setSubArgs(subArgs);
        subArgs && (stream.subArgs = subArgs);

        if (self.isSafariButNotPushStream(function success() {
            self.offerCall(rtcId, null, streamId, _onSubFail, function onRspSuccess() {});
        }, function (event) {
            _logger.error("Safari must getUserMedia, gather cands. now try get audio. fail. subfail", rtcId, streamId);
            _onSubFail(event);
        })) {// safari 如果没有getUserMedia时，是不会生成cands的
        } else {
            self.offerCall(rtcId, null, streamId, _onSubFail, function onRspSuccess() {});
        }
    },

    _getOptimalVideoCodecsSubset: function _getOptimalVideoCodecsSubset(pubStreamVCodes, pubMemberSupportVCodes, selfSupportVCodes) {
        var self = this;

        var optimalVideoCodecs = [];

        if (pubStreamVCodes && pubStreamVCodes.length > 0 && selfSupportVCodes[pubStreamVCodes[0]]) {
            optimalVideoCodecs.push(pubStreamVCodes[0]);
        }
        if (optimalVideoCodecs.length == 0) {
            for (var i = 0; i < self._orderVCodes.length; i++) {
                _util.forEach(pubMemberSupportVCodes, function (index, sVCode) {
                    if (sVCode == self._orderVCodes[i]) {
                        optimalVideoCodecs.push(sVCode);
                    }
                });
            }
        }

        return optimalVideoCodecs;
    },

    subscribeStream: function subscribeStream(rtcId, streamId, rspFail, subArgs, onSub) {
        var self = this;

        var webrtc = self._ices[rtcId];

        var subStream = self._cacheStreams[streamId];
        var subMember = self._cacheMembers[subStream.memId];

        //var stream = self.newStream(subStream);
        var stream = subStream;
        stream._webrtc = webrtc;
        stream.rtcId = rtcId;
        stream.owner = _util.extend({}, subMember);

        var preSubArgs = stream.subArgs;

        subArgs = subArgs || { subSVideo: true, subSAudio: true };
        stream.subArgs = stream.subArgs || { subSVideo: true, subSAudio: true };
        stream._webrtc && (stream._webrtc.subArgs = stream._webrtc.subArgs || { subSVideo: true, subSAudio: true });

        if (!stream.subArgs.subSVideo && subArgs.subSVideo && !stream.voff) {
            var pubStreamVCodes = subStream.vcodes;
            var pubMemberSupportVCodes = subMember.vcodes;
            var selfSupportVCodes = self.supportVCodes;

            var optimalVideoCodecs = self._getOptimalVideoCodecsSubset(pubStreamVCodes, pubMemberSupportVCodes, selfSupportVCodes);

            // if(optimalVideoCodecs.length == 0){ // 订阅视频 但是 没有相同的 视频编码格式。失败
            //     preSubArgs && stream._webrtc && stream._webrtc.setSubArgs(preSubArgs);
            //     preSubArgs && (stream.subArgs = preSubArgs);
            //
            //     var evt = _util.extend(new __event.SubFail(), new __event.SubFailNotSupportVCodes({
            //         stream: stream
            //     }));
            //
            //     rspFail && rspFail(evt);
            //     self.onEvent(evt);
            //
            //     return;
            // }
        }

        subArgs && stream._webrtc && stream._webrtc.setSubArgs(subArgs);
        subArgs && (stream.subArgs = subArgs);

        var subMessage = self.newMessage().setOp(205).setRtcId(rtcId).setSubSId(streamId);

        subArgs && _util.extend(subMessage, subArgs);

        self.postMessage(subMessage, function (rsp) {
            if (rsp.result != 0) {
                preSubArgs && stream._webrtc && stream._webrtc.setSubArgs(preSubArgs);
                preSubArgs && (stream.subArgs = preSubArgs);

                var evt = new __event.SubFail({
                    stream: stream,
                    cause: new __event.RspFail({ request: subMessage, response: rsp })
                });

                rspFail && rspFail(evt);
                self.onEvent(evt);

                return;
            }

            var evt = new __event.SubSuccess({
                stream: stream,
                hidden: true
            });
            self._updateRemoteStream(stream, stream._webrtc.getRemoteStream());
            self.onEvent(evt);

            typeof onSub === 'function' && onSub();
        });
    },

    unsubscribeStream: function unsubscribeStream(streamId) {
        var self = this;

        var stream = self._cacheStreams[streamId];
        var rtcId = stream._webrtc && stream._webrtc.getRtcId();
        if (!rtcId) {
            return;
        }

        try {
            var unsubMessage = self.newMessage().setOp(206).setRtcId(rtcId).setSubSId(streamId);

            self.postMessage(unsubMessage);
        } finally {
            self.closeWebrtc(rtcId);
        }

        return rtcId;
    },

    onEnter: function onEnter(cver, mem) {
        var self = this;

        cver && (self._cver = cver);

        if (!mem) return;
        if (self._cacheMembers[mem.id]) {
            return;
        }

        self._cacheMembers[mem.id] = mem;

        var _tmpMap = {};
        if (mem.res && mem.res.vcodes && mem.res.vcodes.length > 0) {
            _util.forEach(mem.res.vcodes, function (index, vcode) {
                if (_tmpMap[vcode]) {} else {
                    _tmpMap[vcode] = true;
                    self.supportVCodes[vcode] && self.supportVCodes[vcode]++;
                }
            });
        }

        // var hasOtherDevices;
        // _util.forEach(self._cacheMembers, function (_memId, _member) {
        //     if(!hasOtherDevices && _memId != mem.id && mem.memName === _member.memName){
        //         hasOtherDevices = true;
        //     }
        // });
        //
        // if(hasOtherDevices){
        //     return;
        // }

        self.onAddMember(_util.extend({}, mem));
    },

    _onFinally: function _onFinally() {
        var self = this;

        self._cacheMembers = {}; // id, name, nickName, resource
        self._cacheStreams = {}; // id, memId, name, voff, aoff, type
        self._linkedStreams = {};
        self._ices = {};
        self._maybeNotExistStreams = {};

        //self._session._sessionId = undefined;
        //self._session = undefined;


        //push stream时，由于异步，在未返回成功后，退出会议，摄像头不会被关闭问题
        var openedMediaStreams = [];
        _util.forEach(self._openedRtcMediaStreams, function (streamId, mediaStream) {
            if (mediaStream.active !== false) {
                //还没有关闭的流
                openedMediaStreams.push(mediaStream);
            }
        });
        if (openedMediaStreams.length > 0) {
            for (var i = 0; i < openedMediaStreams.length; i++) {
                try {
                    var _openStream = openedMediaStreams[i];
                    _logger.info("exit, close stream = ", _openStream.id);
                    emedia.stopTracks(_openStream);
                } catch (e) {
                    _logger.error(e);
                }
            }
        }

        _logger.warn("finally. all clean.");
    },

    _onRoleUpdate: function _onRoleUpdate(role, roleToken) {
        var self = this;

        _logger.info("Role ", role, " <-", self.role);
        _logger.info(roleToken);
        self.role = role;
        self.roleToken = roleToken;

        self.onRoleUpdate && self.onRoleUpdate(role, roleToken);
    },

    onExit: function onExit(cver, memId, reason) {
        var self = this;

        cver && (self._cver = cver);

        if (memId == self.getMemberId()) {
            //被服务器 强制 exit
            _logger.warn("Me exit. ", reason, memId);

            try {
                self.closed || self.close(reason);
            } catch (e) {
                self.onEvent(new __event.Hangup({ reason: reason, self: { id: self._memberId } }));
                self.onMeExit && self.onMeExit(reason);

                _logger.warn(e);
            }

            return;
        }

        var rmMember = self._cacheMembers[memId];
        if (rmMember) {
            if (rmMember.res && rmMember.res.vcodes && rmMember.res.vcodes.length > 0) {
                _util.forEach(rmMember.res.vcodes, function (index, vcode) {
                    self.supportVCodes[vcode]--;
                });
            }

            self._onRemoveMember(rmMember, reason);
            self.onEvent(new __event.Hangup({ reason: reason, parnter: rmMember }));
        }
    },

    onPub: function onPub(cver, memId, pubS) {
        var self = this;

        if (!self._cacheMembers[memId]) {
            _logger.error("No found member. when pub");
            throw "No found member. when pub";
        }

        // if(pubS.type === 2){ //强制 aoff = 1
        //     pubS._1_aoff = pubS.aoff;
        //     pubS.aoff = self._service.hasAudioMixers() ? 0 : 1;
        // }

        var newStream = self.newStream(pubS);
        var _stream = self._cacheStreams[pubS.id];

        cver && (self._cver = cver);

        if (_stream && newStream.sver !== _stream.sver) {
            _logger.info("Onpub. the steam ", _stream.id, " republish. sver ", _stream.sver, newStream.sver);

            if (newStream && (newStream.aoff !== _stream.aoff || newStream.voff != _stream.voff)) {
                self.onStreamControl(undefined, pubS.id, newStream.voff, newStream.aoff);
            }

            _util.extend(_stream, newStream);
            self._onRepublishStream(_stream);

            return;
        }

        var stream = newStream;

        stream.owner = self._cacheMembers[memId];
        self._cacheStreams[pubS.id] = stream;

        self._onAddStream(self.newStream(stream));

        if (self.autoSub) {
            // if(self.isSafariButNotPushStream()){
            //     stream._autoSubWhenPushStream = true;
            //     _logger.warn("Dont auto sub stream ", stream.id, ", caused by safari not pub stream");
            //     //return;
            // }

            self.createWebrtcAndSubscribeStream(pubS.id, {
                onGotRemote: function onGotRemote(stream) {}
            }); //, undefined, subArgs
        }

        return stream;
    },

    onUnpub: function onUnpub(cver, memId, sId) {
        var self = this;

        var rmStream = self._cacheStreams[sId];
        self._onRemovePubstream(self._cacheMembers[memId], rmStream);

        cver && (self._cver = cver);
    },

    onClose: function onClose(cver, confrId, reason) {
        var self = this;

        try {
            self.close(reason || 0);
        } finally {
            self.onConfrClose && self.onConfrClose(confrId, reason);
        }
    },

    __getWebrtcFor: function __getWebrtcFor(pubStreamId) {
        var self = this;

        var webrtc = self._cacheStreams[pubStreamId] && self._cacheStreams[pubStreamId]._webrtc;
        return webrtc && webrtc.getRtcId();
    },
    _getWebrtc: function _getWebrtc(pubStreamId) {
        var self = this;

        var webrtc = self._cacheStreams[pubStreamId] && self._cacheStreams[pubStreamId]._webrtc;
        return webrtc;
    },

    _updateRemoteStream: function _updateRemoteStream(stream, remoteMediaStream) {
        if (stream.located() && stream.type === 2) {
            emedia.enableAudioTracks(remoteMediaStream, true);
        } else {
            emedia.enableAudioTracks(remoteMediaStream, !stream.aoff && !(stream.subArgs && stream.subArgs.subSAudio === false));
        }

        emedia.enableVideoTracks(remoteMediaStream, !stream.voff && !(stream.subArgs && stream.subArgs.subSVideo === false));
    },

    onStreamControl: function onStreamControl(cver, streamId, voff, aoff, sver) {
        var self = this;

        var stream = self._cacheStreams[streamId];

        stream.voff = voff;
        stream.aoff = aoff;

        var webrtc = stream._webrtc;
        webrtc && webrtc._remoteStream && self._updateRemoteStream(stream, webrtc._remoteStream);

        var stream = self.newStream(stream);
        self.onUpdateStream && self.onUpdateStream(stream, new stream.Update({ voff: voff, aoff: aoff }));

        cver && (self._cver = cver);
        sver && (stream.sver = sver);
    },

    aoff: function aoff(pubS, _aoff, callback) {
        var self = this;

        var rtcId = self.__getWebrtcFor(pubS.id);
        if (!rtcId) {
            _logger.error("pubS not publish", pubS.id);
            throw "pubS not publish" + pubS.id;
        }

        self._linkedStreams[pubS.id].aoff = pubS.aoff = _aoff;

        var streamControl = self.newMessage().setOp(400).setRtcId(rtcId).setVoff(pubS.voff).setAoff(_aoff);
        self.postMessage(streamControl, callback);
        self.onUpdateStream && self.onUpdateStream(pubS, new pubS.Update({ aoff: _aoff }));
    },

    voff: function voff(pubS, _voff, callback) {
        var self = this;

        var rtcId = self.__getWebrtcFor(pubS.id);
        if (!rtcId) {
            _logger.error("pubS not publish", pubS.id);
            throw "pubS not publish" + pubS.id;
        }

        self._linkedStreams[pubS.id].voff = pubS.voff = _voff;

        var streamControl = self.newMessage().setOp(400).setRtcId(rtcId).setVoff(_voff).setAoff(pubS.aoff);
        self.postMessage(streamControl, callback);
        self.onUpdateStream && self.onUpdateStream(pubS, new pubS.Update({ voff: _voff }));
    },

    startRecord: function startRecord(_stream, success) {
        var self = this;

        var rtcId = _stream.rtcId;

        var startRecord = self.newMessage().setOp(500).setRtcId(rtcId).setFlag(1);
        self.postMessage(startRecord, function (rsp) {
            _logger.warn("record ", rtcId, rsp.result, rsp.msg);
            success && success(rsp.result === 0);
            if (rsp.result === 0) {
                self._records[_stream.id] = _util.extend(false, {}, _stream);
            }
        });
    },

    stopRecord: function stopRecord(_stream, success) {
        var self = this;

        var rtcId = _stream.rtcId;

        var stopRecord = self.newMessage().setOp(500).setRtcId(rtcId).setFlag(0);
        self.postMessage(stopRecord, function (rsp) {
            _logger.warn("stop record ", rtcId, rsp.result, rsp.msg);
            success && success(rsp.result === 0);
        });

        if (self._records[_stream.id]) {
            _util.removeAttribute(self._records, _stream.id);
        }
    },

    onMembers: function onMembers(cver, members) {
        var self = this;

        var removedMembers = [];
        _util.forEach(self._cacheMembers, function (_memberId, _member) {
            members[_memberId] || removedMembers.push(_member);
        });
        _util.forEach(removedMembers, function (_index, _member) {
            self.onExit(undefined, _member.id);
        });

        var addMembers = [];
        _util.forEach(members, function (_memberId, _member) {
            if (_memberId != self.getMemberId()) {
                self._cacheMembers[_memberId] || addMembers.push(_member);
                self._cacheMembers[_memberId] && _util.extend(self._cacheMembers[_memberId], _member);
            }
        });
        _util.forEach(addMembers, function (_index, _member) {
            self.onEnter(undefined, _member);
        });

        cver && (self._cver = cver);
    },

    onStreams: function onStreams(cver, streams) {
        var self = this;

        var removedStreams = [];
        _util.forEach(self._cacheStreams, function (_pubSId, _stream) {
            _stream.located() || streams[_pubSId] || removedStreams.push(_stream);
        });
        _util.forEach(removedStreams, function (_index, _stream) {
            self.onUnpub(undefined, _stream.memId, _stream.id);
        });

        var addStreams = [];
        _util.forEach(streams, function (_pubSId, stream) {
            // if(stream.type === 2){ //强制 aoff = 1
            //     stream._1_aoff = stream.aoff;
            //     stream.aoff = self._service.hasAudioMixers() ? 0 : 1;
            // }

            if (stream.memId != self.getMemberId()) {
                self._cacheStreams[_pubSId] || addStreams.push(stream);
                self._cacheStreams[_pubSId] && _util.extend(self._cacheStreams[_pubSId], stream);
            }
        });
        _util.forEach(addStreams, function (_index, _stream) {
            self.onPub(undefined, _stream.memId, _stream);
        });

        _util.forEach(self._cacheStreams, function (_pubSId, _stream) {
            var newStream;
            _stream.located() || (newStream = streams[_pubSId]);
            if (newStream && (newStream.aoff !== _stream.aoff || newStream.voff != _stream.voff)) {
                self.onStreamControl(undefined, _pubSId, newStream.voff, newStream.aoff);
            }

            if (newStream && newStream.sver !== _stream.sver) {
                _util.extend(_stream, newStream);
                self._onRepublishStream(_stream);
            }
        });

        cver && (self._cver = cver);
    },

    _onRemoveMember: function _onRemoveMember(member, reason) {
        var self = this;

        _logger.info("remove", member, reason);

        var unpubStreams = [];
        _util.forEach(self._cacheStreams, function (_pubSId, _stream) {
            if ((_stream.memId || _stream.owner && _stream.owner.id) === member.id) {
                unpubStreams.push(_stream);
            }
        });

        _util.forEach(unpubStreams, function (index, stream) {
            self._onRemovePubstream(stream.owner, stream, reason);
        });

        _util.removeAttribute(self._cacheMembers, member.id);

        // var hasOtherDevices;
        // _util.forEach(self._cacheMembers, function (_memId, _member) {
        //     if(!hasOtherDevices && _memId != member.id && member.memName === _member.memName){
        //         hasOtherDevices = true;
        //     }
        // });
        //
        // if(hasOtherDevices){
        //     return;
        // }

        self.onRemoveMember && self.onRemoveMember(member, reason);
    },

    _onAddStream: function _onAddStream(stream) {
        _logger.info("add stream ", stream.id);
        _logger.debug("add stream ", stream);

        var self = this;
        self.onAddStream(stream);
    },

    _onRemovePubstream: function _onRemovePubstream(member, stream) {
        var self = this;

        if (!stream) {
            return;
        }
        if (stream.id == 0) {
            return;
        }

        function finallyDo(stream) {
            if (stream.type === 2) {
                _util.removeAttribute(self.audioMixers, stream.id);

                if (stream.remotePlayAudioObject) {
                    document.body.removeChild(stream.remotePlayAudioObject);
                }
            }

            var _rtcId = self.unsubscribeStream(stream.id);
            var rmStream = _util.removeAttribute(self._cacheStreams, stream.id);
            self._monitSoundChanagedStreams && _util.removeAttribute(self._monitSoundChanagedStreams, stream.id);

            if (self.onRemoveStream) {
                var stream = self.newStream(stream);

                self.onRemoveStream(stream);
            }
        }

        try {
            var soundMeter = _util.removeAttribute(self._mediaMeters, stream.id);
            soundMeter && soundMeter._finally();
        } finally {
            finallyDo(stream);
        }
    },

    _onRepublishStream: function _onRepublishStream(_stream) {
        var self = this;

        if ((self._ices[_stream.rtcId] || emedia.subscribed(_stream)) && !self._maybeNotExistStreams[_stream.id]) {
            var _rtcId = self.unsubscribeStream(_stream.id);

            self.createWebrtcAndSubscribeStream(_stream.id, {
                onGotRemote: function onGotRemote(stream) {
                    //self.onUpdateStream(_stream);
                }
            });
        } else {
            self.onUpdateStream(_stream);
        }
    },

    _onRecvRemoteMessage: function _onRecvRemoteMessage(fromMemId, args, evt) {
        var self = this;

        _logger.debug("Recv remote message", fromMemId, args);

        var fromMember = self._cacheMembers[fromMemId];
        var argsObject;
        try {
            argsObject = JSON.parse(args);
        } catch (e) {}

        self.onRecvRemoteMessage && self.onRecvRemoteMessage(fromMember || fromMemId, argsObject || args, evt);
    },

    _onSoundChanage: function _onSoundChanage(member, stream, meterData) {
        if (emedia.config._printSoundData) {
            _logger.info("Stream id " + stream.id + ", meter " + (meterData && meterData.instant.toFixed(2) + " " + meterData.slow.toFixed(2) + " " + meterData.clip.toFixed(2) + " " + (meterData.trackAudioLevel || "--") + " " + (meterData.trackTotalAudioEnergy || "--")));
        }

        meterData || (meterData = {
            instant: 0,
            slow: 0,
            clip: 0
        });

        var self = this;

        if (meterData.instant === 0) {
            meterData.instant = meterData.trackAudioLevel || meterData.trackTotalAudioEnergy || 0;
        }

        self.onSoundChanage(member, stream, meterData);
        if (self._service._judgeTalking(meterData)) {
            self.onTalking(member, stream, meterData);
        }
    },

    onAddMember: function onAddMember(member) {},
    onRemoveMember: function onRemoveMember(member, reason) {},
    onAddStream: function onAddStream(stream) {//stream undefined 表明 autoSub属性 空或false. autoSub = true时，自动订阅

    },
    onRemoveStream: function onRemoveStream(stream) {},
    onUpdateStream: function onUpdateStream(stream, update) {},
    onRecvRemoteMessage: function onRecvRemoteMessage(fromMember, argsObject) {},

    onSoundChanage: function onSoundChanage(member, stream, meterData) {},
    onTalking: function onTalking(member, stream, meterData) {}
});

module.exports = Attendee;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {


var _util = __webpack_require__(15);
var _logger = _util.tagLogger("Member");

var __event = __webpack_require__(21);

var WebRTC = __webpack_require__(24);

/**
 * 未体现 Member 使用了 session。
 * 请 这样创建
 * Member({_session: sess, _memberId: memberId})
 * this._session
 *
 * {
 *  _memberId:
 *  _ices[Map]:
 * }
 *
 *
 *
 */
module.exports = _util.prototypeExtend({
    __init__: function __init__() {
        var self = this;

        if (!self._session) {
            _logger.error("Require session");
            throw "Require session";
        }

        self.closed = false;
        self._ices = {};

        self.supportVCodes = {};

        self.audioMixers = {};
    },

    reflushSupportVCodes: function reflushSupportVCodes(vcodes) {
        var self = this;

        self.supportVCodes = {};

        self._orderVCodes = vcodes;

        if (!vcodes || vcodes.length == 0) {
            _logger.warn("Not config support vcodes");
            return;
        }

        _util.forEach(vcodes, function (index, vcode) {
            self.supportVCodes[vcode] = 1;
        });
    },

    getOptimalVideoCodecs: function getOptimalVideoCodecs() {
        var self = this;

        if (!self._orderVCodes || self._orderVCodes.length == 0) {
            return (/Chrome/.test(navigator.userAgent) ? 'VP8' : /Safari/.test(navigator.userAgent) ? 'H264' : 'VP8'
            );
        }

        var memberCount = 0;
        _util.forEach(self._cacheMembers, function () {
            memberCount++;
        });

        var maxSupportCount = 0;
        var optimalVCode;

        for (var i = 0; i < self._orderVCodes.length; i++) {
            var vcode = self._orderVCodes[i];

            if (maxSupportCount == 0) {
                maxSupportCount = self.supportVCodes[vcode];
            }

            if (self.supportVCodes[vcode] > memberCount) {
                return vcode;
            }

            if (self.supportVCodes[vcode] > maxSupportCount) {
                maxSupportCount = self.supportVCodes[vcode];
                optimalVCode = vcode;
            }
        }

        return optimalVCode;
    },

    setMemberId: function setMemberId(memberId) {
        this._memberId = memberId;
    },

    getMemberId: function getMemberId() {
        return this._memberId || this.id;
    },

    /**
     * createWebrtc({
     *  _rtcId:
     *  iceServerConfig:
     *  onGotMediaStream:
      * onEvent:
     * })
     *
     * @param iceServerConfig
     */
    createWebrtc: function createWebrtc(webrtcCfg, rebuildCount) {
        var self = this;

        webrtcCfg || (webrtcCfg = {});

        _util.extend(webrtcCfg, { _rebuildCount: rebuildCount || 0 });

        if (self._service.useRTCCfg === true && self.__rtc_cfg) {
            //优先使用 __rtc_cfg
            webrtcCfg.iceServerConfig = _util.extend(true, {}, self.__rtc_cfg);
        } else if (_util.isPlainObject(self._service.useRTCCfg)) {
            webrtcCfg.iceServerConfig = _util.extend(true, {}, self._service.useRTCCfg);
        }

        var webrtc = new WebRTC({
            //iceServerConfig: iceServerConfig,

            onIceStateChange: function onIceStateChange(iceState) {
                var state = iceState;

                _logger.debug("evt.target ice state", state);
                try {
                    if (state == 'failed') {
                        self.onEvent(new __event.ICEConnectFail({ webrtc: webrtc }));
                        webrtc.onEvent && webrtc.onEvent(new __event.ICEConnectFail({ webrtc: webrtc }));

                        return;
                    }
                    if (state == 'connected') {
                        self.onEvent(new __event.ICEConnected({ webrtc: webrtc }));
                        webrtc.onEvent = null;

                        return;
                    }
                    if (state == 'closed') {
                        self.onEvent(new __event.ICEClosed({ webrtc: webrtc }));
                        webrtc.onEvent && webrtc.onEvent(new __event.ICEClosed({ webrtc: webrtc }));

                        return;
                    }
                    if (state == 'disconnected') {
                        self.onEvent(new __event.ICEDisconnected({ webrtc: webrtc }));
                        webrtc.onEvent && webrtc.onEvent(new __event.ICEDisconnected({ webrtc: webrtc }));

                        return;
                    }
                } finally {
                    self._onIceStateChange && self._onIceStateChange(webrtc, iceState);
                }
            },

            onIceCandidate: function onIceCandidate(candidate) {
                //event.candidate
                self._onIceCandidate && candidate && self._onIceCandidate(webrtc, candidate);
            },

            onGotRemoteStream: function onGotRemoteStream(remoteStream) {
                _logger.info("got stream.", webrtc, remoteStream);

                webrtc.onGotMediaStream && webrtc.onGotMediaStream(remoteStream);

                self.onEvent(new __event.ICERemoteMediaStream({ webrtc: webrtc }));
            },
            onAddIceCandidateError: function onAddIceCandidateError(err) {
                self.onEvent(new __event.AddIceCandError({ webrtc: webrtc, event: err }));
            },
            onSetSessionDescriptionError: function onSetSessionDescriptionError(error) {
                _logger.warn('onSetSessionDescriptionError : Failed to set session description: ' + error.toString());
                self.onEvent && self.onEvent(new __event.ICEConnectFail({ webrtc: webrtc, event: error }));
            },
            onCreateSessionDescriptionError: function onCreateSessionDescriptionError(error) {
                _logger.warn('Failed to create session description: ' + error.toString());
                self.onEvent && self.onEvent(new __event.ICEConnectFail({ webrtc: webrtc, event: error }));
            }
            // onSetLocalSessionDescriptionSuccess: function (error) {
            //     _logger.debug('onSetLocalSessionDescriptionSuccess : setLocalDescription complete: ' + error.toString());
            //     self.onEvent && self.onEvent(new __event.ICEConnectFail({webrtc: webrtc, event: error}));
            // },
        }, webrtcCfg);

        self._ices || (self._ices = {});
        if (self._ices[webrtc.getRtcId()]) {
            self._howDoWebrtcWhenCrtExsitsWebrtc(webrtc);
        }
        self._ices[webrtc.getRtcId()] = webrtc;
        self._ices[webrtc.__id] = webrtc;

        self._iceCreateRtcPeerConnection(webrtc.getRtcId());
        _logger.debug("create rtc ", webrtc);

        return webrtc;
    },

    _howDoWebrtcWhenCrtExsitsWebrtc: function _howDoWebrtcWhenCrtExsitsWebrtc(webrtc) {
        var self = this;

        //throw "Webrtc id exsits at ices. it is " + webrtc.getRtcId();
        self.closeWebrtc(webrtc.getRtcId(), true, false);
    },

    connect: function connect(suceess, fail) {
        var self = this;

        self._session.connect(suceess, fail);
    },

    connected: function connected() {
        var self = this;

        return self._session.connected();
    },

    newMessage: function message(cfg) {
        var self = this;

        var message = self._session.newMessage(cfg);
        message.post = function (callback, timeoutMillis) {
            self.postMessage(this, callback, timeoutMillis);
        };

        return message;
    },

    message: function message(cfg) {
        var self = this;

        var message = self._session.newMessage(cfg);
        message.post = function (callback, timeoutMillis) {
            self.postMessage(this, callback, timeoutMillis);
        };

        return message;
    },

    postMessage: function postMessage(message, callback, timeoutMillis) {
        var self = this;

        try {
            message.sessId || (message.sessId = self._session._sessionId);
            self._session.postMessage(message, callback, timeoutMillis);
        } catch (e) {
            callback && callback({ op: 1001, tsxId: message.tsxId, result: -9527, msg: "post message. exception" });
            _logger.warn(e);
        }
    },

    onEvent: function onEvent(error) {},

    _onIceStateChange: function _onIceStateChange(webrtc, rtcState) {
        var self = this;

        _logger.info(webrtc.getRtcId(), rtcState);
        self.onEvent(new __event.ICEChanage({ webrtc: webrtc, state: rtcState }));
    },

    _onIceCandidate: function _onIceCandidate(webrtc, cand) {
        //event.candidate
        var self = this;

        var cands;
        if (_util.isArray(cand)) {
            cands = cand;
        } else {
            cands = [];
            cands.push(cand);
        }

        var tcklC = self.newMessage().setOp(105).setRtcId(webrtc.getRtcId()).setCands(cands);

        self.postMessage(tcklC, function (rsp) {
            if (rsp.result != 0) {
                self.onEvent(new __event.RspFail({ request: tcklC, response: rsp }));

                return;
            }
        });
    },

    _initC: function _initC(webrtc, stream, sdp, subSId, rspFail, rspSuccess) {
        var self = this;

        if (stream && stream.rtcId !== webrtc.getRtcId()) {
            _logger.error("stream and webrtc rtcId not equal.");
            throw "stream and webrtc rtcId not equal.";
        }

        var initC = self.newMessage().setOp(102).setRtcId(webrtc.getRtcId()).setSdp(sdp).setSubSId(subSId);

        webrtc.subArgs && _util.extend(initC, webrtc.subArgs);

        if (stream && stream.located()) {
            initC.setPubS(stream);
        }

        self.postMessage(initC, function (rsp) {
            if (rsp.result != 0) {
                self.onEvent(new __event.RspFail({ request: initC, response: rsp }));
                rspFail && rspFail(new __event.RspFail({ request: initC, response: rsp, hidden: rsp.retrying === true }));

                return;
            }

            if (stream && !stream.id && rsp.streamId) {
                stream.id = rsp.streamId;
            }

            try {
                rspSuccess && rspSuccess();
            } catch (e) {
                _logger.warn(e);
            }

            rsp.sdp && self.ansC(webrtc.getRtcId(), rsp.sdp, rsp.cands);

            rsp.mems && self.onMembers && self.onMembers(rsp.cver, rsp.mems);
            rsp.streams && self.onStreams && self.onStreams(rsp.cver, rsp.streams);
        });
    },

    _acptC: function _acptC(webrtc, sdp, rspFail) {
        var self = this;

        var acptC = self.newMessage().setOp(104).setRtcId(webrtc.getRtcId()).setSdp(sdp);

        self.postMessage(acptC, function (rsp) {
            if (rsp.result != 0) {
                self.onEvent(new __event.RspFail({ request: acptC, response: rsp }));
                rspFail && rspFail(new __event.RspFail({ request: acptC, response: rsp }));

                return;
            }
        });
    },

    _ansCAndPubstream: function _ansCAndPubstream(webrtc, stream, sdp, rspFail, rspSuccess) {
        var self = this;

        var ansC = self.newMessage().setOp(106).setRtcId(webrtc.getRtcId()).setSdp(sdp);

        webrtc.subArgs && _util.extend(ansC, webrtc.subArgs);

        if (stream && stream.located()) {
            stream = _util.extend({}, stream);
            _util.removeAttribute(stream, "mutedMuted");
            _util.removeAttribute(stream, "_located");

            ansC.setPubS(stream);
        }

        self.postMessage(ansC, function (rsp) {
            if (rsp.result != 0) {
                self.onEvent(new __event.RspFail({ request: ansC, response: rsp }));
                rspFail && rspFail(new __event.RspFail({ request: ansC, response: rsp, hidden: rsp.retrying === true }));

                return;
            }

            if (stream && !stream.id && rsp.streamId) {
                stream.id = rsp.streamId;
            }

            try {
                rspSuccess && rspSuccess();
            } catch (e) {
                _logger.warn(e);
            }
        });
    },

    _ansC: function _ansC(webrtc, sdp, rspFail) {
        var self = this;

        var ansC = self.newMessage().setOp(106).setRtcId(webrtc.getRtcId()).setSdp(sdp);

        self.postMessage(ansC, function (rsp) {
            if (rsp.result != 0) {
                self.onEvent(new __event.RspFail({ request: ansC, response: rsp }));
                rspFail && rspFail(new __event.RspFail({ request: ansC, response: rsp }));

                return;
            }
        });
    },

    _termC: function _termC(webrtc, endReason, rspFail) {
        var self = this;

        var rtcId = typeof webrtc === "string" ? webrtc : webrtc.getRtcId();
        var termC = self.newMessage().setOp(107).setRtcId(rtcId).setEndReason(endReason);

        self.postMessage(termC, function (rsp) {
            if (rsp.result != 0) {
                self.onEvent(new __event.RspFail({ request: termC, response: rsp }));
                rspFail && rspFail(new __event.RspFail({ request: termC, response: rsp }));

                return;
            }
        });
    },

    _iceCreateRtcPeerConnection: function _iceCreateRtcPeerConnection(rtcId) {
        var self = this;

        self._ices[rtcId].createRtcPeerConnection();

        _logger.debug("create rtc peer connection", rtcId);
    },

    doOffer: function doOffer(rtcId, onGotOffer, onCreateOfferError) {
        var self = this;

        var webrtc = self._ices[rtcId];

        webrtc.createOffer(function (sdp) {
            onGotOffer(sdp);
        });
    },

    offerCall: function offerCall(rtcId, stream, subSId, rspFail, rspSuccess) {
        var self = this;

        var webrtc = self._ices[rtcId];

        webrtc.createOffer(function (sdp) {
            self._initC && self._initC(webrtc, stream, sdp, subSId, rspFail, rspSuccess);
        });
    },

    accept: function accept(rtcId, rspFail) {
        var self = this;

        var webrtc = self._ices[rtcId];
        webrtc.createPRAnswer(function (sdp) {
            self._acptC && self._acptC(webrtc, sdp, rspFail);
        });
    },

    answerCall: function answerCall(rtcId, stream, rspFail, rspSuccess) {
        var self = this;

        var webrtc = self._ices[rtcId];

        webrtc.createAnswer(function (sdp) {
            self._ansCAndPubstream && self._ansCAndPubstream(webrtc, stream, sdp, rspFail, rspSuccess);
        });
    },

    answer: function answer(rtcId, rspFail) {
        var self = this;

        var webrtc = self._ices[rtcId];
        webrtc.createAnswer(function (sdp) {
            self._ansC && self._ansC(webrtc, sdp, rspFail);
        });
    },

    onTcklC: function onTcklC(rtcId, cands) {
        var self = this;
        self._addIceCandidate(cands, rtcId);
    },

    onAcptC: function onAcptC(rtcId, sdp, cands) {
        var self = this;
        self._iceSetRemoteSDP(sdp, rtcId);
        cands && self._addIceCandidate(cands, rtcId);
    },

    onAnsC: function onAnsC(rtcId, sdp, cands) {
        var self = this;
        self._iceSetRemoteSDP(sdp, rtcId);
        cands && self._addIceCandidate(cands, rtcId);
    },

    _addIceCandidate: function _addIceCandidate(cands, rtcId) {
        var self = this;

        if (!cands || cands.length == 0) {
            _logger.warn("drop cands", cands);
            return;
        }

        var webrtc = self._ices[rtcId];
        webrtc && webrtc.addIceCandidate(cands);
    },

    closeWebrtc: function closeWebrtc(rtcId, remainLocalStream, serverClosed) {
        var self = this;
        var webrtc = self._ices[rtcId];

        _util.forEach(self._cacheStreams, function (sid, _stream) {
            if (_stream.rtcId === rtcId && !_stream.located()) {
                try {
                    var soundMeter = _util.removeAttribute(self._mediaMeters, sid);
                    soundMeter && soundMeter._finally();
                } catch (e) {
                    _logger.warn(e);
                }
            }

            if (_stream.rtcId === rtcId && _stream.type === 2) {
                _util.removeAttribute(self.audioMixers, _stream.id);
            }
        });

        if (!webrtc || webrtc.closed) {
            _logger.warn("Webrtc not exsits or closed", webrtc && webrtc.closed);

            if (serverClosed) {
                webrtc && _util.forEach(self._cacheStreams, function (sid, _stream) {
                    if (_stream.rtcId === rtcId) {
                        //delete self._linkedStreams[sid];
                        _util.removeAttribute(self._linkedStreams, sid);
                        _logger.warn("Webrtc close, remvoe from _linkedStreams", sid);
                    }
                });
            }

            serverClosed || self._termC(rtcId, 0);

            return;
        }

        if (self._records) {
            var _stopRecord = function _stopRecord(_stream) {
                try {
                    self.stopRecord(_stream);
                } catch (e) {
                    _logger.warn(e);
                } finally {
                    _util.removeAttribute(self._records, _stream.id);
                }
            };

            _util.forEach(self._records, function (sid, _stream) {
                _stream.rtcId === rtcId && _stopRecord(_stream);
            });
        }

        try {
            serverClosed || webrtc && self._termC(webrtc, remainLocalStream && webrtc._localStream ? -10 : 0);
        } finally {
            //webrtc && _util.removeAttribute(self._ices, rtcId);

            webrtc && webrtc.close(remainLocalStream); //
            webrtc && self.onWebrtcTermC && self.onWebrtcTermC(webrtc);

            if (remainLocalStream) {} else {
                webrtc && _util.forEach(self._cacheStreams, function (sid, _stream) {
                    if (_stream.rtcId === rtcId) {
                        if (_stream.located()) {
                            emedia.stopTracks(_stream._localMediaStream);

                            self._cacheStreams[sid] && self._linkedStreams[sid] && self.onRemoveStream(_stream);

                            _util.removeAttribute(self._cacheStreams, sid);
                            self._monitSoundChanagedStreams && _util.removeAttribute(self._monitSoundChanagedStreams, sid);
                            _logger.info("Webrtc close. Remove stream", sid, ". from cache");
                        }

                        if (serverClosed) {
                            //delete self._linkedStreams[sid];
                            _util.removeAttribute(self._linkedStreams, sid);
                            _logger.info("Webrtc close. Remove stream", sid, ". from _linkedStreams");
                        }
                    }
                });
            }
        }

        return webrtc;
    },

    __close: function __close(reason) {
        _logger.warn("closing, reason = ", reason);

        var self = this;
        if (self.closed) {
            return;
        }

        self.closed = true;

        if (self.__getCopyInterval) {
            clearInterval(self.__getCopyInterval);
            _logger.warn("Stop interval get copy");
        }

        if (self._ices) {
            for (var _rtcId in self._ices) {
                self.closeWebrtc(_rtcId, false);
            }
        }

        var exit = self.newMessage().setOp(201).setReason(reason || 0);
        self.postMessage(exit);
    },

    exit: function exit(closeMyConfrIfICrtConfr) {
        var self = this;

        if (!closeMyConfrIfICrtConfr) {
            self.close(0); // 正常挂断
            return;
        }

        if (closeMyConfrIfICrtConfr) {
            self._closeMyConfr(11);
            //return;
        }
        setTimeout(function () {
            self.close(0); // 正常挂断
        }, 100);
    },

    _closeMyConfr: function _closeMyConfr(reason) {
        var self = this;

        var closeConfr = self.newMessage().setOp(204).setReason(reason || 0);
        self.postMessage(closeConfr, function (rsp) {
            _logger.warn("Close confr ", rsp.result, rsp.msg);
        });
    },

    /**
     * 1.服务端 踢掉
     * 2.手动点击 挂断
     * 3.enter失败！
     *
     * @param reason
     */
    close: function close(reason, failed) {
        var self = this;
        if (self.closed) {
            return;
        }

        try {
            _util.forEach(self._cacheStreams || {}, function (sid, _stream) {
                if (_stream.located() && _stream._localMediaStream) {
                    emedia.stopTracks(_stream._localMediaStream);
                }
            });

            self.__close(reason);

            _util.forEach(self._cacheStreams, function (sid, _stream) {
                self.onRemoveStream(_stream);
            });
            _util.forEach(self._cacheMembers, function (_id, _member) {
                self.onRemoveMember(_member);
            });
        } finally {
            try {
                setTimeout(function () {
                    self._session && self._session.close(reason);
                }, 500);

                self.onEvent(new __event.Hangup({ reason: reason, failed: failed, self: { id: self._memberId } }));
                self.onMeExit && self.onMeExit(reason, failed);
            } catch (e) {
                _logger.error(e);
            } finally {
                self._onFinally && self._onFinally();
            }
        }
    },

    webrtcState: function webrtcState(rtcId) {
        var self = this;

        var webrtc = self._ices[rtcId];
        return webrtc.iceConnectionState();
    },

    _iceSetRemoteSDP: function _iceSetRemoteSDP(sdp, rtcId) {
        var self = this;

        var webrtc = self._ices[rtcId];
        webrtc.setRemoteDescription(sdp);
    },

    setLocalStream: function setLocalStream(stream, rtcId) {
        var self = this;

        var webrtc = self._ices[rtcId];
        webrtc.setLocalStream(stream);
    },

    onWebrtcTermC: function onWebrtcTermC(_webrtc) {}
});

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * WebRTC
 *
 *                              A                   |                                       B
 *                                                  |
 *   1.createMedia:got streamA                      | 1.createMedia:got streamB
 *   2.new RTCPeerConnection: APeerConnection       | 2.new RTCPeerConnection: BPeerConnection
 *   3.APeerConnection.createOffer:got offerA       |
 *      APeerConnection.setLocalDescription(offerA) |
 *      send offerA ---> ---> ---> --->        ---> |
 *                                                  | ---> 3.got offerA | offerA = new RTCSessionDescription(offerA);
 *                                                  | BPeerConnection.setRemoteDescription(offerA)
 *                                                  |
 *                                                  |
 *                                                  | 4.BPeerConnection.createAnswer: got answerB
 *                                                  | BPeerConnection.setLocalDescription(answerB)
 *                                                  | <---- send answerB
 *                                                  | 5.got answerB <--- <--- <--- <---
 *                                                  | answerB = new RTCSessionDescription(answerB)
 *                                                  |
 * APeerConnection.setRemoteDescription(answerB)    |
 *                                                  |
 * 6.got candidateA ---> --->  ---> --->            | ---> got candidateA
 *                                                  | BPeerConnection.addIceCandidate(new RTCIceCandidate(candidateA))
 *                                                  |
 *                                                  |
 *                                                  | got candidateB <--- <--- <--- <---
 *                                                  | <--- 6.got candidateB APeerConnection.addIceCandidate(candidateB)
 *                                                  |
 *                                                  |
 *                                                  | 7. APeerConnection.addStream(streamA)
 *                                                  | 7. BPeerConnection.addStream(streamB)
 *                                                  |
 *                              streamA >>>>>>>>>>> |  <<<<< see A
 *                              seeB <<<<<<<<<<<    | <<<<< streamB
 *                                                  |
 *
 */

var _util = __webpack_require__(15);
var _logger = _util.tagLogger("Webrtc");

var __event = __webpack_require__(21);

var SDPUtils = __webpack_require__(25); //希望使用 SDPUtils 取代 SDPSection

var _SDPSection = {
    headerSection: null,

    audioSection: null,
    videoSection: null,

    _parseHeaderSection: function _parseHeaderSection(sdp, audioIndex, videoIndex) {
        var index = audioIndex;

        if (videoIndex === -1) {//保持不变
        } else if (audioIndex === -1) {
            index = videoIndex;
        } else {
            index = Math.min(audioIndex, videoIndex);
        }

        if (index >= 0) {
            return sdp.slice(0, index);
        }
        return sdp;
    },

    _parseAudioSection: function _parseAudioSection(sdp, audioIndex, videoIndex) {
        var index = audioIndex;
        if (index >= 0) {
            return sdp.slice(index, videoIndex < index ? sdp.length : videoIndex);
        }
    },

    _parseVideoSection: function _parseVideoSection(sdp, audioIndex, videoIndex) {
        var index = videoIndex;
        if (index >= 0) {
            return sdp.slice(index, audioIndex < index ? sdp.length : audioIndex);
        }
    },

    spiltSection: function spiltSection(sdp) {
        var self = this;

        self._preSDP = sdp;

        var audioIndex = self._preAudioIndex = sdp.indexOf('m=audio');
        var videoIndex = self._preVideoIndex = sdp.indexOf('m=video');

        self.headerSection = self._parseHeaderSection(sdp, audioIndex, videoIndex);
        self.audioSection = self._parseAudioSection(sdp, audioIndex, videoIndex);
        self.videoSection = self._parseVideoSection(sdp, audioIndex, videoIndex);
    },

    setVideoBitrate: function setVideoBitrate(vbitrate) {
        if (!vbitrate || !this.videoSection) {
            return;
        }

        this.videoSection = this.setBitrate(this.videoSection, vbitrate);
    },

    setAudioBitrate: function setAudioBitrate(abitrate) {
        if (!abitrate || !this.audioSection) {
            return;
        }

        this.audioSection = this.setBitrate(this.audioSection, abitrate);
    },

    setBitrate: function setBitrate(section, bitrate) {
        section = section.replace(/(b=)(?:AS|TIAS)(\:)\d+/g, "$1AS$2" + bitrate);
        if (section.indexOf('b=AS') < 0) {
            section = section.replace(/(m=(?:audio|video)[^\r\n]+)([\r\n]+)/g, "$1$2b=AS:" + bitrate + "$2");
        }
        return section;
    },

    updateVideoSection: function updateVideoSection(regx, oper) {
        var self = this;

        if (!self.videoSection) {
            return;
        }

        self.videoSection = self.videoSection.replace(regx, oper);
    },

    updateAudioSection: function updateAudioSection(regx, oper) {
        var self = this;

        if (!self.audioSection) {
            return;
        }

        self.audioSection = self.audioSection.replace(regx, oper);
    },

    updateVideoSendonly: function updateVideoSendonly() {
        var self = this;

        if (!self.videoSection) {
            return;
        }

        self.videoSection = self.videoSection.replace(/sendrecv/g, "sendonly");
    },

    updateVideoRecvonly: function updateVideoRecvonly() {
        var self = this;

        if (!self.videoSection) {
            return;
        }

        self.videoSection = self.videoSection.replace(/sendrecv/g, "recvonly");
    },

    updateAudioSendonly: function updateAudioSendonly() {
        var self = this;

        if (!self.audioSection) {
            return;
        }

        self.audioSection = self.audioSection.replace(/sendrecv/g, "sendonly");
    },

    updateAudioRecvonly: function updateAudioRecvonly() {
        var self = this;

        if (!self.audioSection) {
            return;
        }

        self.audioSection = self.audioSection.replace(/sendrecv/g, "recvonly");
    },

    updateVCodes: function updateVCodes(vcodes) {
        var self = this;

        if (!vcodes) {
            return;
        }
        if (!self.videoSection) {
            return;
        }

        if (typeof vcodes === "string") {
            var arr = [];
            arr.push(vcodes);
            vcodes = arr;
        }

        var vcodeMap = {};
        var regexp = /a=rtpmap:(\d+) ([A-Za-z0-9]+)\/.*/ig;
        var arr = self._parseLine(self.videoSection, regexp);
        for (var i = 0; i < arr.length; i++) {
            var codeNum = arr[++i];
            var code = arr[++i];
            vcodeMap[code] = codeNum;
        }

        //H264
        //if(/Firefox/.test(navigator.userAgent) || /Chrome/.test(navigator.userAgent)){ //a=fmtp:126 profile-level-id=42e01f;level-asymmetry-allowed=1;packetization-mode=1
        var h264_regexp = /a=fmtp:(\d+) .*profile-level-id=42e01f;?.*/ig;
        var h264_arr = self._parseLine(self.videoSection, h264_regexp);

        if (h264_arr && h264_arr.length >= 2) {
            vcodeMap['H264'] = h264_arr[1];
        }
        //}

        var numCodes = [];
        for (var i = 0; i < vcodes.length; i++) {
            var supportVCode = vcodeMap[vcodes[i]];
            supportVCode && numCodes.push(supportVCode);
        }
        if (numCodes.length == 0) {
            _logger.warn("Not found vcodes map", vcodes);
            if (self._webrtc) {
                _logger.warn("Not found vcodes map", vcodes, self._webrtc._rtcId, self._webrtc.__id);
            }
        }

        var codeLineLastIndex = self.videoSection.indexOf('\r');
        var codeLine = self.videoSection.substring(0, codeLineLastIndex);

        var fields = codeLine.split(' ');

        Array.prototype.push.apply(numCodes, fields.slice(3));

        var newNumCodes = [];
        var _map = {};
        _util.forEach(numCodes, function (index, ele) {
            if (newNumCodes.length == 0) {
                newNumCodes.push(ele);
                _map[ele] = true;
            } else {
                if (!_map[ele]) {
                    newNumCodes.push(ele);
                    _map[ele] = true;
                }
            }
        });
        //alert(numCodes.join(' '));

        //fields.splice(3, 0, numCodes);
        fields.splice(3, fields.length - 3, newNumCodes.join(' '));

        codeLine = fields.join(' ');
        //_logger.info(codeLine);
        if (self._webrtc) {
            _logger.warn(codeLine, self._webrtc._rtcId, self._webrtc.__id);
        }

        self.videoSection = codeLine + self.videoSection.substring(codeLineLastIndex);
    },

    removeSSRC: function removeSSRC(section) {
        var arr = [];

        var _arr = section.split(/a=ssrc:[^\n]+/g);
        for (var i = 0; i < _arr.length; i++) {
            _arr[i] != '\n' && arr.push(_arr[i]);
        }
        // arr.push('');

        return arr.join('\n');
    },

    removeField_msid: function removeField_msid(section) {
        var arr = [];

        var _arr = section.split(/a=msid:[^\n]+/g);
        for (var i = 0; i < _arr.length; i++) {
            _arr[i] != '\n' && arr.push(_arr[i]);
        }
        // arr.push('');

        section = arr.join('\n');
        arr = [];

        _arr = section.split(/[\n]+/g);
        for (var i = 0; i < _arr.length; i++) {
            _arr[i] != '\n' && arr.push(_arr[i]);
        }

        return arr.join('\n');
    },

    updateHeaderMsidSemantic: function updateHeaderMsidSemantic(wms) {

        var self = this;

        var line = "a=msid-semantic: WMS " + wms;

        var _arr = self.headerSection.split(/a=msid\-semantic: WMS.*/g);
        var arr = [];
        switch (_arr.length) {
            case 1:
                arr.push(_arr[0]);
                break;
            case 2:
                arr.push(_arr[0]);
                arr.push(line);
                arr.push('\n');
                break;
            case 3:
                arr.push(_arr[0]);
                arr.push(line);
                arr.push('\n');
                arr.push(_arr[2]);
                arr.push('\n');
                break;
        }

        return self.headerSection = arr.join('');
    },

    updateAudioSSRCSection: function updateAudioSSRCSection(ssrc, cname, msid, label) {
        var self = this;

        self.audioSection && (self.audioSection = self.removeSSRC(self.audioSection));
        self.audioSection && (self.audioSection = self.removeField_msid(self.audioSection));
        self.audioSection && (self.audioSection = self.audioSection + self.ssrcSection(ssrc, cname, msid, label));
    },

    updateVideoSSRCSection: function updateVideoSSRCSection(ssrc, cname, msid, label) {
        var self = this;

        self.videoSection && (self.videoSection = self.removeSSRC(self.videoSection));
        self.videoSection && (self.videoSection = self.removeField_msid(self.videoSection));
        self.videoSection && (self.videoSection = self.videoSection + self.ssrcSection(ssrc, cname, msid, label));
    },

    getUpdatedSDP: function getUpdatedSDP(audioVideo) {
        var self = this;

        var sdp = "";

        self.headerSection && (sdp += self.headerSection);

        if (audioVideo === true || audioVideo === undefined && self._preAudioIndex < self._preVideoIndex) {
            self.audioSection && (sdp += self.audioSection);
            self.videoSection && (sdp += self.videoSection);
        } else {
            if (audioVideo === false && self.videoSection && self.audioSection) {
                var videoMid;
                self.videoSection.replace(/a=mid:([^\r\n]+)/, function (match, p1) {
                    videoMid = p1;
                    return match;
                });

                var audioMid;
                self.audioSection.replace(/a=mid:([^\r\n]+)/, function (match, p1) {
                    audioMid = p1;
                    return match;
                });

                sdp = self.headerSection.replace(/a=group:BUNDLE [^\r\n]+/, "a=group:BUNDLE " + videoMid + " " + audioMid);
            }

            self.videoSection && (sdp += self.videoSection);
            self.audioSection && (sdp += self.audioSection);
        }

        return sdp;
    },

    parseMsidSemantic: function parseMsidSemantic(header) {
        var self = this;

        var regexp = /a=msid\-semantic:\s*WMS (\S+)/ig;
        var arr = self._parseLine(header, regexp);

        arr && arr.length == 2 && (self.msidSemantic = {
            line: arr[0],
            WMS: arr[1]
        });

        return self.msidSemantic;
    },

    ssrcSection: function ssrcSection(ssrc, cname, msid, label) {
        var lines = ['a=ssrc:' + ssrc + ' cname:' + cname, 'a=ssrc:' + ssrc + ' msid:' + msid + ' ' + label, 'a=ssrc:' + ssrc + ' mslabel:' + msid, 'a=ssrc:' + ssrc + ' label:' + label, ''];

        return lines.join('\n');
    },

    parseSSRC: function parseSSRC(section) {
        var self = this;

        var regexp = new RegExp("a=(ssrc):(\\d+) (\\S+):(\\S+)", "ig");

        var arr = self._parseLine(section, regexp);
        if (arr) {
            var ssrc = {
                lines: [],
                updateSSRCSection: self.ssrcSection
            };

            for (var i = 0; i < arr.length; i++) {
                var e = arr[i];
                if (e.indexOf("a=ssrc") >= 0) {
                    ssrc.lines.push(e);
                } else {
                    switch (e) {
                        case 'ssrc':
                        case 'cname':
                        case 'msid':
                        case 'mslabel':
                        case 'label':
                            ssrc[e] = arr[++i];
                    }
                }
            }

            return ssrc;
        }
    },

    _parseLine: function _parseLine(str, regexp) {
        var arr = [];

        var _arr;
        while ((_arr = regexp.exec(str)) != null) {
            for (var i = 0; i < _arr.length; i++) {
                arr.push(_arr[i]);
            }
        }

        if (arr.length > 0) {
            return arr;
        }
    }
};

var SDPSection = function SDPSection(sdp, webrc) {
    _util.extend(this, _SDPSection);
    this._webrtc = webrc;
    this.spiltSection(sdp);
};

SDPSection.isAudioVideo = function (sdp) {
    var audioIndex = sdp.indexOf('m=audio');
    var videoIndex = sdp.indexOf('m=video');

    return audioIndex < videoIndex;
};

SDPSection.isVideoPreAudio = function (sdp) {
    var audioIndex = sdp.indexOf('m=audio');
    var videoIndex = sdp.indexOf('m=video');

    return audioIndex >= 0 && videoIndex >= 0 && videoIndex < audioIndex;
};

var __rtc_globalCount = emedia.__rtc_globalCount = 0;

/**
 * Abstract
 * {
 *   onIceStateChange:
 *   onIceCandidate:
 *   onGotRemoteStream:
 *
 *   createRtcPeerConnection:
 *   createOffer:
 *   createPRAnswer:
 *   createAnswer:
 *   addIceCandidate:
 *   close:
 *   iceState:
 *
 *   setLocalStream:
 *   getRtcId:
 * }
 *
 */
/**
 * ICE 通道失败：
 * 1.set sdp 失败
 * 2.set cands 失败
 * 但最终都是 ice fail
 *
 *
 * onSetSessionDescriptionError
 * onCreateSessionDescriptionError
 * onAddIceCandidateError
 *
 * onIceStateChange  ice fail
 *
 */
var _WebRTC = _util.prototypeExtend({
    closed: false,
    sdpConstraints: {
        'mandatory': {
            'OfferToReceiveAudio': true,
            'OfferToReceiveVideo': true
        }
    },

    /**
     * offerToReceiveAudio false sendonly, or sendrecv
     * offerToReceiveVideo false sendonly, or sendrecv
     *
     */
    offerOptions: {
        offerToReceiveAudio: true,
        offerToReceiveVideo: true
        //voiceActivityDetection: false
    },

    optimalVideoCodecs: null,
    optimalAudioCodecs: null,

    __init__: function __init__() {
        var self = this;

        self._rtcId || (self._rtcId = "RTC" + __rtc_globalCount++);
        self.__id = "_i_" + __rtc_globalCount++;

        self.__setRemoteSDP = false;
        self.__tmpRemoteCands = [];
        self.__tmpLocalCands = [];
        self._rtcPeerConnection = null;

        self.cctx = self.__id;

        _logger.info("Webrtc created.", self._rtcId, self.__id);
    },

    getRtcId: function getRtcId() {
        return this._rtcId;
    },

    iceState: function iceState() {
        var self = this;
        return self._rtcPeerConnection.iceConnectionState;
    },

    setSubArgs: function setSubArgs(subArgs) {
        var self = this;
        self.subArgs = subArgs;
    },

    getReceiversOfPeerConnection: function getReceiversOfPeerConnection() {
        var self = this;

        if (!self._rtcPeerConnection) {
            return;
        }

        if (self._rtcPeerConnection.iceConnectionState == 'closed') {
            return;
        }

        return self._rtcPeerConnection.getReceivers();
    },

    updateRemoteBySubArgs: function updateRemoteBySubArgs() {
        var self = this;

        if (!self.subArgs) {
            return;
        }
        if (!self._remoteStream) {
            return;
        }

        emedia.enableVideoTracks(self._remoteStream, !(self.subArgs && self.subArgs.subSVideo === false));
        emedia.enableAudioTracks(self._remoteStream, !(self.subArgs && self.subArgs.subSAudio === false));

        _logger.info("enable tracks remote stream", self._remoteStream, self.subArgs, self._rtcId, self.__id, self.closed);
    },

    createRtcPeerConnection: function createRtcPeerConnection(iceServerConfig) {
        var self = this;
        _logger.debug('begin create peer connection ......', self._rtcId, self.__id, self.closed);

        iceServerConfig || (iceServerConfig = self.iceServerConfig);

        if (iceServerConfig || emedia.isEdge) {
            //reduce icecandidate number:add default value
            iceServerConfig || (iceServerConfig = {});
            !iceServerConfig.iceServers && (iceServerConfig.iceServers = []);

            iceServerConfig.rtcpMuxPolicy = "require";
            iceServerConfig.bundlePolicy = "max-bundle";

            //iceServerConfig.iceTransportPolicy = 'relay';
            if (iceServerConfig.relayOnly) {
                iceServerConfig.iceTransportPolicy = 'relay';
            }
        } else {
            iceServerConfig = null;
        }

        // iceServerConfig = {
        //     capAudio: true,
        //     capVideo: true,
        //     iceServers:[{
        //         credential: "+F34cGoWeMmwa+XtvibM7dr4Ccc=",
        //         url: "turn:101.200.76.93:3478",
        //         username: "easemob-demo#chatdemoui_yss000@easemob.com/webim_device_uuid%179310420104847360:1506431735"
        //     }],
        //     recvAudio: true,
        //     recvVideo: true,
        //     relayOnly: false,
        // };
        _logger.info('create pc, set config:', iceServerConfig, self._rtcId, self.__id, self.closed);

        var rtcPeerConnection = self._rtcPeerConnection = new RTCPeerConnection(iceServerConfig);
        rtcPeerConnection.__peerId = self._rtcId;
        _logger.debug('created local peer connection object', rtcPeerConnection, self._rtcId);

        rtcPeerConnection.onicecandidate = function (event) {
            var candidate = event.candidate;

            //reduce icecandidate number: don't deal with tcp, udp only
            if (event.type == "icecandidate" && (!candidate || typeof candidate.protocol === 'string' && candidate.protocol.toLowerCase() === 'tcp' || / TCP /.test(candidate.candidate))) {
                _logger.debug("On ICE candidate: drop", candidate, self._rtcId, self.__id, self.closed);
                return;
            }

            if (!candidate.candidate) {
                _logger.error("Not found candidate. candidate is error");
                throw "Not found candidate. candidate is error,";
            }

            candidate.cctx = self.cctx;
            if (!self.__setRemoteSDP) {
                (self.__tmpLocalCands || (self.__tmpLocalCands = {})).push(candidate);
                _logger.debug('On ICE candidate ok: but tmp buffer caused by not set remote sdp: ', candidate, self._rtcId, self.__id, self.closed);
                return;
            } else {
                _logger.debug('On ICE candidate ok: ', candidate, self._rtcId, self.__id, self.closed);
            }
            self._onIceCandidate(candidate);
        };

        function stateChange(event) {
            _logger.info("states: conn", rtcPeerConnection.connectionState || rtcPeerConnection.iceConnectionState, ", ice", rtcPeerConnection.iceConnectionState, "@", self._rtcId, self.__id, self.closed);
            try {
                self.onIceStateChange(rtcPeerConnection.iceConnectionState);
            } finally {}
        }

        rtcPeerConnection.onconnectionstatechange = stateChange.bind(self);
        rtcPeerConnection.onicestatechange = stateChange.bind(self);
        rtcPeerConnection.oniceconnectionstatechange = stateChange.bind(self);
        rtcPeerConnection.onsignalingstatechange = function (event) {
            _logger.info("states: signaling", rtcPeerConnection.signalingState, "@", self._rtcId, self.__id, self.closed);
        };

        if (rtcPeerConnection.ontrack === null) {
            self._onTrack && (rtcPeerConnection.ontrack = function (event) {
                self._onTrack(event);
            });
        }

        rtcPeerConnection.onaddstream = function (event) {
            self._onGotRemoteStream(event);
        };
    },

    addTrack: function addTrack(tracks, stream) {
        var self = this;

        tracks.forEach(function (track) {
            self._rtcPeerConnection.addTrack(track, stream);
        });
    },
    setLocalStream: function setLocalStream(localStream) {
        var self = this;

        self._localStream = localStream;

        if (self._rtcPeerConnection.addTrack) {
            localStream.getTracks().forEach(function (track) {
                self._rtcPeerConnection.addTrack(track, localStream);
            });
        } else {
            self._rtcPeerConnection.addStream(localStream);
        }
        _logger.debug('Added local stream to RtcPeerConnection', localStream, self._rtcId, self.__id, this.closed);
    },

    removeStream: function removeStream(mediaStream) {
        this._rtcPeerConnection.removeStream(mediaStream);
        _logger.debug('Remove stream from RtcPeerConnection', mediaStream, self._rtcId, self.__id, this.closed);
    },

    getLocalStream: function getLocalStream() {
        return this._localStream;
    },
    getRemoteStream: function getRemoteStream() {
        return this._remoteStream;
    },

    createOffer: function createOffer(onCreateOfferSuccess, onCreateOfferError) {
        var self = this;

        _logger.debug('createOffer start...', self.offerOptions);

        var offerOptions = _util.extend({}, self.offerOptions);

        //offerToReceiveAudio = false时，chrome没有video段；safari却这个块。需要将sendrecv改为sendonly
        //由于手机没有视频发布时，sdp中有video字段，而 web以offerToReceiveVideo = false去订阅时，导致订阅流中没有video块，会引发重协商。进而导致 始终无法看到对方视频
        //所以 订阅流时 无论offerToReceiveVideo = false，都生成offer sdp；其中都有video块。即 offerToReceiveVideo = true；但要将sdp修改为recvonly
        if (self.subArgs) {
            offerOptions = {
                offerToReceiveAudio: true,
                offerToReceiveVideo: true
            };
        }

        return self._rtcPeerConnection.createOffer(offerOptions).then(function (desc) {
            self.offerDescription = desc;

            if (emedia.isEdge) {
                desc.sdp = desc.sdp.replace(/profile-level-id=[^;]+/, "profile-level-id=42e01f");
            }
            if (emedia.isFirefox) {
                //需要交换 cand answer
                self.fireFoxOfferVideoPreAudio = self.__offerVideoPreAudio = SDPSection.isVideoPreAudio(desc.sdp);
            } else {
                self.__offerVideoPreAudio = SDPSection.isVideoPreAudio(desc.sdp); // video在audio前时，xswitch的answer是 audio在前。set answer时需要 变换answer
            }

            desc.sdp = desc.sdp.replace(/m=video 0/g, "m=video 9");
            _logger.warn("setLocalDescription. modify offer. if 'm=video 0' -> 'm=video 9'; if H264, 'profile-level-id=42e01f'", self._rtcId, self.__id);

            var updateVCodes;
            if ((updateVCodes = self.optimalVideoCodecs && (typeof self.optimalVideoCodecs === "string" || self.optimalVideoCodecs.length > 0)) || self.offerOptions && (self.offerOptions.offerToReceiveVideo === false || self.offerOptions.offerToReceiveAudio === false)) {
                var sdpSection = new SDPSection(desc.sdp, self);
                updateVCodes && sdpSection.updateVCodes(self.optimalVideoCodecs);

                // if(!emedia.isSafari && self.subArgs){ //订阅流
                // }else if(emedia.isSafari){
                //     self.offerOptions && self.offerOptions.offerToReceiveVideo === false
                //         && sdpSection.updateVideoSection(/a=sendrecv|a=recvonly/g, "a=sendonly");
                //     self.offerOptions && self.offerOptions.offerToReceiveAudio === false
                //         && sdpSection.updateAudioSection(/a=sendrecv|a=recvonly/g, "a=sendonly");
                // }
                self.offerOptions && self.offerOptions.offerToReceiveVideo === false && sdpSection.updateVideoSection(/a=sendrecv|a=recvonly/g, "a=sendonly");
                self.offerOptions && self.offerOptions.offerToReceiveAudio === false && sdpSection.updateAudioSection(/a=sendrecv|a=recvonly/g, "a=sendonly");

                desc.sdp = sdpSection.getUpdatedSDP();
            }

            _logger.debug('setLocalDescription start', desc, self._rtcId, self.__id, self.closed, self.optimalVideoCodecs);
            self._rtcPeerConnection.setLocalDescription(desc).then(self._onSetLocalSessionDescriptionSuccess.bind(self), self._onSetSessionDescriptionError.bind(self)).then(function () {
                desc.cctx = self.cctx;
                (onCreateOfferSuccess || self.onCreateOfferSuccess.bind(self))(desc);
            });
        }, onCreateOfferError || self._onCreateSessionDescriptionError.bind(self));
    },

    createPRAnswer: function createPRAnswer(onCreatePRAnswerSuccess, onCreatePRAnswerError) {
        var self = this;

        _logger.info(' createPRAnswer start', self.closed, self.sdpConstraints);
        // Since the 'remote' side has no media stream we need
        // to pass in the right constraints in order for it to
        // accept the incoming offer of audio and video.
        return self._rtcPeerConnection.createAnswer(self.sdpConstraints).then(function (desc) {
            _logger.debug('_____________PRAnswer ', desc.sdp, self._rtcId, self.__id, self.closed); //_logger.debug('from :\n' + desc.sdp);

            desc.type = "pranswer";
            desc.sdp = desc.sdp.replace(/a=recvonly/g, 'a=inactive');

            self.__prAnswerDescription = desc;

            _logger.debug('inactive PRAnswer ', desc.sdp, self._rtcId, self.__id, self.closed); //_logger.debug('from :\n' + desc.sdp);
            _logger.debug('setLocalDescription start', desc, self._rtcId, self.__id, self.closed);

            self._rtcPeerConnection.setLocalDescription(desc).then(self._onSetLocalSessionDescriptionSuccess.bind(self), self._onSetSessionDescriptionError.bind(self)).then(function () {
                var sdpSection = new SDPSection(desc.sdp);
                sdpSection.updateHeaderMsidSemantic("MS_0000");
                sdpSection.updateAudioSSRCSection(1000, "CHROME0000", "MS_0000", "LABEL_AUDIO_1000");
                sdpSection.updateVideoSSRCSection(2000, "CHROME0000", "MS_0000", "LABEL_VIDEO_2000");

                desc.sdp = sdpSection.getUpdatedSDP();

                _logger.debug('Send PRAnswer ', desc.sdp, self._rtcId, self.__id, self.closed); //_logger.debug('from :\n' + desc.sdp);

                self.cctx && (desc.cctx = self.cctx);
                (onCreatePRAnswerSuccess || self.onCreatePRAnswerSuccess.bind(self))(desc);
            });
        }, onCreatePRAnswerError || self._onCreateSessionDescriptionError.bind(self));
    },

    createAnswer: function createAnswer(onCreateAnswerSuccess, onCreateAnswerError) {
        var self = this;

        _logger.info('createAnswer start', self.closed, self.sdpConstraints);
        // Since the 'remote' side has no media stream we need
        // to pass in the right constraints in order for it to
        // accept the incoming offer of audio and video.
        return self._rtcPeerConnection.createAnswer(self.sdpConstraints).then(function (desc) {
            _logger.debug('_____________________Answer ', self._rtcId, self.__id, self.closed); //_logger.debug('from :\n' + desc.sdp);

            desc.type = 'answer';

            function updateSDP() {
                var sdpSection = new SDPSection(desc.sdp);
                var ms = sdpSection.parseMsidSemantic(sdpSection.headerSection);
                if (!ms) {
                    return;
                }

                if (ms.WMS == '*') {
                    sdpSection.updateHeaderMsidSemantic(ms.WMS = "MS_0000");
                }
                var audioSSRC = sdpSection.parseSSRC(sdpSection.audioSection);
                var videoSSRC = sdpSection.parseSSRC(sdpSection.videoSection);

                audioSSRC && sdpSection.updateAudioSSRCSection(1000, "CHROME0000", ms.WMS, audioSSRC.label || "LABEL_AUDIO_1000");
                if (videoSSRC) {
                    sdpSection.updateVideoSSRCSection(2000, "CHROME0000", ms.WMS, videoSSRC.label || "LABEL_VIDEO_2000");
                }
                // mslabel cname

                desc.sdp = sdpSection.getUpdatedSDP();
            }

            if (emedia.supportPRAnswer) {
                updateSDP();
            }

            self.__answerDescription = desc;

            _logger.debug('Answer ', self._rtcId, self.__id, self.closed); //_logger.debug('from :\n' + desc.sdp);
            _logger.debug('setLocalDescription start', desc, self._rtcId, self.__id, self.closed);

            self._rtcPeerConnection.setLocalDescription(desc).then(self._onSetLocalSessionDescriptionSuccess.bind(self), self._onSetSessionDescriptionError.bind(self)).then(function () {
                if (emedia.supportPRAnswer) {
                    var sdpSection = new SDPSection(desc.sdp);

                    sdpSection.updateHeaderMsidSemantic("MS_0000");
                    sdpSection.updateAudioSSRCSection(1000, "CHROME0000", "MS_0000", "LABEL_AUDIO_1000");
                    sdpSection.updateVideoSSRCSection(2000, "CHROME0000", "MS_0000", "LABEL_VIDEO_2000");

                    desc.sdp = sdpSection.getUpdatedSDP();
                }

                _logger.debug('Send Answer ', self._rtcId, self.__id, self.closed); //_logger.debug('from :\n' + desc.sdp);

                self.cctx && (desc.cctx = self.cctx);
                (onCreateAnswerSuccess || self.onCreateAnswerSuccess.bind(self))(desc);
            });
        }, onCreateAnswerError || self._onCreateSessionDescriptionError.bind(self));
    },

    close: function close(remainLocalStream, onlyPeerConnectionClosed) {
        var self = this;
        _logger.warn("webrtc closing", self._rtcId, self.__id, self.closed);

        if (self.closed) {
            return;
        }

        onlyPeerConnectionClosed = onlyPeerConnectionClosed === true;

        self.closed = true;

        try {
            self._rtcPeerConnection && self._rtcPeerConnection.close();
        } catch (e) {
            _logger.warn(e);
        } finally {
            if (self._localStream && remainLocalStream === false) {
                //localstream存在，不保留localstream
                emedia.stopTracks(self._localStream);
            }

            if (self._remoteStream) {
                emedia.stopTracks(self._remoteStream);
            }
            self._remoteStream = null;

            if (!onlyPeerConnectionClosed) {
                self.onClose && self.onClose();
            }

            _logger.warn("webrtc closed. closed:", self._rtcId, self.__id, self.closed);
        }
    },

    addIceCandidate: function addIceCandidate(candidate) {
        var self = this;

        if (!self._rtcPeerConnection) {
            return;
        }

        _logger.debug('Add ICE candidate: ', candidate, self._rtcId, self.__id, self.closed);

        var _cands = _util.isArray(candidate) ? candidate : [];
        !_util.isArray(candidate) && _cands.push(candidate);

        if (!self.__setRemoteSDP) {
            Array.prototype.push.apply(self.__tmpRemoteCands || (self.__tmpRemoteCands = {}), _cands);

            _logger.debug('Add ICE candidate but tmp buffer caused by not set remote sdp: ', candidate, self._rtcId, self.__id, self.closed);
            return;
        }

        for (var i = 0; i < _cands.length; i++) {
            candidate = _cands[i];

            if (candidate.cctx && candidate.cctx != self.cctx) {
                _logger.warn('addIceCandidate fail drop. cctx not equal. ', candidate, self._rtcId, self.__id, self.closed);
                continue;
            }

            //candidate.candidate = candidate.candidate.replace("172.17.2.130", "10.121.63.1");
            if (self.fireFoxOfferVideoPreAudio === true) {
                //candidate.sdpMid = "sdparta_0";
                var oldLineIndex = candidate.sdpMLineIndex;
                candidate.sdpMLineIndex = parseInt(candidate.sdpMid.replace(/[^0-9]*/, ''));
                _logger.warn("Firefox sdp section video pre audio, sdp mline index update ", oldLineIndex, "->", candidate.sdpMLineIndex);
            }

            if (candidate.candidate && candidate.candidate !== "") {
                self._rtcPeerConnection.addIceCandidate(new RTCIceCandidate(candidate)).then(self.onAddIceCandidateSuccess.bind(self), self._onAddIceCandidateError.bind(self));
            } else {
                _logger.warn("Add ICE candidate fail. drop it ", candidate, self._rtcId, self.__id, self.closed);
            }
        }
    },

    setRemoteDescription: function setRemoteDescription(desc) {
        var self = this;

        _logger.debug('setRemoteDescription start. ', self._rtcId, self.__id, self.closed);

        // 生成offer的
        // 会议模式，也是设置的是 pranswer 和 answer 会有服务器传回。
        // p2p模式下的主叫。此时设置的是 pranswer 和 answer。这个应该有p2p模式下传回。因此，需要如果有的话，需要判断
        if (self.offerDescription) {
            if (desc.cctx && desc.cctx != self.cctx) {
                _logger.warn('setRemoteDescription fail drop. cctx not equal. ', desc, self._rtcId, self.__id, self.closed);
                return;
            }

            if (self.fireFoxOfferVideoPreAudio === true || self.__offerVideoPreAudio === true) {
                //_logger.debug("Remote sdp.1", desc.sdp);

                var sdpSection = new SDPSection(desc.sdp, self);
                desc.sdp = sdpSection.getUpdatedSDP(false);
                _logger.info("Remote sdp.2. switch audio video", desc.sdp);
            }
        } else {
            //被叫 p2p模式，覆盖
            desc.cctx && (self.cctx = desc.cctx);
        }

        desc.sdp = desc.sdp.replace(/UDP\/TLS\/RTP\/SAVPF/g, "RTP/SAVPF");
        _logger.warn('setRemoteDescription. UDP/TLS/RTP/SAVPF -> RTP/SAVPF; if firefox: switch audio video;', self._rtcId, self.__id);
        _logger.debug('setRemoteDescription.', desc, self._rtcId, self.__id);

        // https://webrtchacks.com/limit-webrtc-bandwidth-sdp/
        // bitrate
        if (self.vbitrate || self.abitrate) {
            var sdpSection = new SDPSection(desc.sdp, self);

            self.vbitrate && sdpSection.setVideoBitrate(self.vbitrate);
            self.abitrate && sdpSection.setAudioBitrate(self.abitrate);

            _logger.warn("vbitrate = ", self.vbitrate, ", abitrate = ", self.abitrate, self._rtcId, self.__id);
            desc.sdp = sdpSection.getUpdatedSDP();
        }

        desc = self.__remoteDescription = new RTCSessionDescription(desc);

        return self._rtcPeerConnection.setRemoteDescription(desc).then(function () {
            self.__setRemoteSDP = true;
            self._onSetRemoteSuccess.apply(self, arguments);

            if (self.__tmpLocalCands && self.__tmpLocalCands.length > 0) {
                _logger.debug('After setRemoteDescription. send cands', self._rtcId, self.__id, self.closed);
                self._onIceCandidate(self.__tmpLocalCands);

                self.__tmpLocalCands = [];
            }

            if (self.__tmpRemoteCands && self.__tmpRemoteCands.length > 0) {
                _logger.debug('After setRemoteDescription. add tmp cands', self._rtcId, self.__id, self.closed);
                self.addIceCandidate(self.__tmpRemoteCands);

                self.__tmpRemoteCands = [];
            }
        }, self._onSetSessionDescriptionError.bind(self));
    },

    iceConnectionState: function iceConnectionState() {
        var self = this;

        return self._rtcPeerConnection.iceConnectionState;
    },

    isConnected: function isConnected() {
        var self = this;

        var state = self._rtcPeerConnection.iceConnectionState;

        return "connected" === state || "completed" === state;
    },

    _onGotRemoteStream: function _onGotRemoteStream(event) {
        var self = this;

        _logger.debug('onGotRemoteStream.', self._rtcId, self.__id, event);
        this._remoteStream = event.stream || event.streams[0];
        this._remoteStream._rtcId = this._rtcId;
        this._remoteStream.__rtc_c_id = this.__id;

        self.updateRemoteBySubArgs();

        this.onGotRemoteStream(this._remoteStream, event);

        _logger.debug('received remote stream, you will see the other.', self._rtcId, self.__id, this.closed);
    },

    _onSetRemoteSuccess: function _onSetRemoteSuccess() {
        _logger.info('onSetRemoteSuccess success', this._rtcId, this.__id);
        this.onSetRemoteSuccess.apply(this, arguments);

        if (this.offerDescription && this.__remoteDescription && this.__remoteDescription.sdp) {
            this._onAnswerCodes(this.__remoteDescription.sdp);
        }
    },

    _onAnswerCodes: function _onAnswerCodes(sdp) {
        var self = this;
        var section = new SDPSection(sdp, this);
        if (section.videoSection) {
            var rtpParams = SDPUtils.parseRtpParameters(section.videoSection);

            if (!rtpParams.codecs || rtpParams.codecs.length === 0) {
                _logger.info("not found any video codes. @ ", self._rtcId, self.__id);
                return;
            }

            var vcodes = [];
            _util.forEach(rtpParams.codecs, function (_i, _param) {
                vcodes.push(_param.name);
            });

            self.finalVCodeChoices = vcodes;

            self.onVCodeChoices && self.onVCodeChoices(vcodes);
        }
    },

    onSetRemoteSuccess: function onSetRemoteSuccess() {},

    onAddIceCandidateSuccess: function onAddIceCandidateSuccess() {
        _logger.debug('addIceCandidate success', this._rtcId, this.__id);
    },

    _onAddIceCandidateError: function _onAddIceCandidateError(error) {
        _logger.error('failed to add ICE Candidate: ' + error.toString(), this._rtcId, this.__id);
        this.onAddIceCandidateError(error);
    },
    onAddIceCandidateError: function onAddIceCandidateError(error) {},

    _onIceCandidate: function _onIceCandidate(candidate) {
        _logger.debug('onIceCandidate:', candidate, this._rtcId, this.__id);
        this.onIceCandidate(candidate);
    },
    onIceCandidate: function onIceCandidate(candidate) {},

    onIceStateChange: function onIceStateChange(state) {
        _logger.debug('onIceStateChange : ICE state ', state);
    },

    _onCreateSessionDescriptionError: function _onCreateSessionDescriptionError(error) {
        _logger.error('Failed to create session description: ' + error.toString(), this._rtcId, this.__id);
        this.onCreateSessionDescriptionError(error);
    },
    onCreateSessionDescriptionError: function onCreateSessionDescriptionError(error) {},

    onCreateOfferSuccess: function onCreateOfferSuccess(desc) {
        _logger.debug('create offer success', this._rtcId, this.__id);
    },

    onCreatePRAnswerSuccess: function onCreatePRAnswerSuccess(desc) {
        _logger.debug('create answer success', this._rtcId, this.__id);
    },

    onCreateAnswerSuccess: function onCreateAnswerSuccess(desc) {
        _logger.debug('create answer success', this._rtcId, this.__id);
    },

    _onSetSessionDescriptionError: function _onSetSessionDescriptionError(error) {
        _logger.error('onSetSessionDescriptionError : Failed to set session description: ' + error.toString(), this._rtcId, this.__id);
        this.onSetSessionDescriptionError(error);
    },
    onSetSessionDescriptionError: function onSetSessionDescriptionError(error) {},
    _onSetLocalSessionDescriptionSuccess: function _onSetLocalSessionDescriptionSuccess() {
        _logger.debug('onSetLocalSessionDescriptionSuccess : setLocalDescription complete', this._rtcId, this.__id);
        this.onSetLocalSessionDescriptionSuccess();

        if (this.__answerDescription && this.__answerDescription.sdp) {
            this._onAnswerCodes(this.__answerDescription.sdp);
        }
    },
    onSetLocalSessionDescriptionSuccess: function onSetLocalSessionDescriptionSuccess() {},

    onGotRemoteStream: function onGotRemoteStream(remoteStream) {
        _logger.debug("Got remote stream. ", remoteStream, this._rtcId, this.__id);
    }
});

module.exports = _WebRTC;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 /* eslint-env node */


// SDP helpers.
var SDPUtils = {};

// Generate an alphanumeric identifier for cname or mids.
// TODO: use UUIDs instead? https://gist.github.com/jed/982883
SDPUtils.generateIdentifier = function() {
  return Math.random().toString(36).substr(2, 10);
};

// The RTCP CNAME used by all peerconnections from the same JS.
SDPUtils.localCName = SDPUtils.generateIdentifier();

// Splits SDP into lines, dealing with both CRLF and LF.
SDPUtils.splitLines = function(blob) {
  return blob.trim().split('\n').map(function(line) {
    return line.trim();
  });
};
// Splits SDP into sessionpart and mediasections. Ensures CRLF.
SDPUtils.splitSections = function(blob) {
  var parts = blob.split('\nm=');
  return parts.map(function(part, index) {
    return (index > 0 ? 'm=' + part : part).trim() + '\r\n';
  });
};

// returns the session description.
SDPUtils.getDescription = function(blob) {
  var sections = SDPUtils.splitSections(blob);
  return sections && sections[0];
};

// returns the individual media sections.
SDPUtils.getMediaSections = function(blob) {
  var sections = SDPUtils.splitSections(blob);
  sections.shift();
  return sections;
};

// Returns lines that start with a certain prefix.
SDPUtils.matchPrefix = function(blob, prefix) {
  return SDPUtils.splitLines(blob).filter(function(line) {
    return line.indexOf(prefix) === 0;
  });
};

// Parses an ICE candidate line. Sample input:
// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
// rport 55996"
SDPUtils.parseCandidate = function(line) {
  var parts;
  // Parse both variants.
  if (line.indexOf('a=candidate:') === 0) {
    parts = line.substring(12).split(' ');
  } else {
    parts = line.substring(10).split(' ');
  }

  var candidate = {
    foundation: parts[0],
    component: parseInt(parts[1], 10),
    protocol: parts[2].toLowerCase(),
    priority: parseInt(parts[3], 10),
    ip: parts[4],
    port: parseInt(parts[5], 10),
    // skip parts[6] == 'typ'
    type: parts[7]
  };

  for (var i = 8; i < parts.length; i += 2) {
    switch (parts[i]) {
      case 'raddr':
        candidate.relatedAddress = parts[i + 1];
        break;
      case 'rport':
        candidate.relatedPort = parseInt(parts[i + 1], 10);
        break;
      case 'tcptype':
        candidate.tcpType = parts[i + 1];
        break;
      case 'ufrag':
        candidate.ufrag = parts[i + 1]; // for backward compability.
        candidate.usernameFragment = parts[i + 1];
        break;
      default: // extension handling, in particular ufrag
        candidate[parts[i]] = parts[i + 1];
        break;
    }
  }
  return candidate;
};

// Translates a candidate object into SDP candidate attribute.
SDPUtils.writeCandidate = function(candidate) {
  var sdp = [];
  sdp.push(candidate.foundation);
  sdp.push(candidate.component);
  sdp.push(candidate.protocol.toUpperCase());
  sdp.push(candidate.priority);
  sdp.push(candidate.ip);
  sdp.push(candidate.port);

  var type = candidate.type;
  sdp.push('typ');
  sdp.push(type);
  if (type !== 'host' && candidate.relatedAddress &&
      candidate.relatedPort) {
    sdp.push('raddr');
    sdp.push(candidate.relatedAddress);
    sdp.push('rport');
    sdp.push(candidate.relatedPort);
  }
  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
    sdp.push('tcptype');
    sdp.push(candidate.tcpType);
  }
  if (candidate.usernameFragment || candidate.ufrag) {
    sdp.push('ufrag');
    sdp.push(candidate.usernameFragment || candidate.ufrag);
  }
  return 'candidate:' + sdp.join(' ');
};

// Parses an ice-options line, returns an array of option tags.
// a=ice-options:foo bar
SDPUtils.parseIceOptions = function(line) {
  return line.substr(14).split(' ');
}

// Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:
// a=rtpmap:111 opus/48000/2
SDPUtils.parseRtpMap = function(line) {
  var parts = line.substr(9).split(' ');
  var parsed = {
    payloadType: parseInt(parts.shift(), 10) // was: id
  };

  parts = parts[0].split('/');

  parsed.name = parts[0];
  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
  parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
  // legacy alias, got renamed back to channels in ORTC.
  parsed.numChannels = parsed.channels;
  return parsed;
};

// Generate an a=rtpmap line from RTCRtpCodecCapability or
// RTCRtpCodecParameters.
SDPUtils.writeRtpMap = function(codec) {
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  var channels = codec.channels || codec.numChannels || 1;
  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +
      (channels !== 1 ? '/' + channels : '') + '\r\n';
};

// Parses an a=extmap line (headerextension from RFC 5285). Sample input:
// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset
SDPUtils.parseExtmap = function(line) {
  var parts = line.substr(9).split(' ');
  return {
    id: parseInt(parts[0], 10),
    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
    uri: parts[1]
  };
};

// Generates a=extmap line from RTCRtpHeaderExtensionParameters or
// RTCRtpHeaderExtension.
SDPUtils.writeExtmap = function(headerExtension) {
  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +
      (headerExtension.direction && headerExtension.direction !== 'sendrecv'
          ? '/' + headerExtension.direction
          : '') +
      ' ' + headerExtension.uri + '\r\n';
};

// Parses an ftmp line, returns dictionary. Sample input:
// a=fmtp:96 vbr=on;cng=on
// Also deals with vbr=on; cng=on
SDPUtils.parseFmtp = function(line) {
  var parsed = {};
  var kv;
  var parts = line.substr(line.indexOf(' ') + 1).split(';');
  for (var j = 0; j < parts.length; j++) {
    kv = parts[j].trim().split('=');
    parsed[kv[0].trim()] = kv[1];
  }
  return parsed;
};

// Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeFmtp = function(codec) {
  var line = '';
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.parameters && Object.keys(codec.parameters).length) {
    var params = [];
    Object.keys(codec.parameters).forEach(function(param) {
      if (codec.parameters[param]) {
        params.push(param + '=' + codec.parameters[param]);
      } else {
        params.push(param);
      }
    });
    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
  }
  return line;
};

// Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
// a=rtcp-fb:98 nack rpsi
SDPUtils.parseRtcpFb = function(line) {
  var parts = line.substr(line.indexOf(' ') + 1).split(' ');
  return {
    type: parts.shift(),
    parameter: parts.join(' ')
  };
};
// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeRtcpFb = function(codec) {
  var lines = '';
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
    // FIXME: special handling for trr-int?
    codec.rtcpFeedback.forEach(function(fb) {
      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +
      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +
          '\r\n';
    });
  }
  return lines;
};

// Parses an RFC 5576 ssrc media attribute. Sample input:
// a=ssrc:3735928559 cname:something
SDPUtils.parseSsrcMedia = function(line) {
  var sp = line.indexOf(' ');
  var parts = {
    ssrc: parseInt(line.substr(7, sp - 7), 10)
  };
  var colon = line.indexOf(':', sp);
  if (colon > -1) {
    parts.attribute = line.substr(sp + 1, colon - sp - 1);
    parts.value = line.substr(colon + 1);
  } else {
    parts.attribute = line.substr(sp + 1);
  }
  return parts;
};

// Extracts the MID (RFC 5888) from a media section.
// returns the MID or undefined if no mid line was found.
SDPUtils.getMid = function(mediaSection) {
  var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];
  if (mid) {
    return mid.substr(6);
  }
}

SDPUtils.parseFingerprint = function(line) {
  var parts = line.substr(14).split(' ');
  return {
    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.
    value: parts[1]
  };
};

// Extracts DTLS parameters from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the fingerprint line as input. See also getIceParameters.
SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {
  var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
      'a=fingerprint:');
  // Note: a=setup line is ignored since we use the 'auto' role.
  // Note2: 'algorithm' is not case sensitive except in Edge.
  return {
    role: 'auto',
    fingerprints: lines.map(SDPUtils.parseFingerprint)
  };
};

// Serializes DTLS parameters to SDP.
SDPUtils.writeDtlsParameters = function(params, setupType) {
  var sdp = 'a=setup:' + setupType + '\r\n';
  params.fingerprints.forEach(function(fp) {
    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
  });
  return sdp;
};
// Parses ICE information from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the ice-ufrag and ice-pwd lines as input.
SDPUtils.getIceParameters = function(mediaSection, sessionpart) {
  var lines = SDPUtils.splitLines(mediaSection);
  // Search in session part, too.
  lines = lines.concat(SDPUtils.splitLines(sessionpart));
  var iceParameters = {
    usernameFragment: lines.filter(function(line) {
      return line.indexOf('a=ice-ufrag:') === 0;
    })[0].substr(12),
    password: lines.filter(function(line) {
      return line.indexOf('a=ice-pwd:') === 0;
    })[0].substr(10)
  };
  return iceParameters;
};

// Serializes ICE parameters to SDP.
SDPUtils.writeIceParameters = function(params) {
  return 'a=ice-ufrag:' + params.usernameFragment + '\r\n' +
      'a=ice-pwd:' + params.password + '\r\n';
};

// Parses the SDP media section and returns RTCRtpParameters.
SDPUtils.parseRtpParameters = function(mediaSection) {
  var description = {
    codecs: [],
    headerExtensions: [],
    fecMechanisms: [],
    rtcp: []
  };
  var lines = SDPUtils.splitLines(mediaSection);
  var mline = lines[0].split(' ');
  for (var i = 3; i < mline.length; i++) { // find all codecs from mline[3..]
    var pt = mline[i];
    var rtpmapline = SDPUtils.matchPrefix(
        mediaSection, 'a=rtpmap:' + pt + ' ')[0];
    if (rtpmapline) {
      var codec = SDPUtils.parseRtpMap(rtpmapline);
      var fmtps = SDPUtils.matchPrefix(
          mediaSection, 'a=fmtp:' + pt + ' ');
      // Only the first a=fmtp:<pt> is considered.
      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
      codec.rtcpFeedback = SDPUtils.matchPrefix(
          mediaSection, 'a=rtcp-fb:' + pt + ' ')
        .map(SDPUtils.parseRtcpFb);
      description.codecs.push(codec);
      // parse FEC mechanisms from rtpmap lines.
      switch (codec.name.toUpperCase()) {
        case 'RED':
        case 'ULPFEC':
          description.fecMechanisms.push(codec.name.toUpperCase());
          break;
        default: // only RED and ULPFEC are recognized as FEC mechanisms.
          break;
      }
    }
  }
  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function(line) {
    description.headerExtensions.push(SDPUtils.parseExtmap(line));
  });
  // FIXME: parse rtcp.
  return description;
};

// Generates parts of the SDP media section describing the capabilities /
// parameters.
SDPUtils.writeRtpDescription = function(kind, caps) {
  var sdp = '';

  // Build the mline.
  sdp += 'm=' + kind + ' ';
  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.
  sdp += ' UDP/TLS/RTP/SAVPF ';
  sdp += caps.codecs.map(function(codec) {
    if (codec.preferredPayloadType !== undefined) {
      return codec.preferredPayloadType;
    }
    return codec.payloadType;
  }).join(' ') + '\r\n';

  sdp += 'c=IN IP4 0.0.0.0\r\n';
  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';

  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
  caps.codecs.forEach(function(codec) {
    sdp += SDPUtils.writeRtpMap(codec);
    sdp += SDPUtils.writeFmtp(codec);
    sdp += SDPUtils.writeRtcpFb(codec);
  });
  var maxptime = 0;
  caps.codecs.forEach(function(codec) {
    if (codec.maxptime > maxptime) {
      maxptime = codec.maxptime;
    }
  });
  if (maxptime > 0) {
    sdp += 'a=maxptime:' + maxptime + '\r\n';
  }
  sdp += 'a=rtcp-mux\r\n';

  if (caps.headerExtensions) {
    caps.headerExtensions.forEach(function(extension) {
      sdp += SDPUtils.writeExtmap(extension);
    });
  }
  // FIXME: write fecMechanisms.
  return sdp;
};

// Parses the SDP media section and returns an array of
// RTCRtpEncodingParameters.
SDPUtils.parseRtpEncodingParameters = function(mediaSection) {
  var encodingParameters = [];
  var description = SDPUtils.parseRtpParameters(mediaSection);
  var hasRed = description.fecMechanisms.indexOf('RED') !== -1;
  var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;

  // filter a=ssrc:... cname:, ignore PlanB-msid
  var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
  .map(function(line) {
    return SDPUtils.parseSsrcMedia(line);
  })
  .filter(function(parts) {
    return parts.attribute === 'cname';
  });
  var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
  var secondarySsrc;

  var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')
  .map(function(line) {
    var parts = line.substr(17).split(' ');
    return parts.map(function(part) {
      return parseInt(part, 10);
    });
  });
  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
    secondarySsrc = flows[0][1];
  }

  description.codecs.forEach(function(codec) {
    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
      var encParam = {
        ssrc: primarySsrc,
        codecPayloadType: parseInt(codec.parameters.apt, 10),
      };
      if (primarySsrc && secondarySsrc) {
        encParam.rtx = {ssrc: secondarySsrc};
      }
      encodingParameters.push(encParam);
      if (hasRed) {
        encParam = JSON.parse(JSON.stringify(encParam));
        encParam.fec = {
          ssrc: secondarySsrc,
          mechanism: hasUlpfec ? 'red+ulpfec' : 'red'
        };
        encodingParameters.push(encParam);
      }
    }
  });
  if (encodingParameters.length === 0 && primarySsrc) {
    encodingParameters.push({
      ssrc: primarySsrc
    });
  }

  // we support both b=AS and b=TIAS but interpret AS as TIAS.
  var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');
  if (bandwidth.length) {
    if (bandwidth[0].indexOf('b=TIAS:') === 0) {
      bandwidth = parseInt(bandwidth[0].substr(7), 10);
    } else if (bandwidth[0].indexOf('b=AS:') === 0) {
      // use formula from JSEP to convert b=AS to TIAS value.
      bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95
          - (50 * 40 * 8);
    } else {
      bandwidth = undefined;
    }
    encodingParameters.forEach(function(params) {
      params.maxBitrate = bandwidth;
    });
  }
  return encodingParameters;
};

// parses http://draft.ortc.org/#rtcrtcpparameters*
SDPUtils.parseRtcpParameters = function(mediaSection) {
  var rtcpParameters = {};

  var cname;
  // Gets the first SSRC. Note that with RTX there might be multiple
  // SSRCs.
  var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
      .map(function(line) {
        return SDPUtils.parseSsrcMedia(line);
      })
      .filter(function(obj) {
        return obj.attribute === 'cname';
      })[0];
  if (remoteSsrc) {
    rtcpParameters.cname = remoteSsrc.value;
    rtcpParameters.ssrc = remoteSsrc.ssrc;
  }

  // Edge uses the compound attribute instead of reducedSize
  // compound is !reducedSize
  var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
  rtcpParameters.reducedSize = rsize.length > 0;
  rtcpParameters.compound = rsize.length === 0;

  // parses the rtcp-mux attrіbute.
  // Note that Edge does not support unmuxed RTCP.
  var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
  rtcpParameters.mux = mux.length > 0;

  return rtcpParameters;
};

// parses either a=msid: or a=ssrc:... msid lines and returns
// the id of the MediaStream and MediaStreamTrack.
SDPUtils.parseMsid = function(mediaSection) {
  var parts;
  var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');
  if (spec.length === 1) {
    parts = spec[0].substr(7).split(' ');
    return {stream: parts[0], track: parts[1]};
  }
  var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
  .map(function(line) {
    return SDPUtils.parseSsrcMedia(line);
  })
  .filter(function(parts) {
    return parts.attribute === 'msid';
  });
  if (planB.length > 0) {
    parts = planB[0].value.split(' ');
    return {stream: parts[0], track: parts[1]};
  }
};

// Generate a session ID for SDP.
// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1
// recommends using a cryptographically random +ve 64-bit value
// but right now this should be acceptable and within the right range
SDPUtils.generateSessionId = function() {
  return Math.random().toString().substr(2, 21);
};

// Write boilder plate for start of SDP
// sessId argument is optional - if not supplied it will
// be generated randomly
// sessVersion is optional and defaults to 2
SDPUtils.writeSessionBoilerplate = function(sessId, sessVer) {
  var sessionId;
  var version = sessVer !== undefined ? sessVer : 2;
  if (sessId) {
    sessionId = sessId;
  } else {
    sessionId = SDPUtils.generateSessionId();
  }
  // FIXME: sess-id should be an NTP timestamp.
  return 'v=0\r\n' +
      'o=thisisadapterortc ' + sessionId + ' ' + version + ' IN IP4 127.0.0.1\r\n' +
      's=-\r\n' +
      't=0 0\r\n';
};

SDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {
  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

  // Map ICE parameters (ufrag, pwd) to SDP.
  sdp += SDPUtils.writeIceParameters(
      transceiver.iceGatherer.getLocalParameters());

  // Map DTLS parameters to SDP.
  sdp += SDPUtils.writeDtlsParameters(
      transceiver.dtlsTransport.getLocalParameters(),
      type === 'offer' ? 'actpass' : 'active');

  sdp += 'a=mid:' + transceiver.mid + '\r\n';

  if (transceiver.direction) {
    sdp += 'a=' + transceiver.direction + '\r\n';
  } else if (transceiver.rtpSender && transceiver.rtpReceiver) {
    sdp += 'a=sendrecv\r\n';
  } else if (transceiver.rtpSender) {
    sdp += 'a=sendonly\r\n';
  } else if (transceiver.rtpReceiver) {
    sdp += 'a=recvonly\r\n';
  } else {
    sdp += 'a=inactive\r\n';
  }

  if (transceiver.rtpSender) {
    // spec.
    var msid = 'msid:' + stream.id + ' ' +
        transceiver.rtpSender.track.id + '\r\n';
    sdp += 'a=' + msid;

    // for Chrome.
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
        ' ' + msid;
    if (transceiver.sendEncodingParameters[0].rtx) {
      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
          ' ' + msid;
      sdp += 'a=ssrc-group:FID ' +
          transceiver.sendEncodingParameters[0].ssrc + ' ' +
          transceiver.sendEncodingParameters[0].rtx.ssrc +
          '\r\n';
    }
  }
  // FIXME: this should be written by writeRtpDescription.
  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
      ' cname:' + SDPUtils.localCName + '\r\n';
  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
        ' cname:' + SDPUtils.localCName + '\r\n';
  }
  return sdp;
};

// Gets the direction from the mediaSection or the sessionpart.
SDPUtils.getDirection = function(mediaSection, sessionpart) {
  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
  var lines = SDPUtils.splitLines(mediaSection);
  for (var i = 0; i < lines.length; i++) {
    switch (lines[i]) {
      case 'a=sendrecv':
      case 'a=sendonly':
      case 'a=recvonly':
      case 'a=inactive':
        return lines[i].substr(2);
      default:
        // FIXME: What should happen here?
    }
  }
  if (sessionpart) {
    return SDPUtils.getDirection(sessionpart);
  }
  return 'sendrecv';
};

SDPUtils.getKind = function(mediaSection) {
  var lines = SDPUtils.splitLines(mediaSection);
  var mline = lines[0].split(' ');
  return mline[0].substr(2);
};

SDPUtils.isRejected = function(mediaSection) {
  return mediaSection.split(' ', 2)[1] === '0';
};

SDPUtils.parseMLine = function(mediaSection) {
  var lines = SDPUtils.splitLines(mediaSection);
  var parts = lines[0].substr(2).split(' ');
  return {
    kind: parts[0],
    port: parseInt(parts[1], 10),
    protocol: parts[2],
    fmt: parts.slice(3).join(' ')
  };
};

SDPUtils.parseOLine = function(mediaSection) {
  var line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];
  var parts = line.substr(2).split(' ');
  return {
    username: parts[0],
    sessionId: parts[1],
    sessionVersion: parseInt(parts[2], 10),
    netType: parts[3],
    addressType: parts[4],
    address: parts[5],
  };
}

// Expose public methods.
if (true) {
  module.exports = SDPUtils;
}


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

var _util = __webpack_require__(15);

var SoundMeter = __webpack_require__(27);

/**
 * {
 *  _located:
 *  _webrtc:
 *
 *  id:
 *  memId:
 *  name:
 *  voff:
 *  aoff:
 *  type: 0 1
 *  ext:
 *  owner: {
 *    id:
 *    nickName:
 *    name:
 *    ext:
 *  }
 *
 *  _localMediaStream:
 * }
 *
 *
 *
 */

emedia.subscribed = function (stream) {
    if (stream._located) {
        return true;
    }

    if (stream.type === 2) {
        return !!(!stream._located && stream._webrtc);
    }

    return stream._webrtc !== undefined;
};

var MediaSoundMeter = _util.prototypeExtend({
    voff: 0,
    aoff: 0,

    __init__: function __init__() {
        var self = this;

        if (!self._mediaStream) {
            _logger.error("_mediaStream empty");
            throw "_mediaStream empty";
        }

        if (!self.hasEnabledTracks(self._mediaStream)) {
            return;
        }

        if (!self.__audioContext) {
            _logger.error("require audioContext");
            throw "require audioContext";
        }

        self.__soundMeter = new SoundMeter(self.__audioContext);

        self.__soundMeter.connectToSource(self._mediaStream, function (e) {
            if (e) {
                throw e;
            }
            self.__worked = self.__soundMeter.__worked = true;
        });
    },

    hasEnabledTracks: function hasEnabledTracks(mediaStream) {
        return emedia.hasEnabledTracks(mediaStream);
    },

    getSoundMeters: function getSoundMeters() {
        var self = this;

        if (!self.__soundMeter || !self.__worked) {
            return;
        }

        if (!self._mediaStream.active) {
            self.__worked && self._finally();
            return;
        }

        if (!self.hasEnabledTracks(self._mediaStream)) {
            return;
        }

        return {
            instant: self.__soundMeter.instant,
            slow: self.__soundMeter.slow,
            clip: self.__soundMeter.clip
        };
    },

    _finally: function _finally() {
        var self = this;

        if (self.__soundMeter) {
            self.__soundMeter.stop();
            self.__worked = self.__soundMeter.__worked = false;
        }
    }
});

module.exports = _util.prototypeExtend({ //type 0 AVpub 1 Desktop 2 Sub
    __undefinedEQDelete: true,

    Update: _util.prototypeExtend({

        ifAoff: function ifAoff(update) {
            this.if("aoff", update);
        },

        ifVoff: function ifVoff(update) {
            this.if("voff", update);
        },

        ifMediaStream: function ifMediaStream(update) {
            this.if("mediaStream", update);
        },

        if: function _if(key, update) {
            if (typeof this[key] === "undefined") {
                return;
            }

            update(this[key]);
        }
    }),

    located: function located() {
        return this._located || false;
    },

    webrtc: function webrtc(_webrtc) {
        _webrtc && (this._webrtc = _webrtc);
        return this;
    },

    getMediaStream: function getMediaStream() {
        if (typeof this.mediaStream !== "undefined") {
            return this.mediaStream;
        }

        // if(this.type === 2 && this._webrtc && this._webrtc.getRemoteStream()){
        //     return this._webrtc.getRemoteStream();
        // }

        if (this._located) {
            return this._localMediaStream;
        }

        return this._webrtc && (this._webrtc.getRemoteStream() || this._webrtc.getLocalStream());
    },

    requestFrame: function requestFrame() {
        this._localMediaStream && this._localMediaStream.getVideoTracks().forEach(function (track) {
            typeof track.requestFrame === "function" && track.requestFrame();
        });
    },

    getLocalMediaStream: function getLocalMediaStream() {
        return this._localMediaStream;
    },

    getRemoteMediaStream: function getRemoteMediaStream() {
        if (this._webrtc && typeof this._webrtc.getRemoteStream() !== "undefined") {
            return this._webrtc.getRemoteStream();
        }
    },

    mutedNeed: function mutedNeed() {
        return this.mutedMuted || false;
    },

    ifMediaStream: function ifMediaStream(update) {
        if (typeof this.mediaStream !== "undefined") {
            update(this.mediaStream);
            return;
        }

        // if(this.type === 2 && this._webrtc && this._webrtc.getRemoteStream() !== "undefined"){
        //     update(this._webrtc.getRemoteStream());
        //     return;
        // }

        if (this._located && typeof this._localMediaStream !== "undefined") {
            update(this._localMediaStream);
            return;
        }

        if (!this._located && this._webrtc && typeof this._webrtc.getRemoteStream() !== "undefined") {
            update(this._webrtc.getRemoteStream());
            return;
        }
    },

    subscribed: function subscribed() {
        return emedia.subscribed(this);
    },

    getHtmlDOMID: function getHtmlDOMID() {
        return "_m_" + this.owner.id + "_s_" + this.id;
    },

    MediaSoundMeter: MediaSoundMeter,

    StreamSoundMeter: _util.prototypeExtend({
        __init__: function __init__() {
            var self = this;

            if (!self._stream || typeof self._stream.getMediaStream !== 'function') {
                _logger.error("_stream empty or not found method getMediaStream");
                throw "_stream empty or not found method getMediaStream";
            }

            self._streamId = self._stream.id;
            self._streamCreateId = self._stream.__create_id;
            self._mediaStream = self._mediaStream;

            if (self._stream.type === 2 && !self._stream.located() && !self._webrtc) {
                _logger.error("require webrtc. when type = 2 and not located");
                throw "require webrtc. when type = 2 and not located";
            }

            self.__mediaSoundMeter = self.__mediaSoundMeter || new MediaSoundMeter({
                __audioContext: self.__audioContext,
                _mediaStream: self._mediaStream
            });
            self.__mediaSoundMeter.useCount = (self.__mediaSoundMeter.useCount || 0) + 1;
        },

        onSoundMeters: function onSoundMeters(callback) {
            var self = this;

            var emptyResult = {
                instant: 0,
                slow: 0,
                clip: 0
            };

            if (self._stream.aoff) {
                self._finally();
                callback(emptyResult);
                return emptyResult;
            }

            if (self._stream.type !== 2 && self._stream.subArgs && self._stream.subArgs.subSAudio !== undefined && !self._stream.subArgs.subSAudio) {
                self._finally();
                callback(emptyResult);
                return emptyResult;
            }

            if (self._stream.id == 0 || self._stream.type === 2 && !self._stream.located() && (!self._stream.subArgs || !self._stream.subArgs.subSAudio)) {
                var receivers = self._webrtc.getReceiversOfPeerConnection();

                if (!receivers || receivers.length === 0) {
                    callback(emptyResult);
                    return emptyResult;
                }

                var audioReceiver;
                for (var i in receivers) {
                    if (receivers[i].track.kind === 'audio') {
                        audioReceiver = receivers[i];
                    }
                }

                if (!audioReceiver) {
                    callback(emptyResult);
                    return emptyResult;
                }

                if (typeof audioReceiver.getContributingSources === 'function') {
                    var rtpContributingSources = audioReceiver.getContributingSources();
                    if (emedia.config._printSoundData) {
                        _util.logger.debug(self._stream.id, self._stream.csrc, "rtpContributingSources ", rtpContributingSources);
                    }

                    if (!rtpContributingSources || rtpContributingSources.length === 0) {
                        callback(emptyResult);
                        return emptyResult;
                    }

                    var source;
                    for (var i in rtpContributingSources) {
                        if (rtpContributingSources[i].source == self._stream.csrc) {
                            source = self._stream.csrc;
                        }
                    }

                    if (emedia.config._printSoundData) {
                        _util.logger.debug(self._stream.id, self._stream.csrc, "source ", source);
                    }

                    if (source === undefined) {
                        callback(emptyResult);
                        return emptyResult;
                    }
                }
            }

            var _meter = self.__mediaSoundMeter.getSoundMeters() || emptyResult;

            var webrtc = self._stream.type === 2 ? self._webrtc : self._stream._webrtc;
            if ((emedia.meterWithTrackAudioLevel || _meter.instant === 0) && webrtc && !webrtc.closed && webrtc._rtcPeerConnection) {
                webrtc._rtcPeerConnection.getStats().then(function (stats) {
                    if (stats.size > 0) {
                        stats.forEach(function (res) {
                            if (res.type === "track" && (res.kind === "audio" || res.trackIdentifier === "audio")) {
                                _meter.trackAudioLevel = res.audioLevel;
                                //_meter.trackTotalAudioEnergy = 0;
                                _meter.trackTotalAudioEnergy = res.totalAudioEnergy;
                                callback(_meter);
                            }
                        });
                    }
                });
            }

            callback(_meter);
        },

        _finally: function _finally() {
            var self = this;

            if (self._stream.type === 2 && self._stream.located() && self._remoteMediaSoundMeters) {
                self._remoteMediaSoundMeters._finally();
            }

            self.__mediaSoundMeter.useCount--;

            if (self.__mediaSoundMeter.useCount === 0) {
                self.__mediaSoundMeter._finally();
            }
        }
    })
});

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 *  Copyright (c) 2015 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */



// Meter class that generates a number correlated to audio volume.
// The meter class itself displays nothing, but it makes the
// instantaneous and time-decaying volumes available for inspection.
// It also reports on the fraction of samples that were at or near
// the top of the measurement range.

function SoundMeter(context) {
  this.context = context;
  this.instant = 0.0;
  this.slow = 0.0;
  this.clip = 0.0;
  this.script = context.createScriptProcessor(2048, 1, 1);
  var that = this;
  this.script.onaudioprocess = function (event) {
    var input = event.inputBuffer.getChannelData(0);
    var i;
    var sum = 0.0;
    var clipcount = 0;
    for (i = 0; i < input.length; ++i) {
      sum += input[i] * input[i];
      if (Math.abs(input[i]) > 0.99) {
        clipcount += 1;
      }
    }
    that.instant = Math.sqrt(sum / input.length);
    that.slow = 0.95 * that.slow + 0.05 * that.instant;
    that.clip = clipcount / input.length;
  };
}

SoundMeter.prototype.connectToSource = function (stream, callback) {
  console.log('SoundMeter connecting');
  try {
    this.mic = this.context.createMediaStreamSource(stream);
    this.mic.connect(this.script);
    // necessary to make sample run, but should not be.
    this.script.connect(this.context.destination);
    if (typeof callback !== 'undefined') {
      callback(null);
    }
  } catch (e) {
    console.error(e);
    if (typeof callback !== 'undefined') {
      callback(e);
    }
  }
};
SoundMeter.prototype.stop = function () {
  this.mic.disconnect();
  this.script.disconnect();
};

module.exports = SoundMeter;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {


var _util = __webpack_require__(15);
var _logger = _util.tagLogger("Handler");

var __event = __webpack_require__(21);

/**
 * Error({
 *   code:
 *   targetObj:
 *   evtObj:
 * })
 *
 *
 *
 *
 */
var Handler = _util.prototypeExtend({
    onEvent: function onEvent(evt) {
        var self = this;

        evt && _logger.info("[EVT]", evt.message(), evt.hidden || "");

        if (evt instanceof __event.ServerRefuseEnter) {
            evt.failed && evt.failed === -95270 && (evt.failed = -9527);
        }

        function afterNotify() {
            try {
                self.handleEvent(evt);
            } catch (e) {
                _logger.warn(e);
            }
        }

        if (evt instanceof emedia.event.StreamState && evt.stream && evt.stream.located()) {
            afterNotify();
            return;
        }

        try {
            evt.hidden || self.onNotifyEvent && self.onNotifyEvent(evt);
        } finally {
            afterNotify();
        }
    },

    handleEvent: function handleEvent(evt) {
        var self = this;

        if (evt instanceof __event.RecvResponse) {
            self._onRecvResponse(evt);
        } else if (evt instanceof __event.ServerRefuseEnter) {
            _logger.warn("Server refuse, ", evt.failed, evt.msg);
            self.onServerRefuseEnter(evt);
        } else if (evt instanceof __event.EnterFail) {
            _logger.warn("Enter fail, result = ", evt.failed);
            self.onEnterFail();
        } else if (evt instanceof __event.WSClose) {
            //_logger.warn("Websocket closed");
            self.onWSClose();
        } else if (evt instanceof __event.WSConnected) {
            _logger.warn("Websocket connected");
        } else if (evt instanceof __event.ICEConnected) {
            var webrtc = evt.webrtc;
            self.onICEConnected(webrtc);
        } else if (evt instanceof __event.ICEConnectFail) {
            var webrtc = evt.webrtc;
            self.onICEConnectFail(webrtc);
        } else if (evt instanceof __event.ICEDisconnected) {
            //只要ICE断开
            var webrtc = evt.webrtc;
            self.onICEDisconnected(webrtc);
        } else if (evt instanceof __event.ICEClosed) {
            //只要ICE断开
            var webrtc = evt.webrtc;
            self.onICEClosed(webrtc);
        } else if (evt instanceof __event.ICERemoteMediaStream) {
            self.onICERemoteMediaStream(evt.webrtc);
        } else if (evt instanceof __event.PushSuccess) {
            self._cacheStreams[evt.stream.id] = self._linkedStreams[evt.stream.id] = evt.stream;

            var _stream = self.newStream(evt.stream);

            if (evt.hidden && !self._maybeNotExistStreams[evt.stream.id] && !_stream.isRepublished) {
                self._onAddStream(_stream);
                return;
            }

            if (self.isSafari()) {
                emedia._isSafariYetPushedStream = true;
            }

            try {
                //_stream && (_stream.mediaStream = _stream.getMediaStream());
                _stream && self.onUpdateStream(_stream, new _stream.Update({ voff: _stream.voff, aoff: _stream.aoff, mediaStream: _stream.getMediaStream() }));

                // _util.forEach(self._cacheStreams, function (_pubSId, _stream) {
                //     if(_stream.type === 2){
                //         self.onStreamControl(undefined, _pubSId, _stream.voff, _stream._1_aoff);
                //     }
                // });
            } finally {
                if (self.isSafari()) {
                    _util.forEach(self._cacheStreams, function (_sid, _stream) {
                        if (_stream._autoSubWhenPushStream === true) {
                            _util.removeAttribute(_stream, "_autoSubWhenPushStream");
                            self.createWebrtcAndSubscribeStream(_stream.id);
                        }
                    });
                }
            }
        } else if (evt instanceof __event.SubSuccess) {
            self._linkedStreams[evt.stream.id] = evt.stream;
            evt.stream._zoom = 1;
        } else if (evt instanceof __event.PushFail) {
            if (evt.hidden !== true) {
                var _removeStream = _util.removeAttribute(self._linkedStreams, evt.stream.id);
                _logger.warn("PushFail remove from _linkedStreams", evt.stream.id, _removeStream);

                if (_removeStream) {
                    var _stream = self.newStream(evt.stream);
                    self.onRemoveStream(_stream);
                }
            }
        } else if (evt instanceof __event.SubFail) {
            if (evt.hidden !== true) {
                //delete self._linkedStreams[evt.stream.id];
                _util.removeAttribute(self._linkedStreams, evt.stream.id);
                _logger.warn("SubFail remove from _linkedStreams", evt.stream.id);

                var _stream = self.newStream(evt.stream);
                _stream.rtcId = undefined;
                _stream._webrtc = undefined;
                _stream.mediaStream = undefined;

                self.onUpdateStream(_stream, new _stream.Update(_stream));
            }
        } else if (evt instanceof __event.SubFailNotSupportVCodes) {
            // Server发现 此订阅时 不支持视频视频编码。或者 推送流 打开视频时，并不是所有的订阅端 都支持此视频编码
            // Server保持这个channel，客户端自行处理

            var stream = evt.stream;

            _logger.warn("Rtc donot support pub VCodes. close. sub fail.", stream.rtcId, " -> ", stream.id);
            try {
                self.onNotSupportPublishVideoCodecs && self.onNotSupportPublishVideoCodecs(stream);
            } catch (e) {
                _logger.warn(e);
            }

            // var streamId = stream.id;
            //
            // var webrtc = self._getWebrtc(streamId);
            // if(webrtc && webrtc.isConnected()){
            //     self.subscribeStream(webrtc._rtcId, streamId, undefined, {subSVideo: false, subSAudio: true});
            //     return;
            // }
        } else if (evt instanceof __event.EnterSuccess) {
            self.onEnterSuccess();
        } else if (evt instanceof __event.SwitchVCodes) {
            var stream = evt.stream;
            var useVCodes = evt.useVCodes;
            var webrtc = stream._webrtc;
            _logger.warn("Rtc switch VCodes. ", stream.id, useVCodes);

            if (!useVCodes || useVCodes.length == 0) {
                _logger.warn("Rtc switch VCodes. error! useVCodes is empty ", stream.id, useVCodes);
            }

            if (webrtc && webrtc.optimalVideoCodecs) {
                if (typeof webrtc.optimalVideoCodecs === 'string' && webrtc.optimalVideoCodecs == useVCodes[0]) {
                    _logger.warn("Rtc switch VCodes. igrone . useVCodes == optimalVideoCodecs ", stream.id, webrtc._rtcId, useVCodes);
                    return;
                }
                if (_util.isArray(webrtc.optimalVideoCodecs) && webrtc.optimalVideoCodecs.length > 0 && webrtc.optimalVideoCodecs[0] == useVCodes[0]) {
                    _logger.warn("Rtc switch VCodes. igrone ddd . useVCodes == optimalVideoCodecs ", stream.id, webrtc._rtcId, useVCodes);
                    return;
                }
            }

            stream.optimalVideoCodecs = useVCodes;

            webrtc && self.closeWebrtc(webrtc.getRtcId(), true);
            setTimeout(function () {
                stream.iceRebuildCount = 1;
                self.iceRebuild(stream);
                _logger.warn("Rtc switch VCodes. iceRebuild end.", stream.id, useVCodes);
            }, 300);
        }
    },

    _onRecvResponse: function _onRecvResponse(evt) {
        var self = this;

        var request = evt.request;
        var response = evt.response;

        if (request && response && request.op !== 200 && request.op !== 1002 && response.result !== 0) {

            _logger.warn("Server refuse. when request = ", request);

            var failed = evt.failed;
            switch (failed) {
                case -9527:
                case -95270:
                    //self.close(4, -9527);
                    break;
                case -500:
                case -502:
                case -504:
                case -508:
                case -510:
                    self.close(4, failed);
                    break;
                case -506:
                    self.close(11, failed);
                    break;

                case -501:
                    self.close(11, failed);
                default: // -501 异常引起 忽略
            }
        }
    },

    onServerRefuseEnter: function onServerRefuseEnter(evt) {
        var self = this;

        var failed = evt.failed;
        switch (failed) {
            case -9527:
            case -95270:
                self.close(4, -9527);
                break;
            case -500:
            case -502:
            case -504:
            case -508:
            case -510:
                self.close(4, failed);
                break;
            case -506:
                self.close(11, failed);
                break;
            default:
                self.close(2);
        }
    },

    onEnterFail: function onEnterFail() {
        var self = this;

        if (self.__getCopyInterval) {
            clearInterval(self.__getCopyInterval);
        }
    },

    onEnterSuccess: function onEnterSuccess() {
        var self = this;

        setTimeout(function () {
            self._failIcesRebuild();
        }, 200);

        if (self.getCopyIntervalMillis && self.getCopyIntervalMillis > 0) {
            _logger.warn("Run interval get copy. interval = ", self.getCopyIntervalMillis);

            if (self.__getCopyInterval) {
                clearInterval(self.__getCopyInterval);
            }

            self.__getCopyInterval = setInterval(function () {
                if (self._session.connected()) {
                    self._sysCopy.apply(self);
                } else {
                    _logger.warn("Warn! cannot get copy. cause offline.");

                    self.__getCopyInterval && clearInterval(self.__getCopyInterval);
                }
            }, self.getCopyIntervalMillis);
        }

        if (self.getMediaMeterIntervalMillis && self.getMediaMeterIntervalMillis > 0) {
            self._intervalGetMediaMeters();
        }
    },

    _intervalGetMediaMeters: function _intervalGetMediaMeters() {
        var self = this;

        function _start() {
            self.__getMediaMetersIntervalFlag && emedia.cancelAnimationFrame(self.__getMediaMetersIntervalFlag);

            if (!self.getMediaMeterIntervalMillis) {
                _logger.warn("Ontalking closed. please use getMediaMeterIntervalMillis");
                return;
            }
            self.__getMediaMetersIntervalFlag = emedia.requestAnimationFrame(function (time) {
                if (typeof emedia.AudioContext === 'function') {
                    self._flushMediaMetersByAudioContext.apply(self);
                }

                !(self.closed !== false) && _start();
            }, self.getMediaMeterIntervalMillis);
        }
        _start();
    },

    _flushMediaMetersByAudioContext: function _flushMediaMetersByAudioContext() {
        var self = this;

        _util.forEach(self._cacheStreams, function (_sid, _stream) {
            if (!self._monitSoundChanagedStreams || self._monitSoundChanagedStreams[_sid]) {
                _stream.id != "0" && self._updateMetersOrNewOne.call(self, _sid, _stream);
            }
        });

        var delStreamSoundMeters = [];
        _util.forEach(self._mediaMeters, function (_sid, streamSoundMeter) {
            var _stream = self._cacheStreams[_sid];
            _stream && self._updateMetersOrNewOne.call(self, _sid, _stream);
            _stream || delStreamSoundMeters.push(_sid);
        });

        _util.forEach(delStreamSoundMeters, function (index, _sid) {
            _util.removeAttribute(self._mediaMeters, _sid);
        });
    },

    _updateMetersOrNewOne: function _updateMetersOrNewOne(_sid, _stream) {
        var self = this;

        var metersData;

        var streamSoundMeter = self._mediaMeters[_sid];

        if (_stream.type === 2 && !_stream.located() && (!_stream.subArgs || !_stream.subArgs.subSAudio)) {
            var pubAudioMixersStream = self._oneAudioMixers();
            if (!pubAudioMixersStream || streamSoundMeter && streamSoundMeter._webrtc && pubAudioMixersStream._webrtc.__id != streamSoundMeter._webrtc.__id) {
                streamSoundMeter && streamSoundMeter._finally();
                _util.removeAttribute(self._mediaMeters, _sid);
                self._onSoundChanage.call(self, _stream.owner, _stream);

                return;
            }
        }

        if (streamSoundMeter && streamSoundMeter._streamCreateId === _stream.__create_id && streamSoundMeter.__mediaSoundMeter.__worked) {

            streamSoundMeter.onSoundMeters(function (metersData) {
                self._onSoundChanage.call(self, _stream.owner, _stream, metersData);
            });

            return streamSoundMeter;
        }

        if (streamSoundMeter && (streamSoundMeter._streamCreateId !== _stream.__create_id || streamSoundMeter.__mediaSoundMeter.__worked)) {
            streamSoundMeter && streamSoundMeter._finally();
            _util.removeAttribute(self._mediaMeters, _sid);
            self._onSoundChanage.call(self, _stream.owner, _stream);
        }

        if (_stream.aoff) {
            return;
        }

        streamSoundMeter = self._newMediaMeters(_stream);
        if (streamSoundMeter) {
            self._mediaMeters[_sid] && self._mediaMeters[_sid]._finally();
            self._mediaMeters[_sid] = streamSoundMeter;
        }

        return streamSoundMeter;
    },

    _newAudioContext: function _newAudioContext() {
        var self = this;

        if (!emedia.__usingWebAudio) {
            return;
        }

        return emedia.__audioContext;
    },

    _newMediaMeters: function _newMediaMeters(_stream) {
        var self = this;

        var mediaStream;
        if (_stream.type === 2 && _stream.subArgs && _stream.subArgs.subSAudio && _stream._webrtc && _stream._webrtc.getRemoteStream()) {
            var soundMeter = new _stream.StreamSoundMeter({
                _stream: _stream,
                _mediaStream: _stream._webrtc.getRemoteStream(),
                _webrtc: _stream._webrtc,
                __audioContext: self._newAudioContext()
            });

            return soundMeter;
        }

        if (_stream.type === 2 && _stream.located()) {
            var soundMeter = new _stream.StreamSoundMeter({
                _stream: _stream,
                _mediaStream: _stream._localMediaStream,
                __audioContext: self._newAudioContext()
            });

            return soundMeter;
        }

        if (_stream.type === 2 && !_stream.located()) {
            var pubAudioMixersStream = self._oneAudioMixers();
            if (!pubAudioMixersStream || !pubAudioMixersStream._webrtc || pubAudioMixersStream._webrtc.closed) {
                return;
            }

            if (pubAudioMixersStream && (pubAudioMixersStream._remoteMediaSoundMeters === undefined || !pubAudioMixersStream._remoteMediaSoundMeters.__worked) && pubAudioMixersStream._webrtc && pubAudioMixersStream._webrtc.getRemoteStream()) {
                pubAudioMixersStream._remoteMediaSoundMeters = new pubAudioMixersStream.MediaSoundMeter({
                    _mediaStream: pubAudioMixersStream._webrtc.getRemoteStream(),
                    __audioContext: self._newAudioContext()
                });
            }

            if (!pubAudioMixersStream._remoteMediaSoundMeters) {
                return;
            }

            var soundMeter = new _stream.StreamSoundMeter({
                _stream: _stream,
                _webrtc: pubAudioMixersStream._webrtc,
                __mediaSoundMeter: pubAudioMixersStream._remoteMediaSoundMeters
            });

            return soundMeter;
        }

        if (!_stream.aoff && (mediaStream = _stream.getMediaStream())) {
            var soundMeter = new _stream.StreamSoundMeter({
                _stream: _stream,
                _mediaStream: mediaStream,
                __audioContext: self._newAudioContext()
            });

            return soundMeter;
        }
    },

    _oneAudioMixers: function _oneAudioMixers() {
        var self = this;

        var zeroStream = self._cacheStreams["0"];
        if (zeroStream && zeroStream._webrtc && !zeroStream._webrtc.closed) {
            return zeroStream;
        }

        for (var sid in self.audioMixers) {
            var stream = self.audioMixers[sid];
            if (stream.located()) {
                return stream;
            }
        }
    },

    onWSClose: function onWSClose() {
        var self = this;
        if (self.__getCopyInterval) {
            clearInterval(self.__getCopyInterval);
        }

        _logger.info("Websocket closed.");
    },

    onICEDisconnected: function onICEDisconnected(webrtc) {
        var self = this;

        self.__networkWeakInterval && clearTimeout(self.__networkWeakInterval);
        self.__networkWeakInterval = setTimeout(function () {
            self.onNetworkWeak && self.onNetworkWeak();
        }, 1000);

        _util.forEach(self._linkedStreams, function (sid, stream) {
            if (stream.rtcId == webrtc.getRtcId()) {
                var problemStream;
                if (!(problemStream = self._maybeNotExistStreams[sid])) {
                    problemStream = self._maybeNotExistStreams[sid] = _util.extend({}, stream);
                    problemStream.iceRebuildCount = 1;
                }

                _logger.info("Stream maybe not exist. caused by disconnected", stream.id);
            }
        });
    },

    onICEConnectFail: function onICEConnectFail(webrtc) {
        var self = this;

        for (var sid in self._linkedStreams) {
            var stream = self._linkedStreams[sid];
            if (stream.rtcId == webrtc.getRtcId()) {
                if (stream._webrtc && stream._webrtc.__id !== webrtc.__id) {
                    _logger.warn("Stream use other webrtc rtcId = ", stream.rtcId, ", id: ", stream._webrtc.__id, webrtc.__id);
                    continue;
                }

                var problemStream;
                if (!(problemStream = self._maybeNotExistStreams[sid])) {
                    problemStream = self._maybeNotExistStreams[sid] = _util.extend({}, stream);
                    problemStream.iceRebuildCount = 1;
                }

                if (problemStream) {
                    var _evt = new __event.StreamState({ stream: problemStream });
                    _evt.iceFail();

                    self.onEvent(_evt);
                }

                _logger.info("ice fail. webrtc = ", webrtc.getRtcId(), " problem stream is ", problemStream.iceRebuildCount, problemStream.id);

                if (problemStream.iceRebuildCount > emedia.config.iceRebuildCount) {
                    _logger.info("ice fail. webrtc = ", webrtc.getRtcId(), " rebuild fail. problem stream is ", problemStream.id);

                    if (problemStream.located()) {
                        self.onEvent(new __event.PushFail({
                            stream: stream,
                            cause: "pub ice rebuild failed."
                        }));
                    } else {
                        self.onEvent(new __event.SubFail({
                            stream: stream,
                            cause: "sub ice rebuild failed."
                        }));
                    }
                    self.closeWebrtc(webrtc.getRtcId(), false);
                } else {
                    var recording = self._records[problemStream.id];

                    if (problemStream._localMediaStream) {
                        _logger.info("ice fail. webrtc = ", webrtc.getRtcId(), " will rebuild. remain local stream. ", problemStream.id);
                    } else {
                        _logger.info("ice fail. webrtc = ", webrtc.getRtcId(), " will rebuild.", problemStream.id);
                    }

                    self.closeWebrtc(webrtc.getRtcId(), true);

                    if (recording) {
                        self._records[problemStream.id] = recording;
                    }

                    (function (problemStream) {
                        setTimeout(function () {
                            self.iceRebuild(problemStream);
                        }, emedia.config.iceRebuildIntervalMillis);
                    })(problemStream);

                    _logger.info("ice fail. webrtc = ", webrtc.getRtcId(), " will rebuilding. problem stream is ", problemStream.id);
                }

                if (stream.type === 2) {
                    _util.removeAttribute(self.audioMixers, stream.id);
                }
            }
        }
    },

    onICEClosed: function onICEClosed(webrtc) {
        var self = this;

        if (webrtc.closed) {
            _logger.warn("Webrtc will be removed. by __id = ", webrtc.__id, ", rtcId = ", webrtc.getRtcId());
            var removedWebrtc = _util.removeAttribute(self._ices, webrtc.__id);
            if (removedWebrtc) {
                _logger.warn("Webrtc removed. by id = ", removedWebrtc.__id, ", rtcId = ", removedWebrtc.getRtcId());
            } else {
                _logger.warn("Webrtc removed. by id = ", webrtc.__id, ", rtcId = ", webrtc.getRtcId());
            }

            var webrtc22 = self._ices[webrtc.getRtcId()];
            if (webrtc22 && webrtc22.__id === removedWebrtc.__id) {
                removedWebrtc = _util.removeAttribute(self._ices, webrtc.getRtcId());
                _logger.warn("Webrtc removed. by rtcId = ", removedWebrtc.getRtcId(), ", __id = ", removedWebrtc.__id);
            }
        } else {
            _logger.info("ICE self closed. not allow. will rebuild", webrtc.getRtcId());
            self.onICEConnectFail(webrtc);
        }
    },

    onICEConnected: function onICEConnected(webrtc) {
        var self = this;

        _util.forEach(self._cacheStreams, function (sid, stream) {
            if (stream.rtcId == webrtc.getRtcId()) {
                stream.finalVCodeChoices = webrtc.finalVCodeChoices;

                if (self._maybeNotExistStreams[sid]) {
                    _util.removeAttribute(self._maybeNotExistStreams, stream.id);
                    self._linkedStreams[sid] = stream;

                    _logger.info("ice reconnected. webrtc = ", webrtc.getRtcId(), "will update stream = ", stream.id);
                    //stream.located() && self.onUpdateStream(self._linkedStreams[stream.id]);
                    //self.onUpdateStream(self._linkedStreams[stream.id]);

                    var _recordStream = self._records[stream.id];
                    if (_recordStream && _recordStream.rtcId !== stream.rtcId) {
                        //在重连后，恢复录制
                        //self.stopRecord(_recordStream);
                        self.startRecord(stream);
                        _logger.warn("Re record. for ", stream.id, ", after rebuild ice.", _recordStream.rtcId, "->", stream.rtcId);
                    }
                } else {
                    _logger.info("ice connected. webrtc = ", webrtc.getRtcId(), stream.id);

                    stream.located() && self.onEvent(new __event.PushSuccess({ stream: stream }));
                    stream.located() || self.onEvent(new __event.SubSuccess({ stream: stream }));
                }

                if (stream.type === 2) {
                    self.audioMixers[stream.id] = stream;
                }
            }
        });
    },

    onICERemoteMediaStream: function onICERemoteMediaStream(webrtc) {
        var self = this;

        var streams = [];
        _util.forEach(self._cacheStreams, function (sid, _stream) {
            if (_stream.rtcId == webrtc.getRtcId() && (!_stream.located() || _stream.type === 2)) {
                var mediaStream = webrtc.getRemoteStream();
                self._updateRemoteStream(_stream, mediaStream);

                if (_stream.onGotRemoteMediaStream) {
                    _stream.onGotRemoteMediaStream.call(_stream, mediaStream);
                } else {
                    var _stream = self.newStream(_stream);
                    _stream.mediaStream = webrtc.getRemoteStream();

                    self.onUpdateStream(_stream, new _stream.Update({ mediaStream: _stream.mediaStream }));
                }
            }
        });
    },

    _failIcesRebuild: function _failIcesRebuild() {
        var self = this;

        var count = 1;
        _util.forEach(self._maybeNotExistStreams, function (streamId, stream) {
            setTimeout(function () {
                self.iceRebuild(stream);
            }, count * 100);
        });
    },

    iceRebuild: function iceRebuild(stream) {
        var self = this;

        if (!self.connected()) {
            stream.iceRebuildCount = 1;
            _logger.warn("Websocket disconnect. waiting. rebuild count reset", stream.iceRebuildCount, stream.id);
            return;
        }
        if (!self._linkedStreams[stream.id] || !self._cacheStreams[stream.id]) {
            _logger.info("ice rebuild fail. it yet closed. stream is ", stream.id, stream.rtcId);
            _util.removeAttribute(self._maybeNotExistStreams, stream.id);
            _util.removeAttribute(self._linkedStreams, stream.id);
            _logger.warn("iceRebuild, remvoe from _linkedStreams", stream.id);

            return;
        }

        if (stream.iceRebuildCount > emedia.config.iceRebuildCount) {
            _logger.info("ice rebuild fail. count too many. stream is ", stream.id);

            if (stream.located()) {
                self.onEvent(new __event.PushFail({
                    stream: stream,
                    cause: "pub ice rebuild failed."
                }));
            } else {
                self.onEvent(new __event.SubFail({
                    stream: stream,
                    cause: "sub ice rebuild failed."
                }));
            }
        } else if (self.connected()) {
            _logger.info("ice try rebuild. count", stream.iceRebuildCount, ". stream is ", stream.id);
            self.rebuildIce(stream);

            stream.iceRebuildCount++;
        } else {
            _logger.warn("ice rebuild. stop. cause by not websocket disconnect", stream.id);
        }
    },

    rebuildIce: function rebuildIce(stream) {
        var self = this;

        if (!self._cacheStreams[stream.id]) {
            _logger.warn("Begin rebuild ice. not found stream at local", stream.iceRebuildCount, stream.id);
            return;
        }
        _logger.warn("Begin rebuild ice ", stream.iceRebuildCount, stream.id);

        if (stream.located()) {
            stream.isRepublished = true;
            self.push(stream, undefined, undefined, true);
        } else {
            self.createWebrtcAndSubscribeStream(stream.id);
        }
        _logger.warn("Finish rebuild ice ", stream.iceRebuildCount, stream.id, self._cacheStreams[stream.id].rtcId);
    },

    _sysCopy: function _sysCopy() {
        var self = this;

        var copyMessage = self.newMessage().setOp(1000).setCver(self._cver || 0);

        self.postMessage(copyMessage, function (rsp) {
            if (rsp.result != 0) {
                _logger.warn("Get copy fail. result = ", rsp.result);

                return;
            }

            if ((self._cver || 0) < rsp.cver) {
                self._cver = rsp.cver;

                self.onMembers(rsp.cver, rsp.mems || {});
                self.onStreams(rsp.cver, rsp.streams || {});

                _logger.info("Got copy success.");
            }
        });
    }
});

module.exports = Handler;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {


var _util = __webpack_require__(15);
var _logger = _util.tagLogger("Desktop");

var __event = __webpack_require__(21);

window.__shareDesktopMessageCount__ = 0;

module.exports = _util.prototypeExtend({

    __RTC_PAGE_MSG_TYPE__: 'RTC-SD-PAGE',
    __RTC_EXT_MSG_TYPE__: 'RTC-SD-EXT',

    __init__: function __init__() {
        var self = this;

        self.__extLoaded = self.rsdExtLoaded();
        if (self.__extLoaded) {
            self.__onRsdExtLoad();
        }

        window.addEventListener("load", function (event) {
            if (self.__extLoaded) {
                return;
            }

            var exist = self.rsdExtLoaded();
            // console.log('exist=', exist, ', ev4detect=', ev4detect);

            self.__extLoaded = exist;
        });

        window.addEventListener('message', function (event) {
            if (!event.data) {
                return;
            }

            var msg = event.data;
            if (!msg.type || msg.type !== self.__RTC_EXT_MSG_TYPE__ || !msg.evname) {
                return;
            }
            _logger.info('got ext-msg: ', msg);

            if (msg.evname === 'extLoaded') {
                if (!self.__extLoaded) {
                    self.__extLoaded = true;

                    setTimeout(self.__onRsdExtLoad(), 50);
                }

                return;
            }

            self.__onMessage(msg);
        });
    },

    rsdExtLoaded: function rsdExtLoaded() {
        var existele = document.getElementById('RTC-Share-Deskto-installed-ele-rat1abrr');
        return emedia.isElectron || existele ? true : false;
    },

    __sendMessage: function __sendMessage(msg, callback) {
        var self = this;

        var tsxId = 'tsx_' + __shareDesktopMessageCount__++ + '_' + Math.random().toString(36).substr(2, 4);

        if (!self.__extLoaded) {
            _logger.error("Rtc share desktop not loaded");
            throw "Rtc share desktop not loaded";
        }

        msg.tsxId = tsxId;

        self["on_" + tsxId] = function () {
            callback && callback.apply(self, arguments);

            //delete self["on_" + tsxId];
            _util.removeAttribute(self, "on_" + tsxId);
        };

        window.postMessage && window.postMessage(msg, '*');
    },

    __onMessage: function __onMessage(msg) {
        var self = this;

        var tsxId = msg.tsxId;

        self["on_" + tsxId] && self["on_" + tsxId](msg);
        //self["on_" + tsxId] || _logger.info(msg);
    },

    __onRsdExtLoad: function __onRsdExtLoad() {
        var self = this;

        self.onExtLoaded && self.onExtLoaded();
    },

    openDesktopMedia: function openDesktopMedia(screenOptions, callback) {
        var self = this;

        if (emedia.isElectron) {
            self.openDesktopMediaInElectron(screenOptions, callback);
            return;
        }

        if (!self.__extLoaded || !self.rsdExtLoaded()) {
            callback(new __event.ShareDesktopExtensionNotFound());
            return;
        }

        var msg = { type: self.__RTC_PAGE_MSG_TYPE__, evname: 'chooseDesktopMedia', screenOptions: screenOptions };
        self.__sendMessage(msg, function (m) {
            if (m.evname === 'onAccessApproved' && m.streamId) {
                callback(new __event.OpenDesktopMedia({ desktopStreamId: m.streamId }));
            } else {
                callback(new __event.OpenDesktopMediaAccessDenied());
            }
        });
    },

    openDesktopMediaInElectron: function openDesktopMediaInElectron(screenOptions, callback) {
        var self = this;

        if (!screenOptions) {
            screenOptions = ['screen', 'window'];
        }

        emedia.electron.desktopCapturer.getSources({ types: screenOptions }, function (error, sources) {
            if (error) {
                callback(new __event.OpenDesktopMediaAccessDenied({ error: error }));
                return;
            }

            if (typeof emedia.chooseElectronDesktopMedia !== 'function') {
                callback(new __event.OpenDesktopMedia({ desktopStreamId: sources[0].id }));
                return;
            }

            for (var i = 0; i < sources.length; i++) {
                _logger.debug("desktop capturer. ", sources[i]);
                var source = sources[i];
                source.easemobThumbDataURL = source.thumbnail.toDataURL();
            }

            emedia.chooseElectronDesktopMedia(sources, function accessApproved(desktopCapturerSource) {
                var sourceId;
                if (desktopCapturerSource && desktopCapturerSource.id) {
                    sourceId = desktopCapturerSource.id;
                } else {
                    sourceId = desktopCapturerSource;
                }

                callback(new __event.OpenDesktopMedia({ desktopStreamId: sourceId }));
            }, function accessDenied() {
                callback(new __event.OpenDesktopMediaAccessDenied({ message: "User denied access" }));
            });

            return;
        });
    }
});

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

var _util = __webpack_require__(15);
var _logger = _util.tagLogger("DefaultTrack");

var MouseTrack = __webpack_require__(31);

function zoomCanvas(canvas, width, height) {
    var canvasContext = canvas.getContext("2d");

    var _width = canvas.width,
        _height = canvas.height;

    canvasContext.scale(_width / width, _height / height);
    _logger.warn("Canvas scale", _width / width, _height / height, width, height);
    var imageData = canvasContext.getImageData(0, 0, _width, _height);

    canvas.width = width;
    canvas.height = height;

    canvasContext.putImageData(imageData, 0, 0);
}

function initCanvas(_target) {
    var _canvas;
    _canvas = document.createElement("canvas");
    _target.appendChild(_canvas);

    _canvas.style.cssText = "position: absolute; background: transparent; width: 100%; height: 100%";

    _canvas.width = _target.offsetWidth;
    _canvas.height = _target.offsetHeight;
    _logger.warn("Canvas", _canvas.width, _canvas.height);

    // if(initCanvas.timeoutId === undefined){
    //     var targetElement = _target.onresize ? _target : window;
    //     _util.addEvent(targetElement, "resize", function () {
    //         if(initCanvas.timeoutId){
    //             clearTimeout(initCanvas.timeoutId);
    //         }
    //
    //         initCanvas.timeoutId = setTimeout(function () {
    //             initCanvas();
    //             initCanvas.timeoutId = null;
    //         }, 500);
    //     });
    // }

    return _canvas;
}

var DefaultMouseTrack;
module.exports = DefaultMouseTrack = MouseTrack.extend({
    __init__: function __init__() {
        this._canvas || (this._canvas = initCanvas(this._target));
        this._canvasContext || (this._canvasContext = this._canvas.getContext("2d"));
    },

    resizeCanvas: function resizeCanvas() {},

    _calPosition: function _calPosition() {
        var xy = MouseTrack.prototype._calPosition.apply(this, arguments);
        xy.x = Math.floor(xy.x * this._canvas.width / xy.width);
        xy.y = Math.floor(xy.y * this._canvas.height / xy.height);

        return xy;
    },

    _draw: function _draw(position, pixelCount, r, g, b, alpha) {
        var self = this;
        //_logger.warn(self._canvas.width, self._canvas.height);

        var canvasContext = self._canvasContext;

        if (!pixelCount || pixelCount <= 1) {
            pixelCount = 2;
        }

        var pixel = canvasContext.getImageData(position.x - pixelCount / 2, position.y - pixelCount / 2, pixelCount, pixelCount);
        var color = function color(imageData, r, g, b, alpha) {
            for (var i = 0, data = imageData.data; i < data.length; i += 4) {
                var rgb = {
                    r: r === undefined ? data[i] : r,
                    g: g === undefined ? data[i + 1] : g,
                    b: b === undefined ? data[i + 2] : b,
                    alpha: alpha === undefined ? data[i + 3] : alpha };

                data[i] = rgb.r; // red
                data[i + 1] = rgb.g; // green
                data[i + 2] = rgb.b; // blue
                data[i + 3] = rgb.alpha;

                //_logger.debug(rgb);
            }
        };
        pixel && color(pixel, r, g, b, alpha);

        canvasContext.putImageData(pixel, position.x, position.y);
    },

    redraw: function redraw(x, y, r, g, b, alpha) {
        var self = this;
        var draw = DefaultMouseTrack.prototype._draw.bind(self);
        draw({ x: x, y: y }, 2);
    },

    onMouseTrigger: function onMouseTrigger(trigger, _lastTrigger) {
        trigger.isLeftKey() && this._draw(trigger.xy, 8, 189, 56, 51, 255);
        trigger.isRightKey() && this._draw(trigger.xy, 8, 45, 23, 189, 255);
        trigger.isWheelKey() && this._draw(trigger.xy, 8, 58, 189, 76, 255);
    },

    onMouseTrack: function onMouseTrack(position, lastPosition, lastTrigger) {
        this._draw(position, 2, 227, 18, 247, 255);
    }

    // onMouseTrack2: function (position, lastPosition, lastTrigger) {
    //     var self = this;
    //     //_logger.warn(self._canvas.width, self._canvas.height);
    //
    //     self._canvasContext || (self._canvasContext = self._canvas.getContext("2d"));
    //
    //     var canvasContext = self._canvasContext;
    //
    //     var pixel = canvasContext.getImageData(position.x - 1, position.y - 1, 3, 3);
    //     var rgb;
    //     var color = function(imageData, r, g, b, alpha) {
    //         rgb = {r: r, g: g, b: b, alpha: alpha};
    //         for (var i = 0, data = imageData.data; i < data.length; i += 4) {
    //             data[i]     = r === undefined ? 0 : r; // red
    //             data[i + 1] = g === undefined ? 0 : g; // green
    //             data[i + 2] = b === undefined ? 0 : b; // blue
    //             data[i + 3] = alpha === undefined ? 255 : alpha;
    //         }
    //     };
    //     pixel && color(pixel, 189, 56, 51);
    //     lastTrigger.isRightKey() && pixel && color(pixel, 45, 23, 189);
    //     lastTrigger.isWheelKey() && pixel && color(pixel, 58, 189, 76);
    //
    //     if(!lastPosition){
    //         canvasContext.putImageData(pixel, position.x, position.y);
    //     }
    //
    //
    //     function line() {
    //         canvasContext.lineWidth = 2;
    //         canvasContext.beginPath();
    //         canvasContext.strokeStyle = _util.list('rgb(', rgb.r, ",", rgb.g, ",", rgb.b, ")").join("");
    //         canvasContext.moveTo(lastPosition ? lastPosition.x : position.x, lastPosition ? lastPosition.y : position.y);
    //         canvasContext.lineTo(position.x, position.y);
    //
    //         canvasContext.stroke();
    //         canvasContext.closePath();
    //     }
    //
    //     if(lastPosition){
    //         line();
    //     }
    // }
});

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

var _util = __webpack_require__(15);
var _logger = _util.tagLogger("MouseTrack");

var MouseTrigger = __webpack_require__(32);

module.exports = _util.prototypeExtend({
    _scale: 1,
    //_target
    //_referenceVideo

    __init__: function __init__() {
        var self = this;
    },

    getTargetPageXY: function getTargetPageXY() {
        var self = this;
        return self._target && _util.extend({}, _util.getDomPageRect(self._target));
    },

    onMouseTrack: function onMouseTrack(position, lastPosition, lastTrigger) {
        //_logger.warn(position.x, position.y);
    },

    onMouseTrigger: function onMouseTrigger(trigger, _lastTrigger) {},

    _onMouseTrack: function _onMouseTrack(position, lastPosition, _lastTrigger) {
        this.onMouseTrack && this.onMouseTrack(position, lastPosition, _lastTrigger);
    },

    _onMouseTrigger: function _onMouseTrigger(trigger, _lastTrigger) {
        this.onMouseTrigger && this.onMouseTrigger(trigger, _lastTrigger);
    },

    track: function track(pos) {
        var self = this;

        var pageXY = pos = _util.extend({}, pos);

        var _elementPageXY = self.getTargetPageXY();
        _elementPageXY && (pos = self._calPosition(pos), pageXY = {
            x: pos.x,
            y: pos.y,
            pageX: _elementPageXY.x + pos.x,
            pageY: _elementPageXY.y + pos.y
        });

        self._onMouseTrack(pageXY, self._lastPageXY, self._lastTrigger);
        self._lastPageXY = pageXY;
    },

    trigger: function trigger(_trigger) {
        var self = this;

        _trigger = new MouseTrigger(_trigger);

        var _elementPageXY = self.getTargetPageXY();

        var pos;
        _elementPageXY && (pos = self._calPosition(_trigger.xy), _trigger.xy = {
            x: pos.x,
            y: pos.y,
            pageX: _elementPageXY.x + pos.x,
            pageY: _elementPageXY.y + pos.y
        });
        _trigger._time || (_trigger._time = new Date().getTime());

        self._onMouseTrigger(_trigger, self._lastTrigger);
        self._lastTrigger = _trigger;
    },

    releaseTrigger: function releaseTrigger() {
        this._lastTrigger = undefined;
        this._lastPageXY = undefined;

        this.onReleaseTrigger && this.onReleaseTrigger(this._lastTrigger);
    },

    /**
     *
     *
     * @param mousePos
     * @private
     */
    _calPosition: function _calPosition(mousePos) {
        var self = this;

        if (self._referenceVideo) {
            mousePos = emedia.Service.prototype.eventXYAtVideo.call(null, mousePos, self._referenceVideo);
        }

        var _elementPageXY = self.getTargetPageXY();
        if (!_elementPageXY) {
            return mousePos;
        }

        if (_util.isFloat(mousePos.x) && mousePos.width !== undefined) {
            //比率
            mousePos.x = mousePos.x * mousePos.width * self._scale * (_elementPageXY.width / mousePos.width);
        }
        if (_util.isFloat(mousePos.y) && mousePos.height !== undefined) {
            //比率
            mousePos.y = mousePos.y * mousePos.height * self._scale * (_elementPageXY.height / mousePos.height);
        }

        if (_util.isFloat(mousePos.x) && mousePos.width === undefined) {
            //比率
            mousePos.x = mousePos.x * self._scale * _elementPageXY.width;
        }
        if (_util.isFloat(mousePos.y) && mousePos.height === undefined) {
            //比率
            mousePos.y = mousePos.y * self._scale * _elementPageXY.height;
        }

        if (_util.isInt(mousePos.x) && mousePos.width !== undefined) {
            mousePos.x = mousePos.x * self._scale * (_elementPageXY.width / mousePos.width);
        }
        if (_util.isInt(mousePos.y) && mousePos.height !== undefined) {
            mousePos.y = mousePos.y * self._scale * (_elementPageXY.height / mousePos.height);
        }

        if (_util.isInt(mousePos.x) && mousePos.width === undefined) {
            mousePos.x = mousePos.x * self._scale;
        }
        if (_util.isInt(mousePos.y) && mousePos.height === undefined) {
            mousePos.y = mousePos.y * self._scale;
        }

        var x = Math.floor(mousePos.x);
        var y = Math.floor(mousePos.y);

        if (x < 0) {
            x = _elementPageXY.width + x;
        }
        if (y < 0) {
            y = _elementPageXY.width + y;
        }

        return { x: x, y: y, width: _elementPageXY.width, height: _elementPageXY.height };
    }
});

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

var _util = __webpack_require__(15);
var _logger = _util.tagLogger("MouseTrigger");

var BTN = {
    LEFT: 1,
    WHEEL: 2,
    RIGHT: 4,

    WHEEL_ROLL_UP: 8,
    WHEEL_ROLL_DOWN: 16,

    KEY_UP: 0,
    KEY_DOWN: 1,
    MOVE: 2,

    KEYBOARD_DOWN: 3,
    KEYBOARD_UP: 4

    /**
     *
     * {
     *  xy: eventXY,
     *  oper: oper,
     *  btn: button,
     *  _time: _time
     * }
     *
     *
     */
};module.exports = _util.prototypeExtend({
    _timeoutMillis: 500,
    _time: new Date().getTime(),

    isKeyup: function isKeyup() {
        return BTN.KEY_UP == this.oper;
    },
    isKeydown: function isKeydown() {
        return BTN.KEY_DOWN == this.oper;
    },
    isWheelup: function isWheelup() {
        return BTN.WHEEL_ROLL_UP == this.btn;
    },
    isWheeldown: function isWheeldown() {
        return BTN.WHEEL_ROLL_DOWN == this.btn;
    },
    isLeftKey: function isLeftKey() {
        return BTN.LEFT == this.btn;
    },
    isRightKey: function isRightKey() {
        return BTN.RIGHT == this.btn;
    },
    isWheelKey: function isWheelKey() {
        return BTN.WHEEL == this.btn;
    },
    isWheelRoll: function isWheelRoll() {
        return this.isWheeldown() || this.isWheelup();
    },

    timeout: function timeout() {
        var cur = new Date().getTime();
        return cur - this._time >= this._timeoutMillis;
    },

    _toString: function _toString() {
        return _util.list("btn:", this.btn, ", oper:", this.oper, ", timeout:", this.timeout(), ", at (", this.xy.x, ", ", this.xy.y, ")").join("");
    }
});

module.exports.BTN = BTN;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

var _util = __webpack_require__(15);
var _logger = _util.tagLogger("AddonsP2P");

var __event = __webpack_require__(21);

/**
 *
 * 对于视频流，往往 会出现 多个流 共用一个webrtc情况
 *
 *
 * @type {{}}
 * @private
 */

var addonsSession = function addonsSession(Session) {
    var NewSession = Session.extend({

        postMessage: function postMessage(message, callback) {
            var self = this;

            var tsxId = message.tsxId;
            if (!message.tsxId) {
                tsxId = message.tsxId = "MSG" + Date.now() + "-" + emedia.__session_globalCount++;
            }

            Session.prototype.postMessage.call(self, message, callback);

            (function (tsxId) {
                var attendee = self.owner;
                if (attendee.isP2P() && self._callbacks[tsxId]) {
                    setTimeout(function () {
                        var _sentMessage = self._callbacks[tsxId];
                        if (_sentMessage && _sentMessage.op === 1004) {
                            var rsp = self.newMessage({
                                op: 1001,
                                tsxId: _sentMessage.tsxId,
                                memId: _sentMessage.memId,
                                result: 0,
                                msg: "3000ms not recv response. will success callback. " + _sentMessage.tsxId
                            });
                            self.onMessage(rsp);
                        }
                    }, 3000);
                }
            })(tsxId);
        },

        __modifyMessageForPost: function __modifyMessageForPost(message) {
            var self = this;

            message = Session.prototype.__modifyMessageForPost.call(self, message);

            var attendee = self.owner;
            if (attendee.isP2P()) {
                if (message.op === 102 || message.op === 105) {
                    //缓存  回调推流成功
                    var rsp = self.newMessage({
                        op: 1001,
                        tsxId: message.tsxId,
                        memId: message.memId,
                        result: 0,
                        streamId: message.rtcId + (attendee.isCaller() ? "__Caller" : "__Callee"),
                        sver: 1
                    });

                    setTimeout(function () {
                        self.onMessage(rsp);
                    }, 100);

                    if (!message._cached_) {
                        var cacheMessage = _util.extend({ _cached_: true }, message);
                        _util.removeAttribute(cacheMessage, "tsxId");
                        message.op === 102 && (attendee.__cache_[message.rtcId] = []).push(cacheMessage);
                        message.op === 105 && attendee.__cache_[message.rtcId] && attendee.__cache_[message.rtcId].push(cacheMessage);
                        attendee.__cache_[message.rtcId] && (attendee.__cache_[message.rtcId].selfId = attendee.getMemberId());
                    }
                }

                _util.removeAttribute(message, "_cached_");

                if (message.memId) {
                    var p2pMessage = self.newMessage({
                        op: 1004,
                        sessId: _util.removeAttribute(message, "sessId"),
                        memId: _util.removeAttribute(message, "memId"),
                        tsxId: _util.removeAttribute(message, "tsxId"),
                        arg: JSON.stringify(message)
                    });

                    message = p2pMessage;
                }

                switch (message.op) {
                    case 205:
                        var rsp = self.newMessage({
                            op: 1001,
                            tsxId: message.tsxId,
                            result: 0
                        });

                        setTimeout(function () {
                            self.onMessage(rsp);
                        }, 50);

                        return;
                    case 102:
                    case 104:
                    case 105:
                    case 106:
                    case 107:
                        if (message.endReason === -10) {
                            return;
                        }
                    case 1001:
                    case 400:
                        var p2pMessage = self.newMessage({
                            op: 1004,
                            sessId: _util.removeAttribute(message, "sessId"),
                            tsxId: _util.removeAttribute(message, "tsxId"),
                            arg: JSON.stringify(message)
                        });

                        message = p2pMessage;

                        break;

                    case 303:
                    case 206:
                        return;

                    default:
                }
            }

            return message;
        },

        onP2PMessage: function onP2PMessage(evt) {
            var self = this;
            var attendee = self.owner;

            if (self.owner.isConfr()) {
                _logger.warn("Recv p2p ctrl message. when CONFR. ignore");
                return;
            }

            var message = JSON.parse(evt.arg);
            message.memId = evt.memId;
            message.tsxId = evt.tsxId;
            message.sessId = evt.sessId;

            if (message.op === 400) {
                message.streamId = message.rtcId + (self.owner.isCaller() ? "__Callee" : "__Caller");
            }

            if (message.op !== 1001) {
                var rsp = self.newMessage({
                    op: 1001,
                    tsxId: evt.tsxId,
                    memId: evt.memId,
                    sessId: evt.sessId,
                    result: 0,
                    msg: "Web sdk success recv"
                });

                if (message.op === 102 || message.op === 105) {
                    _util.extend(rsp, {
                        streamId: message.rtcId + (attendee.isCaller() ? "__Callee" : "__Caller"),
                        sver: 1
                    });
                }

                self.postMessage(rsp);
            }

            (function (message) {
                setTimeout(function () {
                    self.onMessage(message);
                }, 10);
            })(message);
        }
    });

    _util.extend(NewSession.prototype._events, {
        '1004': 'onP2PMessage'
    });

    return NewSession;
};

var addonsAttendee = function addonsAttendee(Attendee) {
    var NewAttendee = Attendee.extend({
        __init__: function __init__() {
            var self = this;
            Attendee.prototype.__init__.call(self);

            self.__cache_ = {};

            var extIceRebuild = self.iceRebuild;
            self.iceRebuild = function (stream) {
                var self = this;

                if (!self.isP2P() || !stream.rtcId) {
                    extIceRebuild.call(self, stream);
                    return;
                }

                if (stream._webrtc && stream._webrtc.answerWebrtc === true) {
                    _logger.warn("Stream not auto iceRebuild. caused by answer webrtc. it = ", stream.id, stream);
                    return;
                }

                if (!stream.located()) {
                    //被叫 rtcId 不自动重建；所有的订阅流不自动重建；
                    _logger.warn("Stream not auto iceRebuild. caused by not located. it = ", stream.id, stream);
                    return;
                }

                // stream.isRepublished = true;
                // self.push(stream, undefined, undefined, true);
                extIceRebuild.call(self, stream);
            };
        },

        onEnter: function onEnter(cver, mem) {
            var self = this;
            try {
                Attendee.prototype.onEnter.call(self, cver, mem);
            } finally {
                if (!self.isP2P() || !(mem = self._cacheMembers[mem.id])) {
                    //不是p2p 或者 没有 member
                    return;
                }
                _util.forEach(self.__cache_, function (rtcId, cacheMessages) {
                    if (cacheMessages.answered !== true) {
                        _util.forEach(cacheMessages, function (index, cacheMessage) {
                            (function (cacheMessage) {
                                cacheMessage.memId = mem.id;
                                self.postMessage(cacheMessage);
                            })(cacheMessage);
                        });
                    }
                });
            }
        },

        rejectAnswer: function rejectAnswer(memId, rtcId, endReason, rspFail) {
            var self = this;

            var termC = self.newMessage().setOp(107).setRtcId(rtcId).setMemId(memId).setEndReason(endReason);

            self.postMessage(termC, function (rsp) {
                if (rsp.result != 0) {
                    self.onEvent(new __event.RspFail({ request: termC, response: rsp }));
                    rspFail && rspFail(new __event.RspFail({ request: termC, response: rsp }));

                    return;
                }
            });
        },

        closeWebrtc: function closeWebrtc(rtcId, remainLocalStream, serverClosed) {
            var self = this;

            var failed = false;

            if (self.isP2P()) {
                var _webrtc = self._ices[rtcId];
                if (_webrtc) {
                    var state = _webrtc.iceConnectionState();
                    failed = state === 'failed';
                    failed = failed && _webrtc._rebuildCount < emedia.config.iceRebuildCount;

                    _logger.warn("Webrtc state failed. it is ", rtcId, _webrtc._rebuildCount, emedia.config.iceRebuildCount, _webrtc.__id);
                }
            }

            //p2p failed认为服务端关闭，不发送 107.
            Attendee.prototype.closeWebrtc.call(self, rtcId, remainLocalStream, serverClosed || failed);

            if (self.isP2P()) if (!serverClosed && failed) {
                //p2p failed 需要重连 所以需要将 steam重新添加到_linkedStreams中
                //换句话说 需要重建RTC必须 _linkedStreams中有值
                _util.forEach(self._cacheStreams, function (sid, _stream) {
                    if (_stream.rtcId === rtcId) {
                        self._linkedStreams[sid] = _stream;
                        _logger.warn("Reput stream to _linkedStreams", sid);
                    }
                });
            }

            // p2p时 ice close 可以认为 流 已经关闭，移除流
            if (self.isP2P() && !remainLocalStream) {
                _util.removeAttribute(self.__cache_, rtcId);

                var _tmp = _util.extend({}, self._cacheStreams);

                _util.forEach(_tmp, function (streamId, stream) {
                    if (rtcId === stream.rtcId) {
                        _util.removeAttribute(self._linkedStreams, stream.id);
                        var rmStream = _util.removeAttribute(self._cacheStreams, stream.id);
                        _logger.warn("P2P close webrtc. remove stream from _cacheStreams. it = ", stream.id, stream);

                        if (rmStream._localMediaStream) {
                            self._service._stopTracks(rmStream._localMediaStream);
                        }

                        if (self.onRemoveStream) {
                            var stream = self.newStream(stream);

                            self.onRemoveStream(stream);
                        }
                    }
                });
            }
        },

        subscribeStream: function subscribeStream(rtcId, streamId, rspFail, subArgs) {
            var self = this;

            if (!self.isP2P()) {
                Attendee.prototype.subscribeStream.call(self, rtcId, streamId, rspFail, subArgs);
                return;
            }

            // throw "P2P not allow call subscribeStream";
            var webrtc = self._ices[rtcId];

            var subStream = self._cacheStreams[streamId];

            //var stream = self.newStream(subStream);
            var stream = subStream;
            stream._webrtc = webrtc;
            stream.rtcId = rtcId;

            var preSubArgs = stream.subArgs;

            subArgs = subArgs || { subSVideo: true, subSAudio: true };
            stream.subArgs = stream.subArgs || { subSVideo: true, subSAudio: true };
            stream._webrtc && (stream._webrtc.subArgs = stream._webrtc.subArgs || { subSVideo: true, subSAudio: true });

            if (!stream.subArgs.subSVideo && subArgs.subSVideo && stream.voff) {
                _logger.error("Sub not allow. stream voff");
                throw "Sub not allow. stream voff";
            }

            if (!stream.subArgs.subSAudio && subArgs.subSAudio && stream.aoff) {
                _logger.error("Sub not allow. stream aoff");
                throw "Sub not allow. stream aoff";
            }

            if (stream.subArgs.subSVideo && !subArgs.subSVideo && !stream.voff && emedia.isSafari) {
                _logger.error("Sub not allow. safari close sub video. will error");
                throw "Sub not allow. safari close sub video. will error";
            }

            subArgs && stream._webrtc && stream._webrtc.setSubArgs(subArgs);
            subArgs && (stream.subArgs = subArgs);

            var evt = new __event.SubSuccess({
                stream: stream,
                hidden: true
            });
            self._updateRemoteStream(stream, stream._webrtc.getRemoteStream());
            self.onEvent(evt);
        },

        unsubscribeStream: function unsubscribeStream(streamId) {
            var self = this;

            if (!self.isP2P()) {
                Attendee.prototype.unsubscribeStream.call(self, streamId);
                return;
            }
        },

        onPub: function onPub(cver, memId, pubS) {
            var self = this;

            if (!self.isP2P()) {
                Attendee.prototype.onPub.call(self, cver, memId, pubS);
                return;
            }

            var stream = Attendee.prototype.onPub.call(self, cver, memId, pubS);

            return stream;
        },

        onStreams: function onStreams(cver, streams) {
            var self = this;

            if (!self.isP2P()) {
                Attendee.prototype.onStreams.call(self, cver, streams);
                return;
            }

            _logger.warn("P2P ingrone the onStreams");
        },

        _howDoWebrtcWhenCrtExsitsWebrtc: function _howDoWebrtcWhenCrtExsitsWebrtc(webrtc) {
            var self = this;

            if (!self.isP2P()) {
                Attendee.prototype._howDoWebrtcWhenCrtExsitsWebrtc.call(self, webrtc);
                return;
            }

            self.closeWebrtc(webrtc.getRtcId(), true, true);
        },

        createWebrtcAndSubscribeStream: function createWebrtcAndSubscribeStream(streamId, callbacks, iceServerConfig, subArgs) {
            var self = this;

            if (!self.isP2P()) {
                Attendee.prototype.createWebrtcAndSubscribeStream.call(self, streamId, callbacks, iceServerConfig, subArgs);
                return;
            }

            var self = this;

            callbacks || (callbacks = {});

            var subStream = self._cacheStreams[streamId];
            var subMember = self._cacheMembers[subStream.owner.id];

            //var stream = self.newStream(subStream);
            var stream = subStream;
            subArgs = subArgs || stream.subArgs || { subSVideo: true, subSAudio: true };

            function _onSubFail(evt) {
                _logger.warn("sub stream error", streamId, evt);

                preSubArgs && stream._webrtc && stream._webrtc.setSubArgs(preSubArgs);
                preSubArgs && (stream.subArgs = preSubArgs);

                evt = new __event.SubFail({
                    stream: stream,
                    hidden: evt.hidden === true,
                    cause: evt
                });

                callbacks && callbacks.onEvent && callbacks.onEvent(evt);
                self.onEvent && self.onEvent(evt);
            }

            var pubStreamVCodes = subStream.vcodes;
            var pubMemberSupportVCodes = subMember.vcodes;
            var selfSupportVCodes = self.supportVCodes;

            var optimalVideoCodecs = self._getOptimalVideoCodecsSubset(pubStreamVCodes, pubMemberSupportVCodes, selfSupportVCodes);

            subArgs = subArgs || stream.subArgs;

            var preSubArgs = stream.subArgs;

            var withoutVideo = !(stream.vcodes && stream.vcodes.length > 0);
            var offerOptions = {
                offerToReceiveAudio: true,
                offerToReceiveVideo: subArgs.subSVideo && withoutVideo
            };

            if (!offerOptions.offerToReceiveAudio && !offerOptions.offerToReceiveVideo) {
                _logger.warn("offerToReceiveAudio == false and offerToReceiveVideo == false");
            }

            var webrtc = self.createWebrtc({
                _rtcId: stream.rtcId,

                iceServerConfig: iceServerConfig,
                optimalVideoCodecs: optimalVideoCodecs,
                offerOptions: offerOptions,

                onGotMediaStream: function onGotMediaStream(remoteMediaStream) {
                    var evt = new __event.SubSuccess({
                        stream: stream,
                        hidden: true
                    });

                    callbacks.onGotRemote && callbacks.onGotRemote(stream);
                    self.onEvent && self.onEvent(evt);
                }
            }, stream.iceRebuildCount);
            var rtcId = webrtc.getRtcId();

            _logger.warn(rtcId, " sub stream ", streamId, optimalVideoCodecs);

            var preWebrtc = stream._webrtc;

            stream._webrtc = webrtc;
            stream.rtcId = rtcId;
            stream.owner = _util.extend({}, subMember);
            self._ices[rtcId] = webrtc;

            webrtc.answerWebrtc = true;

            subArgs && stream._webrtc && stream._webrtc.setSubArgs(subArgs);
            subArgs && (stream.subArgs = subArgs);

            function channelSet(localStream) {
                localStream && webrtc.setLocalStream(localStream);
                webrtc.setRemoteDescription(stream.sdp);
                stream.cands && stream.cands.length > 0 && webrtc.addIceCandidate(stream.cands);
            }

            if (rtcId === "rtc-" + self.ticket.confrId) {
                var lastCalleePub = self.__lastCalleePub;

                var calleePub = self._cacheStreams[rtcId + (self.isCaller() ? "__Caller" : "__Callee")];
                var calleePub = new self._service.AVPubstream(calleePub || {
                    constaints: {
                        audio: !stream.aoff,
                        video: !stream.voff
                    }
                });

                preWebrtc && preWebrtc.getLocalStream() && self._service._stopTracks(preWebrtc.getLocalStream());

                self._service.openUserMedia(calleePub).then(function () {
                    var stream = self.newStream(calleePub);

                    stream._localMediaStream = calleePub.localStream;
                    stream._webrtc = webrtc;
                    stream.rtcId = webrtc.getRtcId();
                    stream.id = rtcId + (self.isCaller() ? "__Caller" : "__Callee");
                    stream.owner = { id: self.getMemberId(), nickName: self.nickName, name: self.sysUserId, ext: self.extObj };

                    self.onEvent(new __event.PushSuccess({ stream: stream, hidden: true }));

                    channelSet(calleePub.localStream);
                    self.answerCall(rtcId, calleePub, _onSubFail);
                }, _onSubFail);
            } else {
                channelSet();
                self.answer(rtcId, _onSubFail);
            }
        }
    });

    return NewAttendee;
};

var addonsService = function addonsService(Service, Session, Attendee) {
    var NewService = Service.extend({
        Session: Session,
        Attendee: Attendee,

        __init__: function __init__() {
            var self = this;
            Service.prototype.__init__.call(self);

            if (self.useRTCCfg === undefined || self.useRTCCfg === false || self.useRTCCfg === null) {
                self.useRTCCfg = emedia.config.forceUseRTCCfgIfServerReturnWhenP2P;
            }
        },

        push: function push(pubS, pushed, onPushError) {
            var self = this;

            if (self.current && self.current.isP2P()) {
                if (pubS.type === 2) {
                    _logger.error("P2P do not allow audio_mixer");
                    throw "P2P do not allow audio_mixer";
                }

                if (pubS instanceof self.AVPubstream && !pubS.rtcId) {
                    // 主叫 如果没有主RTC, 将创建
                    var p2pAV = self.current._cacheStreams["rtc-" + self.current.ticket.confrId + "__Caller"] || self.current._cacheStreams["rtc-" + self.current.ticket.confrId + "__Callee"];

                    if (!p2pAV) {
                        pubS.rtcId = "rtc-" + self.current.ticket.confrId;
                    }
                }
            }

            Service.prototype.push.call(self, pubS, pushed, onPushError);
        },

        newSession: function newSession(attendee, ticket) {
            var self = this;

            var session = Service.prototype.newSession.call(self, attendee, ticket);
            var preOnTermC = session.onTermC;
            var preOnAnsC = session.onAnsC;

            return _util.extend(session, {
                onInitC: function onInitC(message) {
                    if (!attendee.isP2P()) {
                        return;
                    }

                    if (message.rtcId === "rtc-" + attendee.ticket.confrId) {
                        //收到主呼叫
                        var streamId = message.rtcId + (attendee.isCaller() ? "__Callee" : "__Caller");
                        var _stream = attendee._cacheStreams[streamId];
                        if (_stream && _stream.owner && _stream.owner.id !== message.memId) {
                            attendee.rejectAnswer(message.memId, message.rtcId, 10);
                            attendee.postMessage(attendee.newMessage({
                                op: 1001,
                                memId: message.memId,
                                tsxId: message.tsxId,
                                result: -554,
                                msg: "Other device call it. you no."
                            }));

                            return;
                        }
                    }

                    //认为 只有一个音视频流，多个桌面共享的流  音视频流双向的。
                    message.pubS.sdp = message.sdp;
                    message.pubS.cands = message.cands;
                    message.pubS.id = message.rtcId + (attendee.isCaller() ? "__Callee" : "__Caller");
                    message.pubS._located = false;
                    message.pubS.memId = message.memId;
                    message.pubS.rtcId = message.rtcId;
                    message.pubS.sver = 0;

                    var _stream = attendee._cacheStreams[message.pubS.id];
                    if (_stream) {
                        message.pubS.sver = _stream.sver + 1;
                        _util.removeAttribute(attendee._maybeNotExistStreams, message.pubS.id);
                    }
                    attendee.onPub.call(attendee, ++attendee._cver, message.memId, message.pubS);
                },

                onTermC: function onTermC(evt) {
                    if (!attendee.isP2P()) {
                        preOnTermC.call(attendee, evt);
                        return;
                    }

                    if (evt.endReason === -20) {
                        var callerPub = attendee._cacheStreams[evt.rtcId + "__Caller"];

                        _logger.warn("Begin re-publish. 20", callerPub);
                        callerPub && self._republish(callerPub);

                        return;
                    }

                    // memId 不相等说明 来自 p2p的对方
                    // 意思是 evt.memId 关闭了一个 rtcId
                    if (evt.memId && evt.memId !== attendee.getMemberId()) {
                        // 由于流集合中，所有的发布流均有个特点，caller __Caller结尾，callee __Callee结尾
                        // 关闭流时，先关闭订阅流，在关闭发布流
                        // 所以做了下排序
                        var sortedStreams = [];
                        _util.forEach(attendee._cacheStreams, function (streamId, stream) {
                            sortedStreams.push(stream);
                        });
                        sortedStreams = sortedStreams.sort(function (a, b) {
                            var result = -1;
                            if (a.id > b.id) {
                                result = 1;
                            }

                            return attendee.isCallee() ? 0 - result : result;
                        });

                        _util.forEach(sortedStreams, function (_index, stream) {
                            // evt.memId 关闭的 evt.rtcId 所关联的流 要关闭
                            if (stream && stream.owner && stream.owner.id === evt.memId && evt.rtcId === stream.rtcId) {
                                evt.endReason !== -10 && preOnTermC.call(attendee, evt);

                                if (evt.rtcId === "rtc-" + attendee.ticket.confrId) {
                                    attendee.onUnpub(++attendee._cver, evt.memId, stream.id);
                                }

                                if (evt.endReason === 10) {
                                    attendee.onEvent(new __event.OtherDeviceAnswer({ rtcId: evt.rtcId, stream: stream }));
                                }
                            }

                            if (stream && stream.owner && stream.owner.id === attendee.getMemberId() && evt.rtcId === stream.rtcId) {
                                attendee.closeWebrtc(evt.rtcId);
                                attendee.onUnpub(++attendee._cver, stream.owner.id, stream.id);
                            }
                        });
                        return;
                    }

                    evt.endReason !== -10 && preOnTermC.call(attendee, evt);

                    if (evt.endReason === 10) {
                        attendee.onEvent(new __event.OtherDeviceAnswer({ rtcId: evt.rtcId }));
                    }
                },

                onAnsC: function onAnsC(evt) {
                    if (!attendee.isP2P()) {
                        preOnAnsC.call(attendee, evt);
                        return;
                    }

                    if (!attendee.__cache_[evt.rtcId]) {
                        _logger.warn("Webrtc ", evt.rtcId, "not created. drop the answer");

                        return;
                    }

                    if (attendee.__cache_[evt.rtcId].answered === true) {
                        _logger.warn("Webrtc ", evt.rtcId, "had been ansC");

                        attendee.rejectAnswer(evt.memId, evt.rtcId, 10);
                        attendee.postMessage(attendee.newMessage({
                            op: 1001,
                            memId: evt.memId,
                            tsxId: evt.tsxId,
                            result: -554,
                            msg: "Other device sub it. you no."
                        }));

                        return;
                    }

                    try {
                        if (evt.pubS) {
                            var stream = attendee.newStream(evt.pubS);

                            stream._webrtc = attendee._ices[evt.rtcId];
                            stream.rtcId = evt.rtcId;
                            stream.id = evt.rtcId + (attendee.isCaller() ? "__Callee" : "__Caller");
                            stream.owner = attendee._cacheMembers[evt.memId];

                            if (!attendee._cacheStreams[stream.id]) {
                                attendee.onPub.call(attendee, ++attendee._cver, evt.memId, stream);
                            } else {
                                attendee._cacheStreams[stream.id] = stream;
                            }

                            attendee.onEvent(new __event.SubSuccess({ stream: stream, hidden: true }));
                        }

                        var ansCMember = attendee._cacheMembers[evt.memId];

                        preOnAnsC.call(attendee, evt);

                        _util.forEach(attendee._cacheMembers, function (_memberId, _member) {
                            if (_memberId !== evt.memId && ansCMember.memName === _member.memName) {
                                attendee.rejectAnswer(_memberId, evt.rtcId, 10);
                            }
                        });
                    } finally {
                        attendee.__cache_[evt.rtcId].answered = true;
                    }
                }
            });
        }
    });

    return NewService;
};

module.exports = function (Service) {
    var _Session = Service.prototype.Session || __webpack_require__(20);
    var Session = addonsSession(_Session.extend({}));

    var _Attendee = Service.prototype.Attendee || __webpack_require__(22);
    var Attendee = addonsAttendee(_Attendee.extend({}));

    return addonsService(Service, Session, Attendee);
};

/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "outer", function() { return outer; });
/* harmony import */ var _Manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(35);
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(underscore__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var zepto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6);
/* harmony import */ var zepto__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(zepto__WEBPACK_IMPORTED_MODULE_2__);





var _outer = {};

_Manager__WEBPACK_IMPORTED_MODULE_0__["single"].onMemberJoin = function (member, confrId) {
    emedia.decodeMemeberName(member);
    this.onMemberJoined(member, _Manager__WEBPACK_IMPORTED_MODULE_0__["single"]._confr(confrId));
};
_Manager__WEBPACK_IMPORTED_MODULE_0__["single"].onMemberLeave = function (member, reason, confrId) {
    emedia.decodeMemeberName(member);
    this.onMemberExited(member, reason, _Manager__WEBPACK_IMPORTED_MODULE_0__["single"]._confr(confrId));
};
_Manager__WEBPACK_IMPORTED_MODULE_0__["single"]._onRoleUpdated = function (role, confrId) {
    this.onRoleChanged(role, _Manager__WEBPACK_IMPORTED_MODULE_0__["single"]._confr(confrId));
};
_Manager__WEBPACK_IMPORTED_MODULE_0__["single"]._onAddMemberStream = function (stream, confrId) {
    stream && emedia.decodeMemeberName(stream.owner);
    this.onStreamAdded(stream.owner, stream, _Manager__WEBPACK_IMPORTED_MODULE_0__["single"]._confr(confrId));
};
_Manager__WEBPACK_IMPORTED_MODULE_0__["single"]._onRemoveMemberStream = function (stream, confrId) {
    stream && emedia.decodeMemeberName(stream.owner);
    this.onStreamRemoved(stream.owner, stream, _Manager__WEBPACK_IMPORTED_MODULE_0__["single"]._confr(confrId));
};
_Manager__WEBPACK_IMPORTED_MODULE_0__["single"]._onUpdateMemberStream = function (stream, constaints, confrId) {
    stream && emedia.decodeMemeberName(stream.owner);
    this.onStreamUpdated && this.onStreamUpdated(stream.owner, stream, constaints, _Manager__WEBPACK_IMPORTED_MODULE_0__["single"]._confr(confrId));
};
_Manager__WEBPACK_IMPORTED_MODULE_0__["single"].onExit = function (reason, failed, confrId) {
    this.onConferenceExit(reason, failed, _Manager__WEBPACK_IMPORTED_MODULE_0__["single"]._confr(confrId));
};

_outer.onMemberJoined = function (member) {};
_outer.onMemberExited = function (member, reason) {};
_outer.onRoleChanged = function (role) {};
_outer.onStreamAdded = function (member, stream) {};
_outer.onStreamRemoved = function (member, stream) {};
_outer.onConferenceExit = function (reason, error) {};

// Promise
_outer.joinConferenceWithTicket = _Manager__WEBPACK_IMPORTED_MODULE_0__["single"].joinUseTicket;
_outer.joinConference = _Manager__WEBPACK_IMPORTED_MODULE_0__["single"].joinUsePassword;
_outer.getConferenceTkt = _Manager__WEBPACK_IMPORTED_MODULE_0__["single"].reqTkt;

_outer.publish = function (constaints, videoTag, ext) {
    return _Manager__WEBPACK_IMPORTED_MODULE_0__["single"].shareVideoWithAudio(constaints.video, constaints.audio, videoTag, ext);
};
_outer.unpublish = function (stream) {
    return _Manager__WEBPACK_IMPORTED_MODULE_0__["single"].hungup(stream);
};
//_outer.subscribe = inner.subscribe; //subscribe: function (member, stream, subSVideo, subSAudio, videoTag, confrId)
_outer.unsubscribe = function (stream) {
    return _Manager__WEBPACK_IMPORTED_MODULE_0__["single"].hungup(stream);
};
//_outer.switchCamera = inner.switchCamera;
_outer.exitConference = function (closedSelfConfr) {
    return _Manager__WEBPACK_IMPORTED_MODULE_0__["single"].exit(closedSelfConfr || false);
};

_outer.getConferenceInfo = function (confrId, password) {
    return _Manager__WEBPACK_IMPORTED_MODULE_0__["single"].selectConfr(confrId, password);
};
_outer.createConference = _Manager__WEBPACK_IMPORTED_MODULE_0__["single"].createConfr;
_outer.grantRole = function (confr, members, role) {
    emedia.decodeMemeberName(members);
    return _Manager__WEBPACK_IMPORTED_MODULE_0__["single"].chanageRoles(role, members, confr.id);
};
_outer.kickMembersById = function (confr, members) {
    emedia.decodeMemeberName(members);
    return _Manager__WEBPACK_IMPORTED_MODULE_0__["single"].kickMember(members, confr.id);
};
_outer.destroyConference = function (confr) {
    return _Manager__WEBPACK_IMPORTED_MODULE_0__["single"].disbandConfr(confr, confr.roleToken);
};

emedia.decodeMemeberName = function (member) {
    if (typeof emedia.decodeMemeberNameString !== "function") {
        return member;
    }

    if (typeof member === 'string') {
        return emedia.decodeMemeberNameString(member);
    }

    if (underscore__WEBPACK_IMPORTED_MODULE_1___default.a.isArray(member)) {
        for (var i = 0; i < member.length; i++) {
            member[i] = emedia.decodeMemeberName(member[i]);
        }
        return member;
    }

    if (member.name) {
        member.globalName = member.name;
        member.memName = member.name = emedia.decodeMemeberName(member.name);
        return;
    }

    if (member.memName) {
        member.globalName = member.memName;
        member.memName = member.name = emedia.decodeMemeberName(member.memName);
        return;
    }
};

emedia.ConfrType = _Manager__WEBPACK_IMPORTED_MODULE_0__["single"].ConfrType;
emedia.Role = _Manager__WEBPACK_IMPORTED_MODULE_0__["single"].Role;

zepto__WEBPACK_IMPORTED_MODULE_2___default()(function () {
    var WebIM = window.WebIM;

    if (WebIM && WebIM.conn && typeof WebIM.conn.onOpened === "function") {
        // noinspection JSAnnotator
        var useIM = function useIM() {
            emedia.decodeMemeberNameString = function (member) {
                if (typeof member === 'string') {
                    if (member.indexOf(WebIM.conn.orgName) < 0) {
                        return member;
                    }

                    var _index = member.indexOf("_");
                    if (_index < 0) {
                        _index = 0;
                    } else {
                        _index++;
                    }

                    var endIndex = member.indexOf("@");
                    if (endIndex < 0) {
                        endIndex = member.length;
                    }

                    return member.substring(_index, endIndex);
                }

                return member;
            };

            _Manager__WEBPACK_IMPORTED_MODULE_0__["single"].setUrlCreator(function (url, apiName) {
                return WebIM.conn.apiUrl + url;
            });

            _Manager__WEBPACK_IMPORTED_MODULE_0__["single"].setIdentity(WebIM.conn.orgName + "#" + WebIM.conn.appName + "_" + WebIM.conn.user + "@" + WebIM.conn.domain, WebIM.conn.token);
        };

        var _onOpened = WebIM.conn.onOpened;
        WebIM.conn.onOpened = function () {
            _onOpened.apply(WebIM.conn, arguments);
            useIM();
        };

        if (WebIM.conn.token) {
            useIM();
        };
    }
});

var outer = underscore__WEBPACK_IMPORTED_MODULE_1___default.a.extend(_Manager__WEBPACK_IMPORTED_MODULE_0__["single"], _outer);

/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "single", function() { return single; });
/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);
/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Util__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var zepto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);
/* harmony import */ var zepto__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(zepto__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17);
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(underscore__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(36);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(135);
/* harmony import */ var _Stream__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(26);
/* harmony import */ var _Stream__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_Stream__WEBPACK_IMPORTED_MODULE_5__);









var _logger = _Util__WEBPACK_IMPORTED_MODULE_0___default.a.tagLogger("mgr");

window.emedia = window.emedia || {};

var restApis = {
    createConfr: "/easemob/rtc/req/ticket",
    reqTkt: "/easemob/rtc/req/ticket",
    chanageRoles: "/easemob/rtc/chanage/roles",
    disbandConfr: "/easemob/rtc/disband/conference",
    kickMember: "/easemob/rtc/kick/member",
    selectConfr: "/easemob/rtc/select/confr"
};

function Manager() {
    this._confrs = {};
    this._services = {};
    this._events = {};
    this._videos = {};
}

Manager.prototype.ConfrType = {
    COMMUNICATION: 10,
    COMMUNICATION_MIX: 11,
    LIVE: 12,
    P2P: 13,
    INTERCOMM: 14
};

Manager.prototype.Role = {
    ADMIN: 7,
    TALKER: 3,
    AUDIENCE: 1
};

var _ajax = function _ajax(ajaxUrl, confrArgs) {
    return new Promise(function (resolve, reject) {
        zepto__WEBPACK_IMPORTED_MODULE_1___default.a.ajax({
            type: 'POST',
            url: ajaxUrl,
            data: JSON.stringify(confrArgs),
            contentType: 'application/json',
            dataType: 'json',
            success: function success(data, status, xhr) {
                _logger.debug("REST: ", data, " -> ", confrArgs, ajaxUrl);
                if (data.error === 0) {
                    _Util__WEBPACK_IMPORTED_MODULE_0___default.a.removeAttribute(data, "error");
                    resolve(data);
                } else {
                    _Util__WEBPACK_IMPORTED_MODULE_0___default.a.extend(data, { errorType: "server_refuse" });
                    reject(data);
                }
            },
            error: function error(xhr, errorType, _error) {
                var data = {
                    errorType: "http_error",
                    error: xhr.status,
                    errorMessage: _error
                };
                _logger.debug("REST: ", data, " -> ", confrArgs, ajaxUrl);

                reject({
                    errorType: "http_error",
                    error: xhr.status,
                    errorMessage: _error
                });
            }
        });
    });
};

var _ajax2 = function _ajax2(ajaxUrl, confrArgs) {
    return function onSubscription(observer) {
        zepto__WEBPACK_IMPORTED_MODULE_1___default.a.ajax({
            type: 'POST',
            url: ajaxUrl,
            data: JSON.stringify(confrArgs),
            contentType: 'application/json',
            dataType: 'json',
            success: function success(data, status, xhr) {
                _logger.debug("REST: ", data, " -> ", confrArgs, ajaxUrl);
                if (data.error === 0) {
                    _Util__WEBPACK_IMPORTED_MODULE_0___default.a.removeAttribute(data, "error");
                    observer.next(data);
                    observer.complete();
                } else {
                    _Util__WEBPACK_IMPORTED_MODULE_0___default.a.extend(data, { errorType: "server_refuse" });
                    observer.error(data);
                }
            },
            error: function error(xhr, errorType, _error2) {
                var data = {
                    errorType: "http_error",
                    error: xhr.status,
                    errorMessage: _error2
                };
                _logger.debug("REST: ", data, " -> ", confrArgs, ajaxUrl);

                observer.error({
                    errorType: "http_error",
                    error: xhr.status,
                    errorMessage: _error2
                });
            }
        });
    };
};

(function loadApi(_urls) {
    _Util__WEBPACK_IMPORTED_MODULE_0___default.a.forEach(_urls, function (api, url) {
        Manager.prototype[api] = function (apiArgs) {
            return _ajax2(this.createUrl(url, api), apiArgs);
        };
    });
})(restApis);

Manager.prototype.createUrl = function (url, api) {
    return url;
};

Manager.prototype.setUrlCreator = function (creator) {
    this.createUrl = creator.bind(this);
};

Manager.prototype.destroy = function () {};

Manager.prototype.ZeroStream = _Stream__WEBPACK_IMPORTED_MODULE_5___default.a.extend({
    __init__: function __init__() {
        var self = this;

        self.type = 2;
        self.id = "0";
        self._located = false;

        self.mutedMuted = false;
    },

    onGotRemoteMediaStream: function onGotRemoteMediaStream(remoteMediaStream) {
        var self = this;

        if (!self.remotePlayAudioObject) {
            var _audioId = "__o_remote_play_audio_" + self.id;

            var audioObject = document.createElement("audio");
            audioObject.style.display = "none";
            audioObject.id = "__o_remote_play_audio_" + self.id;
            audioObject.autoplay = true;
            audioObject.playsinline = true;

            //monitorEvents && monitorEvents(audioObject);

            self.remotePlayAudioObject = audioObject;

            document.body.appendChild(audioObject);
        }

        // self.remotePlayAudioObject.autoplay = true;
        // self.remotePlayAudioObject.playsinline = true;
        self.remotePlayAudioObject.srcObject = remoteMediaStream;

        //window.__$_remoteMediaStream = remoteMediaStream;
    }
});

Manager.prototype.setIdentity = function (identityName, identityToken, extInfo) {
    this.identityName = identityName;
    this.identityToken = identityToken;
    this.ext = extInfo;

    this._terminalInfo = {
        "browser": emedia.browser,
        "browserVersion": emedia.browserVersion,
        "version": emedia.config.version,
        "userAgent": emedia.config.userAgent
    };

    _logger.info("set identity: ", identityName, identityToken);
    this.destroy();

    emedia.config({
        autoSub: false,
        onlyEnter: true
    });
};

Manager.prototype.EventsObservable = __webpack_require__(235).default;

var errorHandler = Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["catchError"])(function (err, caught) {
    _logger.error(err);
    throw err;
});

function rxCreateConfr(confrType, password) {
    var self = this;

    if (typeof confrType === 'string') {
        confrType = parseInt(confrType);
    }

    return rxjs__WEBPACK_IMPORTED_MODULE_3__["Observable"].create(Manager.prototype.createConfr.call(self, {
        uid: self.identityName,
        token: self.identityToken,
        confrType: confrType,
        password: password,
        terminal: self._terminalInfo
    })).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["map"])(function (response) {
        response.mixed = response.type === 11 || response.type === 12;
        response.id = response.serverConfrId = response.confrId;
        self._confrs[response.confrId] = underscore__WEBPACK_IMPORTED_MODULE_2___default.a.extend({}, response);

        //_util.removeAttribute(response, "ticket");
        //_util.removeAttribute(response, "roleToken");
        _Util__WEBPACK_IMPORTED_MODULE_0___default.a.removeAttribute(response, "rtcCfg");

        return response;
    }), errorHandler);
}

function rxReqTkt(confrId, password) {
    var self = this;

    var apiArgs = {
        uid: self.identityName,
        token: self.identityToken,
        confrId: confrId,
        password: password,
        terminal: self._terminalInfo
    };

    self._confrs[confrId] && (apiArgs.roleToken = self._confrs[confrId].roleToken);
    return rxjs__WEBPACK_IMPORTED_MODULE_3__["Observable"].create(Manager.prototype.reqTkt.call(self, apiArgs)).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["map"])(function (response) {
        response.mixed = response.type === 11 || response.type === 12;
        response.id = response.serverConfrId = response.confrId = confrId;
        self._confrs[confrId] = _Util__WEBPACK_IMPORTED_MODULE_0___default.a.extend(self._confrs[confrId] || {}, response);

        //_util.removeAttribute(response, "ticket");
        //_util.removeAttribute(response, "roleToken");
        _Util__WEBPACK_IMPORTED_MODULE_0___default.a.removeAttribute(response, "rtcCfg");

        return response;
    }), errorHandler);
}

function rxChanageRoles(role, uids, confrId) {
    var self = this;

    var confr = self._confr(confrId);
    var service = self._service(confrId);

    var apiArgs = {
        uids: uids,
        role: role,
        roleToken: confr.roleToken
    };

    return rxjs__WEBPACK_IMPORTED_MODULE_3__["Observable"].create(Manager.prototype.chanageRoles.call(self, apiArgs)).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["map"])(function (response) {
        service && service.current && service.current._sysCopy();
        //return response.error === 0;
        return confr.id;
    }), errorHandler);
}

function rxDisbandConfr(confrId, roleToken) {
    var self = this;

    var confr = self._confr(confrId);
    var apiArgs = {
        roleToken: confr && confr.roleToken || roleToken
    };

    return rxjs__WEBPACK_IMPORTED_MODULE_3__["Observable"].create(Manager.prototype.disbandConfr.call(self, apiArgs)).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["map"])(function (response) {
        _Util__WEBPACK_IMPORTED_MODULE_0___default.a.removeAttribute(self._confrs, confrId);
        return confr.id;
    }), errorHandler);
}

function rxKickMember(uids, confrId) {
    var self = this;

    var confr = self._confr(confrId);
    var apiArgs = {
        uids: uids,
        roleToken: confr.roleToken
    };

    return rxjs__WEBPACK_IMPORTED_MODULE_3__["Observable"].create(Manager.prototype.kickMember.call(self, apiArgs)).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["map"])(function (response) {
        //return response.error === 0;
        return confr.id;
    }), errorHandler);
}

function rxSelectConfr(confrId, password) {
    var self = this;

    var confr = self._confr(confrId);

    var apiArgs = {
        uid: self.identityName,
        token: self.identityToken,
        confrId: confrId,
        password: password
    };

    if (confr) {
        apiArgs.password = password || confr.password;
        apiArgs.roleToken = confr.roleToken;
    }

    return rxjs__WEBPACK_IMPORTED_MODULE_3__["Observable"].create(Manager.prototype.selectConfr.call(self, apiArgs)).pipe(errorHandler);
}

function onRemoteStream(confrId, stream) {}

function rxAfterJoinedConfr(confrId, joinMemberId) {
    var self = this;
    var confr = self._confr(confrId);
    var service = self._service(confrId);

    switch (confr.type) {
        case 0: //CONFR
        case 10:
            //COMMUNICATION
            break;
        case 11:
            //COMMUNICATION_MIX  Audio:Mixed
            break;
        case 12:
            //LIVE  Audio:Mixed=
            var zeroStream = new self.ZeroStream();
            service.current._cacheStreams[zeroStream.id] = zeroStream;
            if (service.current.role == single.Role.AUDIENCE) {
                //观众 订阅0
                return rxSubscribe.call(self, confrId, zeroStream, false, true).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["concatMap"])(function () {
                    return Object(rxjs__WEBPACK_IMPORTED_MODULE_3__["of"])(_Util__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, self._confrs[confrId]));;
                }));
            }
            break;
        case 13: //P2P
        case 14:
            //INTERCOMM
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_3__["throwError"])("not support conf type: " + confr.type);
        default:
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_3__["throwError"])("not support conf type: " + confr.type);
    }

    return Object(rxjs__WEBPACK_IMPORTED_MODULE_3__["of"])(_Util__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, self._confrs[confrId]));;
}

function rxSupportRemoteControl(confrId, joinMemberId, service) {
    var self = this;
    emedia.ctrl.support(service, function onHasRemoteControl(stream, controler, controlRequest) {
        self.onHasRemoteControl(stream, controler, controlRequest, confrId);
    }, function onRemoteFreeControl(stream, controler, cId) {
        self.onRemoteFreeControl(stream, controler, cId, confrId);
    });
    _logger.info("support remote control. ", confrId, joinMemberId);

    return Object(rxjs__WEBPACK_IMPORTED_MODULE_3__["of"])(_Util__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, self._confrs[confrId]));
}

function rxJoinUseTicket(confrId, ticket, ext) {
    var self = this;

    if (self.joined(confrId)) {
        return Object(rxjs__WEBPACK_IMPORTED_MODULE_3__["throwError"])("had joined confr " + confrId + ", if you want join again, please call exitConference");
    }

    var events = self._events[confrId] = new self.EventsObservable(self, confrId, function (stream) {
        onRemoteStream.call(self, confrId, stream);
    });

    self.confrEventsObserver && events.subscribe(self.confrEventsObserver);

    var service = self._service(confrId);
    service = self._services[confrId] = new emedia.XService({
        listeners: events
    });

    service.setup(ticket, ext);

    return rxjs__WEBPACK_IMPORTED_MODULE_3__["Observable"].create(function onSubscription(observer) {
        service.join(function (memId) {
            self.__current_confrId = confrId;
            self._confrs[confrId].joinId = memId;
            self._confrs[confrId].role = service.current && service.current.role;

            observer.next(self._confrs[confrId]);
            observer.complete();
        }, function (event) {
            service.exit();
            observer.error({
                errorType: "join_fail",
                error: -200,
                errorMessage: event.message()
            });
        });
    }).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["concatMap"])(function (joinMemberId, _index) {
        return rxSupportRemoteControl.call(self, confrId, joinMemberId, service);
    }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["concatMap"])(function (joinMemberId, _index) {
        return rxAfterJoinedConfr.call(self, confrId, joinMemberId);
    }), errorHandler);
}

function rxJoinUsePassword(confrId, password, ext) {
    var self = this;

    return rxReqTkt.call(self, confrId, password, ext).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["concatMap"])(function (_confr, _index) {
        return rxJoinUseTicket.call(self, confrId, _confr.ticket, ext);
    }));
}

function rxJoinExistConfrUsePassword(confrId, password, ext) {
    var self = this;
    return rxSelectConfr.call(self, confrId, password, ext).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["concatMap"])(function (_confr, _index) {
        return rxJoinUsePassword.call(self, confrId, password, ext);
    }));
}

function openUserMedia(confrId, openingStream) {
    var self = this;
    var service = self._service(confrId);

    return rxjs__WEBPACK_IMPORTED_MODULE_3__["Observable"].create(function onSubscription(observer) {
        service.openUserMedia(openingStream).then(function () {
            observer.next(openingStream);
            observer.complete();
        }, function fail(evt) {
            observer.error({
                errorType: "open_user_media_fail",
                error: -201,
                errorMessage: evt.message()
            });
        });
    }).pipe(errorHandler);
}

function rxPublish(confrId, userStream) {
    var self = this;
    var service = self._service(confrId);

    return rxjs__WEBPACK_IMPORTED_MODULE_3__["Observable"].create(function onSubscription(observer) {
        service.push(userStream, function (pushedStream) {
            observer.next(pushedStream);
            observer.complete();
        }, function fail(evt) {
            observer.error({
                errorType: "push_fail",
                error: -203,
                errorMessage: evt.message()
            });
        });
    }).pipe(errorHandler);
}

function rxResumePauseVideo(pubS, videoConstaints, confrId) {
    var self = this;
    var confr = self._confr(confrId);
    var service = self._service(confrId);

    if (typeof pubS === 'string') {
        pubS = service.getStreamById(pubS);
    } else {
        pubS = service.getStreamById(pubS.id);
    }
    if (!pubS) {
        return Object(rxjs__WEBPACK_IMPORTED_MODULE_3__["throwError"])("pub stream not exsits. it is " + pubS);
    }

    if (typeof videoConstaints !== 'boolean' && pubS.constaints && underscore__WEBPACK_IMPORTED_MODULE_2___default.a.isEqual(videoConstaints, pubS.constaints.video) || videoConstaints == !pubS.voff) {
        return Object(rxjs__WEBPACK_IMPORTED_MODULE_3__["of"])(underscore__WEBPACK_IMPORTED_MODULE_2___default.a.extend({}, confr.av));
    }

    return rxVoff.call(self, confrId, pubS, videoConstaints);
}

function rxVoff(confrId, pubS, videoConstaints) {
    var self = this;
    var service = self._service(confrId);

    return rxjs__WEBPACK_IMPORTED_MODULE_3__["Observable"].create(function onSubscription(observer) {
        service._republishByVideoConstaints(pubS, videoConstaints, function fail(evt) {
            observer.error({
                errorType: "voff_fail",
                error: -203,
                errorMessage: evt.message()
            });
        }, function success() {
            observer.next(service.getStreamById(pubS.id));
            observer.complete();
        });
    }).pipe(errorHandler);
}

function rxResumePauseAudio(pubS, aoff, confrId) {
    var self = this;
    var confr = self._confr(confrId);
    var service = self._service(confrId);

    if (typeof pubS === 'string') {
        pubS = service.getStreamById(pubS);
    } else {
        pubS = service.getStreamById(pubS.id);
    }
    if (!pubS) {
        return Object(rxjs__WEBPACK_IMPORTED_MODULE_3__["throwError"])("pub stream not exsits. it is " + pubS);
    }

    if (confr.type === self.ConfrType.COMMUNICATION_MIX || confr.type === self.ConfrType.LIVE) {
        //混音时，共享桌面带声音，会造成 服务端错误。
        if (pubS.type === 1 && !aoff) {
            _logger.warn("confr mix. not allow desktop with audio.");
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_3__["throwError"])("confr mix. not allow desktop with audio.");
        }
    }

    return rxAoff.call(self, confrId, pubS, aoff);
}

function rxAoff(confrId, pubS, aoff) {
    var self = this;
    var service = self._service(confrId);

    return rxjs__WEBPACK_IMPORTED_MODULE_3__["Observable"].create(function onSubscription(observer) {
        service.aoff(pubS, aoff, function fail(evt) {
            observer.error({
                errorType: "aoff_fail",
                error: -203,
                errorMessage: evt.message()
            });
        }, function success() {
            observer.next(service.getStreamById(pubS.id));
            observer.complete();
        });
    }).pipe(errorHandler);
}

function rxPublishMedia(confrId, constaints, videoTag, ext) {
    var self = this;

    var confr = self._confr(confrId);
    var service = self._service(confrId);

    if (service.current.role == self.Role.AUDIENCE) {
        return Object(rxjs__WEBPACK_IMPORTED_MODULE_3__["throwError"])("Audience not allow publish");
    }
    if (confr.av) {
        return Object(rxjs__WEBPACK_IMPORTED_MODULE_3__["throwError"])("Audio and video stream has been published. not allow repeat publish.");
    }

    var Stream = confr.mixed ? service.AudioMixerPubstream : service.AVPubstream;
    var stream = confr.av = new Stream({
        constaints: constaints,
        aoff: 0,
        voff: 0,
        ext: ext
    });

    return openUserMedia.call(self, confr.id, stream).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["concatMap"])(function (userStream) {
        videoTag && _Util__WEBPACK_IMPORTED_MODULE_0___default.a.targetDOM(videoTag) && attachMediaStream(videoTag, userStream.localStream);
        return rxPublish.call(self, confr.id, userStream, ext);
    }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["map"])(function (pushedStream) {
        confr.av = pushedStream;
        videoTag && self.streamBindVideo(confr.av, videoTag);
        confr.type == self.ConfrType.LIVE && self.hungup(0);
        return _Util__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, pushedStream);
    }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["catchError"])(function (err, caught) {
        confr.av && self.hungup(confr.av);
        confr.av = undefined;

        _logger.error(err);
        throw err;
    }));
}

function rxChanageCamera(confrId) {
    var self = this;

    var confr = self._confr(confrId);
    var service = self._service(confrId);

    if (service.current.role == self.Role.AUDIENCE) {
        return Object(rxjs__WEBPACK_IMPORTED_MODULE_3__["throwError"])("Audience not allow publish");
    }

    return rxjs__WEBPACK_IMPORTED_MODULE_3__["Observable"].create(function onSubscription(observer) {
        service.chanageCamera(confr.av, function fail(evt) {
            observer.error({
                errorType: "switch_camera_fail",
                error: -203,
                errorMessage: evt.message()
            });
        }, function success() {
            observer.complete();
        });
    }).pipe(errorHandler);
}

function rxShareDesktop(confrId, constaints, videoTag, ext) {
    var self = this;

    var confr = self._confr(confrId);
    var service = self._service(confrId);

    if (service.current.role == self.Role.AUDIENCE) {
        return Object(rxjs__WEBPACK_IMPORTED_MODULE_3__["throwError"])("Audience not allow publish");
    }
    if (confr.desktop) {
        return Object(rxjs__WEBPACK_IMPORTED_MODULE_3__["throwError"])("desktop stream has been published. not allow repeat publish.");
    }

    if (confr.type === self.ConfrType.COMMUNICATION_MIX || confr.type === self.ConfrType.LIVE) {
        //混音时，共享桌面带声音，会造成 服务端错误。
        if (constaints.audio) {
            _logger.warn("confr mix. not allow desktop with audio.");
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_3__["throwError"])("confr mix. not allow desktop with audio.");
        }
    }

    if (!constaints.audio && confr.av && !confr.av.aoff) {
        _logger.warn("repeat audio. desktop and av");
    }

    var stream = confr.desktop = new service.ShareDesktopPubstream({
        screenOptions: constaints.video && constaints.video.screenOptions || ['screen', 'window', 'tab'],
        mandatory: constaints.video && constaints.video.mandatory || {},
        vbitrate: constaints.video && constaints.video.bitrate,
        abitrate: constaints.audio && constaints.audio.bitrate,
        aoff: !!constaints.audio ? 0 : 1,
        ext: ext
    });

    return openUserMedia.call(self, confr.id, stream).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["concatMap"])(function (userStream) {
        videoTag && _Util__WEBPACK_IMPORTED_MODULE_0___default.a.targetDOM(videoTag) && attachMediaStream(videoTag, userStream.localStream);
        return rxPublish.call(self, confr.id, userStream, ext);
    }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["map"])(function (pushedStream) {
        confr.desktop = pushedStream;
        videoTag && _Util__WEBPACK_IMPORTED_MODULE_0___default.a.targetDOM(videoTag) && self.streamBindVideo(confr.desktop, videoTag);
        return _Util__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, pushedStream);
    }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["catchError"])(function (err, caught) {
        confr.desktop = undefined;
        _logger.error(err);
        throw err;
    }));
}

function rxSubscribe(confrId, stream, subSVideo, subSAudio, videoTag) {
    var self = this;
    var streamId = typeof stream === "string" ? stream : stream.id;

    var confr = self._confr(confrId);
    var service = self._service(confrId);

    if (stream.type === 2 && subSAudio == true && stream.id != 0) {
        //return throwError("Mixed audio stream. not allow repeat sub audio");
        subSAudio = false;
        _logger.warn("Mixed audio stream. not allow repeat sub audio. force reset subSAudio = false");
    }

    videoTag && _Util__WEBPACK_IMPORTED_MODULE_0___default.a.targetDOM(videoTag) && self.streamBindVideo(streamId, videoTag);

    return rxjs__WEBPACK_IMPORTED_MODULE_3__["Observable"].create(function onSubscription(observer) {
        service.subscribe(streamId, function (remoteMediaStream) {
            try {
                if (streamId != "0") {
                    var cacheStream = service.getStreamById(streamId);
                    var constaints = {
                        video: cacheStream.subArgs ? cacheStream.subArgs.subSVideo : !cacheStream.voff,
                        audio: cacheStream.subArgs ? cacheStream.subArgs.subSAudio : !cacheStream.aoff
                    };
                    if (cacheStream.type === 2) {
                        constaints.audio = true;
                    }
                    self._onMemberMediaChanaged(cacheStream.owner, cacheStream, constaints, confr.confrId);
                }
            } finally {
                observer.next(remoteMediaStream);
                observer.complete();
            }
        }, function (evt) {
            observer.error({
                errorType: "sub_fail",
                error: -203,
                errorMessage: evt.message()
            });
        }, { subSVideo: subSVideo, subSAudio: subSAudio });
    }).pipe(errorHandler);
}

function _streamBindVideo(stream, _videoTag, confrId) {
    var self = this;

    var service = self._service(confrId);
    stream = service.current._cacheStreams[typeof stream === "string" ? stream : stream.id];

    var videoTag = _videoTag || self.crtAndReturnVideo(stream.owner, stream);
    if (!videoTag) {
        return;
    }
    self._videos[stream.id] = videoTag;

    videoTag.setAttribute("autoplay", "autoplay");
    videoTag.setAttribute("playsinline", "playsinline");
    videoTag.setAttribute("easemob_stream", stream.id);

    stream.aoff ? videoTag.setAttribute("aoff", "aoff") : videoTag.removeAttribute("aoff");
    stream.voff ? videoTag.setAttribute("voff", "voff") : videoTag.removeAttribute("voff");

    stream.ifMediaStream(function (mediaStream) {
        videoTag && attachMediaStream(videoTag, mediaStream);

        if (videoTag.hasAttribute("flow")) {
            self.onMediaTransmission(videoTag, function cb(trackId, type, subtype, data) {
                zepto__WEBPACK_IMPORTED_MODULE_1___default()(videoTag).trigger("onMediaTransmission", [trackId, type, subtype, data]);
            });
        }
    });

    var $video = zepto__WEBPACK_IMPORTED_MODULE_1___default()(videoTag);
    $video.off("hungup");
    $video.on("hungup", function (e, fail, success) {
        self.hungup(stream, confrId);
        success && success();
    });

    $video.off("subscribe");
    $video.on("subscribe", function (e, subSVideo, subSAudio, fail, success) {
        if (stream.located()) {
            fail && fail("local stream not allow sub");
        } else {
            subSVideo = stream.subArgs && stream.subArgs.subSVideo || true;
            subSAudio = stream.subArgs && stream.subArgs.subSAudio || true;
            self.subscribe(stream.owner, stream, subSVideo, subSAudio, confrId).then(success).catch(fail);
        }
    });

    $video.off("pauseVideo");
    $video.on("pauseVideo", function (e, fail, success) {
        if (stream.located()) {
            self.pauseVideo(stream, confrId).then(success).catch(fail);
        } else {
            self.subscribe(stream.owner, stream, false, stream.subArgs && stream.subArgs.subSAudio || !stream.aoff, confrId).then(success).catch(fail);
        }
    });

    $video.off("resumeVideo");
    $video.on("resumeVideo", function (e, fail, success) {
        if (stream.located()) {
            self.resumeVideo(stream, true, confrId).then(success).catch(fail);
        } else {
            self.subscribe(stream.owner, stream, true, stream.subArgs && stream.subArgs.subSVideo || !stream.voff, confrId).then(success).catch(fail);
        }
    });

    $video.off("pauseAudio");
    $video.on("pauseAudio", function (e, fail, success) {
        if (stream.located()) {
            self.pauseAudio(stream, confrId).then(success).catch(fail);
        } else {
            self.subscribe(stream.owner, stream, stream.subArgs.subSVideo, false, confrId).then(success).catch(fail);
        }
    });

    $video.off("resumeAudio");
    $video.on("resumeAudio", function (e, fail, success) {
        if (stream.located()) {
            self.resumeAudio(stream, confrId).then(success).catch(fail);
        } else {
            self.subscribe(stream.owner, stream, stream.subArgs.subSVideo, true, confrId).then(success).catch(fail);
        }
    });

    $video.off("remoteControl");
    $video.on("remoteControl", function (e, mirror, onDisControlled, onAccept, onNotAllowRemoteControl, onRemoteControlTimeout, onReject, onBusy) {
        if (stream.located()) {
            _logger.error("not allow remote control at local");
            throw "not allow remote control at local";
        } else {
            self.remoteControl(stream, videoTag, videoTag, mirror, onDisControlled, onAccept, onNotAllowRemoteControl, onRemoteControlTimeout, onReject, onBusy, confrId);
        }
    });

    $video.off("chanageCamera");
    $video.on("chanageCamera", function (e, fail, success) {
        self.chanageCamera(confrId).then(success).catch(fail);
    });

    $video.off("captureVideo");
    $video.on("captureVideo", function (e, success, storeLocal, filename) {
        var base64 = self.captureVideo(videoTag, storeLocal, filename, confrId);
        success && success(base64);
    });

    $video.off("capturePictureRemote");
    $video.on("capturePictureRemote", function (e, fail, success) {
        self.capturePictureRemote(stream, false, confrId).then(success).catch(fail);
    });

    $video.off("freezeFrameRemote");
    $video.on("freezeFrameRemote", function (e, fail, success) {
        self.freezeFrameRemote(stream, confrId).then(success).catch(fail);
    });

    $video.off("zoomRemote");
    $video.on("zoomRemote", function (e, multiples, fail, success) {
        self.zoomRemote(stream, multiples, confrId).then(success).catch(fail);
    });

    $video.off("torchRemote");
    $video.on("torchRemote", function (e, torch, fail, success) {
        self.torchRemote(stream, torch, confrId).then(success).catch(fail);
    });

    $video.off("freeRemoteControl");
    $video.on('freeRemoteControl', function (e, fail, success) {
        try {
            self.freeRemoteControl(stream, confrId);
        } finally {
            success && success();
        }
    });

    var constaints = { video: !stream.voff, audio: !stream.aoff, voff: stream.voff, aoff: stream.aoff };
    if (!stream.located()) {
        constaints = {
            video: stream.subArgs ? stream.subArgs.subSVideo : !stream.voff,
            audio: stream.subArgs ? stream.subArgs.subSAudio : !stream.aoff,
            voff: stream.voff,
            aoff: stream.aoff
        };
    }
    $video.trigger("onMediaChanaged", [constaints, stream, stream.owner, confrId]);

    if (videoTag.getAttribute("sound")) {
        service.current._monitSoundChanagedStreams = service.current._monitSoundChanagedStreams || {};
        service.current._monitSoundChanagedStreams[stream.id] = stream.id;
    }
}

function rxFocusExpoRemote(confrId, streamId, videoTag, clickEvent) {
    var self = this;

    if (typeof streamId !== 'string') {
        streamId = streamId.id;
    }

    var confr = self._confr(confrId);
    var service = self._service(confrId);

    return rxjs__WEBPACK_IMPORTED_MODULE_3__["Observable"].create(function onSubscription(observer) {
        service.focusExpoRemote(streamId, videoTag, clickEvent, function (evt) {
            observer.error({
                errorType: "focusexpo_remote_fail",
                error: -203,
                errorMessage: evt.message()
            });
        }, function () {
            observer.complete();
        });
    }).pipe(errorHandler);
}

function rxCapturePictureRemote(confrId, streamId, rspBase64Pic) {
    var self = this;

    if (typeof streamId !== 'string') {
        streamId = streamId.id;
    }

    var confr = self._confr(confrId);
    var service = self._service(confrId);

    return rxjs__WEBPACK_IMPORTED_MODULE_3__["Observable"].create(function onSubscription(observer) {
        service.capturePictureRemote(streamId, rspBase64Pic, function (base64) {
            observer.next(base64);
            observer.complete();
        }, function (evt) {
            observer.error({
                errorType: "capture_remote_fail",
                error: -203,
                errorMessage: evt.message()
            });
        });
    }).pipe(errorHandler);
}

function rxZoomRemote(confrId, streamId, multiples) {
    var self = this;

    if (typeof streamId !== 'string') {
        streamId = streamId.id;
    }

    var confr = self._confr(confrId);
    var service = self._service(confrId);

    return rxjs__WEBPACK_IMPORTED_MODULE_3__["Observable"].create(function onSubscription(observer) {
        service.zoomRemote(streamId, multiples, function fail(evt) {
            observer.error({
                errorType: "capture_remote_fail",
                error: -203,
                errorMessage: evt.message()
            });
        }, function () {
            observer.complete();
        });
    }).pipe(errorHandler);
}

function rxTorchRemote(confrId, streamId, torch) {
    var self = this;

    if (typeof streamId !== 'string') {
        streamId = streamId.id;
    }

    var confr = self._confr(confrId);
    var service = self._service(confrId);

    return rxjs__WEBPACK_IMPORTED_MODULE_3__["Observable"].create(function onSubscription(observer) {
        service.torchRemote(streamId, torch, function (torch) {
            observer.next(torch);
            observer.complete();
        }, function fail(evt) {
            observer.error({
                errorType: "torch_remote_fail",
                error: -203,
                errorMessage: evt.message()
            });
        });
    }).pipe(errorHandler);
}

function rxFreezeFrameRemote(confrId, streamId) {
    var self = this;

    if (typeof streamId !== 'string') {
        streamId = streamId.id;
    }

    var confr = self._confr(confrId);
    var service = self._service(confrId);

    return rxjs__WEBPACK_IMPORTED_MODULE_3__["Observable"].create(function onSubscription(observer) {
        service.freezeFrameRemote(streamId, function (freezeFrame) {
            observer.next(freezeFrame);
            observer.complete();
        }, function fail(evt) {
            observer.error({
                errorType: "freeze_remote_fail",
                error: -203,
                errorMessage: evt.message()
            });
        });
    }).pipe(errorHandler);
}

var _single = _Util__WEBPACK_IMPORTED_MODULE_0___default.a.extend(new Manager(), {
    _confr: function _confr(confrId) {
        var self = this;
        confrId || (confrId = self.__current_confrId);
        return self._confrs[confrId];
    },
    _service: function _service(confrId) {
        var self = this;
        confrId || (confrId = self.__current_confrId);
        return this._services[confrId];
    },

    getStreamById: function getStreamById(streamId, confrId) {
        var self = this;
        var service = self._service(confrId);
        return service && service.getStreamById(streamId);
    },
    getMemberById: function getMemberById(memId, confrId) {
        var self = this;
        var service = self._service(confrId);
        return service && service.getMemberById(memId);
    },

    streamBindVideo: function streamBindVideo(stream, videoTag, confrId) {
        _streamBindVideo.call(this, stream, videoTag, confrId);
    },
    getBindVideoBy: function getBindVideoBy(stream) {
        var self = this;
        if (typeof stream !== "string" && stream && stream.id) {
            stream = stream.id;
        }
        if (typeof stream !== "string") {
            _logger.error("Bad stream ", stream);
            throw "Bad stream " + stream;
        }
        return self._videos[stream];
    },
    createConfr: function createConfr(confrType, password) {
        return rxCreateConfr.apply(this, arguments).toPromise();
    },

    reqTkt: function reqTkt(confrId, password) {
        return rxReqTkt.apply(this, arguments).toPromise();
    },

    chanageRoles: function chanageRoles(role, uids, confrId) {
        return rxChanageRoles.apply(this, arguments).toPromise();
    },

    disbandConfr: function disbandConfr(confrId, roleToken) {
        return rxDisbandConfr.apply(this, arguments).toPromise();
    },

    kickMember: function kickMember(uids, confrId) {
        return rxKickMember.apply(this, arguments).toPromise();
    },

    selectConfr: function selectConfr(confrId, password) {
        return rxSelectConfr.apply(this, arguments).toPromise();
    },

    joinUsePassword: function joinUsePassword(confrId, password, ext) {
        return rxJoinExistConfrUsePassword.call(this, confrId, password, ext).toPromise();
    },
    joinUseTicket: function joinUseTicket(confrId, ticket, ext) {
        return rxJoinUseTicket.call(this, confrId, ticket, ext).toPromise();
    },
    joined: function joined(confrId) {
        return confrId && this._confrs[confrId] && this._confrs[confrId].joinId || this.__current_confrId && this.joined(this.__current_confrId);
    },

    shareDesktopWithAudio: function shareDesktopWithAudio(videoConstaints, withAudio, videoTag, ext, confrId) {
        var self = this;

        if (!_Util__WEBPACK_IMPORTED_MODULE_0___default.a.targetDOM(videoTag)) {
            confrId = ext;
            ext = videoTag;
            videoTag = undefined;
        }

        var constaints = {
            video: videoConstaints,
            audio: withAudio
        };

        return rxShareDesktop.call(self, confrId, constaints, videoTag, ext).toPromise();
    },
    chanageCamera: function chanageCamera(confrId) {
        return rxChanageCamera.call(this, confrId).toPromise();
    },
    switchCamera: function switchCamera(confrId) {
        return rxChanageCamera.call(this, confrId).toPromise();
    },
    shareVideoWithAudio: function shareVideoWithAudio(videoConstaints, withAudio, videoTag, ext, confrId) {
        var self = this;

        if (!_Util__WEBPACK_IMPORTED_MODULE_0___default.a.targetDOM(videoTag)) {
            confrId = ext;
            ext = videoTag;
            videoTag = undefined;
        }

        var constaints = {
            video: videoConstaints,
            audio: withAudio
        };

        return rxPublishMedia.call(self, confrId, constaints, videoTag, ext).toPromise();
    },
    captureVideo: function captureVideo(videoObj, storeLocal, filename, confrId) {
        var self = this;
        var service = self._service(confrId);
        return service.captureVideo(videoObj, storeLocal, filename);
    },

    openUserMedia: function openUserMedia(constaints, confrId) {
        var self = this;
        var service = self._service(confrId);

        return rxjs__WEBPACK_IMPORTED_MODULE_3__["Observable"].create(function onSubscription(observer) {
            service.__getUserMedia(constaints, function (attendee, stream) {
                observer.next(stream);
                observer.complete();
            }, function (error) {
                observer.error(error);
            });
        }).pipe(errorHandler).toPromise();
    },

    mediaDevices: function mediaDevices(kind) {
        if (typeof kind === 'function') {
            kind = undefined;
        }

        return rxjs__WEBPACK_IMPORTED_MODULE_3__["Observable"].create(function onSubscription(observer) {
            navigator.mediaDevices.enumerateDevices().then(function (deviceInfos) {
                var resultDeviceInfos = [];

                for (var i = 0; i !== deviceInfos.length; ++i) {
                    var deviceInfo = deviceInfos[i];
                    var deviceId = deviceInfo.deviceId;

                    if (!kind) {
                        resultDeviceInfos.push(deviceInfo);
                    }

                    if (kind && kind === deviceInfo.kind) {
                        resultDeviceInfos.push(deviceInfo);
                    } else if (deviceInfo.kind === 'audioinput') {} else if (deviceInfo.kind === 'audiooutput') {} else if (deviceInfo.kind === 'videoinput') {} else {
                        _logger.info('Some other kind of source/device: ', deviceInfo);
                    }
                }

                observer.next(resultDeviceInfos);
                observer.complete();
            }).catch(function handleError(error) {
                _logger.warn('navigator.getUserMedia error: ', error);
                observer.error(error);
            });
        }).pipe(errorHandler).toPromise();
    },
    resumeVideo: function resumeVideo(pubS, videoConstaints, confrId) {
        return rxResumePauseVideo.call(this, pubS, videoConstaints || true, confrId).toPromise();
    },
    pauseVideo: function pauseVideo(pubS, confrId) {
        return rxResumePauseVideo.call(this, pubS, false, confrId).toPromise();
    },

    resumeAudio: function resumeAudio(pubS, confrId) {
        return rxResumePauseAudio.call(this, pubS, false, confrId).toPromise();
    },
    pauseAudio: function pauseAudio(pubS, confrId) {
        return rxResumePauseAudio.call(this, pubS, true, confrId).toPromise();
    },

    freezeFrameRemote: function freezeFrameRemote(stream, confrId) {
        return rxFreezeFrameRemote.call(this, confrId, stream).toPromise();
    },
    torchRemote: function torchRemote(stream, torch, confrId) {
        return rxTorchRemote.call(this, confrId, stream, torch).toPromise();
    },
    zoomRemote: function zoomRemote(stream, multiples, confrId) {
        return rxZoomRemote.call(this, confrId, stream, multiples).toPromise();
    },
    capturePictureRemote: function capturePictureRemote(streamId, confrId) {
        return rxCapturePictureRemote.call(this, confrId, streamId, false).toPromise();
    },

    focusExpoRemote: function focusExpoRemote(stream, videoTag, clickEvent, confrId) {
        return rxFocusExpoRemote.call(this, confrId, stream, videoTag, clickEvent).toPromise();
    },

    onFocusExpoRemoteWhenClickVideo: function onFocusExpoRemoteWhenClickVideo(tag, event, fail, success) {
        var self = this;

        if (typeof event === 'function') {
            success = fail;
            fail = event;
            event = undefined;
        }

        zepto__WEBPACK_IMPORTED_MODULE_1___default()(tag).off(event || 'click');
        zepto__WEBPACK_IMPORTED_MODULE_1___default()(tag).on(event || 'click', function (e) {
            var streamId = tag.getAttribute("easemob_stream");
            self.focusExpoRemote(streamId, tag, e).then(success).catch(fail);
        });

        return event;
    },
    offEventAtTag: function offEventAtTag(tag, event) {
        event && zepto__WEBPACK_IMPORTED_MODULE_1___default()(tag).off(event);
    },

    hungup: function hungup(stream, confrId) {
        var self = this;

        var streamId;
        if (typeof stream === "string") {
            streamId = stream;
        } else {
            streamId = stream.id || stream + "";
        }

        var service = self._service(confrId);
        var confr = self._confr(confrId);
        if (!confr || !service) {
            _logger.warn("when hungup stream. not found confr and service.", stream);
            return;
        }

        service.hungup(streamId);

        var hungeAv = false;
        confr.av && (hungeAv = confr.av.id === streamId) && (confr.av = undefined);
        confr.desktop && confr.desktop.id === streamId && (confr.desktop = undefined);

        if (hungeAv && confr.type == self.ConfrType.LIVE && service.current.role == single.Role.AUDIENCE) {
            //观众 订阅0  && service.current.role == single.Role.AUDIENCE
            var zeroStream = service.current && service.current._cacheStreams["0"];
            self.subscribe(service.current, zeroStream, false, true, confrId);
        }
    },

    subscribe: function subscribe(member, stream, subSVideo, subSAudio, videoTag, confrId) {
        var self = this;
        if (!_Util__WEBPACK_IMPORTED_MODULE_0___default.a.targetDOM(videoTag)) {
            confrId = videoTag;
            videoTag = undefined;
        }
        return rxSubscribe.call(self, confrId, stream, subSVideo, subSAudio, videoTag).toPromise();
    },

    exit: function exit(closeMyConfrIfICrtConfr, confrId) {
        var self = this;

        var service = self._service(confrId);
        if (!service) {
            _logger.warn("when exit. not found service.", confrId);
            return;
        }

        service.exit(closeMyConfrIfICrtConfr);
    },

    _onExit: function _onExit(confrId, reason, failed) {
        var self = this;
        try {
            self.__current_confrId = undefined;
            self.onExit(reason, failed, confrId);
        } finally {
            _Util__WEBPACK_IMPORTED_MODULE_0___default.a.removeAttribute(self._confrs, confrId);
            _Util__WEBPACK_IMPORTED_MODULE_0___default.a.removeAttribute(self._services, confrId);
            _Util__WEBPACK_IMPORTED_MODULE_0___default.a.removeAttribute(self._videos, confrId);
            _Util__WEBPACK_IMPORTED_MODULE_0___default.a.removeAttribute(self._events, confrId);
        }
    },
    onExit: function onExit(reason, failed, confrId) {},
    _onRoleUpdated: function _onRoleUpdated(role, confrId) {},

    onMemberJoin: function onMemberJoin(member, confrId) {},
    onMemberLeave: function onMemberLeave(member, reason, confrId) {},
    _onRecvRemoteMessage: function _onRecvRemoteMessage(fromMember, argsObject, confrId) {},

    crtAndReturnVideo: function crtAndReturnVideo(member, stream, confrId) {
        //throw "Please set crtAndReturnVideo";
    },
    unloadVideo: function unloadVideo(member, stream, video, confrId) {
        //throw "Please set unloadVideo";
    },

    remoteControl: function remoteControl(stream, videoObj, targetDiv, mirror, onDisControlled, onAccept, onNotAllowRemoteControl, onRemoteControlTimeout, onReject, onBusy, confrId) {
        var self = this;
        var service = self._service(confrId);

        mirror = !!mirror;

        var streamId = typeof stream === "string" ? stream : stream.id;

        if (mirror) {
            emedia.ctrl.mirrorControlled(service, streamId, videoObj, targetDiv, onDisControlled, onAccept, onNotAllowRemoteControl, onRemoteControlTimeout, onReject, onBusy);
        } else {
            emedia.ctrl.controlled(service, streamId, videoObj, targetDiv, onDisControlled, onAccept, onNotAllowRemoteControl, onRemoteControlTimeout, onReject, onBusy);
        }
    },

    freeRemoteControl: function freeRemoteControl(stream, confrId) {
        var self = this;
        var service = self._service(confrId);
        var streamId = typeof stream === "string" ? stream : stream.id;
        emedia.ctrl.disControlled(service, streamId);
    },

    zeptoTrigger: function zeptoTrigger(tag, event) {
        //zepto(tag).trigger(event, [fail, success]);
        return rxjs__WEBPACK_IMPORTED_MODULE_3__["Observable"].create(function onSubscription(observer) {
            zepto__WEBPACK_IMPORTED_MODULE_1___default()(tag).trigger(event, [function fail() {
                observer.error.apply(observer, arguments);
            }, function success() {
                observer.next.apply(observer, arguments);
                observer.complete();
            }]);
        }).pipe(errorHandler).toPromise();
    },
    _onAddMemberStream: function _onAddMemberStream(stream, confrId) {},
    _onRemoveMemberStream: function _onRemoveMemberStream(stream, confrId) {},
    _onUpdateMemberStream: function _onUpdateMemberStream(stream, constaints, confrId) {},
    _onMemberMediaChanaged: function _onMemberMediaChanaged(member, stream, constaints, confrId) {
        var tag = this._videos[stream.id];
        constaints && (constaints.voff = stream.voff, constaints.aoff = stream.aoff);
        tag && zepto__WEBPACK_IMPORTED_MODULE_1___default()(tag).trigger("onMediaChanaged", [constaints, stream, member, confrId]);
    },
    onMediaChanaged: function onMediaChanaged(tag, cb) {
        // cb video audio
        this.addVideoEventListener(tag, "onMediaChanaged", cb);
    },

    _onMemberSoundChanaged: function _onMemberSoundChanaged(member, stream, meterData, confrId) {
        var tag = this._videos[stream.id];
        tag && zepto__WEBPACK_IMPORTED_MODULE_1___default()(tag).trigger("onSoundChanaged", [meterData, stream, member, confrId]);
    },
    onSoundChanaged: function onSoundChanaged(tag, cb) {
        // cb video audio
        if (!emedia.config.getMediaMeterIntervalMillis || emedia.config.getMediaMeterIntervalMillis <= 0) {
            _logger.error("monit sound chanaged not config. please config getMediaMeterIntervalMillis");
            throw "monit sound chanaged not config. please config getMediaMeterIntervalMillis";
        }

        tag.setAttribute("sound", "sound");
        this.addVideoEventListener(tag, "onSoundChanaged", cb);
    },

    onMediaTransmission: function onMediaTransmission(tag, cb) {
        // cb video audio
        if (!emedia.helper || typeof emedia.helper.inboundVideo !== "function") {
            _logger.warn("please import helper. <script>");
            return;
        }

        var service = this._service();

        var streamId = tag.getAttribute("easemob_stream");
        var stream = streamId && service.getStreamById(streamId);
        var flowWebrtc = tag.getAttribute("flowWebrtc");

        if (stream && stream._webrtc && flowWebrtc == stream._webrtc.__id) {
            return;
        }

        if (tag.hasAttribute("flow") && stream && stream._webrtc) {
            //开启流量监控

            if (stream.located()) {
                emedia.helper.outboundVideo(stream, cb, 1000);
            } else {
                emedia.helper.inboundVideo(stream, cb, 1000);
            }

            tag.setAttribute("flowWebrtc", stream._webrtc.__id);
        } else {
            this.addVideoEventListener(tag, "onMediaTransmission", cb);
            tag.setAttribute("flow", "flow");
        }
    },

    _onTalking: function _onTalking(member, stream, meterData, confrId) {},

    _onNotSupportMemberPublishVideoCodecs: function _onNotSupportMemberPublishVideoCodecs(member, stream, confrId) {
        var tag = this._videos[stream.id];
        tag && zepto__WEBPACK_IMPORTED_MODULE_1___default()(tag).trigger("onNotSupportVideoCodecs", [stream, member, confrId]);
    },
    onNotSupportVideoCodecs: function onNotSupportVideoCodecs(tag, cb) {
        this.addVideoEventListener(tag, "onNotSupportVideoCodecs", cb);
    },

    _onStreamIceStateChanged: function _onStreamIceStateChanged(member, stream, state, confrId) {
        var tag = this._videos[stream.id];
        tag && zepto__WEBPACK_IMPORTED_MODULE_1___default()(tag).trigger("onIceStateChanged", [state, stream, member, confrId]);
    },
    onIceStateChanged: function onIceStateChanged(tag, cb) {
        this.addVideoEventListener(tag, "onIceStateChanged", cb);
    },

    onHasRemoteControl: function onHasRemoteControl(stream, controler, controlRequest, confrId) {
        var tag = this._videos[stream.id];
        tag && zepto__WEBPACK_IMPORTED_MODULE_1___default()(tag).trigger("onRemoteControl", [controler, controlRequest, stream, confrId]);
    },
    onRemoteControl: function onRemoteControl(tag, cb) {
        this.addVideoEventListener(tag, "onRemoteControl", cb);
    },

    onRemoteFreeControl: function onRemoteFreeControl(stream, controler, cId, confrId) {
        var tag = this._videos[stream.id];
        tag && zepto__WEBPACK_IMPORTED_MODULE_1___default()(tag).trigger("onFreeControl", [controler, cId, stream, confrId]);
    },
    onFreeControl: function onFreeControl(tag, cb) {
        this.addVideoEventListener(tag, "onFreeControl", cb);
    },

    addVideoEventListener: function addVideoEventListener(tag, event, callback) {
        zepto__WEBPACK_IMPORTED_MODULE_1___default()(tag).off(event);
        zepto__WEBPACK_IMPORTED_MODULE_1___default()(tag).on(event, function () {
            var args = [];
            for (var i = 1; i < arguments.length; i++) {
                args.push(arguments[i]);
            }
            callback && callback.apply(tag, args);
        });
    }
});

underscore__WEBPACK_IMPORTED_MODULE_2___default.a.each(["hungup", "subscribe", "pauseVideo", "resumeVideo", "pauseAudio", "resumeAudio", "chanageCamera", "freeRemoteControl", "capturePictureRemote", "freezeFrameRemote"], function (val, index) {
    var name = val.replace(/\b[a-z]/g, function (s) {
        return s.toUpperCase();
    });
    _single["trigger" + name] = function (tag) {
        return _single.zeptoTrigger(tag, val);
    };
});

_single.triggerTorchRemote = function (tag, torch) {
    return rxjs__WEBPACK_IMPORTED_MODULE_3__["Observable"].create(function onSubscription(observer) {
        zepto__WEBPACK_IMPORTED_MODULE_1___default()(tag).trigger("torchRemote", [torch, function fail() {
            observer.error.apply(observer, arguments);
        }, function success() {
            observer.next.apply(observer, arguments);
            observer.complete();
        }]);
    }).pipe(errorHandler).toPromise();
};

_single.triggerZoomRemote = function (tag, multiples) {
    return rxjs__WEBPACK_IMPORTED_MODULE_3__["Observable"].create(function onSubscription(observer) {
        zepto__WEBPACK_IMPORTED_MODULE_1___default()(tag).trigger("zoomRemote", [multiples, function fail() {
            observer.error.apply(observer, arguments);
        }, function success() {
            observer.next.apply(observer, arguments);
            observer.complete();
        }]);
    }).pipe(errorHandler).toPromise();
};

_single.triggerSubscribe = function (tag, subSVideo, subSAudio) {
    return rxjs__WEBPACK_IMPORTED_MODULE_3__["Observable"].create(function onSubscription(observer) {
        zepto__WEBPACK_IMPORTED_MODULE_1___default()(tag).trigger("subscribe", [subSVideo, subSAudio, function fail() {
            observer.error.apply(observer, arguments);
        }, function success() {
            observer.next.apply(observer, arguments);
            observer.complete();
        }]);
    }).pipe(errorHandler).toPromise();
};

_single.triggerRemoteControl = function (tag, mirror, onDisControlled, onAccept, onNotAllowRemoteControl, onRemoteControlTimeout, onReject, onBusy) {
    zepto__WEBPACK_IMPORTED_MODULE_1___default()(tag).trigger("remoteControl", [mirror, onDisControlled, onAccept, onNotAllowRemoteControl, onRemoteControlTimeout, onReject, onBusy]);
};
_single.triggerCaptureVideo = function (tag, storeLocal, filename) {
    return rxjs__WEBPACK_IMPORTED_MODULE_3__["Observable"].create(function onSubscription(observer) {
        zepto__WEBPACK_IMPORTED_MODULE_1___default()(tag).trigger("captureVideo", [function success() {
            observer.next.apply(observer, arguments);
            observer.complete();
        }, storeLocal, filename]);
    }).pipe(errorHandler).toPromise();
};

var single = _single;

/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Observable", function() { return _internal_Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"]; });

/* harmony import */ var _internal_observable_ConnectableObservable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(55);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ConnectableObservable", function() { return _internal_observable_ConnectableObservable__WEBPACK_IMPORTED_MODULE_1__["ConnectableObservable"]; });

/* harmony import */ var _internal_operators_groupBy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(60);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GroupedObservable", function() { return _internal_operators_groupBy__WEBPACK_IMPORTED_MODULE_2__["GroupedObservable"]; });

/* harmony import */ var _internal_symbol_observable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(52);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "observable", function() { return _internal_symbol_observable__WEBPACK_IMPORTED_MODULE_3__["observable"]; });

/* harmony import */ var _internal_Subject__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(56);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Subject", function() { return _internal_Subject__WEBPACK_IMPORTED_MODULE_4__["Subject"]; });

/* harmony import */ var _internal_BehaviorSubject__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(61);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BehaviorSubject", function() { return _internal_BehaviorSubject__WEBPACK_IMPORTED_MODULE_5__["BehaviorSubject"]; });

/* harmony import */ var _internal_ReplaySubject__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(62);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ReplaySubject", function() { return _internal_ReplaySubject__WEBPACK_IMPORTED_MODULE_6__["ReplaySubject"]; });

/* harmony import */ var _internal_AsyncSubject__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(79);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AsyncSubject", function() { return _internal_AsyncSubject__WEBPACK_IMPORTED_MODULE_7__["AsyncSubject"]; });

/* harmony import */ var _internal_scheduler_asap__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(80);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "asapScheduler", function() { return _internal_scheduler_asap__WEBPACK_IMPORTED_MODULE_8__["asap"]; });

/* harmony import */ var _internal_scheduler_async__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(84);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "asyncScheduler", function() { return _internal_scheduler_async__WEBPACK_IMPORTED_MODULE_9__["async"]; });

/* harmony import */ var _internal_scheduler_queue__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(63);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "queueScheduler", function() { return _internal_scheduler_queue__WEBPACK_IMPORTED_MODULE_10__["queue"]; });

/* harmony import */ var _internal_scheduler_animationFrame__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(85);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "animationFrameScheduler", function() { return _internal_scheduler_animationFrame__WEBPACK_IMPORTED_MODULE_11__["animationFrame"]; });

/* harmony import */ var _internal_scheduler_VirtualTimeScheduler__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(88);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VirtualTimeScheduler", function() { return _internal_scheduler_VirtualTimeScheduler__WEBPACK_IMPORTED_MODULE_12__["VirtualTimeScheduler"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VirtualAction", function() { return _internal_scheduler_VirtualTimeScheduler__WEBPACK_IMPORTED_MODULE_12__["VirtualAction"]; });

/* harmony import */ var _internal_Scheduler__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(69);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Scheduler", function() { return _internal_Scheduler__WEBPACK_IMPORTED_MODULE_13__["Scheduler"]; });

/* harmony import */ var _internal_Subscription__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(45);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Subscription", function() { return _internal_Subscription__WEBPACK_IMPORTED_MODULE_14__["Subscription"]; });

/* harmony import */ var _internal_Subscriber__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(39);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Subscriber", function() { return _internal_Subscriber__WEBPACK_IMPORTED_MODULE_15__["Subscriber"]; });

/* harmony import */ var _internal_Notification__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(71);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Notification", function() { return _internal_Notification__WEBPACK_IMPORTED_MODULE_16__["Notification"]; });

/* harmony import */ var _internal_util_pipe__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(53);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pipe", function() { return _internal_util_pipe__WEBPACK_IMPORTED_MODULE_17__["pipe"]; });

/* harmony import */ var _internal_util_noop__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(54);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "noop", function() { return _internal_util_noop__WEBPACK_IMPORTED_MODULE_18__["noop"]; });

/* harmony import */ var _internal_util_identity__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(89);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return _internal_util_identity__WEBPACK_IMPORTED_MODULE_19__["identity"]; });

/* harmony import */ var _internal_util_isObservable__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(90);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isObservable", function() { return _internal_util_isObservable__WEBPACK_IMPORTED_MODULE_20__["isObservable"]; });

/* harmony import */ var _internal_util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(91);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ArgumentOutOfRangeError", function() { return _internal_util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_21__["ArgumentOutOfRangeError"]; });

/* harmony import */ var _internal_util_EmptyError__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(92);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EmptyError", function() { return _internal_util_EmptyError__WEBPACK_IMPORTED_MODULE_22__["EmptyError"]; });

/* harmony import */ var _internal_util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(57);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ObjectUnsubscribedError", function() { return _internal_util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_23__["ObjectUnsubscribedError"]; });

/* harmony import */ var _internal_util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(50);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "UnsubscriptionError", function() { return _internal_util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_24__["UnsubscriptionError"]; });

/* harmony import */ var _internal_util_TimeoutError__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(93);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimeoutError", function() { return _internal_util_TimeoutError__WEBPACK_IMPORTED_MODULE_25__["TimeoutError"]; });

/* harmony import */ var _internal_observable_bindCallback__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(94);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bindCallback", function() { return _internal_observable_bindCallback__WEBPACK_IMPORTED_MODULE_26__["bindCallback"]; });

/* harmony import */ var _internal_observable_bindNodeCallback__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(96);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bindNodeCallback", function() { return _internal_observable_bindNodeCallback__WEBPACK_IMPORTED_MODULE_27__["bindNodeCallback"]; });

/* harmony import */ var _internal_observable_combineLatest__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(97);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "combineLatest", function() { return _internal_observable_combineLatest__WEBPACK_IMPORTED_MODULE_28__["combineLatest"]; });

/* harmony import */ var _internal_observable_concat__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(108);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concat", function() { return _internal_observable_concat__WEBPACK_IMPORTED_MODULE_29__["concat"]; });

/* harmony import */ var _internal_observable_defer__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(118);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "defer", function() { return _internal_observable_defer__WEBPACK_IMPORTED_MODULE_30__["defer"]; });

/* harmony import */ var _internal_observable_empty__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(72);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "empty", function() { return _internal_observable_empty__WEBPACK_IMPORTED_MODULE_31__["empty"]; });

/* harmony import */ var _internal_observable_forkJoin__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(119);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "forkJoin", function() { return _internal_observable_forkJoin__WEBPACK_IMPORTED_MODULE_32__["forkJoin"]; });

/* harmony import */ var _internal_observable_from__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(109);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "from", function() { return _internal_observable_from__WEBPACK_IMPORTED_MODULE_33__["from"]; });

/* harmony import */ var _internal_observable_fromEvent__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(120);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fromEvent", function() { return _internal_observable_fromEvent__WEBPACK_IMPORTED_MODULE_34__["fromEvent"]; });

/* harmony import */ var _internal_observable_fromEventPattern__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(121);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fromEventPattern", function() { return _internal_observable_fromEventPattern__WEBPACK_IMPORTED_MODULE_35__["fromEventPattern"]; });

/* harmony import */ var _internal_observable_generate__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(122);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "generate", function() { return _internal_observable_generate__WEBPACK_IMPORTED_MODULE_36__["generate"]; });

/* harmony import */ var _internal_observable_iif__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(123);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "iif", function() { return _internal_observable_iif__WEBPACK_IMPORTED_MODULE_37__["iif"]; });

/* harmony import */ var _internal_observable_interval__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(124);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interval", function() { return _internal_observable_interval__WEBPACK_IMPORTED_MODULE_38__["interval"]; });

/* harmony import */ var _internal_observable_merge__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(126);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return _internal_observable_merge__WEBPACK_IMPORTED_MODULE_39__["merge"]; });

/* harmony import */ var _internal_observable_never__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(127);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "never", function() { return _internal_observable_never__WEBPACK_IMPORTED_MODULE_40__["never"]; });

/* harmony import */ var _internal_observable_of__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(73);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "of", function() { return _internal_observable_of__WEBPACK_IMPORTED_MODULE_41__["of"]; });

/* harmony import */ var _internal_observable_onErrorResumeNext__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(128);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "onErrorResumeNext", function() { return _internal_observable_onErrorResumeNext__WEBPACK_IMPORTED_MODULE_42__["onErrorResumeNext"]; });

/* harmony import */ var _internal_observable_pairs__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(129);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pairs", function() { return _internal_observable_pairs__WEBPACK_IMPORTED_MODULE_43__["pairs"]; });

/* harmony import */ var _internal_observable_race__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(130);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "race", function() { return _internal_observable_race__WEBPACK_IMPORTED_MODULE_44__["race"]; });

/* harmony import */ var _internal_observable_range__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(131);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "range", function() { return _internal_observable_range__WEBPACK_IMPORTED_MODULE_45__["range"]; });

/* harmony import */ var _internal_observable_throwError__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(78);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "throwError", function() { return _internal_observable_throwError__WEBPACK_IMPORTED_MODULE_46__["throwError"]; });

/* harmony import */ var _internal_observable_timer__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(132);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timer", function() { return _internal_observable_timer__WEBPACK_IMPORTED_MODULE_47__["timer"]; });

/* harmony import */ var _internal_observable_using__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(133);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "using", function() { return _internal_observable_using__WEBPACK_IMPORTED_MODULE_48__["using"]; });

/* harmony import */ var _internal_observable_zip__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(134);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zip", function() { return _internal_observable_zip__WEBPACK_IMPORTED_MODULE_49__["zip"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EMPTY", function() { return _internal_observable_empty__WEBPACK_IMPORTED_MODULE_31__["EMPTY"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NEVER", function() { return _internal_observable_never__WEBPACK_IMPORTED_MODULE_40__["NEVER"]; });

/* harmony import */ var _internal_config__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(43);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "config", function() { return _internal_config__WEBPACK_IMPORTED_MODULE_50__["config"]; });

/** PURE_IMPORTS_START  PURE_IMPORTS_END */





















































//# sourceMappingURL=index.js.map


/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Observable", function() { return Observable; });
/* harmony import */ var _util_toSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _internal_symbol_observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52);
/* harmony import */ var _util_pipe__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(53);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(43);
/** PURE_IMPORTS_START _util_toSubscriber,_internal_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */




var Observable = /*@__PURE__*/ (function () {
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = Object(_util_toSubscriber__WEBPACK_IMPORTED_MODULE_0__["toSubscriber"])(observerOrNext, error, complete);
        if (operator) {
            operator.call(sink, this.source);
        }
        else {
            sink.add(this.source || (_config__WEBPACK_IMPORTED_MODULE_3__["config"].useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?
                this._subscribe(sink) :
                this._trySubscribe(sink));
        }
        if (_config__WEBPACK_IMPORTED_MODULE_3__["config"].useDeprecatedSynchronousErrorHandling) {
            if (sink.syncErrorThrowable) {
                sink.syncErrorThrowable = false;
                if (sink.syncErrorThrown) {
                    throw sink.syncErrorValue;
                }
            }
        }
        return sink;
    };
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        }
        catch (err) {
            if (_config__WEBPACK_IMPORTED_MODULE_3__["config"].useDeprecatedSynchronousErrorHandling) {
                sink.syncErrorThrown = true;
                sink.syncErrorValue = err;
            }
            sink.error(err);
        }
    };
    Observable.prototype.forEach = function (next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var subscription;
            subscription = _this.subscribe(function (value) {
                try {
                    next(value);
                }
                catch (err) {
                    reject(err);
                    if (subscription) {
                        subscription.unsubscribe();
                    }
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        var source = this.source;
        return source && source.subscribe(subscriber);
    };
    Observable.prototype[_internal_symbol_observable__WEBPACK_IMPORTED_MODULE_1__["observable"]] = function () {
        return this;
    };
    Observable.prototype.pipe = function () {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i] = arguments[_i];
        }
        if (operations.length === 0) {
            return this;
        }
        return Object(_util_pipe__WEBPACK_IMPORTED_MODULE_2__["pipeFromArray"])(operations)(this);
    };
    Observable.prototype.toPromise = function (promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var value;
            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
        });
    };
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}());

function getPromiseCtor(promiseCtor) {
    if (!promiseCtor) {
        promiseCtor = _config__WEBPACK_IMPORTED_MODULE_3__["config"].Promise || Promise;
    }
    if (!promiseCtor) {
        throw new Error('no Promise impl found');
    }
    return promiseCtor;
}
//# sourceMappingURL=Observable.js.map


/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toSubscriber", function() { return toSubscriber; });
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(39);
/* harmony import */ var _symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(51);
/* harmony import */ var _Observer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(42);
/** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */



function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]) {
            return nextOrObserver;
        }
        if (nextOrObserver[_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_1__["rxSubscriber"]]) {
            return nextOrObserver[_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_1__["rxSubscriber"]]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"](_Observer__WEBPACK_IMPORTED_MODULE_2__["empty"]);
    }
    return new _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"](nextOrObserver, error, complete);
}
//# sourceMappingURL=toSubscriber.js.map


/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Subscriber", function() { return Subscriber; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(41);
/* harmony import */ var _Observer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(42);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45);
/* harmony import */ var _internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(51);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(43);
/* harmony import */ var _util_hostReportError__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(44);
/** PURE_IMPORTS_START tslib,_util_isFunction,_Observer,_Subscription,_internal_symbol_rxSubscriber,_config,_util_hostReportError PURE_IMPORTS_END */







var Subscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](Subscriber, _super);
    function Subscriber(destinationOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this.syncErrorValue = null;
        _this.syncErrorThrown = false;
        _this.syncErrorThrowable = false;
        _this.isStopped = false;
        switch (arguments.length) {
            case 0:
                _this.destination = _Observer__WEBPACK_IMPORTED_MODULE_2__["empty"];
                break;
            case 1:
                if (!destinationOrNext) {
                    _this.destination = _Observer__WEBPACK_IMPORTED_MODULE_2__["empty"];
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    if (isTrustedSubscriber(destinationOrNext)) {
                        var trustedSubscriber = destinationOrNext[_internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_4__["rxSubscriber"]]();
                        _this.syncErrorThrowable = trustedSubscriber.syncErrorThrowable;
                        _this.destination = trustedSubscriber;
                        trustedSubscriber.add(_this);
                    }
                    else {
                        _this.syncErrorThrowable = true;
                        _this.destination = new SafeSubscriber(_this, destinationOrNext);
                    }
                    break;
                }
            default:
                _this.syncErrorThrowable = true;
                _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
                break;
        }
        return _this;
    }
    Subscriber.prototype[_internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_4__["rxSubscriber"]] = function () { return this; };
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _a = this, _parent = _a._parent, _parents = _a._parents;
        this._parent = null;
        this._parents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parent = _parent;
        this._parents = _parents;
        return this;
    };
    return Subscriber;
}(_Subscription__WEBPACK_IMPORTED_MODULE_3__["Subscription"]));

var SafeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this._parentSubscriber = _parentSubscriber;
        var next;
        var context = _this;
        if (Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (observerOrNext !== _Observer__WEBPACK_IMPORTED_MODULE_2__["empty"]) {
                context = Object.create(observerOrNext);
                if (Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(context.unsubscribe)) {
                    _this.add(context.unsubscribe.bind(context));
                }
                context.unsubscribe = _this.unsubscribe.bind(_this);
            }
        }
        _this._context = context;
        _this._next = next;
        _this._error = error;
        _this._complete = complete;
        return _this;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!_config__WEBPACK_IMPORTED_MODULE_5__["config"].useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            }
            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            var useDeprecatedSynchronousErrorHandling = _config__WEBPACK_IMPORTED_MODULE_5__["config"].useDeprecatedSynchronousErrorHandling;
            if (this._error) {
                if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            }
            else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                if (useDeprecatedSynchronousErrorHandling) {
                    throw err;
                }
                Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__["hostReportError"])(err);
            }
            else {
                if (useDeprecatedSynchronousErrorHandling) {
                    _parentSubscriber.syncErrorValue = err;
                    _parentSubscriber.syncErrorThrown = true;
                }
                else {
                    Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__["hostReportError"])(err);
                }
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        var _this = this;
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                var wrappedComplete = function () { return _this._complete.call(_this._context); };
                if (!_config__WEBPACK_IMPORTED_MODULE_5__["config"].useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(wrappedComplete);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                    this.unsubscribe();
                }
            }
            else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            this.unsubscribe();
            if (_config__WEBPACK_IMPORTED_MODULE_5__["config"].useDeprecatedSynchronousErrorHandling) {
                throw err;
            }
            else {
                Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__["hostReportError"])(err);
            }
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        if (!_config__WEBPACK_IMPORTED_MODULE_5__["config"].useDeprecatedSynchronousErrorHandling) {
            throw new Error('bad call');
        }
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            if (_config__WEBPACK_IMPORTED_MODULE_5__["config"].useDeprecatedSynchronousErrorHandling) {
                parent.syncErrorValue = err;
                parent.syncErrorThrown = true;
                return true;
            }
            else {
                Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__["hostReportError"])(err);
                return true;
            }
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber));
function isTrustedSubscriber(obj) {
    return obj instanceof Subscriber || ('syncErrorThrowable' in obj && obj[_internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_4__["rxSubscriber"]]);
}
//# sourceMappingURL=Subscriber.js.map


/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__extends", function() { return __extends; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__rest", function() { return __rest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__decorate", function() { return __decorate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__param", function() { return __param; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__metadata", function() { return __metadata; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__awaiter", function() { return __awaiter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__generator", function() { return __generator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__exportStar", function() { return __exportStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__values", function() { return __values; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__read", function() { return __read; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spread", function() { return __spread; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__await", function() { return __await; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncGenerator", function() { return __asyncGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncDelegator", function() { return __asyncDelegator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncValues", function() { return __asyncValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__makeTemplateObject", function() { return __makeTemplateObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importStar", function() { return __importStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importDefault", function() { return __importDefault; });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __exportStar(m, exports) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}


/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFunction", function() { return isFunction; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isFunction(x) {
    return typeof x === 'function';
}
//# sourceMappingURL=isFunction.js.map


/***/ }),
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "empty", function() { return empty; });
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(43);
/* harmony import */ var _util_hostReportError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(44);
/** PURE_IMPORTS_START _config,_util_hostReportError PURE_IMPORTS_END */


var empty = {
    closed: true,
    next: function (value) { },
    error: function (err) {
        if (_config__WEBPACK_IMPORTED_MODULE_0__["config"].useDeprecatedSynchronousErrorHandling) {
            throw err;
        }
        else {
            Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_1__["hostReportError"])(err);
        }
    },
    complete: function () { }
};
//# sourceMappingURL=Observer.js.map


/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "config", function() { return config; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var _enable_super_gross_mode_that_will_cause_bad_things = false;
var config = {
    Promise: undefined,
    set useDeprecatedSynchronousErrorHandling(value) {
        if (value) {
            var error = /*@__PURE__*/ new Error();
            /*@__PURE__*/ console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
        }
        else if (_enable_super_gross_mode_that_will_cause_bad_things) {
            /*@__PURE__*/ console.log('RxJS: Back to a better error behavior. Thank you. <3');
        }
        _enable_super_gross_mode_that_will_cause_bad_things = value;
    },
    get useDeprecatedSynchronousErrorHandling() {
        return _enable_super_gross_mode_that_will_cause_bad_things;
    },
};
//# sourceMappingURL=config.js.map


/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hostReportError", function() { return hostReportError; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function hostReportError(err) {
    setTimeout(function () { throw err; });
}
//# sourceMappingURL=hostReportError.js.map


/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Subscription", function() { return Subscription; });
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46);
/* harmony import */ var _util_isObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(47);
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(41);
/* harmony import */ var _util_tryCatch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(48);
/* harmony import */ var _util_errorObject__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(49);
/* harmony import */ var _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(50);
/** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_tryCatch,_util_errorObject,_util_UnsubscriptionError PURE_IMPORTS_END */






var Subscription = /*@__PURE__*/ (function () {
    function Subscription(unsubscribe) {
        this.closed = false;
        this._parent = null;
        this._parents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    Subscription.prototype.unsubscribe = function () {
        var hasErrors = false;
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parent = null;
        this._parents = null;
        this._subscriptions = null;
        var index = -1;
        var len = _parents ? _parents.length : 0;
        while (_parent) {
            _parent.remove(this);
            _parent = ++index < len && _parents[index] || null;
        }
        if (Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_2__["isFunction"])(_unsubscribe)) {
            var trial = Object(_util_tryCatch__WEBPACK_IMPORTED_MODULE_3__["tryCatch"])(_unsubscribe).call(this);
            if (trial === _util_errorObject__WEBPACK_IMPORTED_MODULE_4__["errorObject"]) {
                hasErrors = true;
                errors = errors || (_util_errorObject__WEBPACK_IMPORTED_MODULE_4__["errorObject"].e instanceof _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_5__["UnsubscriptionError"] ?
                    flattenUnsubscriptionErrors(_util_errorObject__WEBPACK_IMPORTED_MODULE_4__["errorObject"].e.errors) : [_util_errorObject__WEBPACK_IMPORTED_MODULE_4__["errorObject"].e]);
            }
        }
        if (Object(_util_isArray__WEBPACK_IMPORTED_MODULE_0__["isArray"])(_subscriptions)) {
            index = -1;
            len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (Object(_util_isObject__WEBPACK_IMPORTED_MODULE_1__["isObject"])(sub)) {
                    var trial = Object(_util_tryCatch__WEBPACK_IMPORTED_MODULE_3__["tryCatch"])(sub.unsubscribe).call(sub);
                    if (trial === _util_errorObject__WEBPACK_IMPORTED_MODULE_4__["errorObject"]) {
                        hasErrors = true;
                        errors = errors || [];
                        var err = _util_errorObject__WEBPACK_IMPORTED_MODULE_4__["errorObject"].e;
                        if (err instanceof _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_5__["UnsubscriptionError"]) {
                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
                        }
                        else {
                            errors.push(err);
                        }
                    }
                }
            }
        }
        if (hasErrors) {
            throw new _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_5__["UnsubscriptionError"](errors);
        }
    };
    Subscription.prototype.add = function (teardown) {
        if (!teardown || (teardown === Subscription.EMPTY)) {
            return Subscription.EMPTY;
        }
        if (teardown === this) {
            return this;
        }
        var subscription = teardown;
        switch (typeof teardown) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                }
                else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                }
                else if (typeof subscription._addParent !== 'function') {
                    var tmp = subscription;
                    subscription = new Subscription();
                    subscription._subscriptions = [tmp];
                }
                break;
            default:
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
        }
        var subscriptions = this._subscriptions || (this._subscriptions = []);
        subscriptions.push(subscription);
        subscription._addParent(this);
        return subscription;
    };
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.prototype._addParent = function (parent) {
        var _a = this, _parent = _a._parent, _parents = _a._parents;
        if (!_parent || _parent === parent) {
            this._parent = parent;
        }
        else if (!_parents) {
            this._parents = [parent];
        }
        else if (_parents.indexOf(parent) === -1) {
            _parents.push(parent);
        }
    };
    Subscription.EMPTY = (function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());

function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) { return errs.concat((err instanceof _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_5__["UnsubscriptionError"]) ? err.errors : err); }, []);
}
//# sourceMappingURL=Subscription.js.map


/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isArray", function() { return isArray; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });
//# sourceMappingURL=isArray.js.map


/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isObject", function() { return isObject; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isObject(x) {
    return x != null && typeof x === 'object';
}
//# sourceMappingURL=isObject.js.map


/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tryCatch", function() { return tryCatch; });
/* harmony import */ var _errorObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(49);
/** PURE_IMPORTS_START _errorObject PURE_IMPORTS_END */

var tryCatchTarget;
function tryCatcher() {
    try {
        return tryCatchTarget.apply(this, arguments);
    }
    catch (e) {
        _errorObject__WEBPACK_IMPORTED_MODULE_0__["errorObject"].e = e;
        return _errorObject__WEBPACK_IMPORTED_MODULE_0__["errorObject"];
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}
//# sourceMappingURL=tryCatch.js.map


/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "errorObject", function() { return errorObject; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var errorObject = { e: {} };
//# sourceMappingURL=errorObject.js.map


/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsubscriptionError", function() { return UnsubscriptionError; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/** PURE_IMPORTS_START tslib PURE_IMPORTS_END */

var UnsubscriptionError = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](UnsubscriptionError, _super);
    function UnsubscriptionError(errors) {
        var _this = _super.call(this, errors ?
            errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ') : '') || this;
        _this.errors = errors;
        _this.name = 'UnsubscriptionError';
        Object.setPrototypeOf(_this, UnsubscriptionError.prototype);
        return _this;
    }
    return UnsubscriptionError;
}(Error));

//# sourceMappingURL=UnsubscriptionError.js.map


/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rxSubscriber", function() { return rxSubscriber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$$rxSubscriber", function() { return $$rxSubscriber; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function')
    ? /*@__PURE__*/ Symbol.for('rxSubscriber')
    : '@@rxSubscriber';
var $$rxSubscriber = rxSubscriber;
//# sourceMappingURL=rxSubscriber.js.map


/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "observable", function() { return observable; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var observable = typeof Symbol === 'function' && Symbol.observable || '@@observable';
//# sourceMappingURL=observable.js.map


/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pipe", function() { return pipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pipeFromArray", function() { return pipeFromArray; });
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(54);
/** PURE_IMPORTS_START _noop PURE_IMPORTS_END */

function pipe() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
    }
    return pipeFromArray(fns);
}
function pipeFromArray(fns) {
    if (!fns) {
        return _noop__WEBPACK_IMPORTED_MODULE_0__["noop"];
    }
    if (fns.length === 1) {
        return fns[0];
    }
    return function piped(input) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
    };
}
//# sourceMappingURL=pipe.js.map


/***/ }),
/* 54 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "noop", function() { return noop; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function noop() { }
//# sourceMappingURL=noop.js.map


/***/ }),
/* 55 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConnectableObservable", function() { return ConnectableObservable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "connectableObservableDescriptor", function() { return connectableObservableDescriptor; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56);
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(39);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(45);
/* harmony import */ var _operators_refCount__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(59);
/** PURE_IMPORTS_START tslib,_Subject,_Observable,_Subscriber,_Subscription,_operators_refCount PURE_IMPORTS_END */






var ConnectableObservable = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](ConnectableObservable, _super);
    function ConnectableObservable(source, subjectFactory) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subjectFactory = subjectFactory;
        _this._refCount = 0;
        _this._isComplete = false;
        return _this;
    }
    ConnectableObservable.prototype._subscribe = function (subscriber) {
        return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable.prototype.getSubject = function () {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
            this._subject = this.subjectFactory();
        }
        return this._subject;
    };
    ConnectableObservable.prototype.connect = function () {
        var connection = this._connection;
        if (!connection) {
            this._isComplete = false;
            connection = this._connection = new _Subscription__WEBPACK_IMPORTED_MODULE_4__["Subscription"]();
            connection.add(this.source
                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
            if (connection.closed) {
                this._connection = null;
                connection = _Subscription__WEBPACK_IMPORTED_MODULE_4__["Subscription"].EMPTY;
            }
            else {
                this._connection = connection;
            }
        }
        return connection;
    };
    ConnectableObservable.prototype.refCount = function () {
        return Object(_operators_refCount__WEBPACK_IMPORTED_MODULE_5__["refCount"])()(this);
    };
    return ConnectableObservable;
}(_Observable__WEBPACK_IMPORTED_MODULE_2__["Observable"]));

var connectableProto = ConnectableObservable.prototype;
var connectableObservableDescriptor = {
    operator: { value: null },
    _refCount: { value: 0, writable: true },
    _subject: { value: null, writable: true },
    _connection: { value: null, writable: true },
    _subscribe: { value: connectableProto._subscribe },
    _isComplete: { value: connectableProto._isComplete, writable: true },
    getSubject: { value: connectableProto.getSubject },
    connect: { value: connectableProto.connect },
    refCount: { value: connectableProto.refCount }
};
var ConnectableSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](ConnectableSubscriber, _super);
    function ConnectableSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    ConnectableSubscriber.prototype._error = function (err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
    };
    ConnectableSubscriber.prototype._complete = function () {
        this.connectable._isComplete = true;
        this._unsubscribe();
        _super.prototype._complete.call(this);
    };
    ConnectableSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (connectable) {
            this.connectable = null;
            var connection = connectable._connection;
            connectable._refCount = 0;
            connectable._subject = null;
            connectable._connection = null;
            if (connection) {
                connection.unsubscribe();
            }
        }
    };
    return ConnectableSubscriber;
}(_Subject__WEBPACK_IMPORTED_MODULE_1__["SubjectSubscriber"]));
var RefCountOperator = /*@__PURE__*/ (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_3__["Subscriber"]));
//# sourceMappingURL=ConnectableObservable.js.map


/***/ }),
/* 56 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubjectSubscriber", function() { return SubjectSubscriber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Subject", function() { return Subject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnonymousSubject", function() { return AnonymousSubject; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(37);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(39);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45);
/* harmony import */ var _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(57);
/* harmony import */ var _SubjectSubscription__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(58);
/* harmony import */ var _internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(51);
/** PURE_IMPORTS_START tslib,_Observable,_Subscriber,_Subscription,_util_ObjectUnsubscribedError,_SubjectSubscription,_internal_symbol_rxSubscriber PURE_IMPORTS_END */







var SubjectSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        return _this;
    }
    return SubjectSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_2__["Subscriber"]));

var Subject = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](Subject, _super);
    function Subject() {
        var _this = _super.call(this) || this;
        _this.observers = [];
        _this.closed = false;
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
    }
    Subject.prototype[_internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_6__["rxSubscriber"]] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__["ObjectUnsubscribedError"]();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__["ObjectUnsubscribedError"]();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__["ObjectUnsubscribedError"]();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject.prototype._trySubscribe = function (subscriber) {
        if (this.closed) {
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__["ObjectUnsubscribedError"]();
        }
        else {
            return _super.prototype._trySubscribe.call(this, subscriber);
        }
    };
    Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__["ObjectUnsubscribedError"]();
        }
        else if (this.hasError) {
            subscriber.error(this.thrownError);
            return _Subscription__WEBPACK_IMPORTED_MODULE_3__["Subscription"].EMPTY;
        }
        else if (this.isStopped) {
            subscriber.complete();
            return _Subscription__WEBPACK_IMPORTED_MODULE_3__["Subscription"].EMPTY;
        }
        else {
            this.observers.push(subscriber);
            return new _SubjectSubscription__WEBPACK_IMPORTED_MODULE_5__["SubjectSubscription"](this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new _Observable__WEBPACK_IMPORTED_MODULE_1__["Observable"]();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(_Observable__WEBPACK_IMPORTED_MODULE_1__["Observable"]));

var AnonymousSubject = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        }
        else {
            return _Subscription__WEBPACK_IMPORTED_MODULE_3__["Subscription"].EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject));

//# sourceMappingURL=Subject.js.map


/***/ }),
/* 57 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectUnsubscribedError", function() { return ObjectUnsubscribedError; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/** PURE_IMPORTS_START tslib PURE_IMPORTS_END */

var ObjectUnsubscribedError = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](ObjectUnsubscribedError, _super);
    function ObjectUnsubscribedError() {
        var _this = _super.call(this, 'object unsubscribed') || this;
        _this.name = 'ObjectUnsubscribedError';
        Object.setPrototypeOf(_this, ObjectUnsubscribedError.prototype);
        return _this;
    }
    return ObjectUnsubscribedError;
}(Error));

//# sourceMappingURL=ObjectUnsubscribedError.js.map


/***/ }),
/* 58 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubjectSubscription", function() { return SubjectSubscription; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45);
/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */


var SubjectSubscription = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        var _this = _super.call(this) || this;
        _this.subject = subject;
        _this.subscriber = subscriber;
        _this.closed = false;
        return _this;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(_Subscription__WEBPACK_IMPORTED_MODULE_1__["Subscription"]));

//# sourceMappingURL=SubjectSubscription.js.map


/***/ }),
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "refCount", function() { return refCount; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function refCount() {
    return function refCountOperatorFunction(source) {
        return source.lift(new RefCountOperator(source));
    };
}
var RefCountOperator = /*@__PURE__*/ (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=refCount.js.map


/***/ }),
/* 60 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "groupBy", function() { return groupBy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GroupedObservable", function() { return GroupedObservable; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(45);
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(37);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(56);
/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription,_Observable,_Subject PURE_IMPORTS_END */





function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
    return function (source) {
        return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
    };
}
var GroupByOperator = /*@__PURE__*/ (function () {
    function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {
        this.keySelector = keySelector;
        this.elementSelector = elementSelector;
        this.durationSelector = durationSelector;
        this.subjectSelector = subjectSelector;
    }
    GroupByOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
    };
    return GroupByOperator;
}());
var GroupBySubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](GroupBySubscriber, _super);
    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.elementSelector = elementSelector;
        _this.durationSelector = durationSelector;
        _this.subjectSelector = subjectSelector;
        _this.groups = null;
        _this.attemptedToUnsubscribe = false;
        _this.count = 0;
        return _this;
    }
    GroupBySubscriber.prototype._next = function (value) {
        var key;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            this.error(err);
            return;
        }
        this._group(value, key);
    };
    GroupBySubscriber.prototype._group = function (value, key) {
        var groups = this.groups;
        if (!groups) {
            groups = this.groups = new Map();
        }
        var group = groups.get(key);
        var element;
        if (this.elementSelector) {
            try {
                element = this.elementSelector(value);
            }
            catch (err) {
                this.error(err);
            }
        }
        else {
            element = value;
        }
        if (!group) {
            group = (this.subjectSelector ? this.subjectSelector() : new _Subject__WEBPACK_IMPORTED_MODULE_4__["Subject"]());
            groups.set(key, group);
            var groupedObservable = new GroupedObservable(key, group, this);
            this.destination.next(groupedObservable);
            if (this.durationSelector) {
                var duration = void 0;
                try {
                    duration = this.durationSelector(new GroupedObservable(key, group));
                }
                catch (err) {
                    this.error(err);
                    return;
                }
                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
            }
        }
        if (!group.closed) {
            group.next(element);
        }
    };
    GroupBySubscriber.prototype._error = function (err) {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.error(err);
            });
            groups.clear();
        }
        this.destination.error(err);
    };
    GroupBySubscriber.prototype._complete = function () {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.complete();
            });
            groups.clear();
        }
        this.destination.complete();
    };
    GroupBySubscriber.prototype.removeGroup = function (key) {
        this.groups.delete(key);
    };
    GroupBySubscriber.prototype.unsubscribe = function () {
        if (!this.closed) {
            this.attemptedToUnsubscribe = true;
            if (this.count === 0) {
                _super.prototype.unsubscribe.call(this);
            }
        }
    };
    return GroupBySubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
var GroupDurationSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](GroupDurationSubscriber, _super);
    function GroupDurationSubscriber(key, group, parent) {
        var _this = _super.call(this, group) || this;
        _this.key = key;
        _this.group = group;
        _this.parent = parent;
        return _this;
    }
    GroupDurationSubscriber.prototype._next = function (value) {
        this.complete();
    };
    GroupDurationSubscriber.prototype._unsubscribe = function () {
        var _a = this, parent = _a.parent, key = _a.key;
        this.key = this.parent = null;
        if (parent) {
            parent.removeGroup(key);
        }
    };
    return GroupDurationSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
var GroupedObservable = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](GroupedObservable, _super);
    function GroupedObservable(key, groupSubject, refCountSubscription) {
        var _this = _super.call(this) || this;
        _this.key = key;
        _this.groupSubject = groupSubject;
        _this.refCountSubscription = refCountSubscription;
        return _this;
    }
    GroupedObservable.prototype._subscribe = function (subscriber) {
        var subscription = new _Subscription__WEBPACK_IMPORTED_MODULE_2__["Subscription"]();
        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;
        if (refCountSubscription && !refCountSubscription.closed) {
            subscription.add(new InnerRefCountSubscription(refCountSubscription));
        }
        subscription.add(groupSubject.subscribe(subscriber));
        return subscription;
    };
    return GroupedObservable;
}(_Observable__WEBPACK_IMPORTED_MODULE_3__["Observable"]));

var InnerRefCountSubscription = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](InnerRefCountSubscription, _super);
    function InnerRefCountSubscription(parent) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        parent.count++;
        return _this;
    }
    InnerRefCountSubscription.prototype.unsubscribe = function () {
        var parent = this.parent;
        if (!parent.closed && !this.closed) {
            _super.prototype.unsubscribe.call(this);
            parent.count -= 1;
            if (parent.count === 0 && parent.attemptedToUnsubscribe) {
                parent.unsubscribe();
            }
        }
    };
    return InnerRefCountSubscription;
}(_Subscription__WEBPACK_IMPORTED_MODULE_2__["Subscription"]));
//# sourceMappingURL=groupBy.js.map


/***/ }),
/* 61 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BehaviorSubject", function() { return BehaviorSubject; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56);
/* harmony import */ var _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(57);
/** PURE_IMPORTS_START tslib,_Subject,_util_ObjectUnsubscribedError PURE_IMPORTS_END */



var BehaviorSubject = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](BehaviorSubject, _super);
    function BehaviorSubject(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
    }
    Object.defineProperty(BehaviorSubject.prototype, "value", {
        get: function () {
            return this.getValue();
        },
        enumerable: true,
        configurable: true
    });
    BehaviorSubject.prototype._subscribe = function (subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        if (subscription && !subscription.closed) {
            subscriber.next(this._value);
        }
        return subscription;
    };
    BehaviorSubject.prototype.getValue = function () {
        if (this.hasError) {
            throw this.thrownError;
        }
        else if (this.closed) {
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_2__["ObjectUnsubscribedError"]();
        }
        else {
            return this._value;
        }
    };
    BehaviorSubject.prototype.next = function (value) {
        _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject;
}(_Subject__WEBPACK_IMPORTED_MODULE_1__["Subject"]));

//# sourceMappingURL=BehaviorSubject.js.map


/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReplaySubject", function() { return ReplaySubject; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56);
/* harmony import */ var _scheduler_queue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(63);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45);
/* harmony import */ var _operators_observeOn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(70);
/* harmony import */ var _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(57);
/* harmony import */ var _SubjectSubscription__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(58);
/** PURE_IMPORTS_START tslib,_Subject,_scheduler_queue,_Subscription,_operators_observeOn,_util_ObjectUnsubscribedError,_SubjectSubscription PURE_IMPORTS_END */







var ReplaySubject = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](ReplaySubject, _super);
    function ReplaySubject(bufferSize, windowTime, scheduler) {
        if (bufferSize === void 0) {
            bufferSize = Number.POSITIVE_INFINITY;
        }
        if (windowTime === void 0) {
            windowTime = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this) || this;
        _this.scheduler = scheduler;
        _this._events = [];
        _this._infiniteTimeWindow = false;
        _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        _this._windowTime = windowTime < 1 ? 1 : windowTime;
        if (windowTime === Number.POSITIVE_INFINITY) {
            _this._infiniteTimeWindow = true;
            _this.next = _this.nextInfiniteTimeWindow;
        }
        else {
            _this.next = _this.nextTimeWindow;
        }
        return _this;
    }
    ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {
        var _events = this._events;
        _events.push(value);
        if (_events.length > this._bufferSize) {
            _events.shift();
        }
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype.nextTimeWindow = function (value) {
        this._events.push(new ReplayEvent(this._getNow(), value));
        this._trimBufferThenGetEvents();
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype._subscribe = function (subscriber) {
        var _infiniteTimeWindow = this._infiniteTimeWindow;
        var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
        var scheduler = this.scheduler;
        var len = _events.length;
        var subscription;
        if (this.closed) {
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_5__["ObjectUnsubscribedError"]();
        }
        else if (this.isStopped || this.hasError) {
            subscription = _Subscription__WEBPACK_IMPORTED_MODULE_3__["Subscription"].EMPTY;
        }
        else {
            this.observers.push(subscriber);
            subscription = new _SubjectSubscription__WEBPACK_IMPORTED_MODULE_6__["SubjectSubscription"](this, subscriber);
        }
        if (scheduler) {
            subscriber.add(subscriber = new _operators_observeOn__WEBPACK_IMPORTED_MODULE_4__["ObserveOnSubscriber"](subscriber, scheduler));
        }
        if (_infiniteTimeWindow) {
            for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i]);
            }
        }
        else {
            for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i].value);
            }
        }
        if (this.hasError) {
            subscriber.error(this.thrownError);
        }
        else if (this.isStopped) {
            subscriber.complete();
        }
        return subscription;
    };
    ReplaySubject.prototype._getNow = function () {
        return (this.scheduler || _scheduler_queue__WEBPACK_IMPORTED_MODULE_2__["queue"]).now();
    };
    ReplaySubject.prototype._trimBufferThenGetEvents = function () {
        var now = this._getNow();
        var _bufferSize = this._bufferSize;
        var _windowTime = this._windowTime;
        var _events = this._events;
        var eventsCount = _events.length;
        var spliceCount = 0;
        while (spliceCount < eventsCount) {
            if ((now - _events[spliceCount].time) < _windowTime) {
                break;
            }
            spliceCount++;
        }
        if (eventsCount > _bufferSize) {
            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        }
        if (spliceCount > 0) {
            _events.splice(0, spliceCount);
        }
        return _events;
    };
    return ReplaySubject;
}(_Subject__WEBPACK_IMPORTED_MODULE_1__["Subject"]));

var ReplayEvent = /*@__PURE__*/ (function () {
    function ReplayEvent(time, value) {
        this.time = time;
        this.value = value;
    }
    return ReplayEvent;
}());
//# sourceMappingURL=ReplaySubject.js.map


/***/ }),
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "queue", function() { return queue; });
/* harmony import */ var _QueueAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(64);
/* harmony import */ var _QueueScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(67);
/** PURE_IMPORTS_START _QueueAction,_QueueScheduler PURE_IMPORTS_END */


var queue = /*@__PURE__*/ new _QueueScheduler__WEBPACK_IMPORTED_MODULE_1__["QueueScheduler"](_QueueAction__WEBPACK_IMPORTED_MODULE_0__["QueueAction"]);
//# sourceMappingURL=queue.js.map


/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QueueAction", function() { return QueueAction; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _AsyncAction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(65);
/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */


var QueueAction = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](QueueAction, _super);
    function QueueAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    QueueAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay > 0) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
    };
    QueueAction.prototype.execute = function (state, delay) {
        return (delay > 0 || this.closed) ?
            _super.prototype.execute.call(this, state, delay) :
            this._execute(state, delay);
    };
    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        return scheduler.flush(this);
    };
    return QueueAction;
}(_AsyncAction__WEBPACK_IMPORTED_MODULE_1__["AsyncAction"]));

//# sourceMappingURL=QueueAction.js.map


/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AsyncAction", function() { return AsyncAction; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Action__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(66);
/** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */


var AsyncAction = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
    }
    AsyncAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (this.closed) {
            return this;
        }
        this.state = state;
        var id = this.id;
        var scheduler = this.scheduler;
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.pending = true;
        this.delay = delay;
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay !== null && this.delay === delay && this.pending === false) {
            return id;
        }
        return clearInterval(id) && undefined || undefined;
    };
    AsyncAction.prototype.execute = function (state, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
            return error;
        }
        else if (this.pending === false && this.id != null) {
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction.prototype._execute = function (state, delay) {
        var errored = false;
        var errorValue = undefined;
        try {
            this.work(state);
        }
        catch (e) {
            errored = true;
            errorValue = !!e && e || new Error(e);
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction.prototype._unsubscribe = function () {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
            actions.splice(index, 1);
        }
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
    };
    return AsyncAction;
}(_Action__WEBPACK_IMPORTED_MODULE_1__["Action"]));

//# sourceMappingURL=AsyncAction.js.map


/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Action", function() { return Action; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45);
/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */


var Action = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](Action, _super);
    function Action(scheduler, work) {
        return _super.call(this) || this;
    }
    Action.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return this;
    };
    return Action;
}(_Subscription__WEBPACK_IMPORTED_MODULE_1__["Subscription"]));

//# sourceMappingURL=Action.js.map


/***/ }),
/* 67 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QueueScheduler", function() { return QueueScheduler; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _AsyncScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(68);
/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */


var QueueScheduler = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](QueueScheduler, _super);
    function QueueScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return QueueScheduler;
}(_AsyncScheduler__WEBPACK_IMPORTED_MODULE_1__["AsyncScheduler"]));

//# sourceMappingURL=QueueScheduler.js.map


/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AsyncScheduler", function() { return AsyncScheduler; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Scheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(69);
/** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */


var AsyncScheduler = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](AsyncScheduler, _super);
    function AsyncScheduler(SchedulerAction, now) {
        if (now === void 0) {
            now = _Scheduler__WEBPACK_IMPORTED_MODULE_1__["Scheduler"].now;
        }
        var _this = _super.call(this, SchedulerAction, function () {
            if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {
                return AsyncScheduler.delegate.now();
            }
            else {
                return now();
            }
        }) || this;
        _this.actions = [];
        _this.active = false;
        _this.scheduled = undefined;
        return _this;
    }
    AsyncScheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) {
            delay = 0;
        }
        if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
            return AsyncScheduler.delegate.schedule(work, delay, state);
        }
        else {
            return _super.prototype.schedule.call(this, work, delay, state);
        }
    };
    AsyncScheduler.prototype.flush = function (action) {
        var actions = this.actions;
        if (this.active) {
            actions.push(action);
            return;
        }
        var error;
        this.active = true;
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (action = actions.shift());
        this.active = false;
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler;
}(_Scheduler__WEBPACK_IMPORTED_MODULE_1__["Scheduler"]));

//# sourceMappingURL=AsyncScheduler.js.map


/***/ }),
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Scheduler", function() { return Scheduler; });
var Scheduler = /*@__PURE__*/ (function () {
    function Scheduler(SchedulerAction, now) {
        if (now === void 0) {
            now = Scheduler.now;
        }
        this.SchedulerAction = SchedulerAction;
        this.now = now;
    }
    Scheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) {
            delay = 0;
        }
        return new this.SchedulerAction(this, work).schedule(state, delay);
    };
    Scheduler.now = function () { return Date.now(); };
    return Scheduler;
}());

//# sourceMappingURL=Scheduler.js.map


/***/ }),
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "observeOn", function() { return observeOn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObserveOnOperator", function() { return ObserveOnOperator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObserveOnSubscriber", function() { return ObserveOnSubscriber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObserveOnMessage", function() { return ObserveOnMessage; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/* harmony import */ var _Notification__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(71);
/** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */



function observeOn(scheduler, delay) {
    if (delay === void 0) {
        delay = 0;
    }
    return function observeOnOperatorFunction(source) {
        return source.lift(new ObserveOnOperator(scheduler, delay));
    };
}
var ObserveOnOperator = /*@__PURE__*/ (function () {
    function ObserveOnOperator(scheduler, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
    };
    return ObserveOnOperator;
}());

var ObserveOnSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](ObserveOnSubscriber, _super);
    function ObserveOnSubscriber(destination, scheduler, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        var _this = _super.call(this, destination) || this;
        _this.scheduler = scheduler;
        _this.delay = delay;
        return _this;
    }
    ObserveOnSubscriber.dispatch = function (arg) {
        var notification = arg.notification, destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
    };
    ObserveOnSubscriber.prototype._next = function (value) {
        this.scheduleMessage(_Notification__WEBPACK_IMPORTED_MODULE_2__["Notification"].createNext(value));
    };
    ObserveOnSubscriber.prototype._error = function (err) {
        this.scheduleMessage(_Notification__WEBPACK_IMPORTED_MODULE_2__["Notification"].createError(err));
    };
    ObserveOnSubscriber.prototype._complete = function () {
        this.scheduleMessage(_Notification__WEBPACK_IMPORTED_MODULE_2__["Notification"].createComplete());
    };
    return ObserveOnSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));

var ObserveOnMessage = /*@__PURE__*/ (function () {
    function ObserveOnMessage(notification, destination) {
        this.notification = notification;
        this.destination = destination;
    }
    return ObserveOnMessage;
}());

//# sourceMappingURL=observeOn.js.map


/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Notification", function() { return Notification; });
/* harmony import */ var _observable_empty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(72);
/* harmony import */ var _observable_of__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(73);
/* harmony import */ var _observable_throwError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(78);
/** PURE_IMPORTS_START _observable_empty,_observable_of,_observable_throwError PURE_IMPORTS_END */



var Notification = /*@__PURE__*/ (function () {
    function Notification(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === 'N';
    }
    Notification.prototype.observe = function (observer) {
        switch (this.kind) {
            case 'N':
                return observer.next && observer.next(this.value);
            case 'E':
                return observer.error && observer.error(this.error);
            case 'C':
                return observer.complete && observer.complete();
        }
    };
    Notification.prototype.do = function (next, error, complete) {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return next && next(this.value);
            case 'E':
                return error && error(this.error);
            case 'C':
                return complete && complete();
        }
    };
    Notification.prototype.accept = function (nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
            return this.observe(nextOrObserver);
        }
        else {
            return this.do(nextOrObserver, error, complete);
        }
    };
    Notification.prototype.toObservable = function () {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return Object(_observable_of__WEBPACK_IMPORTED_MODULE_1__["of"])(this.value);
            case 'E':
                return Object(_observable_throwError__WEBPACK_IMPORTED_MODULE_2__["throwError"])(this.error);
            case 'C':
                return Object(_observable_empty__WEBPACK_IMPORTED_MODULE_0__["empty"])();
        }
        throw new Error('unexpected notification kind value');
    };
    Notification.createNext = function (value) {
        if (typeof value !== 'undefined') {
            return new Notification('N', value);
        }
        return Notification.undefinedValueNotification;
    };
    Notification.createError = function (err) {
        return new Notification('E', undefined, err);
    };
    Notification.createComplete = function () {
        return Notification.completeNotification;
    };
    Notification.completeNotification = new Notification('C');
    Notification.undefinedValueNotification = new Notification('N', undefined);
    return Notification;
}());

//# sourceMappingURL=Notification.js.map


/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EMPTY", function() { return EMPTY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "empty", function() { return empty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "emptyScheduled", function() { return emptyScheduled; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */

var EMPTY = /*@__PURE__*/ new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) { return subscriber.complete(); });
function empty(scheduler) {
    return scheduler ? emptyScheduled(scheduler) : EMPTY;
}
function emptyScheduled(scheduler) {
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });
}
//# sourceMappingURL=empty.js.map


/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "of", function() { return of; });
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74);
/* harmony import */ var _fromArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(75);
/* harmony import */ var _empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(72);
/* harmony import */ var _scalar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(77);
/** PURE_IMPORTS_START _util_isScheduler,_fromArray,_empty,_scalar PURE_IMPORTS_END */




function of() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var scheduler = args[args.length - 1];
    if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_0__["isScheduler"])(scheduler)) {
        args.pop();
    }
    else {
        scheduler = undefined;
    }
    switch (args.length) {
        case 0:
            return Object(_empty__WEBPACK_IMPORTED_MODULE_2__["empty"])(scheduler);
        case 1:
            return scheduler ? Object(_fromArray__WEBPACK_IMPORTED_MODULE_1__["fromArray"])(args, scheduler) : Object(_scalar__WEBPACK_IMPORTED_MODULE_3__["scalar"])(args[0]);
        default:
            return Object(_fromArray__WEBPACK_IMPORTED_MODULE_1__["fromArray"])(args, scheduler);
    }
}
//# sourceMappingURL=of.js.map


/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isScheduler", function() { return isScheduler; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isScheduler(value) {
    return value && typeof value.schedule === 'function';
}
//# sourceMappingURL=isScheduler.js.map


/***/ }),
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromArray", function() { return fromArray; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45);
/* harmony import */ var _util_subscribeToArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(76);
/** PURE_IMPORTS_START _Observable,_Subscription,_util_subscribeToArray PURE_IMPORTS_END */



function fromArray(input, scheduler) {
    if (!scheduler) {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](Object(_util_subscribeToArray__WEBPACK_IMPORTED_MODULE_2__["subscribeToArray"])(input));
    }
    else {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
            var sub = new _Subscription__WEBPACK_IMPORTED_MODULE_1__["Subscription"]();
            var i = 0;
            sub.add(scheduler.schedule(function () {
                if (i === input.length) {
                    subscriber.complete();
                    return;
                }
                subscriber.next(input[i++]);
                if (!subscriber.closed) {
                    sub.add(this.schedule());
                }
            }));
            return sub;
        });
    }
}
//# sourceMappingURL=fromArray.js.map


/***/ }),
/* 76 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subscribeToArray", function() { return subscribeToArray; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var subscribeToArray = function (array) {
    return function (subscriber) {
        for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
            subscriber.next(array[i]);
        }
        if (!subscriber.closed) {
            subscriber.complete();
        }
    };
};
//# sourceMappingURL=subscribeToArray.js.map


/***/ }),
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scalar", function() { return scalar; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */

function scalar(value) {
    var result = new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
        subscriber.next(value);
        subscriber.complete();
    });
    result._isScalar = true;
    result.value = value;
    return result;
}
//# sourceMappingURL=scalar.js.map


/***/ }),
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "throwError", function() { return throwError; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */

function throwError(error, scheduler) {
    if (!scheduler) {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) { return subscriber.error(error); });
    }
    else {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) { return scheduler.schedule(dispatch, 0, { error: error, subscriber: subscriber }); });
    }
}
function dispatch(_a) {
    var error = _a.error, subscriber = _a.subscriber;
    subscriber.error(error);
}
//# sourceMappingURL=throwError.js.map


/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AsyncSubject", function() { return AsyncSubject; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(45);
/** PURE_IMPORTS_START tslib,_Subject,_Subscription PURE_IMPORTS_END */



var AsyncSubject = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](AsyncSubject, _super);
    function AsyncSubject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.value = null;
        _this.hasNext = false;
        _this.hasCompleted = false;
        return _this;
    }
    AsyncSubject.prototype._subscribe = function (subscriber) {
        if (this.hasError) {
            subscriber.error(this.thrownError);
            return _Subscription__WEBPACK_IMPORTED_MODULE_2__["Subscription"].EMPTY;
        }
        else if (this.hasCompleted && this.hasNext) {
            subscriber.next(this.value);
            subscriber.complete();
            return _Subscription__WEBPACK_IMPORTED_MODULE_2__["Subscription"].EMPTY;
        }
        return _super.prototype._subscribe.call(this, subscriber);
    };
    AsyncSubject.prototype.next = function (value) {
        if (!this.hasCompleted) {
            this.value = value;
            this.hasNext = true;
        }
    };
    AsyncSubject.prototype.error = function (error) {
        if (!this.hasCompleted) {
            _super.prototype.error.call(this, error);
        }
    };
    AsyncSubject.prototype.complete = function () {
        this.hasCompleted = true;
        if (this.hasNext) {
            _super.prototype.next.call(this, this.value);
        }
        _super.prototype.complete.call(this);
    };
    return AsyncSubject;
}(_Subject__WEBPACK_IMPORTED_MODULE_1__["Subject"]));

//# sourceMappingURL=AsyncSubject.js.map


/***/ }),
/* 80 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asap", function() { return asap; });
/* harmony import */ var _AsapAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81);
/* harmony import */ var _AsapScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(83);
/** PURE_IMPORTS_START _AsapAction,_AsapScheduler PURE_IMPORTS_END */


var asap = /*@__PURE__*/ new _AsapScheduler__WEBPACK_IMPORTED_MODULE_1__["AsapScheduler"](_AsapAction__WEBPACK_IMPORTED_MODULE_0__["AsapAction"]);
//# sourceMappingURL=asap.js.map


/***/ }),
/* 81 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AsapAction", function() { return AsapAction; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _util_Immediate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82);
/* harmony import */ var _AsyncAction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(65);
/** PURE_IMPORTS_START tslib,_util_Immediate,_AsyncAction PURE_IMPORTS_END */



var AsapAction = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](AsapAction, _super);
    function AsapAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = _util_Immediate__WEBPACK_IMPORTED_MODULE_1__["Immediate"].setImmediate(scheduler.flush.bind(scheduler, null)));
    };
    AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        if (scheduler.actions.length === 0) {
            _util_Immediate__WEBPACK_IMPORTED_MODULE_1__["Immediate"].clearImmediate(id);
            scheduler.scheduled = undefined;
        }
        return undefined;
    };
    return AsapAction;
}(_AsyncAction__WEBPACK_IMPORTED_MODULE_2__["AsyncAction"]));

//# sourceMappingURL=AsapAction.js.map


/***/ }),
/* 82 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Immediate", function() { return Immediate; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var nextHandle = 1;
var tasksByHandle = {};
function runIfPresent(handle) {
    var cb = tasksByHandle[handle];
    if (cb) {
        cb();
    }
}
var Immediate = {
    setImmediate: function (cb) {
        var handle = nextHandle++;
        tasksByHandle[handle] = cb;
        Promise.resolve().then(function () { return runIfPresent(handle); });
        return handle;
    },
    clearImmediate: function (handle) {
        delete tasksByHandle[handle];
    },
};
//# sourceMappingURL=Immediate.js.map


/***/ }),
/* 83 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AsapScheduler", function() { return AsapScheduler; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _AsyncScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(68);
/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */


var AsapScheduler = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](AsapScheduler, _super);
    function AsapScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AsapScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsapScheduler;
}(_AsyncScheduler__WEBPACK_IMPORTED_MODULE_1__["AsyncScheduler"]));

//# sourceMappingURL=AsapScheduler.js.map


/***/ }),
/* 84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "async", function() { return async; });
/* harmony import */ var _AsyncAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(65);
/* harmony import */ var _AsyncScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(68);
/** PURE_IMPORTS_START _AsyncAction,_AsyncScheduler PURE_IMPORTS_END */


var async = /*@__PURE__*/ new _AsyncScheduler__WEBPACK_IMPORTED_MODULE_1__["AsyncScheduler"](_AsyncAction__WEBPACK_IMPORTED_MODULE_0__["AsyncAction"]);
//# sourceMappingURL=async.js.map


/***/ }),
/* 85 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "animationFrame", function() { return animationFrame; });
/* harmony import */ var _AnimationFrameAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(86);
/* harmony import */ var _AnimationFrameScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(87);
/** PURE_IMPORTS_START _AnimationFrameAction,_AnimationFrameScheduler PURE_IMPORTS_END */


var animationFrame = /*@__PURE__*/ new _AnimationFrameScheduler__WEBPACK_IMPORTED_MODULE_1__["AnimationFrameScheduler"](_AnimationFrameAction__WEBPACK_IMPORTED_MODULE_0__["AnimationFrameAction"]);
//# sourceMappingURL=animationFrame.js.map


/***/ }),
/* 86 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationFrameAction", function() { return AnimationFrameAction; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _AsyncAction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(65);
/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */


var AnimationFrameAction = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](AnimationFrameAction, _super);
    function AnimationFrameAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function () { return scheduler.flush(null); }));
    };
    AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        if (scheduler.actions.length === 0) {
            cancelAnimationFrame(id);
            scheduler.scheduled = undefined;
        }
        return undefined;
    };
    return AnimationFrameAction;
}(_AsyncAction__WEBPACK_IMPORTED_MODULE_1__["AsyncAction"]));

//# sourceMappingURL=AnimationFrameAction.js.map


/***/ }),
/* 87 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationFrameScheduler", function() { return AnimationFrameScheduler; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _AsyncScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(68);
/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */


var AnimationFrameScheduler = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](AnimationFrameScheduler, _super);
    function AnimationFrameScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AnimationFrameScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AnimationFrameScheduler;
}(_AsyncScheduler__WEBPACK_IMPORTED_MODULE_1__["AsyncScheduler"]));

//# sourceMappingURL=AnimationFrameScheduler.js.map


/***/ }),
/* 88 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VirtualTimeScheduler", function() { return VirtualTimeScheduler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VirtualAction", function() { return VirtualAction; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _AsyncAction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(65);
/* harmony import */ var _AsyncScheduler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(68);
/** PURE_IMPORTS_START tslib,_AsyncAction,_AsyncScheduler PURE_IMPORTS_END */



var VirtualTimeScheduler = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](VirtualTimeScheduler, _super);
    function VirtualTimeScheduler(SchedulerAction, maxFrames) {
        if (SchedulerAction === void 0) {
            SchedulerAction = VirtualAction;
        }
        if (maxFrames === void 0) {
            maxFrames = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this, SchedulerAction, function () { return _this.frame; }) || this;
        _this.maxFrames = maxFrames;
        _this.frame = 0;
        _this.index = -1;
        return _this;
    }
    VirtualTimeScheduler.prototype.flush = function () {
        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
        var error, action;
        while ((action = actions.shift()) && (this.frame = action.delay) <= maxFrames) {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        }
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    VirtualTimeScheduler.frameTimeFactor = 10;
    return VirtualTimeScheduler;
}(_AsyncScheduler__WEBPACK_IMPORTED_MODULE_2__["AsyncScheduler"]));

var VirtualAction = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](VirtualAction, _super);
    function VirtualAction(scheduler, work, index) {
        if (index === void 0) {
            index = scheduler.index += 1;
        }
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.index = index;
        _this.active = true;
        _this.index = scheduler.index = index;
        return _this;
    }
    VirtualAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (!this.id) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.active = false;
        var action = new VirtualAction(this.scheduler, this.work);
        this.add(action);
        return action.schedule(state, delay);
    };
    VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        this.delay = scheduler.frame + delay;
        var actions = scheduler.actions;
        actions.push(this);
        actions.sort(VirtualAction.sortActions);
        return true;
    };
    VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return undefined;
    };
    VirtualAction.prototype._execute = function (state, delay) {
        if (this.active === true) {
            return _super.prototype._execute.call(this, state, delay);
        }
    };
    VirtualAction.sortActions = function (a, b) {
        if (a.delay === b.delay) {
            if (a.index === b.index) {
                return 0;
            }
            else if (a.index > b.index) {
                return 1;
            }
            else {
                return -1;
            }
        }
        else if (a.delay > b.delay) {
            return 1;
        }
        else {
            return -1;
        }
    };
    return VirtualAction;
}(_AsyncAction__WEBPACK_IMPORTED_MODULE_1__["AsyncAction"]));

//# sourceMappingURL=VirtualTimeScheduler.js.map


/***/ }),
/* 89 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function identity(x) {
    return x;
}
//# sourceMappingURL=identity.js.map


/***/ }),
/* 90 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isObservable", function() { return isObservable; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */

function isObservable(obj) {
    return !!obj && (obj instanceof _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"] || (typeof obj.lift === 'function' && typeof obj.subscribe === 'function'));
}
//# sourceMappingURL=isObservable.js.map


/***/ }),
/* 91 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArgumentOutOfRangeError", function() { return ArgumentOutOfRangeError; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/** PURE_IMPORTS_START tslib PURE_IMPORTS_END */

var ArgumentOutOfRangeError = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](ArgumentOutOfRangeError, _super);
    function ArgumentOutOfRangeError() {
        var _this = _super.call(this, 'argument out of range') || this;
        _this.name = 'ArgumentOutOfRangeError';
        Object.setPrototypeOf(_this, ArgumentOutOfRangeError.prototype);
        return _this;
    }
    return ArgumentOutOfRangeError;
}(Error));

//# sourceMappingURL=ArgumentOutOfRangeError.js.map


/***/ }),
/* 92 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EmptyError", function() { return EmptyError; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/** PURE_IMPORTS_START tslib PURE_IMPORTS_END */

var EmptyError = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](EmptyError, _super);
    function EmptyError() {
        var _this = _super.call(this, 'no elements in sequence') || this;
        _this.name = 'EmptyError';
        Object.setPrototypeOf(_this, EmptyError.prototype);
        return _this;
    }
    return EmptyError;
}(Error));

//# sourceMappingURL=EmptyError.js.map


/***/ }),
/* 93 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimeoutError", function() { return TimeoutError; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/** PURE_IMPORTS_START tslib PURE_IMPORTS_END */

var TimeoutError = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](TimeoutError, _super);
    function TimeoutError() {
        var _this = _super.call(this, 'Timeout has occurred') || this;
        _this.name = 'TimeoutError';
        Object.setPrototypeOf(_this, TimeoutError.prototype);
        return _this;
    }
    return TimeoutError;
}(Error));

//# sourceMappingURL=TimeoutError.js.map


/***/ }),
/* 94 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bindCallback", function() { return bindCallback; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _AsyncSubject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(79);
/* harmony import */ var _operators_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(95);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(46);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(74);
/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_isArray,_util_isScheduler PURE_IMPORTS_END */





function bindCallback(callbackFunc, resultSelector, scheduler) {
    if (resultSelector) {
        if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_4__["isScheduler"])(resultSelector)) {
            scheduler = resultSelector;
        }
        else {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return bindCallback(callbackFunc, scheduler).apply(void 0, args).pipe(Object(_operators_map__WEBPACK_IMPORTED_MODULE_2__["map"])(function (args) { return Object(_util_isArray__WEBPACK_IMPORTED_MODULE_3__["isArray"])(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
            };
        }
    }
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var context = this;
        var subject;
        var params = {
            context: context,
            subject: subject,
            callbackFunc: callbackFunc,
            scheduler: scheduler,
        };
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
            if (!scheduler) {
                if (!subject) {
                    subject = new _AsyncSubject__WEBPACK_IMPORTED_MODULE_1__["AsyncSubject"]();
                    var handler = function () {
                        var innerArgs = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            innerArgs[_i] = arguments[_i];
                        }
                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
                        subject.complete();
                    };
                    try {
                        callbackFunc.apply(context, args.concat([handler]));
                    }
                    catch (err) {
                        subject.error(err);
                    }
                }
                return subject.subscribe(subscriber);
            }
            else {
                var state = {
                    args: args, subscriber: subscriber, params: params,
                };
                return scheduler.schedule(dispatch, 0, state);
            }
        });
    };
}
function dispatch(state) {
    var _this = this;
    var self = this;
    var args = state.args, subscriber = state.subscriber, params = state.params;
    var callbackFunc = params.callbackFunc, context = params.context, scheduler = params.scheduler;
    var subject = params.subject;
    if (!subject) {
        subject = params.subject = new _AsyncSubject__WEBPACK_IMPORTED_MODULE_1__["AsyncSubject"]();
        var handler = function () {
            var innerArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                innerArgs[_i] = arguments[_i];
            }
            var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
            _this.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));
        };
        try {
            callbackFunc.apply(context, args.concat([handler]));
        }
        catch (err) {
            subject.error(err);
        }
    }
    this.add(subject.subscribe(subscriber));
}
function dispatchNext(state) {
    var value = state.value, subject = state.subject;
    subject.next(value);
    subject.complete();
}
function dispatchError(state) {
    var err = state.err, subject = state.subject;
    subject.error(err);
}
//# sourceMappingURL=bindCallback.js.map


/***/ }),
/* 95 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "map", function() { return map; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MapOperator", function() { return MapOperator; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function map(project, thisArg) {
    return function mapOperation(source) {
        if (typeof project !== 'function') {
            throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
        }
        return source.lift(new MapOperator(project, thisArg));
    };
}
var MapOperator = /*@__PURE__*/ (function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}());

var MapSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.count = 0;
        _this.thisArg = thisArg || _this;
        return _this;
    }
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=map.js.map


/***/ }),
/* 96 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bindNodeCallback", function() { return bindNodeCallback; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _AsyncSubject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(79);
/* harmony import */ var _operators_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(95);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(74);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(46);
/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_isScheduler,_util_isArray PURE_IMPORTS_END */





function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
    if (resultSelector) {
        if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_3__["isScheduler"])(resultSelector)) {
            scheduler = resultSelector;
        }
        else {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return bindNodeCallback(callbackFunc, scheduler).apply(void 0, args).pipe(Object(_operators_map__WEBPACK_IMPORTED_MODULE_2__["map"])(function (args) { return Object(_util_isArray__WEBPACK_IMPORTED_MODULE_4__["isArray"])(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
            };
        }
    }
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var params = {
            subject: undefined,
            args: args,
            callbackFunc: callbackFunc,
            scheduler: scheduler,
            context: this,
        };
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
            var context = params.context;
            var subject = params.subject;
            if (!scheduler) {
                if (!subject) {
                    subject = params.subject = new _AsyncSubject__WEBPACK_IMPORTED_MODULE_1__["AsyncSubject"]();
                    var handler = function () {
                        var innerArgs = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            innerArgs[_i] = arguments[_i];
                        }
                        var err = innerArgs.shift();
                        if (err) {
                            subject.error(err);
                            return;
                        }
                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
                        subject.complete();
                    };
                    try {
                        callbackFunc.apply(context, args.concat([handler]));
                    }
                    catch (err) {
                        subject.error(err);
                    }
                }
                return subject.subscribe(subscriber);
            }
            else {
                return scheduler.schedule(dispatch, 0, { params: params, subscriber: subscriber, context: context });
            }
        });
    };
}
function dispatch(state) {
    var _this = this;
    var params = state.params, subscriber = state.subscriber, context = state.context;
    var callbackFunc = params.callbackFunc, args = params.args, scheduler = params.scheduler;
    var subject = params.subject;
    if (!subject) {
        subject = params.subject = new _AsyncSubject__WEBPACK_IMPORTED_MODULE_1__["AsyncSubject"]();
        var handler = function () {
            var innerArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                innerArgs[_i] = arguments[_i];
            }
            var err = innerArgs.shift();
            if (err) {
                _this.add(scheduler.schedule(dispatchError, 0, { err: err, subject: subject }));
            }
            else {
                var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
                _this.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));
            }
        };
        try {
            callbackFunc.apply(context, args.concat([handler]));
        }
        catch (err) {
            this.add(scheduler.schedule(dispatchError, 0, { err: err, subject: subject }));
        }
    }
    this.add(subject.subscribe(subscriber));
}
function dispatchNext(arg) {
    var value = arg.value, subject = arg.subject;
    subject.next(value);
    subject.complete();
}
function dispatchError(arg) {
    var err = arg.err, subject = arg.subject;
    subject.error(err);
}
//# sourceMappingURL=bindNodeCallback.js.map


/***/ }),
/* 97 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "combineLatest", function() { return combineLatest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CombineLatestOperator", function() { return CombineLatestOperator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CombineLatestSubscriber", function() { return CombineLatestSubscriber; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(74);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(46);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(98);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(99);
/* harmony import */ var _fromArray__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(75);
/** PURE_IMPORTS_START tslib,_util_isScheduler,_util_isArray,_OuterSubscriber,_util_subscribeToResult,_fromArray PURE_IMPORTS_END */






var NONE = {};
function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var resultSelector = null;
    var scheduler = null;
    if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_1__["isScheduler"])(observables[observables.length - 1])) {
        scheduler = observables.pop();
    }
    if (typeof observables[observables.length - 1] === 'function') {
        resultSelector = observables.pop();
    }
    if (observables.length === 1 && Object(_util_isArray__WEBPACK_IMPORTED_MODULE_2__["isArray"])(observables[0])) {
        observables = observables[0];
    }
    return Object(_fromArray__WEBPACK_IMPORTED_MODULE_5__["fromArray"])(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
}
var CombineLatestOperator = /*@__PURE__*/ (function () {
    function CombineLatestOperator(resultSelector) {
        this.resultSelector = resultSelector;
    }
    CombineLatestOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
    };
    return CombineLatestOperator;
}());

var CombineLatestSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](CombineLatestSubscriber, _super);
    function CombineLatestSubscriber(destination, resultSelector) {
        var _this = _super.call(this, destination) || this;
        _this.resultSelector = resultSelector;
        _this.active = 0;
        _this.values = [];
        _this.observables = [];
        return _this;
    }
    CombineLatestSubscriber.prototype._next = function (observable) {
        this.values.push(NONE);
        this.observables.push(observable);
    };
    CombineLatestSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            this.active = len;
            this.toRespond = len;
            for (var i = 0; i < len; i++) {
                var observable = observables[i];
                this.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__["subscribeToResult"])(this, observable, observable, i));
            }
        }
    };
    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
        if ((this.active -= 1) === 0) {
            this.destination.complete();
        }
    };
    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var values = this.values;
        var oldVal = values[outerIndex];
        var toRespond = !this.toRespond
            ? 0
            : oldVal === NONE ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;
        if (toRespond === 0) {
            if (this.resultSelector) {
                this._tryResultSelector(values);
            }
            else {
                this.destination.next(values.slice());
            }
        }
    };
    CombineLatestSubscriber.prototype._tryResultSelector = function (values) {
        var result;
        try {
            result = this.resultSelector.apply(this, values);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return CombineLatestSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__["OuterSubscriber"]));

//# sourceMappingURL=combineLatest.js.map


/***/ }),
/* 98 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OuterSubscriber", function() { return OuterSubscriber; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


var OuterSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](OuterSubscriber, _super);
    function OuterSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));

//# sourceMappingURL=OuterSubscriber.js.map


/***/ }),
/* 99 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subscribeToResult", function() { return subscribeToResult; });
/* harmony import */ var _InnerSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(100);
/* harmony import */ var _subscribeTo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(101);
/** PURE_IMPORTS_START _InnerSubscriber,_subscribeTo PURE_IMPORTS_END */


function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
    var destination = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_0__["InnerSubscriber"](outerSubscriber, outerValue, outerIndex);
    return Object(_subscribeTo__WEBPACK_IMPORTED_MODULE_1__["subscribeTo"])(result)(destination);
}
//# sourceMappingURL=subscribeToResult.js.map


/***/ }),
/* 100 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InnerSubscriber", function() { return InnerSubscriber; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


var InnerSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](InnerSubscriber, _super);
    function InnerSubscriber(parent, outerValue, outerIndex) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.outerValue = outerValue;
        _this.outerIndex = outerIndex;
        _this.index = 0;
        return _this;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));

//# sourceMappingURL=InnerSubscriber.js.map


/***/ }),
/* 101 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subscribeTo", function() { return subscribeTo; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _subscribeToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(76);
/* harmony import */ var _subscribeToPromise__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(102);
/* harmony import */ var _subscribeToIterable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(103);
/* harmony import */ var _subscribeToObservable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(105);
/* harmony import */ var _isArrayLike__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(106);
/* harmony import */ var _isPromise__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(107);
/* harmony import */ var _isObject__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(47);
/* harmony import */ var _symbol_iterator__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(104);
/* harmony import */ var _symbol_observable__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(52);
/** PURE_IMPORTS_START _Observable,_subscribeToArray,_subscribeToPromise,_subscribeToIterable,_subscribeToObservable,_isArrayLike,_isPromise,_isObject,_symbol_iterator,_symbol_observable PURE_IMPORTS_END */










var subscribeTo = function (result) {
    if (result instanceof _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"]) {
        return function (subscriber) {
            if (result._isScalar) {
                subscriber.next(result.value);
                subscriber.complete();
                return undefined;
            }
            else {
                return result.subscribe(subscriber);
            }
        };
    }
    else if (result && typeof result[_symbol_observable__WEBPACK_IMPORTED_MODULE_9__["observable"]] === 'function') {
        return Object(_subscribeToObservable__WEBPACK_IMPORTED_MODULE_4__["subscribeToObservable"])(result);
    }
    else if (Object(_isArrayLike__WEBPACK_IMPORTED_MODULE_5__["isArrayLike"])(result)) {
        return Object(_subscribeToArray__WEBPACK_IMPORTED_MODULE_1__["subscribeToArray"])(result);
    }
    else if (Object(_isPromise__WEBPACK_IMPORTED_MODULE_6__["isPromise"])(result)) {
        return Object(_subscribeToPromise__WEBPACK_IMPORTED_MODULE_2__["subscribeToPromise"])(result);
    }
    else if (result && typeof result[_symbol_iterator__WEBPACK_IMPORTED_MODULE_8__["iterator"]] === 'function') {
        return Object(_subscribeToIterable__WEBPACK_IMPORTED_MODULE_3__["subscribeToIterable"])(result);
    }
    else {
        var value = Object(_isObject__WEBPACK_IMPORTED_MODULE_7__["isObject"])(result) ? 'an invalid object' : "'" + result + "'";
        var msg = "You provided " + value + " where a stream was expected."
            + ' You can provide an Observable, Promise, Array, or Iterable.';
        throw new TypeError(msg);
    }
};
//# sourceMappingURL=subscribeTo.js.map


/***/ }),
/* 102 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subscribeToPromise", function() { return subscribeToPromise; });
/* harmony import */ var _hostReportError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(44);
/** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */

var subscribeToPromise = function (promise) {
    return function (subscriber) {
        promise.then(function (value) {
            if (!subscriber.closed) {
                subscriber.next(value);
                subscriber.complete();
            }
        }, function (err) { return subscriber.error(err); })
            .then(null, _hostReportError__WEBPACK_IMPORTED_MODULE_0__["hostReportError"]);
        return subscriber;
    };
};
//# sourceMappingURL=subscribeToPromise.js.map


/***/ }),
/* 103 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subscribeToIterable", function() { return subscribeToIterable; });
/* harmony import */ var _symbol_iterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(104);
/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */

var subscribeToIterable = function (iterable) {
    return function (subscriber) {
        var iterator = iterable[_symbol_iterator__WEBPACK_IMPORTED_MODULE_0__["iterator"]]();
        do {
            var item = iterator.next();
            if (item.done) {
                subscriber.complete();
                break;
            }
            subscriber.next(item.value);
            if (subscriber.closed) {
                break;
            }
        } while (true);
        if (typeof iterator.return === 'function') {
            subscriber.add(function () {
                if (iterator.return) {
                    iterator.return();
                }
            });
        }
        return subscriber;
    };
};
//# sourceMappingURL=subscribeToIterable.js.map


/***/ }),
/* 104 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSymbolIterator", function() { return getSymbolIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "iterator", function() { return iterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$$iterator", function() { return $$iterator; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function getSymbolIterator() {
    if (typeof Symbol !== 'function' || !Symbol.iterator) {
        return '@@iterator';
    }
    return Symbol.iterator;
}
var iterator = /*@__PURE__*/ getSymbolIterator();
var $$iterator = iterator;
//# sourceMappingURL=iterator.js.map


/***/ }),
/* 105 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subscribeToObservable", function() { return subscribeToObservable; });
/* harmony import */ var _symbol_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */

var subscribeToObservable = function (obj) {
    return function (subscriber) {
        var obs = obj[_symbol_observable__WEBPACK_IMPORTED_MODULE_0__["observable"]]();
        if (typeof obs.subscribe !== 'function') {
            throw new TypeError('Provided object does not correctly implement Symbol.observable');
        }
        else {
            return obs.subscribe(subscriber);
        }
    };
};
//# sourceMappingURL=subscribeToObservable.js.map


/***/ }),
/* 106 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isArrayLike", function() { return isArrayLike; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });
//# sourceMappingURL=isArrayLike.js.map


/***/ }),
/* 107 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPromise", function() { return isPromise; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isPromise(value) {
    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}
//# sourceMappingURL=isPromise.js.map


/***/ }),
/* 108 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concat", function() { return concat; });
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74);
/* harmony import */ var _of__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(73);
/* harmony import */ var _from__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(109);
/* harmony import */ var _operators_concatAll__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(115);
/** PURE_IMPORTS_START _util_isScheduler,_of,_from,_operators_concatAll PURE_IMPORTS_END */




function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    if (observables.length === 1 || (observables.length === 2 && Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_0__["isScheduler"])(observables[1]))) {
        return Object(_from__WEBPACK_IMPORTED_MODULE_2__["from"])(observables[0]);
    }
    return Object(_operators_concatAll__WEBPACK_IMPORTED_MODULE_3__["concatAll"])()(_of__WEBPACK_IMPORTED_MODULE_1__["of"].apply(void 0, observables));
}
//# sourceMappingURL=concat.js.map


/***/ }),
/* 109 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "from", function() { return from; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _util_isPromise__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(107);
/* harmony import */ var _util_isArrayLike__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(106);
/* harmony import */ var _util_isInteropObservable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(110);
/* harmony import */ var _util_isIterable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(111);
/* harmony import */ var _fromArray__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(75);
/* harmony import */ var _fromPromise__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(112);
/* harmony import */ var _fromIterable__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(113);
/* harmony import */ var _fromObservable__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(114);
/* harmony import */ var _util_subscribeTo__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(101);
/** PURE_IMPORTS_START _Observable,_util_isPromise,_util_isArrayLike,_util_isInteropObservable,_util_isIterable,_fromArray,_fromPromise,_fromIterable,_fromObservable,_util_subscribeTo PURE_IMPORTS_END */










function from(input, scheduler) {
    if (!scheduler) {
        if (input instanceof _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"]) {
            return input;
        }
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](Object(_util_subscribeTo__WEBPACK_IMPORTED_MODULE_9__["subscribeTo"])(input));
    }
    if (input != null) {
        if (Object(_util_isInteropObservable__WEBPACK_IMPORTED_MODULE_3__["isInteropObservable"])(input)) {
            return Object(_fromObservable__WEBPACK_IMPORTED_MODULE_8__["fromObservable"])(input, scheduler);
        }
        else if (Object(_util_isPromise__WEBPACK_IMPORTED_MODULE_1__["isPromise"])(input)) {
            return Object(_fromPromise__WEBPACK_IMPORTED_MODULE_6__["fromPromise"])(input, scheduler);
        }
        else if (Object(_util_isArrayLike__WEBPACK_IMPORTED_MODULE_2__["isArrayLike"])(input)) {
            return Object(_fromArray__WEBPACK_IMPORTED_MODULE_5__["fromArray"])(input, scheduler);
        }
        else if (Object(_util_isIterable__WEBPACK_IMPORTED_MODULE_4__["isIterable"])(input) || typeof input === 'string') {
            return Object(_fromIterable__WEBPACK_IMPORTED_MODULE_7__["fromIterable"])(input, scheduler);
        }
    }
    throw new TypeError((input !== null && typeof input || input) + ' is not observable');
}
//# sourceMappingURL=from.js.map


/***/ }),
/* 110 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isInteropObservable", function() { return isInteropObservable; });
/* harmony import */ var _symbol_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */

function isInteropObservable(input) {
    return input && typeof input[_symbol_observable__WEBPACK_IMPORTED_MODULE_0__["observable"]] === 'function';
}
//# sourceMappingURL=isInteropObservable.js.map


/***/ }),
/* 111 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIterable", function() { return isIterable; });
/* harmony import */ var _symbol_iterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(104);
/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */

function isIterable(input) {
    return input && typeof input[_symbol_iterator__WEBPACK_IMPORTED_MODULE_0__["iterator"]] === 'function';
}
//# sourceMappingURL=isIterable.js.map


/***/ }),
/* 112 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromPromise", function() { return fromPromise; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45);
/* harmony import */ var _util_subscribeToPromise__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(102);
/** PURE_IMPORTS_START _Observable,_Subscription,_util_subscribeToPromise PURE_IMPORTS_END */



function fromPromise(input, scheduler) {
    if (!scheduler) {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](Object(_util_subscribeToPromise__WEBPACK_IMPORTED_MODULE_2__["subscribeToPromise"])(input));
    }
    else {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
            var sub = new _Subscription__WEBPACK_IMPORTED_MODULE_1__["Subscription"]();
            sub.add(scheduler.schedule(function () {
                return input.then(function (value) {
                    sub.add(scheduler.schedule(function () {
                        subscriber.next(value);
                        sub.add(scheduler.schedule(function () { return subscriber.complete(); }));
                    }));
                }, function (err) {
                    sub.add(scheduler.schedule(function () { return subscriber.error(err); }));
                });
            }));
            return sub;
        });
    }
}
//# sourceMappingURL=fromPromise.js.map


/***/ }),
/* 113 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromIterable", function() { return fromIterable; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45);
/* harmony import */ var _symbol_iterator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(104);
/* harmony import */ var _util_subscribeToIterable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(103);
/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_iterator,_util_subscribeToIterable PURE_IMPORTS_END */




function fromIterable(input, scheduler) {
    if (!input) {
        throw new Error('Iterable cannot be null');
    }
    if (!scheduler) {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](Object(_util_subscribeToIterable__WEBPACK_IMPORTED_MODULE_3__["subscribeToIterable"])(input));
    }
    else {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
            var sub = new _Subscription__WEBPACK_IMPORTED_MODULE_1__["Subscription"]();
            var iterator;
            sub.add(function () {
                if (iterator && typeof iterator.return === 'function') {
                    iterator.return();
                }
            });
            sub.add(scheduler.schedule(function () {
                iterator = input[_symbol_iterator__WEBPACK_IMPORTED_MODULE_2__["iterator"]]();
                sub.add(scheduler.schedule(function () {
                    if (subscriber.closed) {
                        return;
                    }
                    var value;
                    var done;
                    try {
                        var result = iterator.next();
                        value = result.value;
                        done = result.done;
                    }
                    catch (err) {
                        subscriber.error(err);
                        return;
                    }
                    if (done) {
                        subscriber.complete();
                    }
                    else {
                        subscriber.next(value);
                        this.schedule();
                    }
                }));
            }));
            return sub;
        });
    }
}
//# sourceMappingURL=fromIterable.js.map


/***/ }),
/* 114 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromObservable", function() { return fromObservable; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45);
/* harmony import */ var _symbol_observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(52);
/* harmony import */ var _util_subscribeToObservable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(105);
/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_observable,_util_subscribeToObservable PURE_IMPORTS_END */




function fromObservable(input, scheduler) {
    if (!scheduler) {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](Object(_util_subscribeToObservable__WEBPACK_IMPORTED_MODULE_3__["subscribeToObservable"])(input));
    }
    else {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
            var sub = new _Subscription__WEBPACK_IMPORTED_MODULE_1__["Subscription"]();
            sub.add(scheduler.schedule(function () {
                var observable = input[_symbol_observable__WEBPACK_IMPORTED_MODULE_2__["observable"]]();
                sub.add(observable.subscribe({
                    next: function (value) { sub.add(scheduler.schedule(function () { return subscriber.next(value); })); },
                    error: function (err) { sub.add(scheduler.schedule(function () { return subscriber.error(err); })); },
                    complete: function () { sub.add(scheduler.schedule(function () { return subscriber.complete(); })); },
                }));
            }));
            return sub;
        });
    }
}
//# sourceMappingURL=fromObservable.js.map


/***/ }),
/* 115 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concatAll", function() { return concatAll; });
/* harmony import */ var _mergeAll__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(116);
/** PURE_IMPORTS_START _mergeAll PURE_IMPORTS_END */

function concatAll() {
    return Object(_mergeAll__WEBPACK_IMPORTED_MODULE_0__["mergeAll"])(1);
}
//# sourceMappingURL=concatAll.js.map


/***/ }),
/* 116 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeAll", function() { return mergeAll; });
/* harmony import */ var _mergeMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(117);
/* harmony import */ var _util_identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(89);
/** PURE_IMPORTS_START _mergeMap,_util_identity PURE_IMPORTS_END */


function mergeAll(concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    return Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__["mergeMap"])(_util_identity__WEBPACK_IMPORTED_MODULE_1__["identity"], concurrent);
}
//# sourceMappingURL=mergeAll.js.map


/***/ }),
/* 117 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeMap", function() { return mergeMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MergeMapOperator", function() { return MergeMapOperator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MergeMapSubscriber", function() { return MergeMapSubscriber; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98);
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(95);
/* harmony import */ var _observable_from__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(109);
/** PURE_IMPORTS_START tslib,_util_subscribeToResult,_OuterSubscriber,_map,_observable_from PURE_IMPORTS_END */





function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    if (typeof resultSelector === 'function') {
        return function (source) { return source.pipe(mergeMap(function (a, i) { return Object(_observable_from__WEBPACK_IMPORTED_MODULE_4__["from"])(project(a, i)).pipe(Object(_map__WEBPACK_IMPORTED_MODULE_3__["map"])(function (b, ii) { return resultSelector(a, b, i, ii); })); }, concurrent)); };
    }
    else if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
    }
    return function (source) { return source.lift(new MergeMapOperator(project, concurrent)); };
}
var MergeMapOperator = /*@__PURE__*/ (function () {
    function MergeMapOperator(project, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        this.project = project;
        this.concurrent = concurrent;
    }
    MergeMapOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
    };
    return MergeMapOperator;
}());

var MergeMapSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](MergeMapSubscriber, _super);
    function MergeMapSubscriber(destination, project, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
    }
    MergeMapSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            this._tryNext(value);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeMapSubscriber.prototype._tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.active++;
        this._innerSub(result, value, index);
    };
    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
        this.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__["subscribeToResult"])(this, ish, value, index));
    };
    MergeMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
    };
    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__["OuterSubscriber"]));

//# sourceMappingURL=mergeMap.js.map


/***/ }),
/* 118 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defer", function() { return defer; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _from__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(109);
/* harmony import */ var _empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(72);
/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */



function defer(observableFactory) {
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
        var input;
        try {
            input = observableFactory();
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var source = input ? Object(_from__WEBPACK_IMPORTED_MODULE_1__["from"])(input) : Object(_empty__WEBPACK_IMPORTED_MODULE_2__["empty"])();
        return source.subscribe(subscriber);
    });
}
//# sourceMappingURL=defer.js.map


/***/ }),
/* 119 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forkJoin", function() { return forkJoin; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(37);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(46);
/* harmony import */ var _empty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(72);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(99);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(98);
/* harmony import */ var _operators_map__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(95);
/** PURE_IMPORTS_START tslib,_Observable,_util_isArray,_empty,_util_subscribeToResult,_OuterSubscriber,_operators_map PURE_IMPORTS_END */







function forkJoin() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    var resultSelector;
    if (typeof sources[sources.length - 1] === 'function') {
        resultSelector = sources.pop();
    }
    if (sources.length === 1 && Object(_util_isArray__WEBPACK_IMPORTED_MODULE_2__["isArray"])(sources[0])) {
        sources = sources[0];
    }
    if (sources.length === 0) {
        return _empty__WEBPACK_IMPORTED_MODULE_3__["EMPTY"];
    }
    if (resultSelector) {
        return forkJoin(sources).pipe(Object(_operators_map__WEBPACK_IMPORTED_MODULE_6__["map"])(function (args) { return resultSelector.apply(void 0, args); }));
    }
    return new _Observable__WEBPACK_IMPORTED_MODULE_1__["Observable"](function (subscriber) {
        return new ForkJoinSubscriber(subscriber, sources);
    });
}
var ForkJoinSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](ForkJoinSubscriber, _super);
    function ForkJoinSubscriber(destination, sources) {
        var _this = _super.call(this, destination) || this;
        _this.sources = sources;
        _this.completed = 0;
        _this.haveValues = 0;
        var len = sources.length;
        _this.values = new Array(len);
        for (var i = 0; i < len; i++) {
            var source = sources[i];
            var innerSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__["subscribeToResult"])(_this, source, null, i);
            if (innerSubscription) {
                _this.add(innerSubscription);
            }
        }
        return _this;
    }
    ForkJoinSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values[outerIndex] = innerValue;
        if (!innerSub._hasValue) {
            innerSub._hasValue = true;
            this.haveValues++;
        }
    };
    ForkJoinSubscriber.prototype.notifyComplete = function (innerSub) {
        var _a = this, destination = _a.destination, haveValues = _a.haveValues, values = _a.values;
        var len = values.length;
        if (!innerSub._hasValue) {
            destination.complete();
            return;
        }
        this.completed++;
        if (this.completed !== len) {
            return;
        }
        if (haveValues === len) {
            destination.next(values);
        }
        destination.complete();
    };
    return ForkJoinSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_5__["OuterSubscriber"]));
//# sourceMappingURL=forkJoin.js.map


/***/ }),
/* 120 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromEvent", function() { return fromEvent; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(46);
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(41);
/* harmony import */ var _operators_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(95);
/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */




var toString = Object.prototype.toString;
function fromEvent(target, eventName, options, resultSelector) {
    if (Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_2__["isFunction"])(options)) {
        resultSelector = options;
        options = undefined;
    }
    if (resultSelector) {
        return fromEvent(target, eventName, options).pipe(Object(_operators_map__WEBPACK_IMPORTED_MODULE_3__["map"])(function (args) { return Object(_util_isArray__WEBPACK_IMPORTED_MODULE_1__["isArray"])(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
    }
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
        function handler(e) {
            if (arguments.length > 1) {
                subscriber.next(Array.prototype.slice.call(arguments));
            }
            else {
                subscriber.next(e);
            }
        }
        setupSubscription(target, eventName, handler, subscriber, options);
    });
}
function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
    var unsubscribe;
    if (isEventTarget(sourceObj)) {
        var source_1 = sourceObj;
        sourceObj.addEventListener(eventName, handler, options);
        unsubscribe = function () { return source_1.removeEventListener(eventName, handler, options); };
    }
    else if (isJQueryStyleEventEmitter(sourceObj)) {
        var source_2 = sourceObj;
        sourceObj.on(eventName, handler);
        unsubscribe = function () { return source_2.off(eventName, handler); };
    }
    else if (isNodeStyleEventEmitter(sourceObj)) {
        var source_3 = sourceObj;
        sourceObj.addListener(eventName, handler);
        unsubscribe = function () { return source_3.removeListener(eventName, handler); };
    }
    else if (sourceObj && sourceObj.length) {
        for (var i = 0, len = sourceObj.length; i < len; i++) {
            setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
        }
    }
    else {
        throw new TypeError('Invalid event target');
    }
    subscriber.add(unsubscribe);
}
function isNodeStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
}
function isJQueryStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
}
function isEventTarget(sourceObj) {
    return sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
}
//# sourceMappingURL=fromEvent.js.map


/***/ }),
/* 121 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromEventPattern", function() { return fromEventPattern; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(46);
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(41);
/* harmony import */ var _operators_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(95);
/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */




function fromEventPattern(addHandler, removeHandler, resultSelector) {
    if (resultSelector) {
        return fromEventPattern(addHandler, removeHandler).pipe(Object(_operators_map__WEBPACK_IMPORTED_MODULE_3__["map"])(function (args) { return Object(_util_isArray__WEBPACK_IMPORTED_MODULE_1__["isArray"])(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
    }
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
        var handler = function () {
            var e = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                e[_i] = arguments[_i];
            }
            return subscriber.next(e.length === 1 ? e[0] : e);
        };
        var retValue;
        try {
            retValue = addHandler(handler);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        if (!Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_2__["isFunction"])(removeHandler)) {
            return undefined;
        }
        return function () { return removeHandler(handler, retValue); };
    });
}
//# sourceMappingURL=fromEventPattern.js.map


/***/ }),
/* 122 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generate", function() { return generate; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _util_identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(89);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(74);
/** PURE_IMPORTS_START _Observable,_util_identity,_util_isScheduler PURE_IMPORTS_END */



function generate(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {
    var resultSelector;
    var initialState;
    if (arguments.length == 1) {
        var options = initialStateOrOptions;
        initialState = options.initialState;
        condition = options.condition;
        iterate = options.iterate;
        resultSelector = options.resultSelector || _util_identity__WEBPACK_IMPORTED_MODULE_1__["identity"];
        scheduler = options.scheduler;
    }
    else if (resultSelectorOrObservable === undefined || Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_2__["isScheduler"])(resultSelectorOrObservable)) {
        initialState = initialStateOrOptions;
        resultSelector = _util_identity__WEBPACK_IMPORTED_MODULE_1__["identity"];
        scheduler = resultSelectorOrObservable;
    }
    else {
        initialState = initialStateOrOptions;
        resultSelector = resultSelectorOrObservable;
    }
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
        var state = initialState;
        if (scheduler) {
            return scheduler.schedule(dispatch, 0, {
                subscriber: subscriber,
                iterate: iterate,
                condition: condition,
                resultSelector: resultSelector,
                state: state
            });
        }
        do {
            if (condition) {
                var conditionResult = void 0;
                try {
                    conditionResult = condition(state);
                }
                catch (err) {
                    subscriber.error(err);
                    return undefined;
                }
                if (!conditionResult) {
                    subscriber.complete();
                    break;
                }
            }
            var value = void 0;
            try {
                value = resultSelector(state);
            }
            catch (err) {
                subscriber.error(err);
                return undefined;
            }
            subscriber.next(value);
            if (subscriber.closed) {
                break;
            }
            try {
                state = iterate(state);
            }
            catch (err) {
                subscriber.error(err);
                return undefined;
            }
        } while (true);
        return undefined;
    });
}
function dispatch(state) {
    var subscriber = state.subscriber, condition = state.condition;
    if (subscriber.closed) {
        return undefined;
    }
    if (state.needIterate) {
        try {
            state.state = state.iterate(state.state);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
    }
    else {
        state.needIterate = true;
    }
    if (condition) {
        var conditionResult = void 0;
        try {
            conditionResult = condition(state.state);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        if (!conditionResult) {
            subscriber.complete();
            return undefined;
        }
        if (subscriber.closed) {
            return undefined;
        }
    }
    var value;
    try {
        value = state.resultSelector(state.state);
    }
    catch (err) {
        subscriber.error(err);
        return undefined;
    }
    if (subscriber.closed) {
        return undefined;
    }
    subscriber.next(value);
    if (subscriber.closed) {
        return undefined;
    }
    return this.schedule(state);
}
//# sourceMappingURL=generate.js.map


/***/ }),
/* 123 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "iif", function() { return iif; });
/* harmony import */ var _defer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(118);
/* harmony import */ var _empty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(72);
/** PURE_IMPORTS_START _defer,_empty PURE_IMPORTS_END */


function iif(condition, trueResult, falseResult) {
    if (trueResult === void 0) {
        trueResult = _empty__WEBPACK_IMPORTED_MODULE_1__["EMPTY"];
    }
    if (falseResult === void 0) {
        falseResult = _empty__WEBPACK_IMPORTED_MODULE_1__["EMPTY"];
    }
    return Object(_defer__WEBPACK_IMPORTED_MODULE_0__["defer"])(function () { return condition() ? trueResult : falseResult; });
}
//# sourceMappingURL=iif.js.map


/***/ }),
/* 124 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interval", function() { return interval; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(84);
/* harmony import */ var _util_isNumeric__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(125);
/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric PURE_IMPORTS_END */



function interval(period, scheduler) {
    if (period === void 0) {
        period = 0;
    }
    if (scheduler === void 0) {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__["async"];
    }
    if (!Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_2__["isNumeric"])(period) || period < 0) {
        period = 0;
    }
    if (!scheduler || typeof scheduler.schedule !== 'function') {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__["async"];
    }
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
        subscriber.add(scheduler.schedule(dispatch, period, { subscriber: subscriber, counter: 0, period: period }));
        return subscriber;
    });
}
function dispatch(state) {
    var subscriber = state.subscriber, counter = state.counter, period = state.period;
    subscriber.next(counter);
    this.schedule({ subscriber: subscriber, counter: counter + 1, period: period }, period);
}
//# sourceMappingURL=interval.js.map


/***/ }),
/* 125 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNumeric", function() { return isNumeric; });
/* harmony import */ var _isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46);
/** PURE_IMPORTS_START _isArray PURE_IMPORTS_END */

function isNumeric(val) {
    return !Object(_isArray__WEBPACK_IMPORTED_MODULE_0__["isArray"])(val) && (val - parseFloat(val) + 1) >= 0;
}
//# sourceMappingURL=isNumeric.js.map


/***/ }),
/* 126 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return merge; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(74);
/* harmony import */ var _operators_mergeAll__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(116);
/* harmony import */ var _fromArray__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(75);
/** PURE_IMPORTS_START _Observable,_util_isScheduler,_operators_mergeAll,_fromArray PURE_IMPORTS_END */




function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var concurrent = Number.POSITIVE_INFINITY;
    var scheduler = null;
    var last = observables[observables.length - 1];
    if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_1__["isScheduler"])(last)) {
        scheduler = observables.pop();
        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
            concurrent = observables.pop();
        }
    }
    else if (typeof last === 'number') {
        concurrent = observables.pop();
    }
    if (scheduler === null && observables.length === 1 && observables[0] instanceof _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"]) {
        return observables[0];
    }
    return Object(_operators_mergeAll__WEBPACK_IMPORTED_MODULE_2__["mergeAll"])(concurrent)(Object(_fromArray__WEBPACK_IMPORTED_MODULE_3__["fromArray"])(observables, scheduler));
}
//# sourceMappingURL=merge.js.map


/***/ }),
/* 127 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NEVER", function() { return NEVER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "never", function() { return never; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _util_noop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54);
/** PURE_IMPORTS_START _Observable,_util_noop PURE_IMPORTS_END */


var NEVER = /*@__PURE__*/ new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](_util_noop__WEBPACK_IMPORTED_MODULE_1__["noop"]);
function never() {
    return NEVER;
}
//# sourceMappingURL=never.js.map


/***/ }),
/* 128 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onErrorResumeNext", function() { return onErrorResumeNext; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _from__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(109);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(46);
/* harmony import */ var _empty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(72);
/** PURE_IMPORTS_START _Observable,_from,_util_isArray,_empty PURE_IMPORTS_END */




function onErrorResumeNext() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    if (sources.length === 0) {
        return _empty__WEBPACK_IMPORTED_MODULE_3__["EMPTY"];
    }
    var first = sources[0], remainder = sources.slice(1);
    if (sources.length === 1 && Object(_util_isArray__WEBPACK_IMPORTED_MODULE_2__["isArray"])(first)) {
        return onErrorResumeNext.apply(void 0, first);
    }
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
        var subNext = function () { return subscriber.add(onErrorResumeNext.apply(void 0, remainder).subscribe(subscriber)); };
        return Object(_from__WEBPACK_IMPORTED_MODULE_1__["from"])(first).subscribe({
            next: function (value) { subscriber.next(value); },
            error: subNext,
            complete: subNext,
        });
    });
}
//# sourceMappingURL=onErrorResumeNext.js.map


/***/ }),
/* 129 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pairs", function() { return pairs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dispatch", function() { return dispatch; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45);
/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */


function pairs(obj, scheduler) {
    if (!scheduler) {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
            var keys = Object.keys(obj);
            for (var i = 0; i < keys.length && !subscriber.closed; i++) {
                var key = keys[i];
                if (obj.hasOwnProperty(key)) {
                    subscriber.next([key, obj[key]]);
                }
            }
            subscriber.complete();
        });
    }
    else {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
            var keys = Object.keys(obj);
            var subscription = new _Subscription__WEBPACK_IMPORTED_MODULE_1__["Subscription"]();
            subscription.add(scheduler.schedule(dispatch, 0, { keys: keys, index: 0, subscriber: subscriber, subscription: subscription, obj: obj }));
            return subscription;
        });
    }
}
function dispatch(state) {
    var keys = state.keys, index = state.index, subscriber = state.subscriber, subscription = state.subscription, obj = state.obj;
    if (!subscriber.closed) {
        if (index < keys.length) {
            var key = keys[index];
            subscriber.next([key, obj[key]]);
            subscription.add(this.schedule({ keys: keys, index: index + 1, subscriber: subscriber, subscription: subscription, obj: obj }));
        }
        else {
            subscriber.complete();
        }
    }
}
//# sourceMappingURL=pairs.js.map


/***/ }),
/* 130 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "race", function() { return race; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RaceOperator", function() { return RaceOperator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RaceSubscriber", function() { return RaceSubscriber; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(46);
/* harmony import */ var _fromArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(75);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(98);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(99);
/** PURE_IMPORTS_START tslib,_util_isArray,_fromArray,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */





function race() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    if (observables.length === 1) {
        if (Object(_util_isArray__WEBPACK_IMPORTED_MODULE_1__["isArray"])(observables[0])) {
            observables = observables[0];
        }
        else {
            return observables[0];
        }
    }
    return Object(_fromArray__WEBPACK_IMPORTED_MODULE_2__["fromArray"])(observables, undefined).lift(new RaceOperator());
}
var RaceOperator = /*@__PURE__*/ (function () {
    function RaceOperator() {
    }
    RaceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RaceSubscriber(subscriber));
    };
    return RaceOperator;
}());

var RaceSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](RaceSubscriber, _super);
    function RaceSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasFirst = false;
        _this.observables = [];
        _this.subscriptions = [];
        return _this;
    }
    RaceSubscriber.prototype._next = function (observable) {
        this.observables.push(observable);
    };
    RaceSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            for (var i = 0; i < len && !this.hasFirst; i++) {
                var observable = observables[i];
                var subscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__["subscribeToResult"])(this, observable, observable, i);
                if (this.subscriptions) {
                    this.subscriptions.push(subscription);
                }
                this.add(subscription);
            }
            this.observables = null;
        }
    };
    RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (!this.hasFirst) {
            this.hasFirst = true;
            for (var i = 0; i < this.subscriptions.length; i++) {
                if (i !== outerIndex) {
                    var subscription = this.subscriptions[i];
                    subscription.unsubscribe();
                    this.remove(subscription);
                }
            }
            this.subscriptions = null;
        }
        this.destination.next(innerValue);
    };
    return RaceSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__["OuterSubscriber"]));

//# sourceMappingURL=race.js.map


/***/ }),
/* 131 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "range", function() { return range; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dispatch", function() { return dispatch; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */

function range(start, count, scheduler) {
    if (start === void 0) {
        start = 0;
    }
    if (count === void 0) {
        count = 0;
    }
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
        var index = 0;
        var current = start;
        if (scheduler) {
            return scheduler.schedule(dispatch, 0, {
                index: index, count: count, start: start, subscriber: subscriber
            });
        }
        else {
            do {
                if (index++ >= count) {
                    subscriber.complete();
                    break;
                }
                subscriber.next(current++);
                if (subscriber.closed) {
                    break;
                }
            } while (true);
        }
        return undefined;
    });
}
function dispatch(state) {
    var start = state.start, index = state.index, count = state.count, subscriber = state.subscriber;
    if (index >= count) {
        subscriber.complete();
        return;
    }
    subscriber.next(start);
    if (subscriber.closed) {
        return;
    }
    state.index = index + 1;
    state.start = start + 1;
    this.schedule(state);
}
//# sourceMappingURL=range.js.map


/***/ }),
/* 132 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timer", function() { return timer; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(84);
/* harmony import */ var _util_isNumeric__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(125);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(74);
/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */




function timer(dueTime, periodOrScheduler, scheduler) {
    if (dueTime === void 0) {
        dueTime = 0;
    }
    var period = -1;
    if (Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_2__["isNumeric"])(periodOrScheduler)) {
        period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
    }
    else if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_3__["isScheduler"])(periodOrScheduler)) {
        scheduler = periodOrScheduler;
    }
    if (!Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_3__["isScheduler"])(scheduler)) {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__["async"];
    }
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
        var due = Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_2__["isNumeric"])(dueTime)
            ? dueTime
            : (+dueTime - scheduler.now());
        return scheduler.schedule(dispatch, due, {
            index: 0, period: period, subscriber: subscriber
        });
    });
}
function dispatch(state) {
    var index = state.index, period = state.period, subscriber = state.subscriber;
    subscriber.next(index);
    if (subscriber.closed) {
        return;
    }
    else if (period === -1) {
        return subscriber.complete();
    }
    state.index = index + 1;
    this.schedule(state, period);
}
//# sourceMappingURL=timer.js.map


/***/ }),
/* 133 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "using", function() { return using; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _from__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(109);
/* harmony import */ var _empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(72);
/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */



function using(resourceFactory, observableFactory) {
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
        var resource;
        try {
            resource = resourceFactory();
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var result;
        try {
            result = observableFactory(resource);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var source = result ? Object(_from__WEBPACK_IMPORTED_MODULE_1__["from"])(result) : _empty__WEBPACK_IMPORTED_MODULE_2__["EMPTY"];
        var subscription = source.subscribe(subscriber);
        return function () {
            subscription.unsubscribe();
            if (resource) {
                resource.unsubscribe();
            }
        };
    });
}
//# sourceMappingURL=using.js.map


/***/ }),
/* 134 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zip", function() { return zip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZipOperator", function() { return ZipOperator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZipSubscriber", function() { return ZipSubscriber; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _fromArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(75);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(46);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(39);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(98);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(99);
/* harmony import */ var _internal_symbol_iterator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(104);
/** PURE_IMPORTS_START tslib,_fromArray,_util_isArray,_Subscriber,_OuterSubscriber,_util_subscribeToResult,_.._internal_symbol_iterator PURE_IMPORTS_END */







function zip() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var resultSelector = observables[observables.length - 1];
    if (typeof resultSelector === 'function') {
        observables.pop();
    }
    return Object(_fromArray__WEBPACK_IMPORTED_MODULE_1__["fromArray"])(observables, undefined).lift(new ZipOperator(resultSelector));
}
var ZipOperator = /*@__PURE__*/ (function () {
    function ZipOperator(resultSelector) {
        this.resultSelector = resultSelector;
    }
    ZipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
    };
    return ZipOperator;
}());

var ZipSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](ZipSubscriber, _super);
    function ZipSubscriber(destination, resultSelector, values) {
        if (values === void 0) {
            values = Object.create(null);
        }
        var _this = _super.call(this, destination) || this;
        _this.iterators = [];
        _this.active = 0;
        _this.resultSelector = (typeof resultSelector === 'function') ? resultSelector : null;
        _this.values = values;
        return _this;
    }
    ZipSubscriber.prototype._next = function (value) {
        var iterators = this.iterators;
        if (Object(_util_isArray__WEBPACK_IMPORTED_MODULE_2__["isArray"])(value)) {
            iterators.push(new StaticArrayIterator(value));
        }
        else if (typeof value[_internal_symbol_iterator__WEBPACK_IMPORTED_MODULE_6__["iterator"]] === 'function') {
            iterators.push(new StaticIterator(value[_internal_symbol_iterator__WEBPACK_IMPORTED_MODULE_6__["iterator"]]()));
        }
        else {
            iterators.push(new ZipBufferIterator(this.destination, this, value));
        }
    };
    ZipSubscriber.prototype._complete = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        if (len === 0) {
            this.destination.complete();
            return;
        }
        this.active = len;
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (iterator.stillUnsubscribed) {
                this.add(iterator.subscribe(iterator, i));
            }
            else {
                this.active--;
            }
        }
    };
    ZipSubscriber.prototype.notifyInactive = function () {
        this.active--;
        if (this.active === 0) {
            this.destination.complete();
        }
    };
    ZipSubscriber.prototype.checkIterators = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        var destination = this.destination;
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {
                return;
            }
        }
        var shouldComplete = false;
        var args = [];
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            var result = iterator.next();
            if (iterator.hasCompleted()) {
                shouldComplete = true;
            }
            if (result.done) {
                destination.complete();
                return;
            }
            args.push(result.value);
        }
        if (this.resultSelector) {
            this._tryresultSelector(args);
        }
        else {
            destination.next(args);
        }
        if (shouldComplete) {
            destination.complete();
        }
    };
    ZipSubscriber.prototype._tryresultSelector = function (args) {
        var result;
        try {
            result = this.resultSelector.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return ZipSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_3__["Subscriber"]));

var StaticIterator = /*@__PURE__*/ (function () {
    function StaticIterator(iterator) {
        this.iterator = iterator;
        this.nextResult = iterator.next();
    }
    StaticIterator.prototype.hasValue = function () {
        return true;
    };
    StaticIterator.prototype.next = function () {
        var result = this.nextResult;
        this.nextResult = this.iterator.next();
        return result;
    };
    StaticIterator.prototype.hasCompleted = function () {
        var nextResult = this.nextResult;
        return nextResult && nextResult.done;
    };
    return StaticIterator;
}());
var StaticArrayIterator = /*@__PURE__*/ (function () {
    function StaticArrayIterator(array) {
        this.array = array;
        this.index = 0;
        this.length = 0;
        this.length = array.length;
    }
    StaticArrayIterator.prototype[_internal_symbol_iterator__WEBPACK_IMPORTED_MODULE_6__["iterator"]] = function () {
        return this;
    };
    StaticArrayIterator.prototype.next = function (value) {
        var i = this.index++;
        var array = this.array;
        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };
    };
    StaticArrayIterator.prototype.hasValue = function () {
        return this.array.length > this.index;
    };
    StaticArrayIterator.prototype.hasCompleted = function () {
        return this.array.length === this.index;
    };
    return StaticArrayIterator;
}());
var ZipBufferIterator = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](ZipBufferIterator, _super);
    function ZipBufferIterator(destination, parent, observable) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        _this.observable = observable;
        _this.stillUnsubscribed = true;
        _this.buffer = [];
        _this.isComplete = false;
        return _this;
    }
    ZipBufferIterator.prototype[_internal_symbol_iterator__WEBPACK_IMPORTED_MODULE_6__["iterator"]] = function () {
        return this;
    };
    ZipBufferIterator.prototype.next = function () {
        var buffer = this.buffer;
        if (buffer.length === 0 && this.isComplete) {
            return { value: null, done: true };
        }
        else {
            return { value: buffer.shift(), done: false };
        }
    };
    ZipBufferIterator.prototype.hasValue = function () {
        return this.buffer.length > 0;
    };
    ZipBufferIterator.prototype.hasCompleted = function () {
        return this.buffer.length === 0 && this.isComplete;
    };
    ZipBufferIterator.prototype.notifyComplete = function () {
        if (this.buffer.length > 0) {
            this.isComplete = true;
            this.parent.notifyInactive();
        }
        else {
            this.destination.complete();
        }
    };
    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.buffer.push(innerValue);
        this.parent.checkIterators();
    };
    ZipBufferIterator.prototype.subscribe = function (value, index) {
        return Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_5__["subscribeToResult"])(this, this.observable, this, index);
    };
    return ZipBufferIterator;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_4__["OuterSubscriber"]));
//# sourceMappingURL=zip.js.map


/***/ }),
/* 135 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_operators_audit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(136);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "audit", function() { return _internal_operators_audit__WEBPACK_IMPORTED_MODULE_0__["audit"]; });

/* harmony import */ var _internal_operators_auditTime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(137);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "auditTime", function() { return _internal_operators_auditTime__WEBPACK_IMPORTED_MODULE_1__["auditTime"]; });

/* harmony import */ var _internal_operators_buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(138);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "buffer", function() { return _internal_operators_buffer__WEBPACK_IMPORTED_MODULE_2__["buffer"]; });

/* harmony import */ var _internal_operators_bufferCount__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(139);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bufferCount", function() { return _internal_operators_bufferCount__WEBPACK_IMPORTED_MODULE_3__["bufferCount"]; });

/* harmony import */ var _internal_operators_bufferTime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(140);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bufferTime", function() { return _internal_operators_bufferTime__WEBPACK_IMPORTED_MODULE_4__["bufferTime"]; });

/* harmony import */ var _internal_operators_bufferToggle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(141);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bufferToggle", function() { return _internal_operators_bufferToggle__WEBPACK_IMPORTED_MODULE_5__["bufferToggle"]; });

/* harmony import */ var _internal_operators_bufferWhen__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(142);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bufferWhen", function() { return _internal_operators_bufferWhen__WEBPACK_IMPORTED_MODULE_6__["bufferWhen"]; });

/* harmony import */ var _internal_operators_catchError__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(143);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "catchError", function() { return _internal_operators_catchError__WEBPACK_IMPORTED_MODULE_7__["catchError"]; });

/* harmony import */ var _internal_operators_combineAll__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(144);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "combineAll", function() { return _internal_operators_combineAll__WEBPACK_IMPORTED_MODULE_8__["combineAll"]; });

/* harmony import */ var _internal_operators_combineLatest__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(145);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "combineLatest", function() { return _internal_operators_combineLatest__WEBPACK_IMPORTED_MODULE_9__["combineLatest"]; });

/* harmony import */ var _internal_operators_concat__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(146);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concat", function() { return _internal_operators_concat__WEBPACK_IMPORTED_MODULE_10__["concat"]; });

/* harmony import */ var _internal_operators_concatAll__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(115);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concatAll", function() { return _internal_operators_concatAll__WEBPACK_IMPORTED_MODULE_11__["concatAll"]; });

/* harmony import */ var _internal_operators_concatMap__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(147);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concatMap", function() { return _internal_operators_concatMap__WEBPACK_IMPORTED_MODULE_12__["concatMap"]; });

/* harmony import */ var _internal_operators_concatMapTo__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(148);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concatMapTo", function() { return _internal_operators_concatMapTo__WEBPACK_IMPORTED_MODULE_13__["concatMapTo"]; });

/* harmony import */ var _internal_operators_count__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(149);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "count", function() { return _internal_operators_count__WEBPACK_IMPORTED_MODULE_14__["count"]; });

/* harmony import */ var _internal_operators_debounce__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(150);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "debounce", function() { return _internal_operators_debounce__WEBPACK_IMPORTED_MODULE_15__["debounce"]; });

/* harmony import */ var _internal_operators_debounceTime__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(151);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "debounceTime", function() { return _internal_operators_debounceTime__WEBPACK_IMPORTED_MODULE_16__["debounceTime"]; });

/* harmony import */ var _internal_operators_defaultIfEmpty__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(152);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "defaultIfEmpty", function() { return _internal_operators_defaultIfEmpty__WEBPACK_IMPORTED_MODULE_17__["defaultIfEmpty"]; });

/* harmony import */ var _internal_operators_delay__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(153);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "delay", function() { return _internal_operators_delay__WEBPACK_IMPORTED_MODULE_18__["delay"]; });

/* harmony import */ var _internal_operators_delayWhen__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(155);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "delayWhen", function() { return _internal_operators_delayWhen__WEBPACK_IMPORTED_MODULE_19__["delayWhen"]; });

/* harmony import */ var _internal_operators_dematerialize__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(156);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dematerialize", function() { return _internal_operators_dematerialize__WEBPACK_IMPORTED_MODULE_20__["dematerialize"]; });

/* harmony import */ var _internal_operators_distinct__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(157);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "distinct", function() { return _internal_operators_distinct__WEBPACK_IMPORTED_MODULE_21__["distinct"]; });

/* harmony import */ var _internal_operators_distinctUntilChanged__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(158);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "distinctUntilChanged", function() { return _internal_operators_distinctUntilChanged__WEBPACK_IMPORTED_MODULE_22__["distinctUntilChanged"]; });

/* harmony import */ var _internal_operators_distinctUntilKeyChanged__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(159);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "distinctUntilKeyChanged", function() { return _internal_operators_distinctUntilKeyChanged__WEBPACK_IMPORTED_MODULE_23__["distinctUntilKeyChanged"]; });

/* harmony import */ var _internal_operators_elementAt__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(160);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "elementAt", function() { return _internal_operators_elementAt__WEBPACK_IMPORTED_MODULE_24__["elementAt"]; });

/* harmony import */ var _internal_operators_endWith__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(165);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "endWith", function() { return _internal_operators_endWith__WEBPACK_IMPORTED_MODULE_25__["endWith"]; });

/* harmony import */ var _internal_operators_every__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(166);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "every", function() { return _internal_operators_every__WEBPACK_IMPORTED_MODULE_26__["every"]; });

/* harmony import */ var _internal_operators_exhaust__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(167);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "exhaust", function() { return _internal_operators_exhaust__WEBPACK_IMPORTED_MODULE_27__["exhaust"]; });

/* harmony import */ var _internal_operators_exhaustMap__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(168);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "exhaustMap", function() { return _internal_operators_exhaustMap__WEBPACK_IMPORTED_MODULE_28__["exhaustMap"]; });

/* harmony import */ var _internal_operators_expand__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(169);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "expand", function() { return _internal_operators_expand__WEBPACK_IMPORTED_MODULE_29__["expand"]; });

/* harmony import */ var _internal_operators_filter__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(161);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "filter", function() { return _internal_operators_filter__WEBPACK_IMPORTED_MODULE_30__["filter"]; });

/* harmony import */ var _internal_operators_finalize__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(170);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "finalize", function() { return _internal_operators_finalize__WEBPACK_IMPORTED_MODULE_31__["finalize"]; });

/* harmony import */ var _internal_operators_find__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(171);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "find", function() { return _internal_operators_find__WEBPACK_IMPORTED_MODULE_32__["find"]; });

/* harmony import */ var _internal_operators_findIndex__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(172);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "findIndex", function() { return _internal_operators_findIndex__WEBPACK_IMPORTED_MODULE_33__["findIndex"]; });

/* harmony import */ var _internal_operators_first__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(173);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "first", function() { return _internal_operators_first__WEBPACK_IMPORTED_MODULE_34__["first"]; });

/* harmony import */ var _internal_operators_groupBy__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(60);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "groupBy", function() { return _internal_operators_groupBy__WEBPACK_IMPORTED_MODULE_35__["groupBy"]; });

/* harmony import */ var _internal_operators_ignoreElements__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(174);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ignoreElements", function() { return _internal_operators_ignoreElements__WEBPACK_IMPORTED_MODULE_36__["ignoreElements"]; });

/* harmony import */ var _internal_operators_isEmpty__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(175);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isEmpty", function() { return _internal_operators_isEmpty__WEBPACK_IMPORTED_MODULE_37__["isEmpty"]; });

/* harmony import */ var _internal_operators_last__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(176);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "last", function() { return _internal_operators_last__WEBPACK_IMPORTED_MODULE_38__["last"]; });

/* harmony import */ var _internal_operators_map__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(95);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "map", function() { return _internal_operators_map__WEBPACK_IMPORTED_MODULE_39__["map"]; });

/* harmony import */ var _internal_operators_mapTo__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(178);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mapTo", function() { return _internal_operators_mapTo__WEBPACK_IMPORTED_MODULE_40__["mapTo"]; });

/* harmony import */ var _internal_operators_materialize__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(179);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "materialize", function() { return _internal_operators_materialize__WEBPACK_IMPORTED_MODULE_41__["materialize"]; });

/* harmony import */ var _internal_operators_max__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(180);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "max", function() { return _internal_operators_max__WEBPACK_IMPORTED_MODULE_42__["max"]; });

/* harmony import */ var _internal_operators_merge__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(183);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return _internal_operators_merge__WEBPACK_IMPORTED_MODULE_43__["merge"]; });

/* harmony import */ var _internal_operators_mergeAll__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(116);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mergeAll", function() { return _internal_operators_mergeAll__WEBPACK_IMPORTED_MODULE_44__["mergeAll"]; });

/* harmony import */ var _internal_operators_mergeMap__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(117);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mergeMap", function() { return _internal_operators_mergeMap__WEBPACK_IMPORTED_MODULE_45__["mergeMap"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "flatMap", function() { return _internal_operators_mergeMap__WEBPACK_IMPORTED_MODULE_45__["mergeMap"]; });

/* harmony import */ var _internal_operators_mergeMapTo__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(184);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mergeMapTo", function() { return _internal_operators_mergeMapTo__WEBPACK_IMPORTED_MODULE_46__["mergeMapTo"]; });

/* harmony import */ var _internal_operators_mergeScan__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(185);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mergeScan", function() { return _internal_operators_mergeScan__WEBPACK_IMPORTED_MODULE_47__["mergeScan"]; });

/* harmony import */ var _internal_operators_min__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(186);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "min", function() { return _internal_operators_min__WEBPACK_IMPORTED_MODULE_48__["min"]; });

/* harmony import */ var _internal_operators_multicast__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(187);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "multicast", function() { return _internal_operators_multicast__WEBPACK_IMPORTED_MODULE_49__["multicast"]; });

/* harmony import */ var _internal_operators_observeOn__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(70);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "observeOn", function() { return _internal_operators_observeOn__WEBPACK_IMPORTED_MODULE_50__["observeOn"]; });

/* harmony import */ var _internal_operators_onErrorResumeNext__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(188);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "onErrorResumeNext", function() { return _internal_operators_onErrorResumeNext__WEBPACK_IMPORTED_MODULE_51__["onErrorResumeNext"]; });

/* harmony import */ var _internal_operators_pairwise__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(189);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pairwise", function() { return _internal_operators_pairwise__WEBPACK_IMPORTED_MODULE_52__["pairwise"]; });

/* harmony import */ var _internal_operators_partition__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(190);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "partition", function() { return _internal_operators_partition__WEBPACK_IMPORTED_MODULE_53__["partition"]; });

/* harmony import */ var _internal_operators_pluck__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(192);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pluck", function() { return _internal_operators_pluck__WEBPACK_IMPORTED_MODULE_54__["pluck"]; });

/* harmony import */ var _internal_operators_publish__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(193);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "publish", function() { return _internal_operators_publish__WEBPACK_IMPORTED_MODULE_55__["publish"]; });

/* harmony import */ var _internal_operators_publishBehavior__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(194);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "publishBehavior", function() { return _internal_operators_publishBehavior__WEBPACK_IMPORTED_MODULE_56__["publishBehavior"]; });

/* harmony import */ var _internal_operators_publishLast__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(195);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "publishLast", function() { return _internal_operators_publishLast__WEBPACK_IMPORTED_MODULE_57__["publishLast"]; });

/* harmony import */ var _internal_operators_publishReplay__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(196);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "publishReplay", function() { return _internal_operators_publishReplay__WEBPACK_IMPORTED_MODULE_58__["publishReplay"]; });

/* harmony import */ var _internal_operators_race__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(197);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "race", function() { return _internal_operators_race__WEBPACK_IMPORTED_MODULE_59__["race"]; });

/* harmony import */ var _internal_operators_reduce__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(181);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reduce", function() { return _internal_operators_reduce__WEBPACK_IMPORTED_MODULE_60__["reduce"]; });

/* harmony import */ var _internal_operators_repeat__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(198);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "repeat", function() { return _internal_operators_repeat__WEBPACK_IMPORTED_MODULE_61__["repeat"]; });

/* harmony import */ var _internal_operators_repeatWhen__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(199);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "repeatWhen", function() { return _internal_operators_repeatWhen__WEBPACK_IMPORTED_MODULE_62__["repeatWhen"]; });

/* harmony import */ var _internal_operators_retry__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(200);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "retry", function() { return _internal_operators_retry__WEBPACK_IMPORTED_MODULE_63__["retry"]; });

/* harmony import */ var _internal_operators_retryWhen__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(201);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "retryWhen", function() { return _internal_operators_retryWhen__WEBPACK_IMPORTED_MODULE_64__["retryWhen"]; });

/* harmony import */ var _internal_operators_refCount__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(59);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "refCount", function() { return _internal_operators_refCount__WEBPACK_IMPORTED_MODULE_65__["refCount"]; });

/* harmony import */ var _internal_operators_sample__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(202);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sample", function() { return _internal_operators_sample__WEBPACK_IMPORTED_MODULE_66__["sample"]; });

/* harmony import */ var _internal_operators_sampleTime__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(203);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sampleTime", function() { return _internal_operators_sampleTime__WEBPACK_IMPORTED_MODULE_67__["sampleTime"]; });

/* harmony import */ var _internal_operators_scan__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(182);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scan", function() { return _internal_operators_scan__WEBPACK_IMPORTED_MODULE_68__["scan"]; });

/* harmony import */ var _internal_operators_sequenceEqual__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(204);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sequenceEqual", function() { return _internal_operators_sequenceEqual__WEBPACK_IMPORTED_MODULE_69__["sequenceEqual"]; });

/* harmony import */ var _internal_operators_share__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(205);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "share", function() { return _internal_operators_share__WEBPACK_IMPORTED_MODULE_70__["share"]; });

/* harmony import */ var _internal_operators_shareReplay__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(206);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "shareReplay", function() { return _internal_operators_shareReplay__WEBPACK_IMPORTED_MODULE_71__["shareReplay"]; });

/* harmony import */ var _internal_operators_single__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(207);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "single", function() { return _internal_operators_single__WEBPACK_IMPORTED_MODULE_72__["single"]; });

/* harmony import */ var _internal_operators_skip__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(208);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "skip", function() { return _internal_operators_skip__WEBPACK_IMPORTED_MODULE_73__["skip"]; });

/* harmony import */ var _internal_operators_skipLast__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(209);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "skipLast", function() { return _internal_operators_skipLast__WEBPACK_IMPORTED_MODULE_74__["skipLast"]; });

/* harmony import */ var _internal_operators_skipUntil__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(210);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "skipUntil", function() { return _internal_operators_skipUntil__WEBPACK_IMPORTED_MODULE_75__["skipUntil"]; });

/* harmony import */ var _internal_operators_skipWhile__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(211);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "skipWhile", function() { return _internal_operators_skipWhile__WEBPACK_IMPORTED_MODULE_76__["skipWhile"]; });

/* harmony import */ var _internal_operators_startWith__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(212);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "startWith", function() { return _internal_operators_startWith__WEBPACK_IMPORTED_MODULE_77__["startWith"]; });

/* harmony import */ var _internal_operators_subscribeOn__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(213);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "subscribeOn", function() { return _internal_operators_subscribeOn__WEBPACK_IMPORTED_MODULE_78__["subscribeOn"]; });

/* harmony import */ var _internal_operators_switchAll__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(215);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "switchAll", function() { return _internal_operators_switchAll__WEBPACK_IMPORTED_MODULE_79__["switchAll"]; });

/* harmony import */ var _internal_operators_switchMap__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(216);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "switchMap", function() { return _internal_operators_switchMap__WEBPACK_IMPORTED_MODULE_80__["switchMap"]; });

/* harmony import */ var _internal_operators_switchMapTo__WEBPACK_IMPORTED_MODULE_81__ = __webpack_require__(217);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "switchMapTo", function() { return _internal_operators_switchMapTo__WEBPACK_IMPORTED_MODULE_81__["switchMapTo"]; });

/* harmony import */ var _internal_operators_take__WEBPACK_IMPORTED_MODULE_82__ = __webpack_require__(164);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "take", function() { return _internal_operators_take__WEBPACK_IMPORTED_MODULE_82__["take"]; });

/* harmony import */ var _internal_operators_takeLast__WEBPACK_IMPORTED_MODULE_83__ = __webpack_require__(177);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "takeLast", function() { return _internal_operators_takeLast__WEBPACK_IMPORTED_MODULE_83__["takeLast"]; });

/* harmony import */ var _internal_operators_takeUntil__WEBPACK_IMPORTED_MODULE_84__ = __webpack_require__(218);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "takeUntil", function() { return _internal_operators_takeUntil__WEBPACK_IMPORTED_MODULE_84__["takeUntil"]; });

/* harmony import */ var _internal_operators_takeWhile__WEBPACK_IMPORTED_MODULE_85__ = __webpack_require__(219);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "takeWhile", function() { return _internal_operators_takeWhile__WEBPACK_IMPORTED_MODULE_85__["takeWhile"]; });

/* harmony import */ var _internal_operators_tap__WEBPACK_IMPORTED_MODULE_86__ = __webpack_require__(163);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tap", function() { return _internal_operators_tap__WEBPACK_IMPORTED_MODULE_86__["tap"]; });

/* harmony import */ var _internal_operators_throttle__WEBPACK_IMPORTED_MODULE_87__ = __webpack_require__(220);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "throttle", function() { return _internal_operators_throttle__WEBPACK_IMPORTED_MODULE_87__["throttle"]; });

/* harmony import */ var _internal_operators_throttleTime__WEBPACK_IMPORTED_MODULE_88__ = __webpack_require__(221);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "throttleTime", function() { return _internal_operators_throttleTime__WEBPACK_IMPORTED_MODULE_88__["throttleTime"]; });

/* harmony import */ var _internal_operators_throwIfEmpty__WEBPACK_IMPORTED_MODULE_89__ = __webpack_require__(162);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "throwIfEmpty", function() { return _internal_operators_throwIfEmpty__WEBPACK_IMPORTED_MODULE_89__["throwIfEmpty"]; });

/* harmony import */ var _internal_operators_timeInterval__WEBPACK_IMPORTED_MODULE_90__ = __webpack_require__(222);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeInterval", function() { return _internal_operators_timeInterval__WEBPACK_IMPORTED_MODULE_90__["timeInterval"]; });

/* harmony import */ var _internal_operators_timeout__WEBPACK_IMPORTED_MODULE_91__ = __webpack_require__(223);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeout", function() { return _internal_operators_timeout__WEBPACK_IMPORTED_MODULE_91__["timeout"]; });

/* harmony import */ var _internal_operators_timeoutWith__WEBPACK_IMPORTED_MODULE_92__ = __webpack_require__(224);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeoutWith", function() { return _internal_operators_timeoutWith__WEBPACK_IMPORTED_MODULE_92__["timeoutWith"]; });

/* harmony import */ var _internal_operators_timestamp__WEBPACK_IMPORTED_MODULE_93__ = __webpack_require__(225);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timestamp", function() { return _internal_operators_timestamp__WEBPACK_IMPORTED_MODULE_93__["timestamp"]; });

/* harmony import */ var _internal_operators_toArray__WEBPACK_IMPORTED_MODULE_94__ = __webpack_require__(226);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toArray", function() { return _internal_operators_toArray__WEBPACK_IMPORTED_MODULE_94__["toArray"]; });

/* harmony import */ var _internal_operators_window__WEBPACK_IMPORTED_MODULE_95__ = __webpack_require__(227);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "window", function() { return _internal_operators_window__WEBPACK_IMPORTED_MODULE_95__["window"]; });

/* harmony import */ var _internal_operators_windowCount__WEBPACK_IMPORTED_MODULE_96__ = __webpack_require__(228);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "windowCount", function() { return _internal_operators_windowCount__WEBPACK_IMPORTED_MODULE_96__["windowCount"]; });

/* harmony import */ var _internal_operators_windowTime__WEBPACK_IMPORTED_MODULE_97__ = __webpack_require__(229);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "windowTime", function() { return _internal_operators_windowTime__WEBPACK_IMPORTED_MODULE_97__["windowTime"]; });

/* harmony import */ var _internal_operators_windowToggle__WEBPACK_IMPORTED_MODULE_98__ = __webpack_require__(230);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "windowToggle", function() { return _internal_operators_windowToggle__WEBPACK_IMPORTED_MODULE_98__["windowToggle"]; });

/* harmony import */ var _internal_operators_windowWhen__WEBPACK_IMPORTED_MODULE_99__ = __webpack_require__(231);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "windowWhen", function() { return _internal_operators_windowWhen__WEBPACK_IMPORTED_MODULE_99__["windowWhen"]; });

/* harmony import */ var _internal_operators_withLatestFrom__WEBPACK_IMPORTED_MODULE_100__ = __webpack_require__(232);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "withLatestFrom", function() { return _internal_operators_withLatestFrom__WEBPACK_IMPORTED_MODULE_100__["withLatestFrom"]; });

/* harmony import */ var _internal_operators_zip__WEBPACK_IMPORTED_MODULE_101__ = __webpack_require__(233);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zip", function() { return _internal_operators_zip__WEBPACK_IMPORTED_MODULE_101__["zip"]; });

/* harmony import */ var _internal_operators_zipAll__WEBPACK_IMPORTED_MODULE_102__ = __webpack_require__(234);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zipAll", function() { return _internal_operators_zipAll__WEBPACK_IMPORTED_MODULE_102__["zipAll"]; });

/** PURE_IMPORTS_START  PURE_IMPORTS_END */








































































































//# sourceMappingURL=index.js.map


/***/ }),
/* 136 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "audit", function() { return audit; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _util_tryCatch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48);
/* harmony import */ var _util_errorObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(49);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(98);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(99);
/** PURE_IMPORTS_START tslib,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */





function audit(durationSelector) {
    return function auditOperatorFunction(source) {
        return source.lift(new AuditOperator(durationSelector));
    };
}
var AuditOperator = /*@__PURE__*/ (function () {
    function AuditOperator(durationSelector) {
        this.durationSelector = durationSelector;
    }
    AuditOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
    };
    return AuditOperator;
}());
var AuditSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](AuditSubscriber, _super);
    function AuditSubscriber(destination, durationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.durationSelector = durationSelector;
        _this.hasValue = false;
        return _this;
    }
    AuditSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
        if (!this.throttled) {
            var duration = Object(_util_tryCatch__WEBPACK_IMPORTED_MODULE_1__["tryCatch"])(this.durationSelector)(value);
            if (duration === _util_errorObject__WEBPACK_IMPORTED_MODULE_2__["errorObject"]) {
                this.destination.error(_util_errorObject__WEBPACK_IMPORTED_MODULE_2__["errorObject"].e);
            }
            else {
                var innerSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__["subscribeToResult"])(this, duration);
                if (!innerSubscription || innerSubscription.closed) {
                    this.clearThrottle();
                }
                else {
                    this.add(this.throttled = innerSubscription);
                }
            }
        }
    };
    AuditSubscriber.prototype.clearThrottle = function () {
        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;
        if (throttled) {
            this.remove(throttled);
            this.throttled = null;
            throttled.unsubscribe();
        }
        if (hasValue) {
            this.value = null;
            this.hasValue = false;
            this.destination.next(value);
        }
    };
    AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
        this.clearThrottle();
    };
    AuditSubscriber.prototype.notifyComplete = function () {
        this.clearThrottle();
    };
    return AuditSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__["OuterSubscriber"]));
//# sourceMappingURL=audit.js.map


/***/ }),
/* 137 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "auditTime", function() { return auditTime; });
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(84);
/* harmony import */ var _audit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(136);
/* harmony import */ var _observable_timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(132);
/** PURE_IMPORTS_START _scheduler_async,_audit,_observable_timer PURE_IMPORTS_END */



function auditTime(duration, scheduler) {
    if (scheduler === void 0) {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_0__["async"];
    }
    return Object(_audit__WEBPACK_IMPORTED_MODULE_1__["audit"])(function () { return Object(_observable_timer__WEBPACK_IMPORTED_MODULE_2__["timer"])(duration, scheduler); });
}
//# sourceMappingURL=auditTime.js.map


/***/ }),
/* 138 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buffer", function() { return buffer; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(99);
/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */



function buffer(closingNotifier) {
    return function bufferOperatorFunction(source) {
        return source.lift(new BufferOperator(closingNotifier));
    };
}
var BufferOperator = /*@__PURE__*/ (function () {
    function BufferOperator(closingNotifier) {
        this.closingNotifier = closingNotifier;
    }
    BufferOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
    };
    return BufferOperator;
}());
var BufferSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](BufferSubscriber, _super);
    function BufferSubscriber(destination, closingNotifier) {
        var _this = _super.call(this, destination) || this;
        _this.buffer = [];
        _this.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(_this, closingNotifier));
        return _this;
    }
    BufferSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var buffer = this.buffer;
        this.buffer = [];
        this.destination.next(buffer);
    };
    return BufferSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"]));
//# sourceMappingURL=buffer.js.map


/***/ }),
/* 139 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bufferCount", function() { return bufferCount; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function bufferCount(bufferSize, startBufferEvery) {
    if (startBufferEvery === void 0) {
        startBufferEvery = null;
    }
    return function bufferCountOperatorFunction(source) {
        return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));
    };
}
var BufferCountOperator = /*@__PURE__*/ (function () {
    function BufferCountOperator(bufferSize, startBufferEvery) {
        this.bufferSize = bufferSize;
        this.startBufferEvery = startBufferEvery;
        if (!startBufferEvery || bufferSize === startBufferEvery) {
            this.subscriberClass = BufferCountSubscriber;
        }
        else {
            this.subscriberClass = BufferSkipCountSubscriber;
        }
    }
    BufferCountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));
    };
    return BufferCountOperator;
}());
var BufferCountSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](BufferCountSubscriber, _super);
    function BufferCountSubscriber(destination, bufferSize) {
        var _this = _super.call(this, destination) || this;
        _this.bufferSize = bufferSize;
        _this.buffer = [];
        return _this;
    }
    BufferCountSubscriber.prototype._next = function (value) {
        var buffer = this.buffer;
        buffer.push(value);
        if (buffer.length == this.bufferSize) {
            this.destination.next(buffer);
            this.buffer = [];
        }
    };
    BufferCountSubscriber.prototype._complete = function () {
        var buffer = this.buffer;
        if (buffer.length > 0) {
            this.destination.next(buffer);
        }
        _super.prototype._complete.call(this);
    };
    return BufferCountSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
var BufferSkipCountSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](BufferSkipCountSubscriber, _super);
    function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {
        var _this = _super.call(this, destination) || this;
        _this.bufferSize = bufferSize;
        _this.startBufferEvery = startBufferEvery;
        _this.buffers = [];
        _this.count = 0;
        return _this;
    }
    BufferSkipCountSubscriber.prototype._next = function (value) {
        var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers, count = _a.count;
        this.count++;
        if (count % startBufferEvery === 0) {
            buffers.push([]);
        }
        for (var i = buffers.length; i--;) {
            var buffer = buffers[i];
            buffer.push(value);
            if (buffer.length === bufferSize) {
                buffers.splice(i, 1);
                this.destination.next(buffer);
            }
        }
    };
    BufferSkipCountSubscriber.prototype._complete = function () {
        var _a = this, buffers = _a.buffers, destination = _a.destination;
        while (buffers.length > 0) {
            var buffer = buffers.shift();
            if (buffer.length > 0) {
                destination.next(buffer);
            }
        }
        _super.prototype._complete.call(this);
    };
    return BufferSkipCountSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=bufferCount.js.map


/***/ }),
/* 140 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bufferTime", function() { return bufferTime; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(84);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(39);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(74);
/** PURE_IMPORTS_START tslib,_scheduler_async,_Subscriber,_util_isScheduler PURE_IMPORTS_END */




function bufferTime(bufferTimeSpan) {
    var length = arguments.length;
    var scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__["async"];
    if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_3__["isScheduler"])(arguments[arguments.length - 1])) {
        scheduler = arguments[arguments.length - 1];
        length--;
    }
    var bufferCreationInterval = null;
    if (length >= 2) {
        bufferCreationInterval = arguments[1];
    }
    var maxBufferSize = Number.POSITIVE_INFINITY;
    if (length >= 3) {
        maxBufferSize = arguments[2];
    }
    return function bufferTimeOperatorFunction(source) {
        return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));
    };
}
var BufferTimeOperator = /*@__PURE__*/ (function () {
    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        this.bufferTimeSpan = bufferTimeSpan;
        this.bufferCreationInterval = bufferCreationInterval;
        this.maxBufferSize = maxBufferSize;
        this.scheduler = scheduler;
    }
    BufferTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
    };
    return BufferTimeOperator;
}());
var Context = /*@__PURE__*/ (function () {
    function Context() {
        this.buffer = [];
    }
    return Context;
}());
var BufferTimeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](BufferTimeSubscriber, _super);
    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.bufferTimeSpan = bufferTimeSpan;
        _this.bufferCreationInterval = bufferCreationInterval;
        _this.maxBufferSize = maxBufferSize;
        _this.scheduler = scheduler;
        _this.contexts = [];
        var context = _this.openContext();
        _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
        if (_this.timespanOnly) {
            var timeSpanOnlyState = { subscriber: _this, context: context, bufferTimeSpan: bufferTimeSpan };
            _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
        else {
            var closeState = { subscriber: _this, context: context };
            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: _this, scheduler: scheduler };
            _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
            _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
        }
        return _this;
    }
    BufferTimeSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        var len = contexts.length;
        var filledBufferContext;
        for (var i = 0; i < len; i++) {
            var context_1 = contexts[i];
            var buffer = context_1.buffer;
            buffer.push(value);
            if (buffer.length == this.maxBufferSize) {
                filledBufferContext = context_1;
            }
        }
        if (filledBufferContext) {
            this.onBufferFull(filledBufferContext);
        }
    };
    BufferTimeSubscriber.prototype._error = function (err) {
        this.contexts.length = 0;
        _super.prototype._error.call(this, err);
    };
    BufferTimeSubscriber.prototype._complete = function () {
        var _a = this, contexts = _a.contexts, destination = _a.destination;
        while (contexts.length > 0) {
            var context_2 = contexts.shift();
            destination.next(context_2.buffer);
        }
        _super.prototype._complete.call(this);
    };
    BufferTimeSubscriber.prototype._unsubscribe = function () {
        this.contexts = null;
    };
    BufferTimeSubscriber.prototype.onBufferFull = function (context) {
        this.closeContext(context);
        var closeAction = context.closeAction;
        closeAction.unsubscribe();
        this.remove(closeAction);
        if (!this.closed && this.timespanOnly) {
            context = this.openContext();
            var bufferTimeSpan = this.bufferTimeSpan;
            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };
            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
    };
    BufferTimeSubscriber.prototype.openContext = function () {
        var context = new Context();
        this.contexts.push(context);
        return context;
    };
    BufferTimeSubscriber.prototype.closeContext = function (context) {
        this.destination.next(context.buffer);
        var contexts = this.contexts;
        var spliceIndex = contexts ? contexts.indexOf(context) : -1;
        if (spliceIndex >= 0) {
            contexts.splice(contexts.indexOf(context), 1);
        }
    };
    return BufferTimeSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_2__["Subscriber"]));
function dispatchBufferTimeSpanOnly(state) {
    var subscriber = state.subscriber;
    var prevContext = state.context;
    if (prevContext) {
        subscriber.closeContext(prevContext);
    }
    if (!subscriber.closed) {
        state.context = subscriber.openContext();
        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
    }
}
function dispatchBufferCreation(state) {
    var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;
    var context = subscriber.openContext();
    var action = this;
    if (!subscriber.closed) {
        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));
        action.schedule(state, bufferCreationInterval);
    }
}
function dispatchBufferClose(arg) {
    var subscriber = arg.subscriber, context = arg.context;
    subscriber.closeContext(context);
}
//# sourceMappingURL=bufferTime.js.map


/***/ }),
/* 141 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bufferToggle", function() { return bufferToggle; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(99);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(98);
/** PURE_IMPORTS_START tslib,_Subscription,_util_subscribeToResult,_OuterSubscriber PURE_IMPORTS_END */




function bufferToggle(openings, closingSelector) {
    return function bufferToggleOperatorFunction(source) {
        return source.lift(new BufferToggleOperator(openings, closingSelector));
    };
}
var BufferToggleOperator = /*@__PURE__*/ (function () {
    function BufferToggleOperator(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
    }
    BufferToggleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
    };
    return BufferToggleOperator;
}());
var BufferToggleSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](BufferToggleSubscriber, _super);
    function BufferToggleSubscriber(destination, openings, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.openings = openings;
        _this.closingSelector = closingSelector;
        _this.contexts = [];
        _this.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(_this, openings));
        return _this;
    }
    BufferToggleSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        var len = contexts.length;
        for (var i = 0; i < len; i++) {
            contexts[i].buffer.push(value);
        }
    };
    BufferToggleSubscriber.prototype._error = function (err) {
        var contexts = this.contexts;
        while (contexts.length > 0) {
            var context_1 = contexts.shift();
            context_1.subscription.unsubscribe();
            context_1.buffer = null;
            context_1.subscription = null;
        }
        this.contexts = null;
        _super.prototype._error.call(this, err);
    };
    BufferToggleSubscriber.prototype._complete = function () {
        var contexts = this.contexts;
        while (contexts.length > 0) {
            var context_2 = contexts.shift();
            this.destination.next(context_2.buffer);
            context_2.subscription.unsubscribe();
            context_2.buffer = null;
            context_2.subscription = null;
        }
        this.contexts = null;
        _super.prototype._complete.call(this);
    };
    BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
    };
    BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {
        this.closeBuffer(innerSub.context);
    };
    BufferToggleSubscriber.prototype.openBuffer = function (value) {
        try {
            var closingSelector = this.closingSelector;
            var closingNotifier = closingSelector.call(this, value);
            if (closingNotifier) {
                this.trySubscribe(closingNotifier);
            }
        }
        catch (err) {
            this._error(err);
        }
    };
    BufferToggleSubscriber.prototype.closeBuffer = function (context) {
        var contexts = this.contexts;
        if (contexts && context) {
            var buffer = context.buffer, subscription = context.subscription;
            this.destination.next(buffer);
            contexts.splice(contexts.indexOf(context), 1);
            this.remove(subscription);
            subscription.unsubscribe();
        }
    };
    BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {
        var contexts = this.contexts;
        var buffer = [];
        var subscription = new _Subscription__WEBPACK_IMPORTED_MODULE_1__["Subscription"]();
        var context = { buffer: buffer, subscription: subscription };
        contexts.push(context);
        var innerSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(this, closingNotifier, context);
        if (!innerSubscription || innerSubscription.closed) {
            this.closeBuffer(context);
        }
        else {
            innerSubscription.context = context;
            this.add(innerSubscription);
            subscription.add(innerSubscription);
        }
    };
    return BufferToggleSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__["OuterSubscriber"]));
//# sourceMappingURL=bufferToggle.js.map


/***/ }),
/* 142 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bufferWhen", function() { return bufferWhen; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45);
/* harmony import */ var _util_tryCatch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(48);
/* harmony import */ var _util_errorObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(49);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(98);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(99);
/** PURE_IMPORTS_START tslib,_Subscription,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */






function bufferWhen(closingSelector) {
    return function (source) {
        return source.lift(new BufferWhenOperator(closingSelector));
    };
}
var BufferWhenOperator = /*@__PURE__*/ (function () {
    function BufferWhenOperator(closingSelector) {
        this.closingSelector = closingSelector;
    }
    BufferWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
    };
    return BufferWhenOperator;
}());
var BufferWhenSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](BufferWhenSubscriber, _super);
    function BufferWhenSubscriber(destination, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.closingSelector = closingSelector;
        _this.subscribing = false;
        _this.openBuffer();
        return _this;
    }
    BufferWhenSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferWhenSubscriber.prototype._complete = function () {
        var buffer = this.buffer;
        if (buffer) {
            this.destination.next(buffer);
        }
        _super.prototype._complete.call(this);
    };
    BufferWhenSubscriber.prototype._unsubscribe = function () {
        this.buffer = null;
        this.subscribing = false;
    };
    BufferWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openBuffer();
    };
    BufferWhenSubscriber.prototype.notifyComplete = function () {
        if (this.subscribing) {
            this.complete();
        }
        else {
            this.openBuffer();
        }
    };
    BufferWhenSubscriber.prototype.openBuffer = function () {
        var closingSubscription = this.closingSubscription;
        if (closingSubscription) {
            this.remove(closingSubscription);
            closingSubscription.unsubscribe();
        }
        var buffer = this.buffer;
        if (this.buffer) {
            this.destination.next(buffer);
        }
        this.buffer = [];
        var closingNotifier = Object(_util_tryCatch__WEBPACK_IMPORTED_MODULE_2__["tryCatch"])(this.closingSelector)();
        if (closingNotifier === _util_errorObject__WEBPACK_IMPORTED_MODULE_3__["errorObject"]) {
            this.error(_util_errorObject__WEBPACK_IMPORTED_MODULE_3__["errorObject"].e);
        }
        else {
            closingSubscription = new _Subscription__WEBPACK_IMPORTED_MODULE_1__["Subscription"]();
            this.closingSubscription = closingSubscription;
            this.add(closingSubscription);
            this.subscribing = true;
            closingSubscription.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_5__["subscribeToResult"])(this, closingNotifier));
            this.subscribing = false;
        }
    };
    return BufferWhenSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_4__["OuterSubscriber"]));
//# sourceMappingURL=bufferWhen.js.map


/***/ }),
/* 143 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "catchError", function() { return catchError; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(99);
/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */



function catchError(selector) {
    return function catchErrorOperatorFunction(source) {
        var operator = new CatchOperator(selector);
        var caught = source.lift(operator);
        return (operator.caught = caught);
    };
}
var CatchOperator = /*@__PURE__*/ (function () {
    function CatchOperator(selector) {
        this.selector = selector;
    }
    CatchOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
    };
    return CatchOperator;
}());
var CatchSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](CatchSubscriber, _super);
    function CatchSubscriber(destination, selector, caught) {
        var _this = _super.call(this, destination) || this;
        _this.selector = selector;
        _this.caught = caught;
        return _this;
    }
    CatchSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var result = void 0;
            try {
                result = this.selector(err, this.caught);
            }
            catch (err2) {
                _super.prototype.error.call(this, err2);
                return;
            }
            this._unsubscribeAndRecycle();
            this.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(this, result));
        }
    };
    return CatchSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"]));
//# sourceMappingURL=catchError.js.map


/***/ }),
/* 144 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "combineAll", function() { return combineAll; });
/* harmony import */ var _observable_combineLatest__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97);
/** PURE_IMPORTS_START _observable_combineLatest PURE_IMPORTS_END */

function combineAll(project) {
    return function (source) { return source.lift(new _observable_combineLatest__WEBPACK_IMPORTED_MODULE_0__["CombineLatestOperator"](project)); };
}
//# sourceMappingURL=combineAll.js.map


/***/ }),
/* 145 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "combineLatest", function() { return combineLatest; });
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46);
/* harmony import */ var _observable_combineLatest__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(97);
/* harmony import */ var _observable_from__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(109);
/** PURE_IMPORTS_START _util_isArray,_observable_combineLatest,_observable_from PURE_IMPORTS_END */



var none = {};
function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var project = null;
    if (typeof observables[observables.length - 1] === 'function') {
        project = observables.pop();
    }
    if (observables.length === 1 && Object(_util_isArray__WEBPACK_IMPORTED_MODULE_0__["isArray"])(observables[0])) {
        observables = observables[0].slice();
    }
    return function (source) { return source.lift.call(Object(_observable_from__WEBPACK_IMPORTED_MODULE_2__["from"])([source].concat(observables)), new _observable_combineLatest__WEBPACK_IMPORTED_MODULE_1__["CombineLatestOperator"](project)); };
}
//# sourceMappingURL=combineLatest.js.map


/***/ }),
/* 146 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concat", function() { return concat; });
/* harmony import */ var _observable_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(108);
/** PURE_IMPORTS_START _observable_concat PURE_IMPORTS_END */

function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return function (source) { return source.lift.call(_observable_concat__WEBPACK_IMPORTED_MODULE_0__["concat"].apply(void 0, [source].concat(observables))); };
}
//# sourceMappingURL=concat.js.map


/***/ }),
/* 147 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concatMap", function() { return concatMap; });
/* harmony import */ var _mergeMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(117);
/** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */

function concatMap(project, resultSelector) {
    return Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__["mergeMap"])(project, resultSelector, 1);
}
//# sourceMappingURL=concatMap.js.map


/***/ }),
/* 148 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concatMapTo", function() { return concatMapTo; });
/* harmony import */ var _concatMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(147);
/** PURE_IMPORTS_START _concatMap PURE_IMPORTS_END */

function concatMapTo(innerObservable, resultSelector) {
    return Object(_concatMap__WEBPACK_IMPORTED_MODULE_0__["concatMap"])(function () { return innerObservable; }, resultSelector);
}
//# sourceMappingURL=concatMapTo.js.map


/***/ }),
/* 149 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "count", function() { return count; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function count(predicate) {
    return function (source) { return source.lift(new CountOperator(predicate, source)); };
}
var CountOperator = /*@__PURE__*/ (function () {
    function CountOperator(predicate, source) {
        this.predicate = predicate;
        this.source = source;
    }
    CountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
    };
    return CountOperator;
}());
var CountSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](CountSubscriber, _super);
    function CountSubscriber(destination, predicate, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.count = 0;
        _this.index = 0;
        return _this;
    }
    CountSubscriber.prototype._next = function (value) {
        if (this.predicate) {
            this._tryPredicate(value);
        }
        else {
            this.count++;
        }
    };
    CountSubscriber.prototype._tryPredicate = function (value) {
        var result;
        try {
            result = this.predicate(value, this.index++, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.count++;
        }
    };
    CountSubscriber.prototype._complete = function () {
        this.destination.next(this.count);
        this.destination.complete();
    };
    return CountSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=count.js.map


/***/ }),
/* 150 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "debounce", function() { return debounce; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(99);
/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */



function debounce(durationSelector) {
    return function (source) { return source.lift(new DebounceOperator(durationSelector)); };
}
var DebounceOperator = /*@__PURE__*/ (function () {
    function DebounceOperator(durationSelector) {
        this.durationSelector = durationSelector;
    }
    DebounceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
    };
    return DebounceOperator;
}());
var DebounceSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](DebounceSubscriber, _super);
    function DebounceSubscriber(destination, durationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.durationSelector = durationSelector;
        _this.hasValue = false;
        _this.durationSubscription = null;
        return _this;
    }
    DebounceSubscriber.prototype._next = function (value) {
        try {
            var result = this.durationSelector.call(this, value);
            if (result) {
                this._tryNext(value, result);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    DebounceSubscriber.prototype._complete = function () {
        this.emitValue();
        this.destination.complete();
    };
    DebounceSubscriber.prototype._tryNext = function (value, duration) {
        var subscription = this.durationSubscription;
        this.value = value;
        this.hasValue = true;
        if (subscription) {
            subscription.unsubscribe();
            this.remove(subscription);
        }
        subscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(this, duration);
        if (subscription && !subscription.closed) {
            this.add(this.durationSubscription = subscription);
        }
    };
    DebounceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.emitValue();
    };
    DebounceSubscriber.prototype.notifyComplete = function () {
        this.emitValue();
    };
    DebounceSubscriber.prototype.emitValue = function () {
        if (this.hasValue) {
            var value = this.value;
            var subscription = this.durationSubscription;
            if (subscription) {
                this.durationSubscription = null;
                subscription.unsubscribe();
                this.remove(subscription);
            }
            this.value = null;
            this.hasValue = false;
            _super.prototype._next.call(this, value);
        }
    };
    return DebounceSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"]));
//# sourceMappingURL=debounce.js.map


/***/ }),
/* 151 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "debounceTime", function() { return debounceTime; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(84);
/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */



function debounceTime(dueTime, scheduler) {
    if (scheduler === void 0) {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_2__["async"];
    }
    return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };
}
var DebounceTimeOperator = /*@__PURE__*/ (function () {
    function DebounceTimeOperator(dueTime, scheduler) {
        this.dueTime = dueTime;
        this.scheduler = scheduler;
    }
    DebounceTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
    };
    return DebounceTimeOperator;
}());
var DebounceTimeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](DebounceTimeSubscriber, _super);
    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.dueTime = dueTime;
        _this.scheduler = scheduler;
        _this.debouncedSubscription = null;
        _this.lastValue = null;
        _this.hasValue = false;
        return _this;
    }
    DebounceTimeSubscriber.prototype._next = function (value) {
        this.clearDebounce();
        this.lastValue = value;
        this.hasValue = true;
        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
    };
    DebounceTimeSubscriber.prototype._complete = function () {
        this.debouncedNext();
        this.destination.complete();
    };
    DebounceTimeSubscriber.prototype.debouncedNext = function () {
        this.clearDebounce();
        if (this.hasValue) {
            var lastValue = this.lastValue;
            this.lastValue = null;
            this.hasValue = false;
            this.destination.next(lastValue);
        }
    };
    DebounceTimeSubscriber.prototype.clearDebounce = function () {
        var debouncedSubscription = this.debouncedSubscription;
        if (debouncedSubscription !== null) {
            this.remove(debouncedSubscription);
            debouncedSubscription.unsubscribe();
            this.debouncedSubscription = null;
        }
    };
    return DebounceTimeSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
function dispatchNext(subscriber) {
    subscriber.debouncedNext();
}
//# sourceMappingURL=debounceTime.js.map


/***/ }),
/* 152 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultIfEmpty", function() { return defaultIfEmpty; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function defaultIfEmpty(defaultValue) {
    if (defaultValue === void 0) {
        defaultValue = null;
    }
    return function (source) { return source.lift(new DefaultIfEmptyOperator(defaultValue)); };
}
var DefaultIfEmptyOperator = /*@__PURE__*/ (function () {
    function DefaultIfEmptyOperator(defaultValue) {
        this.defaultValue = defaultValue;
    }
    DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
    };
    return DefaultIfEmptyOperator;
}());
var DefaultIfEmptySubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](DefaultIfEmptySubscriber, _super);
    function DefaultIfEmptySubscriber(destination, defaultValue) {
        var _this = _super.call(this, destination) || this;
        _this.defaultValue = defaultValue;
        _this.isEmpty = true;
        return _this;
    }
    DefaultIfEmptySubscriber.prototype._next = function (value) {
        this.isEmpty = false;
        this.destination.next(value);
    };
    DefaultIfEmptySubscriber.prototype._complete = function () {
        if (this.isEmpty) {
            this.destination.next(this.defaultValue);
        }
        this.destination.complete();
    };
    return DefaultIfEmptySubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=defaultIfEmpty.js.map


/***/ }),
/* 153 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "delay", function() { return delay; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(84);
/* harmony import */ var _util_isDate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(154);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(39);
/* harmony import */ var _Notification__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(71);
/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_Subscriber,_Notification PURE_IMPORTS_END */





function delay(delay, scheduler) {
    if (scheduler === void 0) {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__["async"];
    }
    var absoluteDelay = Object(_util_isDate__WEBPACK_IMPORTED_MODULE_2__["isDate"])(delay);
    var delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);
    return function (source) { return source.lift(new DelayOperator(delayFor, scheduler)); };
}
var DelayOperator = /*@__PURE__*/ (function () {
    function DelayOperator(delay, scheduler) {
        this.delay = delay;
        this.scheduler = scheduler;
    }
    DelayOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
    };
    return DelayOperator;
}());
var DelaySubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](DelaySubscriber, _super);
    function DelaySubscriber(destination, delay, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.delay = delay;
        _this.scheduler = scheduler;
        _this.queue = [];
        _this.active = false;
        _this.errored = false;
        return _this;
    }
    DelaySubscriber.dispatch = function (state) {
        var source = state.source;
        var queue = source.queue;
        var scheduler = state.scheduler;
        var destination = state.destination;
        while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {
            queue.shift().notification.observe(destination);
        }
        if (queue.length > 0) {
            var delay_1 = Math.max(0, queue[0].time - scheduler.now());
            this.schedule(state, delay_1);
        }
        else {
            this.unsubscribe();
            source.active = false;
        }
    };
    DelaySubscriber.prototype._schedule = function (scheduler) {
        this.active = true;
        this.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
            source: this, destination: this.destination, scheduler: scheduler
        }));
    };
    DelaySubscriber.prototype.scheduleNotification = function (notification) {
        if (this.errored === true) {
            return;
        }
        var scheduler = this.scheduler;
        var message = new DelayMessage(scheduler.now() + this.delay, notification);
        this.queue.push(message);
        if (this.active === false) {
            this._schedule(scheduler);
        }
    };
    DelaySubscriber.prototype._next = function (value) {
        this.scheduleNotification(_Notification__WEBPACK_IMPORTED_MODULE_4__["Notification"].createNext(value));
    };
    DelaySubscriber.prototype._error = function (err) {
        this.errored = true;
        this.queue = [];
        this.destination.error(err);
    };
    DelaySubscriber.prototype._complete = function () {
        this.scheduleNotification(_Notification__WEBPACK_IMPORTED_MODULE_4__["Notification"].createComplete());
    };
    return DelaySubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_3__["Subscriber"]));
var DelayMessage = /*@__PURE__*/ (function () {
    function DelayMessage(time, notification) {
        this.time = time;
        this.notification = notification;
    }
    return DelayMessage;
}());
//# sourceMappingURL=delay.js.map


/***/ }),
/* 154 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDate", function() { return isDate; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isDate(value) {
    return value instanceof Date && !isNaN(+value);
}
//# sourceMappingURL=isDate.js.map


/***/ }),
/* 155 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "delayWhen", function() { return delayWhen; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(98);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(99);
/** PURE_IMPORTS_START tslib,_Subscriber,_Observable,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */





function delayWhen(delayDurationSelector, subscriptionDelay) {
    if (subscriptionDelay) {
        return function (source) {
            return new SubscriptionDelayObservable(source, subscriptionDelay)
                .lift(new DelayWhenOperator(delayDurationSelector));
        };
    }
    return function (source) { return source.lift(new DelayWhenOperator(delayDurationSelector)); };
}
var DelayWhenOperator = /*@__PURE__*/ (function () {
    function DelayWhenOperator(delayDurationSelector) {
        this.delayDurationSelector = delayDurationSelector;
    }
    DelayWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
    };
    return DelayWhenOperator;
}());
var DelayWhenSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](DelayWhenSubscriber, _super);
    function DelayWhenSubscriber(destination, delayDurationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.delayDurationSelector = delayDurationSelector;
        _this.completed = false;
        _this.delayNotifierSubscriptions = [];
        return _this;
    }
    DelayWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(outerValue);
        this.removeSubscription(innerSub);
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {
        var value = this.removeSubscription(innerSub);
        if (value) {
            this.destination.next(value);
        }
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype._next = function (value) {
        try {
            var delayNotifier = this.delayDurationSelector(value);
            if (delayNotifier) {
                this.tryDelay(delayNotifier, value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    DelayWhenSubscriber.prototype._complete = function () {
        this.completed = true;
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {
        subscription.unsubscribe();
        var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
        if (subscriptionIdx !== -1) {
            this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
        }
        return subscription.outerValue;
    };
    DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {
        var notifierSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__["subscribeToResult"])(this, delayNotifier, value);
        if (notifierSubscription && !notifierSubscription.closed) {
            this.add(notifierSubscription);
            this.delayNotifierSubscriptions.push(notifierSubscription);
        }
    };
    DelayWhenSubscriber.prototype.tryComplete = function () {
        if (this.completed && this.delayNotifierSubscriptions.length === 0) {
            this.destination.complete();
        }
    };
    return DelayWhenSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__["OuterSubscriber"]));
var SubscriptionDelayObservable = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](SubscriptionDelayObservable, _super);
    function SubscriptionDelayObservable(source, subscriptionDelay) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subscriptionDelay = subscriptionDelay;
        return _this;
    }
    SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {
        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
    };
    return SubscriptionDelayObservable;
}(_Observable__WEBPACK_IMPORTED_MODULE_2__["Observable"]));
var SubscriptionDelaySubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](SubscriptionDelaySubscriber, _super);
    function SubscriptionDelaySubscriber(parent, source) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.source = source;
        _this.sourceSubscribed = false;
        return _this;
    }
    SubscriptionDelaySubscriber.prototype._next = function (unused) {
        this.subscribeToSource();
    };
    SubscriptionDelaySubscriber.prototype._error = function (err) {
        this.unsubscribe();
        this.parent.error(err);
    };
    SubscriptionDelaySubscriber.prototype._complete = function () {
        this.subscribeToSource();
    };
    SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {
        if (!this.sourceSubscribed) {
            this.sourceSubscribed = true;
            this.unsubscribe();
            this.source.subscribe(this.parent);
        }
    };
    return SubscriptionDelaySubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=delayWhen.js.map


/***/ }),
/* 156 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dematerialize", function() { return dematerialize; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function dematerialize() {
    return function dematerializeOperatorFunction(source) {
        return source.lift(new DeMaterializeOperator());
    };
}
var DeMaterializeOperator = /*@__PURE__*/ (function () {
    function DeMaterializeOperator() {
    }
    DeMaterializeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DeMaterializeSubscriber(subscriber));
    };
    return DeMaterializeOperator;
}());
var DeMaterializeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](DeMaterializeSubscriber, _super);
    function DeMaterializeSubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    DeMaterializeSubscriber.prototype._next = function (value) {
        value.observe(this.destination);
    };
    return DeMaterializeSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=dematerialize.js.map


/***/ }),
/* 157 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distinct", function() { return distinct; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DistinctSubscriber", function() { return DistinctSubscriber; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(99);
/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */



function distinct(keySelector, flushes) {
    return function (source) { return source.lift(new DistinctOperator(keySelector, flushes)); };
}
var DistinctOperator = /*@__PURE__*/ (function () {
    function DistinctOperator(keySelector, flushes) {
        this.keySelector = keySelector;
        this.flushes = flushes;
    }
    DistinctOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
    };
    return DistinctOperator;
}());
var DistinctSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](DistinctSubscriber, _super);
    function DistinctSubscriber(destination, keySelector, flushes) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.values = new Set();
        if (flushes) {
            _this.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(_this, flushes));
        }
        return _this;
    }
    DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values.clear();
    };
    DistinctSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    DistinctSubscriber.prototype._next = function (value) {
        if (this.keySelector) {
            this._useKeySelector(value);
        }
        else {
            this._finalizeNext(value, value);
        }
    };
    DistinctSubscriber.prototype._useKeySelector = function (value) {
        var key;
        var destination = this.destination;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this._finalizeNext(key, value);
    };
    DistinctSubscriber.prototype._finalizeNext = function (key, value) {
        var values = this.values;
        if (!values.has(key)) {
            values.add(key);
            this.destination.next(value);
        }
    };
    return DistinctSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"]));

//# sourceMappingURL=distinct.js.map


/***/ }),
/* 158 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distinctUntilChanged", function() { return distinctUntilChanged; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/* harmony import */ var _util_tryCatch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(48);
/* harmony import */ var _util_errorObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(49);
/** PURE_IMPORTS_START tslib,_Subscriber,_util_tryCatch,_util_errorObject PURE_IMPORTS_END */




function distinctUntilChanged(compare, keySelector) {
    return function (source) { return source.lift(new DistinctUntilChangedOperator(compare, keySelector)); };
}
var DistinctUntilChangedOperator = /*@__PURE__*/ (function () {
    function DistinctUntilChangedOperator(compare, keySelector) {
        this.compare = compare;
        this.keySelector = keySelector;
    }
    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
    };
    return DistinctUntilChangedOperator;
}());
var DistinctUntilChangedSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](DistinctUntilChangedSubscriber, _super);
    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.hasKey = false;
        if (typeof compare === 'function') {
            _this.compare = compare;
        }
        return _this;
    }
    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
        return x === y;
    };
    DistinctUntilChangedSubscriber.prototype._next = function (value) {
        var keySelector = this.keySelector;
        var key = value;
        if (keySelector) {
            key = Object(_util_tryCatch__WEBPACK_IMPORTED_MODULE_2__["tryCatch"])(this.keySelector)(value);
            if (key === _util_errorObject__WEBPACK_IMPORTED_MODULE_3__["errorObject"]) {
                return this.destination.error(_util_errorObject__WEBPACK_IMPORTED_MODULE_3__["errorObject"].e);
            }
        }
        var result = false;
        if (this.hasKey) {
            result = Object(_util_tryCatch__WEBPACK_IMPORTED_MODULE_2__["tryCatch"])(this.compare)(this.key, key);
            if (result === _util_errorObject__WEBPACK_IMPORTED_MODULE_3__["errorObject"]) {
                return this.destination.error(_util_errorObject__WEBPACK_IMPORTED_MODULE_3__["errorObject"].e);
            }
        }
        else {
            this.hasKey = true;
        }
        if (Boolean(result) === false) {
            this.key = key;
            this.destination.next(value);
        }
    };
    return DistinctUntilChangedSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=distinctUntilChanged.js.map


/***/ }),
/* 159 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distinctUntilKeyChanged", function() { return distinctUntilKeyChanged; });
/* harmony import */ var _distinctUntilChanged__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(158);
/** PURE_IMPORTS_START _distinctUntilChanged PURE_IMPORTS_END */

function distinctUntilKeyChanged(key, compare) {
    return Object(_distinctUntilChanged__WEBPACK_IMPORTED_MODULE_0__["distinctUntilChanged"])(function (x, y) { return compare ? compare(x[key], y[key]) : x[key] === y[key]; });
}
//# sourceMappingURL=distinctUntilKeyChanged.js.map


/***/ }),
/* 160 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elementAt", function() { return elementAt; });
/* harmony import */ var _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(91);
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(161);
/* harmony import */ var _throwIfEmpty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(162);
/* harmony import */ var _defaultIfEmpty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(152);
/* harmony import */ var _take__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(164);
/** PURE_IMPORTS_START _util_ArgumentOutOfRangeError,_filter,_throwIfEmpty,_defaultIfEmpty,_take PURE_IMPORTS_END */





function elementAt(index, defaultValue) {
    if (index < 0) {
        throw new _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_0__["ArgumentOutOfRangeError"]();
    }
    var hasDefaultValue = arguments.length >= 2;
    return function (source) {
        return source.pipe(Object(_filter__WEBPACK_IMPORTED_MODULE_1__["filter"])(function (v, i) { return i === index; }), Object(_take__WEBPACK_IMPORTED_MODULE_4__["take"])(1), hasDefaultValue
            ? Object(_defaultIfEmpty__WEBPACK_IMPORTED_MODULE_3__["defaultIfEmpty"])(defaultValue)
            : Object(_throwIfEmpty__WEBPACK_IMPORTED_MODULE_2__["throwIfEmpty"])(function () { return new _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_0__["ArgumentOutOfRangeError"](); }));
    };
}
//# sourceMappingURL=elementAt.js.map


/***/ }),
/* 161 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "filter", function() { return filter; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function filter(predicate, thisArg) {
    return function filterOperatorFunction(source) {
        return source.lift(new FilterOperator(predicate, thisArg));
    };
}
var FilterOperator = /*@__PURE__*/ (function () {
    function FilterOperator(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
    }
    FilterOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator;
}());
var FilterSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](FilterSubscriber, _super);
    function FilterSubscriber(destination, predicate, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.count = 0;
        return _this;
    }
    FilterSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.predicate.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.destination.next(value);
        }
    };
    return FilterSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=filter.js.map


/***/ }),
/* 162 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "throwIfEmpty", function() { return throwIfEmpty; });
/* harmony import */ var _tap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(163);
/* harmony import */ var _util_EmptyError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(92);
/** PURE_IMPORTS_START _tap,_util_EmptyError PURE_IMPORTS_END */


var throwIfEmpty = function (errorFactory) {
    if (errorFactory === void 0) {
        errorFactory = defaultErrorFactory;
    }
    return Object(_tap__WEBPACK_IMPORTED_MODULE_0__["tap"])({
        hasValue: false,
        next: function () { this.hasValue = true; },
        complete: function () {
            if (!this.hasValue) {
                throw errorFactory();
            }
        }
    });
};
function defaultErrorFactory() {
    return new _util_EmptyError__WEBPACK_IMPORTED_MODULE_1__["EmptyError"]();
}
//# sourceMappingURL=throwIfEmpty.js.map


/***/ }),
/* 163 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tap", function() { return tap; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/* harmony import */ var _util_noop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(54);
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(41);
/** PURE_IMPORTS_START tslib,_Subscriber,_util_noop,_util_isFunction PURE_IMPORTS_END */




function tap(nextOrObserver, error, complete) {
    return function tapOperatorFunction(source) {
        return source.lift(new DoOperator(nextOrObserver, error, complete));
    };
}
var DoOperator = /*@__PURE__*/ (function () {
    function DoOperator(nextOrObserver, error, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
    }
    DoOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
    };
    return DoOperator;
}());
var TapSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](TapSubscriber, _super);
    function TapSubscriber(destination, observerOrNext, error, complete) {
        var _this = _super.call(this, destination) || this;
        _this._tapNext = _util_noop__WEBPACK_IMPORTED_MODULE_2__["noop"];
        _this._tapError = _util_noop__WEBPACK_IMPORTED_MODULE_2__["noop"];
        _this._tapComplete = _util_noop__WEBPACK_IMPORTED_MODULE_2__["noop"];
        _this._tapError = error || _util_noop__WEBPACK_IMPORTED_MODULE_2__["noop"];
        _this._tapComplete = complete || _util_noop__WEBPACK_IMPORTED_MODULE_2__["noop"];
        if (Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_3__["isFunction"])(observerOrNext)) {
            _this._context = _this;
            _this._tapNext = observerOrNext;
        }
        else if (observerOrNext) {
            _this._context = observerOrNext;
            _this._tapNext = observerOrNext.next || _util_noop__WEBPACK_IMPORTED_MODULE_2__["noop"];
            _this._tapError = observerOrNext.error || _util_noop__WEBPACK_IMPORTED_MODULE_2__["noop"];
            _this._tapComplete = observerOrNext.complete || _util_noop__WEBPACK_IMPORTED_MODULE_2__["noop"];
        }
        return _this;
    }
    TapSubscriber.prototype._next = function (value) {
        try {
            this._tapNext.call(this._context, value);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(value);
    };
    TapSubscriber.prototype._error = function (err) {
        try {
            this._tapError.call(this._context, err);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.error(err);
    };
    TapSubscriber.prototype._complete = function () {
        try {
            this._tapComplete.call(this._context);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        return this.destination.complete();
    };
    return TapSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=tap.js.map


/***/ }),
/* 164 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "take", function() { return take; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/* harmony import */ var _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(91);
/* harmony import */ var _observable_empty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(72);
/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */




function take(count) {
    return function (source) {
        if (count === 0) {
            return Object(_observable_empty__WEBPACK_IMPORTED_MODULE_3__["empty"])();
        }
        else {
            return source.lift(new TakeOperator(count));
        }
    };
}
var TakeOperator = /*@__PURE__*/ (function () {
    function TakeOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_2__["ArgumentOutOfRangeError"];
        }
    }
    TakeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeSubscriber(subscriber, this.total));
    };
    return TakeOperator;
}());
var TakeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](TakeSubscriber, _super);
    function TakeSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
    }
    TakeSubscriber.prototype._next = function (value) {
        var total = this.total;
        var count = ++this.count;
        if (count <= total) {
            this.destination.next(value);
            if (count === total) {
                this.destination.complete();
                this.unsubscribe();
            }
        }
    };
    return TakeSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=take.js.map


/***/ }),
/* 165 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "endWith", function() { return endWith; });
/* harmony import */ var _observable_fromArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(75);
/* harmony import */ var _observable_scalar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(77);
/* harmony import */ var _observable_empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(72);
/* harmony import */ var _observable_concat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(108);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(74);
/** PURE_IMPORTS_START _observable_fromArray,_observable_scalar,_observable_empty,_observable_concat,_util_isScheduler PURE_IMPORTS_END */





function endWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        array[_i] = arguments[_i];
    }
    return function (source) {
        var scheduler = array[array.length - 1];
        if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_4__["isScheduler"])(scheduler)) {
            array.pop();
        }
        else {
            scheduler = null;
        }
        var len = array.length;
        if (len === 1 && !scheduler) {
            return Object(_observable_concat__WEBPACK_IMPORTED_MODULE_3__["concat"])(source, Object(_observable_scalar__WEBPACK_IMPORTED_MODULE_1__["scalar"])(array[0]));
        }
        else if (len > 0) {
            return Object(_observable_concat__WEBPACK_IMPORTED_MODULE_3__["concat"])(source, Object(_observable_fromArray__WEBPACK_IMPORTED_MODULE_0__["fromArray"])(array, scheduler));
        }
        else {
            return Object(_observable_concat__WEBPACK_IMPORTED_MODULE_3__["concat"])(source, Object(_observable_empty__WEBPACK_IMPORTED_MODULE_2__["empty"])(scheduler));
        }
    };
}
//# sourceMappingURL=endWith.js.map


/***/ }),
/* 166 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "every", function() { return every; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function every(predicate, thisArg) {
    return function (source) { return source.lift(new EveryOperator(predicate, thisArg, source)); };
}
var EveryOperator = /*@__PURE__*/ (function () {
    function EveryOperator(predicate, thisArg, source) {
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.source = source;
    }
    EveryOperator.prototype.call = function (observer, source) {
        return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
    };
    return EveryOperator;
}());
var EverySubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](EverySubscriber, _super);
    function EverySubscriber(destination, predicate, thisArg, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.source = source;
        _this.index = 0;
        _this.thisArg = thisArg || _this;
        return _this;
    }
    EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {
        this.destination.next(everyValueMatch);
        this.destination.complete();
    };
    EverySubscriber.prototype._next = function (value) {
        var result = false;
        try {
            result = this.predicate.call(this.thisArg, value, this.index++, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (!result) {
            this.notifyComplete(false);
        }
    };
    EverySubscriber.prototype._complete = function () {
        this.notifyComplete(true);
    };
    return EverySubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=every.js.map


/***/ }),
/* 167 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exhaust", function() { return exhaust; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(99);
/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */



function exhaust() {
    return function (source) { return source.lift(new SwitchFirstOperator()); };
}
var SwitchFirstOperator = /*@__PURE__*/ (function () {
    function SwitchFirstOperator() {
    }
    SwitchFirstOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchFirstSubscriber(subscriber));
    };
    return SwitchFirstOperator;
}());
var SwitchFirstSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](SwitchFirstSubscriber, _super);
    function SwitchFirstSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasCompleted = false;
        _this.hasSubscription = false;
        return _this;
    }
    SwitchFirstSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.hasSubscription = true;
            this.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(this, value));
        }
    };
    SwitchFirstSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
    };
    SwitchFirstSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return SwitchFirstSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"]));
//# sourceMappingURL=exhaust.js.map


/***/ }),
/* 168 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exhaustMap", function() { return exhaustMap; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(99);
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(95);
/* harmony import */ var _observable_from__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(109);
/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */





function exhaustMap(project, resultSelector) {
    if (resultSelector) {
        return function (source) { return source.pipe(exhaustMap(function (a, i) { return Object(_observable_from__WEBPACK_IMPORTED_MODULE_4__["from"])(project(a, i)).pipe(Object(_map__WEBPACK_IMPORTED_MODULE_3__["map"])(function (b, ii) { return resultSelector(a, b, i, ii); })); })); };
    }
    return function (source) {
        return source.lift(new ExhauseMapOperator(project));
    };
}
var ExhauseMapOperator = /*@__PURE__*/ (function () {
    function ExhauseMapOperator(project) {
        this.project = project;
    }
    ExhauseMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ExhaustMapSubscriber(subscriber, this.project));
    };
    return ExhauseMapOperator;
}());
var ExhaustMapSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](ExhaustMapSubscriber, _super);
    function ExhaustMapSubscriber(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.hasSubscription = false;
        _this.hasCompleted = false;
        _this.index = 0;
        return _this;
    }
    ExhaustMapSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.tryNext(value);
        }
    };
    ExhaustMapSubscriber.prototype.tryNext = function (value) {
        var index = this.index++;
        var destination = this.destination;
        try {
            var result = this.project(value, index);
            this.hasSubscription = true;
            this.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(this, result, value, index));
        }
        catch (err) {
            destination.error(err);
        }
    };
    ExhaustMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
    };
    ExhaustMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    ExhaustMapSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    ExhaustMapSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return ExhaustMapSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"]));
//# sourceMappingURL=exhaustMap.js.map


/***/ }),
/* 169 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expand", function() { return expand; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExpandOperator", function() { return ExpandOperator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExpandSubscriber", function() { return ExpandSubscriber; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _util_tryCatch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48);
/* harmony import */ var _util_errorObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(49);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(98);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(99);
/** PURE_IMPORTS_START tslib,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */





function expand(project, concurrent, scheduler) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    if (scheduler === void 0) {
        scheduler = undefined;
    }
    concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
    return function (source) { return source.lift(new ExpandOperator(project, concurrent, scheduler)); };
}
var ExpandOperator = /*@__PURE__*/ (function () {
    function ExpandOperator(project, concurrent, scheduler) {
        this.project = project;
        this.concurrent = concurrent;
        this.scheduler = scheduler;
    }
    ExpandOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
    };
    return ExpandOperator;
}());

var ExpandSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](ExpandSubscriber, _super);
    function ExpandSubscriber(destination, project, concurrent, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.scheduler = scheduler;
        _this.index = 0;
        _this.active = 0;
        _this.hasCompleted = false;
        if (concurrent < Number.POSITIVE_INFINITY) {
            _this.buffer = [];
        }
        return _this;
    }
    ExpandSubscriber.dispatch = function (arg) {
        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;
        subscriber.subscribeToProjection(result, value, index);
    };
    ExpandSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (destination.closed) {
            this._complete();
            return;
        }
        var index = this.index++;
        if (this.active < this.concurrent) {
            destination.next(value);
            var result = Object(_util_tryCatch__WEBPACK_IMPORTED_MODULE_1__["tryCatch"])(this.project)(value, index);
            if (result === _util_errorObject__WEBPACK_IMPORTED_MODULE_2__["errorObject"]) {
                destination.error(_util_errorObject__WEBPACK_IMPORTED_MODULE_2__["errorObject"].e);
            }
            else if (!this.scheduler) {
                this.subscribeToProjection(result, value, index);
            }
            else {
                var state = { subscriber: this, result: result, value: value, index: index };
                this.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));
            }
        }
        else {
            this.buffer.push(value);
        }
    };
    ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {
        this.active++;
        this.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__["subscribeToResult"])(this, result, value, index));
    };
    ExpandSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
    };
    ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this._next(innerValue);
    };
    ExpandSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer && buffer.length > 0) {
            this._next(buffer.shift());
        }
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
    };
    return ExpandSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__["OuterSubscriber"]));

//# sourceMappingURL=expand.js.map


/***/ }),
/* 170 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "finalize", function() { return finalize; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(45);
/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription PURE_IMPORTS_END */



function finalize(callback) {
    return function (source) { return source.lift(new FinallyOperator(callback)); };
}
var FinallyOperator = /*@__PURE__*/ (function () {
    function FinallyOperator(callback) {
        this.callback = callback;
    }
    FinallyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FinallySubscriber(subscriber, this.callback));
    };
    return FinallyOperator;
}());
var FinallySubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](FinallySubscriber, _super);
    function FinallySubscriber(destination, callback) {
        var _this = _super.call(this, destination) || this;
        _this.add(new _Subscription__WEBPACK_IMPORTED_MODULE_2__["Subscription"](callback));
        return _this;
    }
    return FinallySubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=finalize.js.map


/***/ }),
/* 171 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "find", function() { return find; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FindValueOperator", function() { return FindValueOperator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FindValueSubscriber", function() { return FindValueSubscriber; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function find(predicate, thisArg) {
    if (typeof predicate !== 'function') {
        throw new TypeError('predicate is not a function');
    }
    return function (source) { return source.lift(new FindValueOperator(predicate, source, false, thisArg)); };
}
var FindValueOperator = /*@__PURE__*/ (function () {
    function FindValueOperator(predicate, source, yieldIndex, thisArg) {
        this.predicate = predicate;
        this.source = source;
        this.yieldIndex = yieldIndex;
        this.thisArg = thisArg;
    }
    FindValueOperator.prototype.call = function (observer, source) {
        return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));
    };
    return FindValueOperator;
}());

var FindValueSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](FindValueSubscriber, _super);
    function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.yieldIndex = yieldIndex;
        _this.thisArg = thisArg;
        _this.index = 0;
        return _this;
    }
    FindValueSubscriber.prototype.notifyComplete = function (value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
    };
    FindValueSubscriber.prototype._next = function (value) {
        var _a = this, predicate = _a.predicate, thisArg = _a.thisArg;
        var index = this.index++;
        try {
            var result = predicate.call(thisArg || this, value, index, this.source);
            if (result) {
                this.notifyComplete(this.yieldIndex ? index : value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    FindValueSubscriber.prototype._complete = function () {
        this.notifyComplete(this.yieldIndex ? -1 : undefined);
    };
    return FindValueSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));

//# sourceMappingURL=find.js.map


/***/ }),
/* 172 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findIndex", function() { return findIndex; });
/* harmony import */ var _operators_find__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(171);
/** PURE_IMPORTS_START _operators_find PURE_IMPORTS_END */

function findIndex(predicate, thisArg) {
    return function (source) { return source.lift(new _operators_find__WEBPACK_IMPORTED_MODULE_0__["FindValueOperator"](predicate, source, true, thisArg)); };
}
//# sourceMappingURL=findIndex.js.map


/***/ }),
/* 173 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "first", function() { return first; });
/* harmony import */ var _util_EmptyError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(92);
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(161);
/* harmony import */ var _take__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(164);
/* harmony import */ var _defaultIfEmpty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(152);
/* harmony import */ var _throwIfEmpty__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(162);
/* harmony import */ var _util_identity__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(89);
/** PURE_IMPORTS_START _util_EmptyError,_filter,_take,_defaultIfEmpty,_throwIfEmpty,_util_identity PURE_IMPORTS_END */






function first(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function (source) { return source.pipe(predicate ? Object(_filter__WEBPACK_IMPORTED_MODULE_1__["filter"])(function (v, i) { return predicate(v, i, source); }) : _util_identity__WEBPACK_IMPORTED_MODULE_5__["identity"], Object(_take__WEBPACK_IMPORTED_MODULE_2__["take"])(1), hasDefaultValue ? Object(_defaultIfEmpty__WEBPACK_IMPORTED_MODULE_3__["defaultIfEmpty"])(defaultValue) : Object(_throwIfEmpty__WEBPACK_IMPORTED_MODULE_4__["throwIfEmpty"])(function () { return new _util_EmptyError__WEBPACK_IMPORTED_MODULE_0__["EmptyError"](); })); };
}
//# sourceMappingURL=first.js.map


/***/ }),
/* 174 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ignoreElements", function() { return ignoreElements; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function ignoreElements() {
    return function ignoreElementsOperatorFunction(source) {
        return source.lift(new IgnoreElementsOperator());
    };
}
var IgnoreElementsOperator = /*@__PURE__*/ (function () {
    function IgnoreElementsOperator() {
    }
    IgnoreElementsOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new IgnoreElementsSubscriber(subscriber));
    };
    return IgnoreElementsOperator;
}());
var IgnoreElementsSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](IgnoreElementsSubscriber, _super);
    function IgnoreElementsSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    IgnoreElementsSubscriber.prototype._next = function (unused) {
    };
    return IgnoreElementsSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=ignoreElements.js.map


/***/ }),
/* 175 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEmpty", function() { return isEmpty; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function isEmpty() {
    return function (source) { return source.lift(new IsEmptyOperator()); };
}
var IsEmptyOperator = /*@__PURE__*/ (function () {
    function IsEmptyOperator() {
    }
    IsEmptyOperator.prototype.call = function (observer, source) {
        return source.subscribe(new IsEmptySubscriber(observer));
    };
    return IsEmptyOperator;
}());
var IsEmptySubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](IsEmptySubscriber, _super);
    function IsEmptySubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {
        var destination = this.destination;
        destination.next(isEmpty);
        destination.complete();
    };
    IsEmptySubscriber.prototype._next = function (value) {
        this.notifyComplete(false);
    };
    IsEmptySubscriber.prototype._complete = function () {
        this.notifyComplete(true);
    };
    return IsEmptySubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=isEmpty.js.map


/***/ }),
/* 176 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "last", function() { return last; });
/* harmony import */ var _util_EmptyError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(92);
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(161);
/* harmony import */ var _takeLast__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(177);
/* harmony import */ var _throwIfEmpty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(162);
/* harmony import */ var _defaultIfEmpty__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(152);
/* harmony import */ var _util_identity__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(89);
/** PURE_IMPORTS_START _util_EmptyError,_filter,_takeLast,_throwIfEmpty,_defaultIfEmpty,_util_identity PURE_IMPORTS_END */






function last(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function (source) { return source.pipe(predicate ? Object(_filter__WEBPACK_IMPORTED_MODULE_1__["filter"])(function (v, i) { return predicate(v, i, source); }) : _util_identity__WEBPACK_IMPORTED_MODULE_5__["identity"], Object(_takeLast__WEBPACK_IMPORTED_MODULE_2__["takeLast"])(1), hasDefaultValue ? Object(_defaultIfEmpty__WEBPACK_IMPORTED_MODULE_4__["defaultIfEmpty"])(defaultValue) : Object(_throwIfEmpty__WEBPACK_IMPORTED_MODULE_3__["throwIfEmpty"])(function () { return new _util_EmptyError__WEBPACK_IMPORTED_MODULE_0__["EmptyError"](); })); };
}
//# sourceMappingURL=last.js.map


/***/ }),
/* 177 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "takeLast", function() { return takeLast; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/* harmony import */ var _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(91);
/* harmony import */ var _observable_empty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(72);
/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */




function takeLast(count) {
    return function takeLastOperatorFunction(source) {
        if (count === 0) {
            return Object(_observable_empty__WEBPACK_IMPORTED_MODULE_3__["empty"])();
        }
        else {
            return source.lift(new TakeLastOperator(count));
        }
    };
}
var TakeLastOperator = /*@__PURE__*/ (function () {
    function TakeLastOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_2__["ArgumentOutOfRangeError"];
        }
    }
    TakeLastOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
    };
    return TakeLastOperator;
}());
var TakeLastSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](TakeLastSubscriber, _super);
    function TakeLastSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.ring = new Array();
        _this.count = 0;
        return _this;
    }
    TakeLastSubscriber.prototype._next = function (value) {
        var ring = this.ring;
        var total = this.total;
        var count = this.count++;
        if (ring.length < total) {
            ring.push(value);
        }
        else {
            var index = count % total;
            ring[index] = value;
        }
    };
    TakeLastSubscriber.prototype._complete = function () {
        var destination = this.destination;
        var count = this.count;
        if (count > 0) {
            var total = this.count >= this.total ? this.total : this.count;
            var ring = this.ring;
            for (var i = 0; i < total; i++) {
                var idx = (count++) % total;
                destination.next(ring[idx]);
            }
        }
        destination.complete();
    };
    return TakeLastSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=takeLast.js.map


/***/ }),
/* 178 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapTo", function() { return mapTo; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function mapTo(value) {
    return function (source) { return source.lift(new MapToOperator(value)); };
}
var MapToOperator = /*@__PURE__*/ (function () {
    function MapToOperator(value) {
        this.value = value;
    }
    MapToOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapToSubscriber(subscriber, this.value));
    };
    return MapToOperator;
}());
var MapToSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](MapToSubscriber, _super);
    function MapToSubscriber(destination, value) {
        var _this = _super.call(this, destination) || this;
        _this.value = value;
        return _this;
    }
    MapToSubscriber.prototype._next = function (x) {
        this.destination.next(this.value);
    };
    return MapToSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=mapTo.js.map


/***/ }),
/* 179 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "materialize", function() { return materialize; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/* harmony import */ var _Notification__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(71);
/** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */



function materialize() {
    return function materializeOperatorFunction(source) {
        return source.lift(new MaterializeOperator());
    };
}
var MaterializeOperator = /*@__PURE__*/ (function () {
    function MaterializeOperator() {
    }
    MaterializeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MaterializeSubscriber(subscriber));
    };
    return MaterializeOperator;
}());
var MaterializeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](MaterializeSubscriber, _super);
    function MaterializeSubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    MaterializeSubscriber.prototype._next = function (value) {
        this.destination.next(_Notification__WEBPACK_IMPORTED_MODULE_2__["Notification"].createNext(value));
    };
    MaterializeSubscriber.prototype._error = function (err) {
        var destination = this.destination;
        destination.next(_Notification__WEBPACK_IMPORTED_MODULE_2__["Notification"].createError(err));
        destination.complete();
    };
    MaterializeSubscriber.prototype._complete = function () {
        var destination = this.destination;
        destination.next(_Notification__WEBPACK_IMPORTED_MODULE_2__["Notification"].createComplete());
        destination.complete();
    };
    return MaterializeSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=materialize.js.map


/***/ }),
/* 180 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony import */ var _reduce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(181);
/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */

function max(comparer) {
    var max = (typeof comparer === 'function')
        ? function (x, y) { return comparer(x, y) > 0 ? x : y; }
        : function (x, y) { return x > y ? x : y; };
    return Object(_reduce__WEBPACK_IMPORTED_MODULE_0__["reduce"])(max);
}
//# sourceMappingURL=max.js.map


/***/ }),
/* 181 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reduce", function() { return reduce; });
/* harmony import */ var _scan__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(182);
/* harmony import */ var _takeLast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(177);
/* harmony import */ var _defaultIfEmpty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(152);
/* harmony import */ var _util_pipe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(53);
/** PURE_IMPORTS_START _scan,_takeLast,_defaultIfEmpty,_util_pipe PURE_IMPORTS_END */




function reduce(accumulator, seed) {
    if (arguments.length >= 2) {
        return function reduceOperatorFunctionWithSeed(source) {
            return Object(_util_pipe__WEBPACK_IMPORTED_MODULE_3__["pipe"])(Object(_scan__WEBPACK_IMPORTED_MODULE_0__["scan"])(accumulator, seed), Object(_takeLast__WEBPACK_IMPORTED_MODULE_1__["takeLast"])(1), Object(_defaultIfEmpty__WEBPACK_IMPORTED_MODULE_2__["defaultIfEmpty"])(seed))(source);
        };
    }
    return function reduceOperatorFunction(source) {
        return Object(_util_pipe__WEBPACK_IMPORTED_MODULE_3__["pipe"])(Object(_scan__WEBPACK_IMPORTED_MODULE_0__["scan"])(function (acc, value, index) {
            return accumulator(acc, value, index + 1);
        }), Object(_takeLast__WEBPACK_IMPORTED_MODULE_1__["takeLast"])(1))(source);
    };
}
//# sourceMappingURL=reduce.js.map


/***/ }),
/* 182 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scan", function() { return scan; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function scan(accumulator, seed) {
    var hasSeed = false;
    if (arguments.length >= 2) {
        hasSeed = true;
    }
    return function scanOperatorFunction(source) {
        return source.lift(new ScanOperator(accumulator, seed, hasSeed));
    };
}
var ScanOperator = /*@__PURE__*/ (function () {
    function ScanOperator(accumulator, seed, hasSeed) {
        if (hasSeed === void 0) {
            hasSeed = false;
        }
        this.accumulator = accumulator;
        this.seed = seed;
        this.hasSeed = hasSeed;
    }
    ScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
    };
    return ScanOperator;
}());
var ScanSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](ScanSubscriber, _super);
    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this._seed = _seed;
        _this.hasSeed = hasSeed;
        _this.index = 0;
        return _this;
    }
    Object.defineProperty(ScanSubscriber.prototype, "seed", {
        get: function () {
            return this._seed;
        },
        set: function (value) {
            this.hasSeed = true;
            this._seed = value;
        },
        enumerable: true,
        configurable: true
    });
    ScanSubscriber.prototype._next = function (value) {
        if (!this.hasSeed) {
            this.seed = value;
            this.destination.next(value);
        }
        else {
            return this._tryNext(value);
        }
    };
    ScanSubscriber.prototype._tryNext = function (value) {
        var index = this.index++;
        var result;
        try {
            result = this.accumulator(this.seed, value, index);
        }
        catch (err) {
            this.destination.error(err);
        }
        this.seed = result;
        this.destination.next(result);
    };
    return ScanSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=scan.js.map


/***/ }),
/* 183 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return merge; });
/* harmony import */ var _observable_merge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(126);
/** PURE_IMPORTS_START _observable_merge PURE_IMPORTS_END */

function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return function (source) { return source.lift.call(_observable_merge__WEBPACK_IMPORTED_MODULE_0__["merge"].apply(void 0, [source].concat(observables))); };
}
//# sourceMappingURL=merge.js.map


/***/ }),
/* 184 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeMapTo", function() { return mergeMapTo; });
/* harmony import */ var _mergeMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(117);
/** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */

function mergeMapTo(innerObservable, resultSelector, concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    if (typeof resultSelector === 'function') {
        return Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__["mergeMap"])(function () { return innerObservable; }, resultSelector, concurrent);
    }
    if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
    }
    return Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__["mergeMap"])(function () { return innerObservable; }, concurrent);
}
//# sourceMappingURL=mergeMapTo.js.map


/***/ }),
/* 185 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeScan", function() { return mergeScan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MergeScanOperator", function() { return MergeScanOperator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MergeScanSubscriber", function() { return MergeScanSubscriber; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _util_tryCatch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48);
/* harmony import */ var _util_errorObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(49);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(99);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(98);
/** PURE_IMPORTS_START tslib,_util_tryCatch,_util_errorObject,_util_subscribeToResult,_OuterSubscriber PURE_IMPORTS_END */





function mergeScan(accumulator, seed, concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    return function (source) { return source.lift(new MergeScanOperator(accumulator, seed, concurrent)); };
}
var MergeScanOperator = /*@__PURE__*/ (function () {
    function MergeScanOperator(accumulator, seed, concurrent) {
        this.accumulator = accumulator;
        this.seed = seed;
        this.concurrent = concurrent;
    }
    MergeScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));
    };
    return MergeScanOperator;
}());

var MergeScanSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](MergeScanSubscriber, _super);
    function MergeScanSubscriber(destination, accumulator, acc, concurrent) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this.acc = acc;
        _this.concurrent = concurrent;
        _this.hasValue = false;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
    }
    MergeScanSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            var index = this.index++;
            var ish = Object(_util_tryCatch__WEBPACK_IMPORTED_MODULE_1__["tryCatch"])(this.accumulator)(this.acc, value);
            var destination = this.destination;
            if (ish === _util_errorObject__WEBPACK_IMPORTED_MODULE_2__["errorObject"]) {
                destination.error(_util_errorObject__WEBPACK_IMPORTED_MODULE_2__["errorObject"].e);
            }
            else {
                this.active++;
                this._innerSub(ish, value, index);
            }
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeScanSubscriber.prototype._innerSub = function (ish, value, index) {
        this.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__["subscribeToResult"])(this, ish, value, index));
    };
    MergeScanSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            if (this.hasValue === false) {
                this.destination.next(this.acc);
            }
            this.destination.complete();
        }
    };
    MergeScanSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var destination = this.destination;
        this.acc = innerValue;
        this.hasValue = true;
        destination.next(innerValue);
    };
    MergeScanSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            if (this.hasValue === false) {
                this.destination.next(this.acc);
            }
            this.destination.complete();
        }
    };
    return MergeScanSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_4__["OuterSubscriber"]));

//# sourceMappingURL=mergeScan.js.map


/***/ }),
/* 186 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony import */ var _reduce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(181);
/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */

function min(comparer) {
    var min = (typeof comparer === 'function')
        ? function (x, y) { return comparer(x, y) < 0 ? x : y; }
        : function (x, y) { return x < y ? x : y; };
    return Object(_reduce__WEBPACK_IMPORTED_MODULE_0__["reduce"])(min);
}
//# sourceMappingURL=min.js.map


/***/ }),
/* 187 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multicast", function() { return multicast; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MulticastOperator", function() { return MulticastOperator; });
/* harmony import */ var _observable_ConnectableObservable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(55);
/** PURE_IMPORTS_START _observable_ConnectableObservable PURE_IMPORTS_END */

function multicast(subjectOrSubjectFactory, selector) {
    return function multicastOperatorFunction(source) {
        var subjectFactory;
        if (typeof subjectOrSubjectFactory === 'function') {
            subjectFactory = subjectOrSubjectFactory;
        }
        else {
            subjectFactory = function subjectFactory() {
                return subjectOrSubjectFactory;
            };
        }
        if (typeof selector === 'function') {
            return source.lift(new MulticastOperator(subjectFactory, selector));
        }
        var connectable = Object.create(source, _observable_ConnectableObservable__WEBPACK_IMPORTED_MODULE_0__["connectableObservableDescriptor"]);
        connectable.source = source;
        connectable.subjectFactory = subjectFactory;
        return connectable;
    };
}
var MulticastOperator = /*@__PURE__*/ (function () {
    function MulticastOperator(subjectFactory, selector) {
        this.subjectFactory = subjectFactory;
        this.selector = selector;
    }
    MulticastOperator.prototype.call = function (subscriber, source) {
        var selector = this.selector;
        var subject = this.subjectFactory();
        var subscription = selector(subject).subscribe(subscriber);
        subscription.add(source.subscribe(subject));
        return subscription;
    };
    return MulticastOperator;
}());

//# sourceMappingURL=multicast.js.map


/***/ }),
/* 188 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onErrorResumeNext", function() { return onErrorResumeNext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onErrorResumeNextStatic", function() { return onErrorResumeNextStatic; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _observable_from__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(109);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(46);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(98);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(99);
/** PURE_IMPORTS_START tslib,_observable_from,_util_isArray,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */





function onErrorResumeNext() {
    var nextSources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        nextSources[_i] = arguments[_i];
    }
    if (nextSources.length === 1 && Object(_util_isArray__WEBPACK_IMPORTED_MODULE_2__["isArray"])(nextSources[0])) {
        nextSources = nextSources[0];
    }
    return function (source) { return source.lift(new OnErrorResumeNextOperator(nextSources)); };
}
function onErrorResumeNextStatic() {
    var nextSources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        nextSources[_i] = arguments[_i];
    }
    var source = null;
    if (nextSources.length === 1 && Object(_util_isArray__WEBPACK_IMPORTED_MODULE_2__["isArray"])(nextSources[0])) {
        nextSources = nextSources[0];
    }
    source = nextSources.shift();
    return Object(_observable_from__WEBPACK_IMPORTED_MODULE_1__["from"])(source, null).lift(new OnErrorResumeNextOperator(nextSources));
}
var OnErrorResumeNextOperator = /*@__PURE__*/ (function () {
    function OnErrorResumeNextOperator(nextSources) {
        this.nextSources = nextSources;
    }
    OnErrorResumeNextOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
    };
    return OnErrorResumeNextOperator;
}());
var OnErrorResumeNextSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](OnErrorResumeNextSubscriber, _super);
    function OnErrorResumeNextSubscriber(destination, nextSources) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.nextSources = nextSources;
        return _this;
    }
    OnErrorResumeNextSubscriber.prototype.notifyError = function (error, innerSub) {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype.notifyComplete = function (innerSub) {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype._error = function (err) {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype._complete = function () {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {
        var next = this.nextSources.shift();
        if (next) {
            this.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__["subscribeToResult"])(this, next));
        }
        else {
            this.destination.complete();
        }
    };
    return OnErrorResumeNextSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__["OuterSubscriber"]));
//# sourceMappingURL=onErrorResumeNext.js.map


/***/ }),
/* 189 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pairwise", function() { return pairwise; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function pairwise() {
    return function (source) { return source.lift(new PairwiseOperator()); };
}
var PairwiseOperator = /*@__PURE__*/ (function () {
    function PairwiseOperator() {
    }
    PairwiseOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new PairwiseSubscriber(subscriber));
    };
    return PairwiseOperator;
}());
var PairwiseSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](PairwiseSubscriber, _super);
    function PairwiseSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasPrev = false;
        return _this;
    }
    PairwiseSubscriber.prototype._next = function (value) {
        if (this.hasPrev) {
            this.destination.next([this.prev, value]);
        }
        else {
            this.hasPrev = true;
        }
        this.prev = value;
    };
    return PairwiseSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=pairwise.js.map


/***/ }),
/* 190 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "partition", function() { return partition; });
/* harmony import */ var _util_not__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(191);
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(161);
/** PURE_IMPORTS_START _util_not,_filter PURE_IMPORTS_END */


function partition(predicate, thisArg) {
    return function (source) {
        return [
            Object(_filter__WEBPACK_IMPORTED_MODULE_1__["filter"])(predicate, thisArg)(source),
            Object(_filter__WEBPACK_IMPORTED_MODULE_1__["filter"])(Object(_util_not__WEBPACK_IMPORTED_MODULE_0__["not"])(predicate, thisArg))(source)
        ];
    };
}
//# sourceMappingURL=partition.js.map


/***/ }),
/* 191 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "not", function() { return not; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function not(pred, thisArg) {
    function notPred() {
        return !(notPred.pred.apply(notPred.thisArg, arguments));
    }
    notPred.pred = pred;
    notPred.thisArg = thisArg;
    return notPred;
}
//# sourceMappingURL=not.js.map


/***/ }),
/* 192 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pluck", function() { return pluck; });
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(95);
/** PURE_IMPORTS_START _map PURE_IMPORTS_END */

function pluck() {
    var properties = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        properties[_i] = arguments[_i];
    }
    var length = properties.length;
    if (length === 0) {
        throw new Error('list of properties cannot be empty.');
    }
    return function (source) { return Object(_map__WEBPACK_IMPORTED_MODULE_0__["map"])(plucker(properties, length))(source); };
}
function plucker(props, length) {
    var mapper = function (x) {
        var currentProp = x;
        for (var i = 0; i < length; i++) {
            var p = currentProp[props[i]];
            if (typeof p !== 'undefined') {
                currentProp = p;
            }
            else {
                return undefined;
            }
        }
        return currentProp;
    };
    return mapper;
}
//# sourceMappingURL=pluck.js.map


/***/ }),
/* 193 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "publish", function() { return publish; });
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(56);
/* harmony import */ var _multicast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(187);
/** PURE_IMPORTS_START _Subject,_multicast PURE_IMPORTS_END */


function publish(selector) {
    return selector ?
        Object(_multicast__WEBPACK_IMPORTED_MODULE_1__["multicast"])(function () { return new _Subject__WEBPACK_IMPORTED_MODULE_0__["Subject"](); }, selector) :
        Object(_multicast__WEBPACK_IMPORTED_MODULE_1__["multicast"])(new _Subject__WEBPACK_IMPORTED_MODULE_0__["Subject"]());
}
//# sourceMappingURL=publish.js.map


/***/ }),
/* 194 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "publishBehavior", function() { return publishBehavior; });
/* harmony import */ var _BehaviorSubject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61);
/* harmony import */ var _multicast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(187);
/** PURE_IMPORTS_START _BehaviorSubject,_multicast PURE_IMPORTS_END */


function publishBehavior(value) {
    return function (source) { return Object(_multicast__WEBPACK_IMPORTED_MODULE_1__["multicast"])(new _BehaviorSubject__WEBPACK_IMPORTED_MODULE_0__["BehaviorSubject"](value))(source); };
}
//# sourceMappingURL=publishBehavior.js.map


/***/ }),
/* 195 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "publishLast", function() { return publishLast; });
/* harmony import */ var _AsyncSubject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(79);
/* harmony import */ var _multicast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(187);
/** PURE_IMPORTS_START _AsyncSubject,_multicast PURE_IMPORTS_END */


function publishLast() {
    return function (source) { return Object(_multicast__WEBPACK_IMPORTED_MODULE_1__["multicast"])(new _AsyncSubject__WEBPACK_IMPORTED_MODULE_0__["AsyncSubject"]())(source); };
}
//# sourceMappingURL=publishLast.js.map


/***/ }),
/* 196 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "publishReplay", function() { return publishReplay; });
/* harmony import */ var _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(62);
/* harmony import */ var _multicast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(187);
/** PURE_IMPORTS_START _ReplaySubject,_multicast PURE_IMPORTS_END */


function publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {
    if (selectorOrScheduler && typeof selectorOrScheduler !== 'function') {
        scheduler = selectorOrScheduler;
    }
    var selector = typeof selectorOrScheduler === 'function' ? selectorOrScheduler : undefined;
    var subject = new _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__["ReplaySubject"](bufferSize, windowTime, scheduler);
    return function (source) { return Object(_multicast__WEBPACK_IMPORTED_MODULE_1__["multicast"])(function () { return subject; }, selector)(source); };
}
//# sourceMappingURL=publishReplay.js.map


/***/ }),
/* 197 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "race", function() { return race; });
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46);
/* harmony import */ var _observable_race__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(130);
/** PURE_IMPORTS_START _util_isArray,_observable_race PURE_IMPORTS_END */


function race() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return function raceOperatorFunction(source) {
        if (observables.length === 1 && Object(_util_isArray__WEBPACK_IMPORTED_MODULE_0__["isArray"])(observables[0])) {
            observables = observables[0];
        }
        return source.lift.call(_observable_race__WEBPACK_IMPORTED_MODULE_1__["race"].apply(void 0, [source].concat(observables)));
    };
}
//# sourceMappingURL=race.js.map


/***/ }),
/* 198 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "repeat", function() { return repeat; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/* harmony import */ var _observable_empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(72);
/** PURE_IMPORTS_START tslib,_Subscriber,_observable_empty PURE_IMPORTS_END */



function repeat(count) {
    if (count === void 0) {
        count = -1;
    }
    return function (source) {
        if (count === 0) {
            return Object(_observable_empty__WEBPACK_IMPORTED_MODULE_2__["empty"])();
        }
        else if (count < 0) {
            return source.lift(new RepeatOperator(-1, source));
        }
        else {
            return source.lift(new RepeatOperator(count - 1, source));
        }
    };
}
var RepeatOperator = /*@__PURE__*/ (function () {
    function RepeatOperator(count, source) {
        this.count = count;
        this.source = source;
    }
    RepeatOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
    };
    return RepeatOperator;
}());
var RepeatSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](RepeatSubscriber, _super);
    function RepeatSubscriber(destination, count, source) {
        var _this = _super.call(this, destination) || this;
        _this.count = count;
        _this.source = source;
        return _this;
    }
    RepeatSubscriber.prototype.complete = function () {
        if (!this.isStopped) {
            var _a = this, source = _a.source, count = _a.count;
            if (count === 0) {
                return _super.prototype.complete.call(this);
            }
            else if (count > -1) {
                this.count = count - 1;
            }
            source.subscribe(this._unsubscribeAndRecycle());
        }
    };
    return RepeatSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=repeat.js.map


/***/ }),
/* 199 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "repeatWhen", function() { return repeatWhen; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56);
/* harmony import */ var _util_tryCatch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(48);
/* harmony import */ var _util_errorObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(49);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(98);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(99);
/** PURE_IMPORTS_START tslib,_Subject,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */






function repeatWhen(notifier) {
    return function (source) { return source.lift(new RepeatWhenOperator(notifier)); };
}
var RepeatWhenOperator = /*@__PURE__*/ (function () {
    function RepeatWhenOperator(notifier) {
        this.notifier = notifier;
    }
    RepeatWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));
    };
    return RepeatWhenOperator;
}());
var RepeatWhenSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](RepeatWhenSubscriber, _super);
    function RepeatWhenSubscriber(destination, notifier, source) {
        var _this = _super.call(this, destination) || this;
        _this.notifier = notifier;
        _this.source = source;
        _this.sourceIsBeingSubscribedTo = true;
        return _this;
    }
    RepeatWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.sourceIsBeingSubscribedTo = true;
        this.source.subscribe(this);
    };
    RepeatWhenSubscriber.prototype.notifyComplete = function (innerSub) {
        if (this.sourceIsBeingSubscribedTo === false) {
            return _super.prototype.complete.call(this);
        }
    };
    RepeatWhenSubscriber.prototype.complete = function () {
        this.sourceIsBeingSubscribedTo = false;
        if (!this.isStopped) {
            if (!this.retries) {
                this.subscribeToRetries();
            }
            if (!this.retriesSubscription || this.retriesSubscription.closed) {
                return _super.prototype.complete.call(this);
            }
            this._unsubscribeAndRecycle();
            this.notifications.next();
        }
    };
    RepeatWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;
        if (notifications) {
            notifications.unsubscribe();
            this.notifications = null;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = null;
        }
        this.retries = null;
    };
    RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function () {
        var _unsubscribe = this._unsubscribe;
        this._unsubscribe = null;
        _super.prototype._unsubscribeAndRecycle.call(this);
        this._unsubscribe = _unsubscribe;
        return this;
    };
    RepeatWhenSubscriber.prototype.subscribeToRetries = function () {
        this.notifications = new _Subject__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
        var retries = Object(_util_tryCatch__WEBPACK_IMPORTED_MODULE_2__["tryCatch"])(this.notifier)(this.notifications);
        if (retries === _util_errorObject__WEBPACK_IMPORTED_MODULE_3__["errorObject"]) {
            return _super.prototype.complete.call(this);
        }
        this.retries = retries;
        this.retriesSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_5__["subscribeToResult"])(this, retries);
    };
    return RepeatWhenSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_4__["OuterSubscriber"]));
//# sourceMappingURL=repeatWhen.js.map


/***/ }),
/* 200 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "retry", function() { return retry; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function retry(count) {
    if (count === void 0) {
        count = -1;
    }
    return function (source) { return source.lift(new RetryOperator(count, source)); };
}
var RetryOperator = /*@__PURE__*/ (function () {
    function RetryOperator(count, source) {
        this.count = count;
        this.source = source;
    }
    RetryOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
    };
    return RetryOperator;
}());
var RetrySubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](RetrySubscriber, _super);
    function RetrySubscriber(destination, count, source) {
        var _this = _super.call(this, destination) || this;
        _this.count = count;
        _this.source = source;
        return _this;
    }
    RetrySubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _a = this, source = _a.source, count = _a.count;
            if (count === 0) {
                return _super.prototype.error.call(this, err);
            }
            else if (count > -1) {
                this.count = count - 1;
            }
            source.subscribe(this._unsubscribeAndRecycle());
        }
    };
    return RetrySubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=retry.js.map


/***/ }),
/* 201 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "retryWhen", function() { return retryWhen; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56);
/* harmony import */ var _util_tryCatch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(48);
/* harmony import */ var _util_errorObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(49);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(98);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(99);
/** PURE_IMPORTS_START tslib,_Subject,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */






function retryWhen(notifier) {
    return function (source) { return source.lift(new RetryWhenOperator(notifier, source)); };
}
var RetryWhenOperator = /*@__PURE__*/ (function () {
    function RetryWhenOperator(notifier, source) {
        this.notifier = notifier;
        this.source = source;
    }
    RetryWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
    };
    return RetryWhenOperator;
}());
var RetryWhenSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](RetryWhenSubscriber, _super);
    function RetryWhenSubscriber(destination, notifier, source) {
        var _this = _super.call(this, destination) || this;
        _this.notifier = notifier;
        _this.source = source;
        return _this;
    }
    RetryWhenSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var errors = this.errors;
            var retries = this.retries;
            var retriesSubscription = this.retriesSubscription;
            if (!retries) {
                errors = new _Subject__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
                retries = Object(_util_tryCatch__WEBPACK_IMPORTED_MODULE_2__["tryCatch"])(this.notifier)(errors);
                if (retries === _util_errorObject__WEBPACK_IMPORTED_MODULE_3__["errorObject"]) {
                    return _super.prototype.error.call(this, _util_errorObject__WEBPACK_IMPORTED_MODULE_3__["errorObject"].e);
                }
                retriesSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_5__["subscribeToResult"])(this, retries);
            }
            else {
                this.errors = null;
                this.retriesSubscription = null;
            }
            this._unsubscribeAndRecycle();
            this.errors = errors;
            this.retries = retries;
            this.retriesSubscription = retriesSubscription;
            errors.next(err);
        }
    };
    RetryWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;
        if (errors) {
            errors.unsubscribe();
            this.errors = null;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = null;
        }
        this.retries = null;
    };
    RetryWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _unsubscribe = this._unsubscribe;
        this._unsubscribe = null;
        this._unsubscribeAndRecycle();
        this._unsubscribe = _unsubscribe;
        this.source.subscribe(this);
    };
    return RetryWhenSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_4__["OuterSubscriber"]));
//# sourceMappingURL=retryWhen.js.map


/***/ }),
/* 202 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sample", function() { return sample; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(99);
/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */



function sample(notifier) {
    return function (source) { return source.lift(new SampleOperator(notifier)); };
}
var SampleOperator = /*@__PURE__*/ (function () {
    function SampleOperator(notifier) {
        this.notifier = notifier;
    }
    SampleOperator.prototype.call = function (subscriber, source) {
        var sampleSubscriber = new SampleSubscriber(subscriber);
        var subscription = source.subscribe(sampleSubscriber);
        subscription.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(sampleSubscriber, this.notifier));
        return subscription;
    };
    return SampleOperator;
}());
var SampleSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](SampleSubscriber, _super);
    function SampleSubscriber() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.hasValue = false;
        return _this;
    }
    SampleSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
    };
    SampleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.emitValue();
    };
    SampleSubscriber.prototype.notifyComplete = function () {
        this.emitValue();
    };
    SampleSubscriber.prototype.emitValue = function () {
        if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.value);
        }
    };
    return SampleSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"]));
//# sourceMappingURL=sample.js.map


/***/ }),
/* 203 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sampleTime", function() { return sampleTime; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(84);
/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */



function sampleTime(period, scheduler) {
    if (scheduler === void 0) {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_2__["async"];
    }
    return function (source) { return source.lift(new SampleTimeOperator(period, scheduler)); };
}
var SampleTimeOperator = /*@__PURE__*/ (function () {
    function SampleTimeOperator(period, scheduler) {
        this.period = period;
        this.scheduler = scheduler;
    }
    SampleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
    };
    return SampleTimeOperator;
}());
var SampleTimeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](SampleTimeSubscriber, _super);
    function SampleTimeSubscriber(destination, period, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.period = period;
        _this.scheduler = scheduler;
        _this.hasValue = false;
        _this.add(scheduler.schedule(dispatchNotification, period, { subscriber: _this, period: period }));
        return _this;
    }
    SampleTimeSubscriber.prototype._next = function (value) {
        this.lastValue = value;
        this.hasValue = true;
    };
    SampleTimeSubscriber.prototype.notifyNext = function () {
        if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.lastValue);
        }
    };
    return SampleTimeSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
function dispatchNotification(state) {
    var subscriber = state.subscriber, period = state.period;
    subscriber.notifyNext();
    this.schedule(state, period);
}
//# sourceMappingURL=sampleTime.js.map


/***/ }),
/* 204 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sequenceEqual", function() { return sequenceEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SequenceEqualOperator", function() { return SequenceEqualOperator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SequenceEqualSubscriber", function() { return SequenceEqualSubscriber; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/* harmony import */ var _util_tryCatch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(48);
/* harmony import */ var _util_errorObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(49);
/** PURE_IMPORTS_START tslib,_Subscriber,_util_tryCatch,_util_errorObject PURE_IMPORTS_END */




function sequenceEqual(compareTo, comparor) {
    return function (source) { return source.lift(new SequenceEqualOperator(compareTo, comparor)); };
}
var SequenceEqualOperator = /*@__PURE__*/ (function () {
    function SequenceEqualOperator(compareTo, comparor) {
        this.compareTo = compareTo;
        this.comparor = comparor;
    }
    SequenceEqualOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparor));
    };
    return SequenceEqualOperator;
}());

var SequenceEqualSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](SequenceEqualSubscriber, _super);
    function SequenceEqualSubscriber(destination, compareTo, comparor) {
        var _this = _super.call(this, destination) || this;
        _this.compareTo = compareTo;
        _this.comparor = comparor;
        _this._a = [];
        _this._b = [];
        _this._oneComplete = false;
        _this.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _this)));
        return _this;
    }
    SequenceEqualSubscriber.prototype._next = function (value) {
        if (this._oneComplete && this._b.length === 0) {
            this.emit(false);
        }
        else {
            this._a.push(value);
            this.checkValues();
        }
    };
    SequenceEqualSubscriber.prototype._complete = function () {
        if (this._oneComplete) {
            this.emit(this._a.length === 0 && this._b.length === 0);
        }
        else {
            this._oneComplete = true;
        }
    };
    SequenceEqualSubscriber.prototype.checkValues = function () {
        var _c = this, _a = _c._a, _b = _c._b, comparor = _c.comparor;
        while (_a.length > 0 && _b.length > 0) {
            var a = _a.shift();
            var b = _b.shift();
            var areEqual = false;
            if (comparor) {
                areEqual = Object(_util_tryCatch__WEBPACK_IMPORTED_MODULE_2__["tryCatch"])(comparor)(a, b);
                if (areEqual === _util_errorObject__WEBPACK_IMPORTED_MODULE_3__["errorObject"]) {
                    this.destination.error(_util_errorObject__WEBPACK_IMPORTED_MODULE_3__["errorObject"].e);
                }
            }
            else {
                areEqual = a === b;
            }
            if (!areEqual) {
                this.emit(false);
            }
        }
    };
    SequenceEqualSubscriber.prototype.emit = function (value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
    };
    SequenceEqualSubscriber.prototype.nextB = function (value) {
        if (this._oneComplete && this._a.length === 0) {
            this.emit(false);
        }
        else {
            this._b.push(value);
            this.checkValues();
        }
    };
    return SequenceEqualSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));

var SequenceEqualCompareToSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](SequenceEqualCompareToSubscriber, _super);
    function SequenceEqualCompareToSubscriber(destination, parent) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        return _this;
    }
    SequenceEqualCompareToSubscriber.prototype._next = function (value) {
        this.parent.nextB(value);
    };
    SequenceEqualCompareToSubscriber.prototype._error = function (err) {
        this.parent.error(err);
    };
    SequenceEqualCompareToSubscriber.prototype._complete = function () {
        this.parent._complete();
    };
    return SequenceEqualCompareToSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=sequenceEqual.js.map


/***/ }),
/* 205 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "share", function() { return share; });
/* harmony import */ var _multicast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(187);
/* harmony import */ var _refCount__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(59);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(56);
/** PURE_IMPORTS_START _multicast,_refCount,_Subject PURE_IMPORTS_END */



function shareSubjectFactory() {
    return new _Subject__WEBPACK_IMPORTED_MODULE_2__["Subject"]();
}
function share() {
    return function (source) { return Object(_refCount__WEBPACK_IMPORTED_MODULE_1__["refCount"])()(Object(_multicast__WEBPACK_IMPORTED_MODULE_0__["multicast"])(shareSubjectFactory)(source)); };
}
//# sourceMappingURL=share.js.map


/***/ }),
/* 206 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shareReplay", function() { return shareReplay; });
/* harmony import */ var _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(62);
/** PURE_IMPORTS_START _ReplaySubject PURE_IMPORTS_END */

function shareReplay(bufferSize, windowTime, scheduler) {
    return function (source) { return source.lift(shareReplayOperator(bufferSize, windowTime, scheduler)); };
}
function shareReplayOperator(bufferSize, windowTime, scheduler) {
    var subject;
    var refCount = 0;
    var subscription;
    var hasError = false;
    var isComplete = false;
    return function shareReplayOperation(source) {
        refCount++;
        if (!subject || hasError) {
            hasError = false;
            subject = new _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__["ReplaySubject"](bufferSize, windowTime, scheduler);
            subscription = source.subscribe({
                next: function (value) { subject.next(value); },
                error: function (err) {
                    hasError = true;
                    subject.error(err);
                },
                complete: function () {
                    isComplete = true;
                    subject.complete();
                },
            });
        }
        var innerSub = subject.subscribe(this);
        return function () {
            refCount--;
            innerSub.unsubscribe();
            if (subscription && refCount === 0 && isComplete) {
                subscription.unsubscribe();
            }
        };
    };
}
//# sourceMappingURL=shareReplay.js.map


/***/ }),
/* 207 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "single", function() { return single; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/* harmony import */ var _util_EmptyError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(92);
/** PURE_IMPORTS_START tslib,_Subscriber,_util_EmptyError PURE_IMPORTS_END */



function single(predicate) {
    return function (source) { return source.lift(new SingleOperator(predicate, source)); };
}
var SingleOperator = /*@__PURE__*/ (function () {
    function SingleOperator(predicate, source) {
        this.predicate = predicate;
        this.source = source;
    }
    SingleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
    };
    return SingleOperator;
}());
var SingleSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](SingleSubscriber, _super);
    function SingleSubscriber(destination, predicate, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.seenValue = false;
        _this.index = 0;
        return _this;
    }
    SingleSubscriber.prototype.applySingleValue = function (value) {
        if (this.seenValue) {
            this.destination.error('Sequence contains more than one element');
        }
        else {
            this.seenValue = true;
            this.singleValue = value;
        }
    };
    SingleSubscriber.prototype._next = function (value) {
        var index = this.index++;
        if (this.predicate) {
            this.tryNext(value, index);
        }
        else {
            this.applySingleValue(value);
        }
    };
    SingleSubscriber.prototype.tryNext = function (value, index) {
        try {
            if (this.predicate(value, index, this.source)) {
                this.applySingleValue(value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    SingleSubscriber.prototype._complete = function () {
        var destination = this.destination;
        if (this.index > 0) {
            destination.next(this.seenValue ? this.singleValue : undefined);
            destination.complete();
        }
        else {
            destination.error(new _util_EmptyError__WEBPACK_IMPORTED_MODULE_2__["EmptyError"]);
        }
    };
    return SingleSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=single.js.map


/***/ }),
/* 208 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "skip", function() { return skip; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function skip(count) {
    return function (source) { return source.lift(new SkipOperator(count)); };
}
var SkipOperator = /*@__PURE__*/ (function () {
    function SkipOperator(total) {
        this.total = total;
    }
    SkipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipSubscriber(subscriber, this.total));
    };
    return SkipOperator;
}());
var SkipSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](SkipSubscriber, _super);
    function SkipSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
    }
    SkipSubscriber.prototype._next = function (x) {
        if (++this.count > this.total) {
            this.destination.next(x);
        }
    };
    return SkipSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=skip.js.map


/***/ }),
/* 209 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "skipLast", function() { return skipLast; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/* harmony import */ var _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(91);
/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError PURE_IMPORTS_END */



function skipLast(count) {
    return function (source) { return source.lift(new SkipLastOperator(count)); };
}
var SkipLastOperator = /*@__PURE__*/ (function () {
    function SkipLastOperator(_skipCount) {
        this._skipCount = _skipCount;
        if (this._skipCount < 0) {
            throw new _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_2__["ArgumentOutOfRangeError"];
        }
    }
    SkipLastOperator.prototype.call = function (subscriber, source) {
        if (this._skipCount === 0) {
            return source.subscribe(new _Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"](subscriber));
        }
        else {
            return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));
        }
    };
    return SkipLastOperator;
}());
var SkipLastSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](SkipLastSubscriber, _super);
    function SkipLastSubscriber(destination, _skipCount) {
        var _this = _super.call(this, destination) || this;
        _this._skipCount = _skipCount;
        _this._count = 0;
        _this._ring = new Array(_skipCount);
        return _this;
    }
    SkipLastSubscriber.prototype._next = function (value) {
        var skipCount = this._skipCount;
        var count = this._count++;
        if (count < skipCount) {
            this._ring[count] = value;
        }
        else {
            var currentIndex = count % skipCount;
            var ring = this._ring;
            var oldValue = ring[currentIndex];
            ring[currentIndex] = value;
            this.destination.next(oldValue);
        }
    };
    return SkipLastSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=skipLast.js.map


/***/ }),
/* 210 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "skipUntil", function() { return skipUntil; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(99);
/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */



function skipUntil(notifier) {
    return function (source) { return source.lift(new SkipUntilOperator(notifier)); };
}
var SkipUntilOperator = /*@__PURE__*/ (function () {
    function SkipUntilOperator(notifier) {
        this.notifier = notifier;
    }
    SkipUntilOperator.prototype.call = function (destination, source) {
        return source.subscribe(new SkipUntilSubscriber(destination, this.notifier));
    };
    return SkipUntilOperator;
}());
var SkipUntilSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](SkipUntilSubscriber, _super);
    function SkipUntilSubscriber(destination, notifier) {
        var _this = _super.call(this, destination) || this;
        _this.hasValue = false;
        _this.add(_this.innerSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(_this, notifier));
        return _this;
    }
    SkipUntilSubscriber.prototype._next = function (value) {
        if (this.hasValue) {
            _super.prototype._next.call(this, value);
        }
    };
    SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.hasValue = true;
        if (this.innerSubscription) {
            this.innerSubscription.unsubscribe();
        }
    };
    SkipUntilSubscriber.prototype.notifyComplete = function () {
    };
    return SkipUntilSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"]));
//# sourceMappingURL=skipUntil.js.map


/***/ }),
/* 211 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "skipWhile", function() { return skipWhile; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function skipWhile(predicate) {
    return function (source) { return source.lift(new SkipWhileOperator(predicate)); };
}
var SkipWhileOperator = /*@__PURE__*/ (function () {
    function SkipWhileOperator(predicate) {
        this.predicate = predicate;
    }
    SkipWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
    };
    return SkipWhileOperator;
}());
var SkipWhileSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](SkipWhileSubscriber, _super);
    function SkipWhileSubscriber(destination, predicate) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.skipping = true;
        _this.index = 0;
        return _this;
    }
    SkipWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (this.skipping) {
            this.tryCallPredicate(value);
        }
        if (!this.skipping) {
            destination.next(value);
        }
    };
    SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {
        try {
            var result = this.predicate(value, this.index++);
            this.skipping = Boolean(result);
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    return SkipWhileSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=skipWhile.js.map


/***/ }),
/* 212 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "startWith", function() { return startWith; });
/* harmony import */ var _observable_fromArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(75);
/* harmony import */ var _observable_scalar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(77);
/* harmony import */ var _observable_empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(72);
/* harmony import */ var _observable_concat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(108);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(74);
/** PURE_IMPORTS_START _observable_fromArray,_observable_scalar,_observable_empty,_observable_concat,_util_isScheduler PURE_IMPORTS_END */





function startWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        array[_i] = arguments[_i];
    }
    return function (source) {
        var scheduler = array[array.length - 1];
        if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_4__["isScheduler"])(scheduler)) {
            array.pop();
        }
        else {
            scheduler = null;
        }
        var len = array.length;
        if (len === 1 && !scheduler) {
            return Object(_observable_concat__WEBPACK_IMPORTED_MODULE_3__["concat"])(Object(_observable_scalar__WEBPACK_IMPORTED_MODULE_1__["scalar"])(array[0]), source);
        }
        else if (len > 0) {
            return Object(_observable_concat__WEBPACK_IMPORTED_MODULE_3__["concat"])(Object(_observable_fromArray__WEBPACK_IMPORTED_MODULE_0__["fromArray"])(array, scheduler), source);
        }
        else {
            return Object(_observable_concat__WEBPACK_IMPORTED_MODULE_3__["concat"])(Object(_observable_empty__WEBPACK_IMPORTED_MODULE_2__["empty"])(scheduler), source);
        }
    };
}
//# sourceMappingURL=startWith.js.map


/***/ }),
/* 213 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subscribeOn", function() { return subscribeOn; });
/* harmony import */ var _observable_SubscribeOnObservable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(214);
/** PURE_IMPORTS_START _observable_SubscribeOnObservable PURE_IMPORTS_END */

function subscribeOn(scheduler, delay) {
    if (delay === void 0) {
        delay = 0;
    }
    return function subscribeOnOperatorFunction(source) {
        return source.lift(new SubscribeOnOperator(scheduler, delay));
    };
}
var SubscribeOnOperator = /*@__PURE__*/ (function () {
    function SubscribeOnOperator(scheduler, delay) {
        this.scheduler = scheduler;
        this.delay = delay;
    }
    SubscribeOnOperator.prototype.call = function (subscriber, source) {
        return new _observable_SubscribeOnObservable__WEBPACK_IMPORTED_MODULE_0__["SubscribeOnObservable"](source, this.delay, this.scheduler).subscribe(subscriber);
    };
    return SubscribeOnOperator;
}());
//# sourceMappingURL=subscribeOn.js.map


/***/ }),
/* 214 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubscribeOnObservable", function() { return SubscribeOnObservable; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(37);
/* harmony import */ var _scheduler_asap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(80);
/* harmony import */ var _util_isNumeric__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(125);
/** PURE_IMPORTS_START tslib,_Observable,_scheduler_asap,_util_isNumeric PURE_IMPORTS_END */




var SubscribeOnObservable = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](SubscribeOnObservable, _super);
    function SubscribeOnObservable(source, delayTime, scheduler) {
        if (delayTime === void 0) {
            delayTime = 0;
        }
        if (scheduler === void 0) {
            scheduler = _scheduler_asap__WEBPACK_IMPORTED_MODULE_2__["asap"];
        }
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.delayTime = delayTime;
        _this.scheduler = scheduler;
        if (!Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_3__["isNumeric"])(delayTime) || delayTime < 0) {
            _this.delayTime = 0;
        }
        if (!scheduler || typeof scheduler.schedule !== 'function') {
            _this.scheduler = _scheduler_asap__WEBPACK_IMPORTED_MODULE_2__["asap"];
        }
        return _this;
    }
    SubscribeOnObservable.create = function (source, delay, scheduler) {
        if (delay === void 0) {
            delay = 0;
        }
        if (scheduler === void 0) {
            scheduler = _scheduler_asap__WEBPACK_IMPORTED_MODULE_2__["asap"];
        }
        return new SubscribeOnObservable(source, delay, scheduler);
    };
    SubscribeOnObservable.dispatch = function (arg) {
        var source = arg.source, subscriber = arg.subscriber;
        return this.add(source.subscribe(subscriber));
    };
    SubscribeOnObservable.prototype._subscribe = function (subscriber) {
        var delay = this.delayTime;
        var source = this.source;
        var scheduler = this.scheduler;
        return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {
            source: source, subscriber: subscriber
        });
    };
    return SubscribeOnObservable;
}(_Observable__WEBPACK_IMPORTED_MODULE_1__["Observable"]));

//# sourceMappingURL=SubscribeOnObservable.js.map


/***/ }),
/* 215 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "switchAll", function() { return switchAll; });
/* harmony import */ var _switchMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(216);
/* harmony import */ var _util_identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(89);
/** PURE_IMPORTS_START _switchMap,_util_identity PURE_IMPORTS_END */


function switchAll() {
    return Object(_switchMap__WEBPACK_IMPORTED_MODULE_0__["switchMap"])(_util_identity__WEBPACK_IMPORTED_MODULE_1__["identity"]);
}
//# sourceMappingURL=switchAll.js.map


/***/ }),
/* 216 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "switchMap", function() { return switchMap; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(99);
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(95);
/* harmony import */ var _observable_from__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(109);
/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */





function switchMap(project, resultSelector) {
    if (typeof resultSelector === 'function') {
        return function (source) { return source.pipe(switchMap(function (a, i) { return Object(_observable_from__WEBPACK_IMPORTED_MODULE_4__["from"])(project(a, i)).pipe(Object(_map__WEBPACK_IMPORTED_MODULE_3__["map"])(function (b, ii) { return resultSelector(a, b, i, ii); })); })); };
    }
    return function (source) { return source.lift(new SwitchMapOperator(project)); };
}
var SwitchMapOperator = /*@__PURE__*/ (function () {
    function SwitchMapOperator(project) {
        this.project = project;
    }
    SwitchMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
    };
    return SwitchMapOperator;
}());
var SwitchMapSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](SwitchMapSubscriber, _super);
    function SwitchMapSubscriber(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.index = 0;
        return _this;
    }
    SwitchMapSubscriber.prototype._next = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (error) {
            this.destination.error(error);
            return;
        }
        this._innerSub(result, value, index);
    };
    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        this.add(this.innerSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(this, result, value, index));
    };
    SwitchMapSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = null;
    };
    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.innerSubscription = null;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    return SwitchMapSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"]));
//# sourceMappingURL=switchMap.js.map


/***/ }),
/* 217 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "switchMapTo", function() { return switchMapTo; });
/* harmony import */ var _switchMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(216);
/** PURE_IMPORTS_START _switchMap PURE_IMPORTS_END */

function switchMapTo(innerObservable, resultSelector) {
    return resultSelector ? Object(_switchMap__WEBPACK_IMPORTED_MODULE_0__["switchMap"])(function () { return innerObservable; }, resultSelector) : Object(_switchMap__WEBPACK_IMPORTED_MODULE_0__["switchMap"])(function () { return innerObservable; });
}
//# sourceMappingURL=switchMapTo.js.map


/***/ }),
/* 218 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "takeUntil", function() { return takeUntil; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(99);
/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */



function takeUntil(notifier) {
    return function (source) { return source.lift(new TakeUntilOperator(notifier)); };
}
var TakeUntilOperator = /*@__PURE__*/ (function () {
    function TakeUntilOperator(notifier) {
        this.notifier = notifier;
    }
    TakeUntilOperator.prototype.call = function (subscriber, source) {
        var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
        var notifierSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(takeUntilSubscriber, this.notifier);
        if (notifierSubscription && !notifierSubscription.closed) {
            takeUntilSubscriber.add(notifierSubscription);
            return source.subscribe(takeUntilSubscriber);
        }
        return takeUntilSubscriber;
    };
    return TakeUntilOperator;
}());
var TakeUntilSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](TakeUntilSubscriber, _super);
    function TakeUntilSubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.complete();
    };
    TakeUntilSubscriber.prototype.notifyComplete = function () {
    };
    return TakeUntilSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"]));
//# sourceMappingURL=takeUntil.js.map


/***/ }),
/* 219 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "takeWhile", function() { return takeWhile; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function takeWhile(predicate) {
    return function (source) { return source.lift(new TakeWhileOperator(predicate)); };
}
var TakeWhileOperator = /*@__PURE__*/ (function () {
    function TakeWhileOperator(predicate) {
        this.predicate = predicate;
    }
    TakeWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate));
    };
    return TakeWhileOperator;
}());
var TakeWhileSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](TakeWhileSubscriber, _super);
    function TakeWhileSubscriber(destination, predicate) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.index = 0;
        return _this;
    }
    TakeWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        var result;
        try {
            result = this.predicate(value, this.index++);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this.nextOrComplete(value, result);
    };
    TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {
        var destination = this.destination;
        if (Boolean(predicateResult)) {
            destination.next(value);
        }
        else {
            destination.complete();
        }
    };
    return TakeWhileSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=takeWhile.js.map


/***/ }),
/* 220 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultThrottleConfig", function() { return defaultThrottleConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "throttle", function() { return throttle; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(99);
/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */



var defaultThrottleConfig = {
    leading: true,
    trailing: false
};
function throttle(durationSelector, config) {
    if (config === void 0) {
        config = defaultThrottleConfig;
    }
    return function (source) { return source.lift(new ThrottleOperator(durationSelector, config.leading, config.trailing)); };
}
var ThrottleOperator = /*@__PURE__*/ (function () {
    function ThrottleOperator(durationSelector, leading, trailing) {
        this.durationSelector = durationSelector;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
    };
    return ThrottleOperator;
}());
var ThrottleSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](ThrottleSubscriber, _super);
    function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.durationSelector = durationSelector;
        _this._leading = _leading;
        _this._trailing = _trailing;
        _this._hasValue = false;
        return _this;
    }
    ThrottleSubscriber.prototype._next = function (value) {
        this._hasValue = true;
        this._sendValue = value;
        if (!this._throttled) {
            if (this._leading) {
                this.send();
            }
            else {
                this.throttle(value);
            }
        }
    };
    ThrottleSubscriber.prototype.send = function () {
        var _a = this, _hasValue = _a._hasValue, _sendValue = _a._sendValue;
        if (_hasValue) {
            this.destination.next(_sendValue);
            this.throttle(_sendValue);
        }
        this._hasValue = false;
        this._sendValue = null;
    };
    ThrottleSubscriber.prototype.throttle = function (value) {
        var duration = this.tryDurationSelector(value);
        if (duration) {
            this.add(this._throttled = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(this, duration));
        }
    };
    ThrottleSubscriber.prototype.tryDurationSelector = function (value) {
        try {
            return this.durationSelector(value);
        }
        catch (err) {
            this.destination.error(err);
            return null;
        }
    };
    ThrottleSubscriber.prototype.throttlingDone = function () {
        var _a = this, _throttled = _a._throttled, _trailing = _a._trailing;
        if (_throttled) {
            _throttled.unsubscribe();
        }
        this._throttled = null;
        if (_trailing) {
            this.send();
        }
    };
    ThrottleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.throttlingDone();
    };
    ThrottleSubscriber.prototype.notifyComplete = function () {
        this.throttlingDone();
    };
    return ThrottleSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"]));
//# sourceMappingURL=throttle.js.map


/***/ }),
/* 221 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "throttleTime", function() { return throttleTime; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(84);
/* harmony import */ var _throttle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(220);
/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async,_throttle PURE_IMPORTS_END */




function throttleTime(duration, scheduler, config) {
    if (scheduler === void 0) {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_2__["async"];
    }
    if (config === void 0) {
        config = _throttle__WEBPACK_IMPORTED_MODULE_3__["defaultThrottleConfig"];
    }
    return function (source) { return source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing)); };
}
var ThrottleTimeOperator = /*@__PURE__*/ (function () {
    function ThrottleTimeOperator(duration, scheduler, leading, trailing) {
        this.duration = duration;
        this.scheduler = scheduler;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
    };
    return ThrottleTimeOperator;
}());
var ThrottleTimeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](ThrottleTimeSubscriber, _super);
    function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {
        var _this = _super.call(this, destination) || this;
        _this.duration = duration;
        _this.scheduler = scheduler;
        _this.leading = leading;
        _this.trailing = trailing;
        _this._hasTrailingValue = false;
        _this._trailingValue = null;
        return _this;
    }
    ThrottleTimeSubscriber.prototype._next = function (value) {
        if (this.throttled) {
            if (this.trailing) {
                this._trailingValue = value;
                this._hasTrailingValue = true;
            }
        }
        else {
            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));
            if (this.leading) {
                this.destination.next(value);
            }
        }
    };
    ThrottleTimeSubscriber.prototype._complete = function () {
        if (this._hasTrailingValue) {
            this.destination.next(this._trailingValue);
            this.destination.complete();
        }
        else {
            this.destination.complete();
        }
    };
    ThrottleTimeSubscriber.prototype.clearThrottle = function () {
        var throttled = this.throttled;
        if (throttled) {
            if (this.trailing && this._hasTrailingValue) {
                this.destination.next(this._trailingValue);
                this._trailingValue = null;
                this._hasTrailingValue = false;
            }
            throttled.unsubscribe();
            this.remove(throttled);
            this.throttled = null;
        }
    };
    return ThrottleTimeSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
function dispatchNext(arg) {
    var subscriber = arg.subscriber;
    subscriber.clearThrottle();
}
//# sourceMappingURL=throttleTime.js.map


/***/ }),
/* 222 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timeInterval", function() { return timeInterval; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimeInterval", function() { return TimeInterval; });
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(84);
/* harmony import */ var _scan__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(182);
/* harmony import */ var _observable_defer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(118);
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(95);
/** PURE_IMPORTS_START _scheduler_async,_scan,_observable_defer,_map PURE_IMPORTS_END */




function timeInterval(scheduler) {
    if (scheduler === void 0) {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_0__["async"];
    }
    return function (source) {
        return Object(_observable_defer__WEBPACK_IMPORTED_MODULE_2__["defer"])(function () {
            return source.pipe(Object(_scan__WEBPACK_IMPORTED_MODULE_1__["scan"])(function (_a, value) {
                var current = _a.current;
                return ({ value: value, current: scheduler.now(), last: current });
            }, { current: scheduler.now(), value: undefined, last: undefined }), Object(_map__WEBPACK_IMPORTED_MODULE_3__["map"])(function (_a) {
                var current = _a.current, last = _a.last, value = _a.value;
                return new TimeInterval(value, current - last);
            }));
        });
    };
}
var TimeInterval = /*@__PURE__*/ (function () {
    function TimeInterval(value, interval) {
        this.value = value;
        this.interval = interval;
    }
    return TimeInterval;
}());

//# sourceMappingURL=timeInterval.js.map


/***/ }),
/* 223 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timeout", function() { return timeout; });
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(84);
/* harmony import */ var _util_TimeoutError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(93);
/* harmony import */ var _timeoutWith__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(224);
/* harmony import */ var _observable_throwError__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(78);
/** PURE_IMPORTS_START _scheduler_async,_util_TimeoutError,_timeoutWith,_observable_throwError PURE_IMPORTS_END */




function timeout(due, scheduler) {
    if (scheduler === void 0) {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_0__["async"];
    }
    return Object(_timeoutWith__WEBPACK_IMPORTED_MODULE_2__["timeoutWith"])(due, Object(_observable_throwError__WEBPACK_IMPORTED_MODULE_3__["throwError"])(new _util_TimeoutError__WEBPACK_IMPORTED_MODULE_1__["TimeoutError"]()), scheduler);
}
//# sourceMappingURL=timeout.js.map


/***/ }),
/* 224 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timeoutWith", function() { return timeoutWith; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(84);
/* harmony import */ var _util_isDate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(154);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(98);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(99);
/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */





function timeoutWith(due, withObservable, scheduler) {
    if (scheduler === void 0) {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__["async"];
    }
    return function (source) {
        var absoluteTimeout = Object(_util_isDate__WEBPACK_IMPORTED_MODULE_2__["isDate"])(due);
        var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);
        return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
    };
}
var TimeoutWithOperator = /*@__PURE__*/ (function () {
    function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {
        this.waitFor = waitFor;
        this.absoluteTimeout = absoluteTimeout;
        this.withObservable = withObservable;
        this.scheduler = scheduler;
    }
    TimeoutWithOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
    };
    return TimeoutWithOperator;
}());
var TimeoutWithSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](TimeoutWithSubscriber, _super);
    function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.absoluteTimeout = absoluteTimeout;
        _this.waitFor = waitFor;
        _this.withObservable = withObservable;
        _this.scheduler = scheduler;
        _this.action = null;
        _this.scheduleTimeout();
        return _this;
    }
    TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {
        var withObservable = subscriber.withObservable;
        subscriber._unsubscribeAndRecycle();
        subscriber.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__["subscribeToResult"])(subscriber, withObservable));
    };
    TimeoutWithSubscriber.prototype.scheduleTimeout = function () {
        var action = this.action;
        if (action) {
            this.action = action.schedule(this, this.waitFor);
        }
        else {
            this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));
        }
    };
    TimeoutWithSubscriber.prototype._next = function (value) {
        if (!this.absoluteTimeout) {
            this.scheduleTimeout();
        }
        _super.prototype._next.call(this, value);
    };
    TimeoutWithSubscriber.prototype._unsubscribe = function () {
        this.action = null;
        this.scheduler = null;
        this.withObservable = null;
    };
    return TimeoutWithSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__["OuterSubscriber"]));
//# sourceMappingURL=timeoutWith.js.map


/***/ }),
/* 225 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timestamp", function() { return timestamp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Timestamp", function() { return Timestamp; });
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(84);
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(95);
/** PURE_IMPORTS_START _scheduler_async,_map PURE_IMPORTS_END */


function timestamp(scheduler) {
    if (scheduler === void 0) {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_0__["async"];
    }
    return Object(_map__WEBPACK_IMPORTED_MODULE_1__["map"])(function (value) { return new Timestamp(value, scheduler.now()); });
}
var Timestamp = /*@__PURE__*/ (function () {
    function Timestamp(value, timestamp) {
        this.value = value;
        this.timestamp = timestamp;
    }
    return Timestamp;
}());

//# sourceMappingURL=timestamp.js.map


/***/ }),
/* 226 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toArray", function() { return toArray; });
/* harmony import */ var _reduce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(181);
/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */

function toArrayReducer(arr, item, index) {
    if (index === 0) {
        return [item];
    }
    arr.push(item);
    return arr;
}
function toArray() {
    return Object(_reduce__WEBPACK_IMPORTED_MODULE_0__["reduce"])(toArrayReducer, []);
}
//# sourceMappingURL=toArray.js.map


/***/ }),
/* 227 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "window", function() { return window; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(99);
/** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */




function window(windowBoundaries) {
    return function windowOperatorFunction(source) {
        return source.lift(new WindowOperator(windowBoundaries));
    };
}
var WindowOperator = /*@__PURE__*/ (function () {
    function WindowOperator(windowBoundaries) {
        this.windowBoundaries = windowBoundaries;
    }
    WindowOperator.prototype.call = function (subscriber, source) {
        var windowSubscriber = new WindowSubscriber(subscriber);
        var sourceSubscription = source.subscribe(windowSubscriber);
        if (!sourceSubscription.closed) {
            windowSubscriber.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__["subscribeToResult"])(windowSubscriber, this.windowBoundaries));
        }
        return sourceSubscription;
    };
    return WindowOperator;
}());
var WindowSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](WindowSubscriber, _super);
    function WindowSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.window = new _Subject__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
        destination.next(_this.window);
        return _this;
    }
    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openWindow();
    };
    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
        this._complete();
    };
    WindowSubscriber.prototype._next = function (value) {
        this.window.next(value);
    };
    WindowSubscriber.prototype._error = function (err) {
        this.window.error(err);
        this.destination.error(err);
    };
    WindowSubscriber.prototype._complete = function () {
        this.window.complete();
        this.destination.complete();
    };
    WindowSubscriber.prototype._unsubscribe = function () {
        this.window = null;
    };
    WindowSubscriber.prototype.openWindow = function () {
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        var destination = this.destination;
        var newWindow = this.window = new _Subject__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
        destination.next(newWindow);
    };
    return WindowSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__["OuterSubscriber"]));
//# sourceMappingURL=window.js.map


/***/ }),
/* 228 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "windowCount", function() { return windowCount; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(56);
/** PURE_IMPORTS_START tslib,_Subscriber,_Subject PURE_IMPORTS_END */



function windowCount(windowSize, startWindowEvery) {
    if (startWindowEvery === void 0) {
        startWindowEvery = 0;
    }
    return function windowCountOperatorFunction(source) {
        return source.lift(new WindowCountOperator(windowSize, startWindowEvery));
    };
}
var WindowCountOperator = /*@__PURE__*/ (function () {
    function WindowCountOperator(windowSize, startWindowEvery) {
        this.windowSize = windowSize;
        this.startWindowEvery = startWindowEvery;
    }
    WindowCountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
    };
    return WindowCountOperator;
}());
var WindowCountSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](WindowCountSubscriber, _super);
    function WindowCountSubscriber(destination, windowSize, startWindowEvery) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.windowSize = windowSize;
        _this.startWindowEvery = startWindowEvery;
        _this.windows = [new _Subject__WEBPACK_IMPORTED_MODULE_2__["Subject"]()];
        _this.count = 0;
        destination.next(_this.windows[0]);
        return _this;
    }
    WindowCountSubscriber.prototype._next = function (value) {
        var startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;
        var destination = this.destination;
        var windowSize = this.windowSize;
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len && !this.closed; i++) {
            windows[i].next(value);
        }
        var c = this.count - windowSize + 1;
        if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {
            windows.shift().complete();
        }
        if (++this.count % startWindowEvery === 0 && !this.closed) {
            var window_1 = new _Subject__WEBPACK_IMPORTED_MODULE_2__["Subject"]();
            windows.push(window_1);
            destination.next(window_1);
        }
    };
    WindowCountSubscriber.prototype._error = function (err) {
        var windows = this.windows;
        if (windows) {
            while (windows.length > 0 && !this.closed) {
                windows.shift().error(err);
            }
        }
        this.destination.error(err);
    };
    WindowCountSubscriber.prototype._complete = function () {
        var windows = this.windows;
        if (windows) {
            while (windows.length > 0 && !this.closed) {
                windows.shift().complete();
            }
        }
        this.destination.complete();
    };
    WindowCountSubscriber.prototype._unsubscribe = function () {
        this.count = 0;
        this.windows = null;
    };
    return WindowCountSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=windowCount.js.map


/***/ }),
/* 229 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "windowTime", function() { return windowTime; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56);
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(84);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(39);
/* harmony import */ var _util_isNumeric__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(125);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(74);
/** PURE_IMPORTS_START tslib,_Subject,_scheduler_async,_Subscriber,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */






function windowTime(windowTimeSpan) {
    var scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_2__["async"];
    var windowCreationInterval = null;
    var maxWindowSize = Number.POSITIVE_INFINITY;
    if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_5__["isScheduler"])(arguments[3])) {
        scheduler = arguments[3];
    }
    if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_5__["isScheduler"])(arguments[2])) {
        scheduler = arguments[2];
    }
    else if (Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_4__["isNumeric"])(arguments[2])) {
        maxWindowSize = arguments[2];
    }
    if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_5__["isScheduler"])(arguments[1])) {
        scheduler = arguments[1];
    }
    else if (Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_4__["isNumeric"])(arguments[1])) {
        windowCreationInterval = arguments[1];
    }
    return function windowTimeOperatorFunction(source) {
        return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));
    };
}
var WindowTimeOperator = /*@__PURE__*/ (function () {
    function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        this.windowTimeSpan = windowTimeSpan;
        this.windowCreationInterval = windowCreationInterval;
        this.maxWindowSize = maxWindowSize;
        this.scheduler = scheduler;
    }
    WindowTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
    };
    return WindowTimeOperator;
}());
var CountedSubject = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](CountedSubject, _super);
    function CountedSubject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._numberOfNextedValues = 0;
        return _this;
    }
    CountedSubject.prototype.next = function (value) {
        this._numberOfNextedValues++;
        _super.prototype.next.call(this, value);
    };
    Object.defineProperty(CountedSubject.prototype, "numberOfNextedValues", {
        get: function () {
            return this._numberOfNextedValues;
        },
        enumerable: true,
        configurable: true
    });
    return CountedSubject;
}(_Subject__WEBPACK_IMPORTED_MODULE_1__["Subject"]));
var WindowTimeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](WindowTimeSubscriber, _super);
    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.windowTimeSpan = windowTimeSpan;
        _this.windowCreationInterval = windowCreationInterval;
        _this.maxWindowSize = maxWindowSize;
        _this.scheduler = scheduler;
        _this.windows = [];
        var window = _this.openWindow();
        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
            var closeState = { subscriber: _this, window: window, context: null };
            var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: _this, scheduler: scheduler };
            _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
            _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
        }
        else {
            var timeSpanOnlyState = { subscriber: _this, window: window, windowTimeSpan: windowTimeSpan };
            _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
        }
        return _this;
    }
    WindowTimeSubscriber.prototype._next = function (value) {
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len; i++) {
            var window_1 = windows[i];
            if (!window_1.closed) {
                window_1.next(value);
                if (window_1.numberOfNextedValues >= this.maxWindowSize) {
                    this.closeWindow(window_1);
                }
            }
        }
    };
    WindowTimeSubscriber.prototype._error = function (err) {
        var windows = this.windows;
        while (windows.length > 0) {
            windows.shift().error(err);
        }
        this.destination.error(err);
    };
    WindowTimeSubscriber.prototype._complete = function () {
        var windows = this.windows;
        while (windows.length > 0) {
            var window_2 = windows.shift();
            if (!window_2.closed) {
                window_2.complete();
            }
        }
        this.destination.complete();
    };
    WindowTimeSubscriber.prototype.openWindow = function () {
        var window = new CountedSubject();
        this.windows.push(window);
        var destination = this.destination;
        destination.next(window);
        return window;
    };
    WindowTimeSubscriber.prototype.closeWindow = function (window) {
        window.complete();
        var windows = this.windows;
        windows.splice(windows.indexOf(window), 1);
    };
    return WindowTimeSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_3__["Subscriber"]));
function dispatchWindowTimeSpanOnly(state) {
    var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window = state.window;
    if (window) {
        subscriber.closeWindow(window);
    }
    state.window = subscriber.openWindow();
    this.schedule(state, windowTimeSpan);
}
function dispatchWindowCreation(state) {
    var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;
    var window = subscriber.openWindow();
    var action = this;
    var context = { action: action, subscription: null };
    var timeSpanState = { subscriber: subscriber, window: window, context: context };
    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
    action.add(context.subscription);
    action.schedule(state, windowCreationInterval);
}
function dispatchWindowClose(state) {
    var subscriber = state.subscriber, window = state.window, context = state.context;
    if (context && context.action && context.subscription) {
        context.action.remove(context.subscription);
    }
    subscriber.closeWindow(window);
}
//# sourceMappingURL=windowTime.js.map


/***/ }),
/* 230 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "windowToggle", function() { return windowToggle; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(45);
/* harmony import */ var _util_tryCatch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(48);
/* harmony import */ var _util_errorObject__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(49);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(98);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(99);
/** PURE_IMPORTS_START tslib,_Subject,_Subscription,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */







function windowToggle(openings, closingSelector) {
    return function (source) { return source.lift(new WindowToggleOperator(openings, closingSelector)); };
}
var WindowToggleOperator = /*@__PURE__*/ (function () {
    function WindowToggleOperator(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
    }
    WindowToggleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
    };
    return WindowToggleOperator;
}());
var WindowToggleSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](WindowToggleSubscriber, _super);
    function WindowToggleSubscriber(destination, openings, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.openings = openings;
        _this.closingSelector = closingSelector;
        _this.contexts = [];
        _this.add(_this.openSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_6__["subscribeToResult"])(_this, openings, openings));
        return _this;
    }
    WindowToggleSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        if (contexts) {
            var len = contexts.length;
            for (var i = 0; i < len; i++) {
                contexts[i].window.next(value);
            }
        }
    };
    WindowToggleSubscriber.prototype._error = function (err) {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context_1 = contexts[index];
                context_1.window.error(err);
                context_1.subscription.unsubscribe();
            }
        }
        _super.prototype._error.call(this, err);
    };
    WindowToggleSubscriber.prototype._complete = function () {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context_2 = contexts[index];
                context_2.window.complete();
                context_2.subscription.unsubscribe();
            }
        }
        _super.prototype._complete.call(this);
    };
    WindowToggleSubscriber.prototype._unsubscribe = function () {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context_3 = contexts[index];
                context_3.window.unsubscribe();
                context_3.subscription.unsubscribe();
            }
        }
    };
    WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (outerValue === this.openings) {
            var closingSelector = this.closingSelector;
            var closingNotifier = Object(_util_tryCatch__WEBPACK_IMPORTED_MODULE_3__["tryCatch"])(closingSelector)(innerValue);
            if (closingNotifier === _util_errorObject__WEBPACK_IMPORTED_MODULE_4__["errorObject"]) {
                return this.error(_util_errorObject__WEBPACK_IMPORTED_MODULE_4__["errorObject"].e);
            }
            else {
                var window_1 = new _Subject__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
                var subscription = new _Subscription__WEBPACK_IMPORTED_MODULE_2__["Subscription"]();
                var context_4 = { window: window_1, subscription: subscription };
                this.contexts.push(context_4);
                var innerSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_6__["subscribeToResult"])(this, closingNotifier, context_4);
                if (innerSubscription.closed) {
                    this.closeWindow(this.contexts.length - 1);
                }
                else {
                    innerSubscription.context = context_4;
                    subscription.add(innerSubscription);
                }
                this.destination.next(window_1);
            }
        }
        else {
            this.closeWindow(this.contexts.indexOf(outerValue));
        }
    };
    WindowToggleSubscriber.prototype.notifyError = function (err) {
        this.error(err);
    };
    WindowToggleSubscriber.prototype.notifyComplete = function (inner) {
        if (inner !== this.openSubscription) {
            this.closeWindow(this.contexts.indexOf(inner.context));
        }
    };
    WindowToggleSubscriber.prototype.closeWindow = function (index) {
        if (index === -1) {
            return;
        }
        var contexts = this.contexts;
        var context = contexts[index];
        var window = context.window, subscription = context.subscription;
        contexts.splice(index, 1);
        window.complete();
        subscription.unsubscribe();
    };
    return WindowToggleSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_5__["OuterSubscriber"]));
//# sourceMappingURL=windowToggle.js.map


/***/ }),
/* 231 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "windowWhen", function() { return windowWhen; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56);
/* harmony import */ var _util_tryCatch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(48);
/* harmony import */ var _util_errorObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(49);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(98);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(99);
/** PURE_IMPORTS_START tslib,_Subject,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */






function windowWhen(closingSelector) {
    return function windowWhenOperatorFunction(source) {
        return source.lift(new WindowOperator(closingSelector));
    };
}
var WindowOperator = /*@__PURE__*/ (function () {
    function WindowOperator(closingSelector) {
        this.closingSelector = closingSelector;
    }
    WindowOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));
    };
    return WindowOperator;
}());
var WindowSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](WindowSubscriber, _super);
    function WindowSubscriber(destination, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.closingSelector = closingSelector;
        _this.openWindow();
        return _this;
    }
    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openWindow(innerSub);
    };
    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
        this.openWindow(innerSub);
    };
    WindowSubscriber.prototype._next = function (value) {
        this.window.next(value);
    };
    WindowSubscriber.prototype._error = function (err) {
        this.window.error(err);
        this.destination.error(err);
        this.unsubscribeClosingNotification();
    };
    WindowSubscriber.prototype._complete = function () {
        this.window.complete();
        this.destination.complete();
        this.unsubscribeClosingNotification();
    };
    WindowSubscriber.prototype.unsubscribeClosingNotification = function () {
        if (this.closingNotification) {
            this.closingNotification.unsubscribe();
        }
    };
    WindowSubscriber.prototype.openWindow = function (innerSub) {
        if (innerSub === void 0) {
            innerSub = null;
        }
        if (innerSub) {
            this.remove(innerSub);
            innerSub.unsubscribe();
        }
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        var window = this.window = new _Subject__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
        this.destination.next(window);
        var closingNotifier = Object(_util_tryCatch__WEBPACK_IMPORTED_MODULE_2__["tryCatch"])(this.closingSelector)();
        if (closingNotifier === _util_errorObject__WEBPACK_IMPORTED_MODULE_3__["errorObject"]) {
            var err = _util_errorObject__WEBPACK_IMPORTED_MODULE_3__["errorObject"].e;
            this.destination.error(err);
            this.window.error(err);
        }
        else {
            this.add(this.closingNotification = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_5__["subscribeToResult"])(this, closingNotifier));
        }
    };
    return WindowSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_4__["OuterSubscriber"]));
//# sourceMappingURL=windowWhen.js.map


/***/ }),
/* 232 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "withLatestFrom", function() { return withLatestFrom; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(99);
/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */



function withLatestFrom() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return function (source) {
        var project;
        if (typeof args[args.length - 1] === 'function') {
            project = args.pop();
        }
        var observables = args;
        return source.lift(new WithLatestFromOperator(observables, project));
    };
}
var WithLatestFromOperator = /*@__PURE__*/ (function () {
    function WithLatestFromOperator(observables, project) {
        this.observables = observables;
        this.project = project;
    }
    WithLatestFromOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
    };
    return WithLatestFromOperator;
}());
var WithLatestFromSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](WithLatestFromSubscriber, _super);
    function WithLatestFromSubscriber(destination, observables, project) {
        var _this = _super.call(this, destination) || this;
        _this.observables = observables;
        _this.project = project;
        _this.toRespond = [];
        var len = observables.length;
        _this.values = new Array(len);
        for (var i = 0; i < len; i++) {
            _this.toRespond.push(i);
        }
        for (var i = 0; i < len; i++) {
            var observable = observables[i];
            _this.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(_this, observable, observable, i));
        }
        return _this;
    }
    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values[outerIndex] = innerValue;
        var toRespond = this.toRespond;
        if (toRespond.length > 0) {
            var found = toRespond.indexOf(outerIndex);
            if (found !== -1) {
                toRespond.splice(found, 1);
            }
        }
    };
    WithLatestFromSubscriber.prototype.notifyComplete = function () {
    };
    WithLatestFromSubscriber.prototype._next = function (value) {
        if (this.toRespond.length === 0) {
            var args = [value].concat(this.values);
            if (this.project) {
                this._tryProject(args);
            }
            else {
                this.destination.next(args);
            }
        }
    };
    WithLatestFromSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return WithLatestFromSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"]));
//# sourceMappingURL=withLatestFrom.js.map


/***/ }),
/* 233 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zip", function() { return zip; });
/* harmony import */ var _observable_zip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(134);
/** PURE_IMPORTS_START _observable_zip PURE_IMPORTS_END */

function zip() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return function zipOperatorFunction(source) {
        return source.lift.call(_observable_zip__WEBPACK_IMPORTED_MODULE_0__["zip"].apply(void 0, [source].concat(observables)));
    };
}
//# sourceMappingURL=zip.js.map


/***/ }),
/* 234 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zipAll", function() { return zipAll; });
/* harmony import */ var _observable_zip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(134);
/** PURE_IMPORTS_START _observable_zip PURE_IMPORTS_END */

function zipAll(project) {
    return function (source) { return source.lift(new _observable_zip__WEBPACK_IMPORTED_MODULE_0__["ZipOperator"](project)); };
}
//# sourceMappingURL=zipAll.js.map


/***/ }),
/* 235 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);
/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Util__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(36);
/* harmony import */ var zepto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6);
/* harmony import */ var zepto__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(zepto__WEBPACK_IMPORTED_MODULE_2__);





function EventsObservable(mgr, confrId, onRemoteStream) {
    this.mgr = mgr;
    this.confrId = confrId;
    init.apply(this);
    this.subject = new rxjs__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
    this.onRemoteStream = onRemoteStream;
}

function init() {
    _Util__WEBPACK_IMPORTED_MODULE_0___default.a.extend(this, {
        subscribe: function subscribe(observerOrNext, error, complete) {
            return this.subject.subscribe(observerOrNext, error, complete);
        }
    }, { //以下监听，this object == me == service.current
        onMeExit: function onMeExit(reason, failed) {
            this.mgr._onExit(this.confrId, reason, failed);
        },

        onAddMember: function onAddMember(member) {
            this.mgr.onMemberJoin(member, this.confrId);
        },
        onRemoveMember: function onRemoveMember(member, reason) {
            this.mgr.onMemberLeave(member, reason, this.confrId);
        },

        onAddStream: function onAddStream(stream) {
            if (stream.id == 0) {
                return;
            }
            if (!stream.located()) {
                this.onRemoteStream && this.onRemoteStream(stream);
            }

            this.mgr.streamBindVideo(stream, undefined, this.confrId);
            this.mgr._onAddMemberStream(stream, this.confrId);
        },
        onRemoveStream: function onRemoveStream(stream) {
            if (stream.id == 0) {
                return;
            }

            var confr = this.mgr._confr(this.confrId);
            if (confr && stream && stream.located()) {
                confr.av && confr.av.id === stream.id && (confr.av = undefined);
                confr.desktop && confr.desktop.id === stream.id && (confr.desktop = undefined);
            }

            var video = _Util__WEBPACK_IMPORTED_MODULE_0___default.a.removeAttribute(this.mgr._videos, stream.id);
            this.mgr._onRemoveMemberStream(stream, this.confrId);
            video && this.mgr.unloadVideo(stream.owner, stream, video);
        },
        onUpdateStream: function onUpdateStream(stream, update) {
            if (stream.id == 0) {
                return;
            }

            var self = this;

            var videoTag = this.mgr._videos[stream.id];
            if (videoTag) {
                update && update.ifMediaStream(function (mediaStream) {
                    videoTag && attachMediaStream(videoTag, mediaStream);

                    if (videoTag && videoTag.hasAttribute("flow")) {
                        self.mgr.onMediaTransmission(videoTag, function cb(trackId, type, subtype, data) {
                            zepto__WEBPACK_IMPORTED_MODULE_2___default()(videoTag).trigger("onMediaTransmission", [trackId, type, subtype, data]);
                        });
                    }
                });

                stream.aoff ? videoTag.setAttribute("aoff", "aoff") : videoTag.removeAttribute("aoff");
                stream.voff ? videoTag.setAttribute("voff", "voff") : videoTag.removeAttribute("voff");
            }

            var constaints = { video: !stream.voff, audio: !stream.aoff };
            update && update.ifVoff(function (voff) {
                constaints || (constaints = {});
                constaints.video = !voff;
                if (!stream.located()) {
                    //constaints.video = constaints.video && (!stream.subArgs ||(stream.subArgs && stream.subArgs.subSVideo));
                    constaints.video = stream.subArgs ? stream.subArgs.subSVideo : !stream.voff;
                }
            });
            update && update.ifAoff(function (aoff) {
                constaints || (constaints = {});
                constaints.audio = !aoff;
                if (!stream.located()) {
                    //constaints.audio = constaints.audio && (!stream.subArgs ||(stream.subArgs && stream.subArgs.subSAudio));
                    constaints.audio = stream.subArgs ? stream.subArgs.subSAudio : !stream.aoff;

                    if (stream.type === 2) {
                        constaints.audio = true;
                    }
                }
            });

            constaints && this.mgr._onMemberMediaChanaged(stream.owner, stream, constaints, this.confrId);
            constaints && this.mgr._onUpdateMemberStream(stream, constaints, this.confrId);
        },
        onNetworkWeak: function onNetworkWeak() {},
        onNotSupportPublishVideoCodecs: function onNotSupportPublishVideoCodecs(stream) {
            this.mgr._onNotSupportMemberPublishVideoCodecs(stream, this.confrId);
        },
        onRecvRemoteMessage: function onRecvRemoteMessage(fromMember, argsObject) {
            this.mgr._onRecvRemoteMessage(fromMember, argsObject, this.confrId);
        },

        onSoundChanage: function onSoundChanage(member, stream, meterData) {
            this.mgr._onMemberSoundChanaged(member, stream, meterData, this.confrId);
        },
        onTalking: function onTalking(member, stream, meterData) {
            this.mgr._onTalking(member, stream, meterData, this.confrId);
        },

        onRoleUpdate: function onRoleUpdate(role, roleToken) {
            var confr = this.mgr._confrs[this.confrId];
            roleToken && (confr.roleToken = roleToken);
            confr.role = role;

            if (role == this.mgr.Role.AUDIENCE) {
                confr.av && this.mgr.hungup(confr.av);
                confr.desktop && this.mgr.hungup(confr.desktop);
            }

            this.mgr._onRoleUpdated(role, this.confrId);
        },

        onNotifyEvent: function onNotifyEvent(evt) {
            var self = this;

            try {
                if (evt instanceof emedia.event.ICEChanage) {
                    var webrtc = evt.webrtc;
                    var state = evt.state;
                    _Util__WEBPACK_IMPORTED_MODULE_0___default.a.forEach(self._cacheStreams, function (sid, stream) {
                        if (stream.rtcId == webrtc.getRtcId()) {

                            var _stream = _Util__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, stream);
                            var _member = _Util__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, stream.owner);

                            self.mgr._onStreamIceStateChanged(_member, _stream, state, self.confrId);
                        }
                    });
                }
            } finally {
                self.subject.next(evt);
            }
        }
    });
}

/* harmony default export */ __webpack_exports__["default"] = (EventsObservable);

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

var _util = __webpack_require__(15);
var _logger = _util.tagLogger("PannelVideo");

var Mouse = __webpack_require__(237);
var Keyboard = __webpack_require__(238);
var MouseTrack = __webpack_require__(31);
var MouseTrigger = __webpack_require__(32);
var TotalBuffer = __webpack_require__(239);

function overrideOnRemoveMember(service) {
    overrideOnRemoveMember._overrideCount++;
    if (overrideOnRemoveMember.overrideObj === service) {
        return;
    }

    overrideOnRemoveMember.overrideObj = service;
    onRemoveMember.override = service.listeners.onRemoveMember;
    service.listeners.onRemoveMember = onRemoveMember;
}
overrideOnRemoveMember._overrideCount = 0;

function onRemoveMember(member, reason) {
    try {
        var remoteControls = member && member.id && selectRemoteControlByMemId(this._service, member.id);

        if (remoteControls && remoteControls.length) {
            _util.forEach(remoteControls, function (_index, ctrl) {
                _logger.warn("Remove member. free remote controller. it is ", ctrl.id, ctrl._ctrlStream.id, ctrl._controller.memName, member.id);

                ctrl._free(); //超时清空

                ctrl._callbacks && ctrl._callbacks.onRemoteFreeControl && ctrl._callbacks.onRemoteFreeControl(ctrl._ctrlStream, ctrl._controller, ctrl._cId);
            });
        }
    } finally {
        onRemoveMember.override && onRemoveMember.override.apply(this, arguments);
    }
}

function overrideOnRemoveStream(service) {
    overrideOnRemoveStream._overrideCount++;
    if (overrideOnRemoveStream.overrideObj === service) {
        return;
    }

    overrideOnRemoveStream.overrideObj = service;
    onRemoveStream.override = service.listeners.onRemoveStream;
    service.listeners.onRemoveStream = onRemoveStream;
}
overrideOnRemoveStream._overrideCount = 0;

function resetOnRemoveStream(service) {
    // overrideOnRemoveStream._overrideCount--;
    //
    // if(overrideOnRemoveStream._overrideCount === 0){
    //     service.current.onRemoveStream = onRemoveStream.override;
    //     overrideOnRemoveStream.overrideObj = undefined;
    // }
}

function onRemoveStream(stream) {
    doCleanAfterStreamClose(this._service, stream);

    onRemoveStream.override && onRemoveStream.override.apply(this, arguments);
}

function doCleanAfterStreamClose(service, stream) {
    disControlled(service, stream.id);

    var controls = getRemoteControl(service, stream);
    controls && _util.forEach(controls, function (_i, control) {
        control._free && control._free();
    });

    _util.removeAttribute(service.current.__remoteControls, stream.id);
}

function overrideOnHungup(service) {
    overrideOnHungup._overrideCount++;
    if (overrideOnHungup.overrideObj === service) {
        return;
    }

    overrideOnHungup.overrideObj = service;
    var override = service.onHungup;

    service.onHungup = function onHungup(stream) {
        doCleanAfterStreamClose(service, stream);
        override && override.apply(this, arguments);
    }.bind(service);
}
overrideOnHungup._overrideCount = 0;

function overrideOnRemotePannelControl(service, callbacks) {
    overrideOnRemotePannelControl._overrideCount++;
    if (overrideOnRemotePannelControl.overrideObj === service) {
        return;
    }

    overrideOnRemotePannelControl.overrideObj = service;
    var override = service._onRemotePannelControl;

    service._onRemotePannelControl = function _onRemotePannelControl(evt) {
        handlePannelRemoteMessage(this, evt, false, callbacks);
        override && override.apply(this, arguments);
    }.bind(service);
}
overrideOnRemotePannelControl._overrideCount = 0;

function resetOnRemotePannelControl(service) {
    // overrideOnRemotePannelControl._overrideCount--;
    //
    // if(overrideOnRemotePannelControl._overrideCount === 0){
    //     service._onRemotePannelControl = _onRemotePannelControl.override;
    //     overrideOnRemotePannelControl.overrideObj = undefined;
    // }
}

function codeCtrlMessage(service, stream, ctrl) {
    var actions = [];

    ctrl && _util.forEach(ctrl.actions, function (i, m) {
        m.xy && actions.push({
            x: Math.round(m.xy.x * 10000),
            y: Math.round(m.xy.y * 10000),
            oper: m.oper,
            btn: m.btn,
            sn: m.sn,
            _time: m._time
        });

        m.xy || actions.push({
            oper: m.oper,
            btn: m.btn,
            sn: m.sn,
            _time: m._time
        });
    });

    var arg = {
        op2: 30,
        evt: 0,
        streamId: stream.id,
        actions: actions,
        cId: ctrl.cId
    };

    return service.current.newMessage({
        op: 1002,
        memId: stream.owner.id,
        arg: JSON.stringify(arg),
        _reqOps: [100230]
    });
}

function decodeCtrlMessage(evt) {
    if (typeof evt.arg === 'string') {
        evt.arg = JSON.parse(evt.arg);
    }

    var arg = evt.arg;

    var mouse = [],
        keyboard = [];
    arg && arg.actions && _util.forEach(arg.actions, function (i, m) {
        m.x !== undefined && m.y !== undefined && mouse.push({
            xy: { x: m.x / 10000, y: m.y / 10000 },
            oper: m.oper,
            btn: m.btn,
            sn: m.sn,
            _time: m._time
        });

        (m.x === undefined || m.y === undefined) && keyboard.push({
            oper: m.oper,
            btn: m.btn,
            sn: m.sn,
            _time: m._time
        });
    });

    arg.mouse = mouse;
    arg.keyboard = keyboard;
}

var remoteControlSeqno = 0;
var RemoteControl = _util.prototypeExtend({
    //id:
    //_service:
    //controller:
    //_ctrlStream:
    //_cId:
    //_reqevt:
    __init__: function __init__() {
        this.id = remoteControlSeqno++;
    },
    accept: function accept(mouseTrack, keyboard) {
        var self = this;

        if (self.hasOtherControl()) {
            self.busy();

            _logger.error("Other has been controled.");
            throw "Other has been controled.";
        }

        var preAcpt = false;

        var preRemoteControls = getRemoteControl(this._service, this._ctrlStream, this._controller); // 获取此前的remotecontrol
        preRemoteControls && _util.forEach(preRemoteControls, function (_index, preRC) {
            if (preRC.id < self.id) {
                preRC._free();
            } else {
                preAcpt = true;
            }
        });

        if (preAcpt) {
            //已经同意最新的控制。忽略这个
            self._free();
            return;
        }

        var remoteControls = this._service.current.__remoteControls || (this._service.current.__remoteControls = {});
        remoteControls[self.id] = self;

        controlling(this, mouseTrack, keyboard);

        rspRemoteControl(this._service, this._reqevt, 0);
    },

    controlling: function controlling() {
        var self = this;

        //存在启动人控制
        var controls = [];
        var remoteControls = getRemoteControl(this._service, this._ctrlStream);
        remoteControls && _util.forEach(remoteControls, function (_index, other) {
            if (other._controller.memName === self._controller.memName) {
                controls.push(other);
            }
        });

        return controls && controls.length ? controls : undefined;
    },

    hasOtherControl: function hasOtherControl() {
        var self = this;

        //存在启动人控制
        var hasOtherControl = false;
        var controls = getRemoteControl(this._service, this._ctrlStream);
        controls && _util.forEach(controls, function (_index, other) {
            if (other._controller.memName != self._controller.memName) {
                hasOtherControl = true;
            }
        });

        return hasOtherControl;
    },

    busy: function busy() {
        rspRemoteControl(this._service, this._reqevt, -403);
    },

    reject: function reject() {
        rspRemoteControl(this._service, this._reqevt, -402);
    },

    _free: function _free() {
        _util.removeAttribute(this._service.current.__remoteControls, this.id);
    },

    forceDisconnect: function forceDisconnect() {
        var remoteControls = getRemoteControl(this._service, this._ctrlStream);
        if (remoteControls) {
            _util.forEach(remoteControls, function (_index, remoteControl) {
                remoteControl._free && remoteControl._free();
            });
        }
        _logger.info("remote control force disconnect");
    }
});

function rspRemoteControl(service, evt, result) {
    service.current.message({
        op: 1001,
        tsxId: evt.tsxId,
        memId: evt.memId,
        arg: JSON.stringify({ cId: evt.arg.cId }),
        result: result
    }).post();
}

function notAllowControl(service, evt) {
    rspRemoteControl(service, evt, -405);
}

function selectRemoteControlByMemId(service, controllerMemId, stream) {
    var remoteControls = [];
    service.current.__remoteControls && _util.forEach(service.current.__remoteControls, function (_remoteControlId, _remoteControl) {
        if ((!stream || _remoteControl._ctrlStream.id === stream.id) && (!controllerMemId || _remoteControl._controller.id === controllerMemId)) {
            remoteControls.push(_remoteControl);
        }
    });

    return remoteControls;
}

function getRemoteControl(service, stream, controller, cId) {
    var remoteControls = [];
    service.current.__remoteControls && _util.forEach(service.current.__remoteControls, function (_remoteControlId, _remoteControl) {
        if ((!stream || _remoteControl._ctrlStream.id === stream.id) && (!controller || _remoteControl._controller.memName === controller.memName) && (!cId || _remoteControl._cId === cId)) {
            remoteControls.push(_remoteControl);
        }
    });

    return remoteControls;
}

function handlePannelRemoteMessage(service, evt, located, callbacks) {
    decodeCtrlMessage(evt);

    var arg = evt.arg;
    var cId = arg.cId;

    var streamId = arg.streamId;

    var member = service.getMemberById(evt.memId);
    var stream = service.getStreamById(streamId);

    function recvRemoteControl() {
        if (!member || !stream) {
            notAllowControl(service, evt);
            return true;
        }

        if (arg.evt === 1) {
            // 控制申请
            var remoteControl = new RemoteControl({
                _service: service,
                _controller: member,
                _ctrlStream: stream,
                _cId: cId,
                _reqevt: evt,
                _callbacks: callbacks
            });

            if (remoteControl.hasOtherControl()) {
                remoteControl.busy();
                return true;
            }

            var ctrls;
            if (ctrls = remoteControl.controlling()) {
                _util.forEach(ctrls, function (_index, ctrl) {
                    ctrl._cId = cId;
                });

                rspRemoteControl(service, evt, 0);
                return true;
            }

            callbacks && callbacks.onHasRemoteControl && callbacks.onHasRemoteControl(stream, member, remoteControl);

            return true;
        }

        if (arg.evt === 2) {
            // 控制释放
            var remoteControls = getRemoteControl(service, stream, member, cId);
            if (remoteControls) {
                _util.forEach(remoteControls, function (_index, remoteControl) {
                    remoteControl._free && remoteControl._free();
                    rspRemoteControl(service, evt, 0);
                });
            }

            callbacks && callbacks.onRemoteFreeControl && callbacks.onRemoteFreeControl(stream, member, cId);

            return true;
        }
    }

    if (!located && recvRemoteControl()) {
        return;
    }

    var remoteControls = getRemoteControl(service, stream, member, cId);
    if (!located && (!remoteControls || remoteControls.length === 0)) {
        notAllowControl(service, evt);
    }

    remoteControls && _util.forEach(remoteControls, function (_index, __ctrl) {
        __ctrl._lastRecvTimestamp = new Date().getTime();
    });

    if (located) {
        var remoteControl = service.current.__remoteControls[stream.id];
        remoteControls = remoteControls || [];

        remoteControl && remoteControls.push(remoteControl);
    }

    _util.forEach(remoteControls, function (_i, ctrl) {
        var maxSN = 0;

        var triggers = arg.mouse;
        if (triggers && triggers.length > 0) {
            try {
                _util.forEach(triggers, function (index, elem) {
                    if (elem.sn > maxSN) {
                        maxSN = elem.sn;
                    }

                    if (elem.oper === MouseTrigger.BTN.MOVE) {
                        ctrl.mouseTrack && ctrl.mouseTrack.track(elem.xy);
                    } else {
                        ctrl.mouseTrack && ctrl.mouseTrack.trigger(new MouseTrigger(elem));
                    }
                });
            } catch (e) {
                _logger.warn(e);
            }
        }

        var triggers = arg.keyboard;
        if (triggers && triggers.length > 0) {
            try {
                _util.forEach(triggers, function (index, elem) {
                    if (elem.sn > maxSN) {
                        maxSN = elem.sn;
                    }

                    if (ctrl.keyboard) if (elem.oper === MouseTrigger.BTN.KEYBOARD_DOWN) {
                        ctrl.keyboard.onKeyDown(elem.btn);
                    } else if (elem.oper === MouseTrigger.BTN.KEYBOARD_UP) {
                        ctrl.keyboard.onKeyUp(elem.btn);
                    }
                });
            } catch (e) {
                _logger.warn(e);
            }
        }

        if (located === true) {
            //自个儿 没通过 session发送
            return;
        }

        function rsp() {
            service.current.message({
                op: 1001,
                tsxId: evt.tsxId,
                memId: evt.memId,
                arg: JSON.stringify({ sn: maxSN }),
                result: 0
            }).post(function (rsp) {
                _logger.debug("Send remote control response. the result = ", rsp.result, rsp.msg || "");
            });
        }

        try {
            rsp();
        } catch (e) {
            _logger.warn(e);
        }
    });
}

function _onMouseEnter2(service, streamId, videoTarget, _onMouseEnter, onCallbacks) {
    _onMouseEnter && _onMouseEnter();
}

function _onMouseExit2(service, streamId, videoTarget, _onMouseExit, onCallbacks) {
    _onMouseExit && _onMouseExit();
}

function _onMouseMove2(service, streamId, videoTarget, eventXY, lastTrigger, _onMouseMove, onCallbacks) {
    var pos = service.eventXYAtMedia(eventXY, videoTarget);
    if (!pos) {
        return;
    }

    pos = {
        x: pos.x / pos.width,
        y: pos.y / pos.height
    };

    //_logger.info(pos.x, pos.y);

    sendPannelMessage(service, { xy: pos, oper: MouseTrigger.BTN.MOVE, sid: streamId }, onCallbacks);
    _onMouseMove && _onMouseMove(pos, lastTrigger);
}

function _onMouseButton2(service, streamId, videoTarget, trigger, lastTrigger, _onMouseButton, onCallbacks) {
    trigger.xy = service.eventXYAtMedia(trigger.xy, videoTarget);
    if (!trigger.xy) {
        return;
    }

    trigger.xy = {
        x: trigger.xy.x / trigger.xy.width,
        y: trigger.xy.y / trigger.xy.height
    };

    _util.extend(trigger, { sid: streamId });

    sendPannelMessage(service, trigger, onCallbacks);
    _onMouseButton && _onMouseButton(trigger, lastTrigger);
}

function onKeyboard(service, streamId, oper, btn, _onKeyboard, onCallbacks) {
    sendPannelMessage(service, { oper: oper, btn: btn, sid: streamId }, onCallbacks);
    _onKeyboard && _onKeyboard(oper, btn);
}

function maskVideo(videoTarget) {
    var maskDiv = document.createElement("div");
    maskDiv.style = videoTarget.style;
    maskDiv.style.background = "transparent";

    videoTarget.parentNode.appendChild(maskDiv);
}

function sendPannelMessage(service, trigger, onCallbacks) {
    var streamId = trigger.sid;

    var stream = service.getStreamById(streamId);

    var ctrl;
    if (service.current.__remoteControls && (ctrl = service.current.__remoteControls[streamId])) {
        handlePannelRemoteMessage(service, codeCtrlMessage(service, stream, { actions: [trigger] }), true);
    }

    var _buffer = service.current.__pannelBuffers[streamId];

    var preUnclearSize = _buffer.getUnclearSize();
    _buffer.put(trigger);

    if (preUnclearSize < emedia.config.allowSendWhenLessThan) {
        var _getAndSend = function _getAndSend() {
            var evts = _buffer.getUnread();

            var _maxSN = 0;
            for (var i = 0; evts && i < evts.length; i++) {
                var evt = evts[i];
                _util.removeAttribute(evt, "sid");

                _maxSN < evt.sn && (_maxSN = evt.sn);
            }

            if (!evts || evts.length === 0) {
                return;
            }

            _logger.debug(streamId, "buffer remain:", _buffer.getUnclearSize(), ", send evt:", evts.length);

            service.current.postMessage(codeCtrlMessage(service, stream, { actions: evts, cId: _buffer._cId }), function (rsp) {
                if (rsp.result === -402) {
                    //对方 拒绝控制
                    onCallbacks && onCallbacks.onReject && onCallbacks.onReject(stream);
                    return;
                }
                if (rsp.result === -403) {
                    //对方 正被控制，忙
                    onCallbacks && onCallbacks.onBusy && onCallbacks.onBusy(stream);
                    return;
                }
                if (rsp.result === -408) {
                    //超时
                    onCallbacks && onCallbacks.onRemoteControlTimeout && onCallbacks.onRemoteControlTimeout(stream);
                    return;
                }
                if (rsp.result === -507 || rsp.result === -405) {
                    //不被支持
                    _buffer.clearRead(_maxSN);
                    onCallbacks && onCallbacks.onNotAllowRemoteControl && onCallbacks.onNotAllowRemoteControl(stream);
                    return;
                }

                if (rsp.result === 0) {
                    _buffer._lastRspTimestamp = new Date().getTime();
                }

                var arg = rsp.arg;
                if (arg && (arg = JSON.parse(arg)) && !_util.isInt(arg.sn)) {
                    _logger.warn("rsp.sn not a Number.", arg.sn, "for streamId", streamId);
                } else {
                    arg && arg.sn !== undefined && _buffer.clearRead(arg.sn);
                }

                _getAndSend();
            });
        };

        _getAndSend();
    }
}

function disControlled(service, streamId) {
    var buffer;

    var mouse = service.current.__pannelMouses && _util.removeAttribute(service.current.__pannelMouses, streamId);
    var keyboard = service.current.__pannelKeyboards && _util.removeAttribute(service.current.__pannelKeyboards, streamId);
    service.current.__pannelBuffers && (buffer = _util.removeAttribute(service.current.__pannelBuffers, streamId));

    mouse && mouse.ungrab();
    keyboard && keyboard.ungrab();

    resetOnRemoveStream(service);

    if (!buffer) {
        return;
    }

    var stream = service.getStreamById(streamId);
    if (buffer._callbacks && buffer._callbacks.onDisControlled) {
        buffer._callbacks.onDisControlled(stream);
    }

    if (!stream) {
        return;
    }

    var messge = service.current.newMessage({
        op: 1002,
        memId: stream.owner.id,
        arg: JSON.stringify({
            op2: 30,
            streamId: stream.id,
            evt: 2,
            cId: buffer._cId
        }),
        _reqOps: [100230]
    });

    service.current.postMessage(messge, function (rsp) {
        if (rsp.result === 0) {
            return;
        }

        _logger.warn("Unkown result：", rsp.result);
        return;
    });
}

function mirrorControlled(service, streamId, videoTarget, maskTarget) {
    var onCallbacks = {};
    _util.forEach(arguments, function (_index, _func) {
        if (typeof _func === "function") {
            onCallbacks[_func.name] = _func;
        }
    });

    reqControlled(service, streamId, videoTarget, true, maskTarget, onCallbacks);
}

function controlled(service, streamId, videoTarget, maskTarget) {
    var onCallbacks = {};
    _util.forEach(arguments, function (_index, _func) {
        if (typeof _func === "function") {
            onCallbacks[_func.name] = _func;
        }
    });

    reqControlled(service, streamId, videoTarget, false, maskTarget, onCallbacks);
}

function reqControlled(service, streamId, videoTarget, mirror, maskTarget, onCallbacks) {
    var cId = Math.uuidFast();
    cId = cId.substr(cId.length - 6, 6);

    var stream = service.getStreamById(streamId);

    if (!stream._webrtc) {
        //throw "Not allow control. cause by the stream not sub";
        onCallbacks && onCallbacks.onNotAllowRemoteControl && onCallbacks.onNotAllowRemoteControl(stream);

        _logger.error("Not allow control. cause by the stream not sub");
        throw "Not allow control. cause by the stream not sub";
    }

    var arg = {
        op2: 30,
        streamId: stream.id,
        evt: 1,
        cId: cId
    };

    var messge = service.current.newMessage({
        op: 1002,
        memId: stream.owner.id,
        arg: JSON.stringify(arg),
        _reqOps: [100230]
    });

    service.current.postMessage(messge, function (rsp) {
        if (rsp.result === -402) {
            //对方 拒绝控制
            onCallbacks && onCallbacks.onReject && onCallbacks.onReject(stream);
            return;
        }
        if (rsp.result === -403) {
            //对方 正被控制，忙
            onCallbacks && onCallbacks.onBusy && onCallbacks.onBusy(stream);
            return;
        }
        if (rsp.result === -408) {
            //超时
            onCallbacks && onCallbacks.onRemoteControlTimeout && onCallbacks.onRemoteControlTimeout(stream);
            return;
        }
        if (rsp.result === -507 || rsp.result === -405) {
            //不被支持
            onCallbacks && onCallbacks.onNotAllowRemoteControl && onCallbacks.onNotAllowRemoteControl(stream);
            return;
        }

        if (rsp.result === 0) {
            _controlled(service, streamId, videoTarget, mirror, maskTarget, onCallbacks, cId, true);
            onCallbacks && onCallbacks.onAccept && onCallbacks.onAccept(stream);
            return;
        }

        _logger.warn("Unkown result：", rsp.result);

        onCallbacks && onCallbacks.onNotAllowRemoteControl && onCallbacks.onNotAllowRemoteControl(stream);
        return;
    });
}

function _controlled(service, streamId, videoTarget, mirror, maskTarget, onCallbacks, cId, openKeyboard) {
    if (maskTarget === undefined) {
        maskTarget = videoTarget;
    }

    var stream = service.getStreamById(streamId);

    var mouse = (service.current.__pannelMouses || (service.current.__pannelMouses = {}))[streamId];
    if (mouse) {
        disControlled(service, streamId);
    }

    if (!stream.located() && !stream.owner.acptOps[1003]) {
        _logger.error("which do not recv remote message, it is ", stream.owner.memName);
        throw stream.owner.memName + " do not recv remote message";
    }

    mouse = new Mouse({
        _target: maskTarget,
        _focused: true,

        onMouseEnter: function onMouseEnter() {
            _onMouseEnter2.call(mouse, service, streamId, videoTarget, onCallbacks && onCallbacks.onMouseEnter, onCallbacks);

            keyboard && keyboard.grab();
        },

        onMouseExit: function onMouseExit() {
            _onMouseExit2.call(mouse, service, streamId, videoTarget, onCallbacks && onCallbacks.onMouseExit, onCallbacks);

            keyboard && keyboard.ungrab();
        },

        onMouseButton: function onMouseButton(trigger, lastTrigger) {
            mirror === true && (trigger.xy.x = -trigger.xy.x);
            _onMouseButton2.call(mouse, service, streamId, videoTarget, trigger, lastTrigger, onCallbacks && onCallbacks.onMouseButton, onCallbacks);
        },

        onMouseMove: function onMouseMove(pos, lastTrigger) {
            //_logger.info(pos.x, pos.y);

            if (!emedia.config.disableTrack) {
                mirror === true && (pos.x = -pos.x);
                _onMouseMove2.call(mouse, service, streamId, videoTarget, pos, lastTrigger, onCallbacks && onCallbacks.onMouseMove, onCallbacks);
            }
        }
    });

    var pannelBuffers = service.current.__pannelBuffers || (service.current.__pannelBuffers = {});
    var _buffer = pannelBuffers[streamId] = new TotalBuffer({
        _cId: cId,
        _callbacks: onCallbacks,
        trackBufferSize: emedia.config.trackBufferSize || 1000
    });

    (service.current.__pannelMouses || (service.current.__pannelMouses = {}))[streamId] = mouse;
    mouse.grab();

    var keyboard;
    if (openKeyboard) {
        keyboard = new Keyboard({
            _target: document,
            _focused: true,
            onKeyPress: function onKeyPress(keyValue, isPressed) {
                var oper = isPressed ? MouseTrigger.BTN.KEYBOARD_DOWN : MouseTrigger.BTN.KEYBOARD_UP;
                var btn = keyValue;

                onKeyboard.call(keyboard, service, streamId, oper, btn, onCallbacks && onCallbacks.onKeyboard, onCallbacks);
            }
        });

        (service.current.__pannelKeyboards || (service.current.__pannelKeyboards = {}))[streamId] = keyboard;
        //keyboard.grab();
    }

    // overrideOnHungup(service);
    // overrideOnRemoveStream(service);
    // overrideOnRemoveMember(service);
}

function graffiti(maskTag, mouseTrack, referenceVideo, mirror) {
    var mouse = new Mouse({
        _target: maskTag,
        _focused: true,

        onMouseEnter: function onMouseEnter() {
            //mouse.grab();
        },

        onMouseExit: function onMouseExit() {
            mouseTrack.releaseTrigger();
        },

        onMouseButton: function onMouseButton(trigger, lastTrigger) {
            trigger.xy = {
                x: trigger.xy.x / trigger.xy.width,
                y: trigger.xy.y / trigger.xy.height
            };

            mirror === true && (trigger.xy.x = -trigger.xy.x);
            referenceVideo && (trigger.xy = emedia.Service.prototype.eventXYAtMedia.call(null, trigger.xy, referenceVideo));
            trigger.xy && mouseTrack.trigger(trigger);
        },

        onMouseMove: function onMouseMove(pos, lastTrigger) {
            pos = {
                x: pos.x / pos.width,
                y: pos.y / pos.height
            };

            mirror === true && (pos.x = -pos.x);
            referenceVideo && (pos = emedia.Service.prototype.eventXYAtMedia.call(null, pos, referenceVideo));
            pos && mouseTrack.track(pos);
        }
    });

    mouse.grab();

    return mouse;
}

function controlling(ctrl, mouseTrack, keyboard) {
    var __mouseTrack = mouseTrack;

    // mouseTrack && (__mouseTrack = new MouseTrack({
    //     _focused: true,
    //
    //     onMouseTrack: function (position, lastPosition, lastTrigger) {
    //         mouseTrack.track(position);
    //     },
    //     onMouseTrigger: function (trigger, _lastTrigger) {
    //         mouseTrack.trigger(trigger);
    //     },
    //     onReleaseTrigger: function (_lastTrigger) {
    //         mouseTrack.releaseTrigger();
    //     }
    // }));

    __mouseTrack && (ctrl.mouseTrack = __mouseTrack);
    ctrl.keyboard = keyboard;
}

function support(service) {
    var onCallbacks = {};
    _util.forEach(arguments, function (_index, _func) {
        if (_index != 0 && typeof _func === "function") {
            onCallbacks[_func.name] = _func;
        }
    });

    overrideOnHungup(service);

    overrideOnRemoveStream(service);
    overrideOnRemoveMember(service);
    overrideOnRemotePannelControl(service, onCallbacks);

    checkTimeout(service);
}

function getController(service, streamId) {
    var stream = service.getStreamById(streamId);

    var controls = getRemoteControl(service, stream);

    if (!controls || controls.length === 0) {
        return;
    }

    return controls[0]._controller.memName;
}

function echoControl(service, streamId, mouseTrack, keyboard) {
    var stream = service.getStreamById(streamId);

    var echoControl = { _ctrlStream: stream, _controller: stream.owner, _service: service };
    controlling(echoControl, mouseTrack, keyboard);

    (service.current.__remoteControls || (service.current.__remoteControls = {}))[streamId] = echoControl;
}

function disEchoControl(service, streamId) {
    _util.removeAttribute(service.current.__remoteControls, streamId);
}

var checkTimeout = function checkTimeout(service) {
    if (checkTimeout.timeoutId) {
        clearTimeout(checkTimeout.timeoutId);
    }

    checkTimeout.timeoutId = setTimeout(function () {
        checkTimeout(service);
    }, emedia.config.ctrlCheckIntervalMillis);

    if (!service.current) {
        return;
    }

    var controls;
    if (controls = service.current.__remoteControls) {
        //受控制端，查看 _lastRecvTimestamp
        //_logger.debug("Will check timeout for remote controller.");

        _util.forEach(controls, function (ctrlId, ctrl) {
            if (ctrl.id !== undefined && ctrlId == ctrl.id) {
                var now = new Date().getTime();
                if (ctrl._lastRecvTimestamp && now - ctrl._lastRecvTimestamp > emedia.config.ctrlTimeoutMillis) {
                    _logger.warn("Timeout for remote controller. it is ", ctrl.id, ctrl._ctrlStream.id, ctrl._controller.memName);

                    ctrl._free(); //超时清空

                    ctrl._callbacks && ctrl._callbacks.onRemoteFreeControl && ctrl._callbacks.onRemoteFreeControl(ctrl._ctrlStream, ctrl._controller, ctrl._cId);
                }
            }
        });
    }

    var buffers;
    if (buffers = service.current.__pannelBuffers) {
        //控制端 根据是否还存在 这个发布流判断，如果 这个pub流被移除，控制 停止。查看 _lastRspTimestamp
        _util.forEach(buffers, function (_streamId, buffer) {
            //控制端发送ping
            var stream = service.getStreamById(_streamId);
            if (stream && !stream.located()) {
                service.current.message({ // 发送ping
                    op: 1002,
                    memId: stream.owner.id,
                    arg: JSON.stringify({
                        op2: 30,
                        streamId: stream.id,
                        evt: 3,
                        cId: buffer._cId
                    }),
                    _reqOps: [100230]
                }).post(function (rsp) {});
            }
        });
    }
};

module.exports = {
    mirrorControlled: mirrorControlled,
    controlled: controlled,
    disControlled: disControlled,

    controlling: controlling,

    graffiti: graffiti,

    echoControl: echoControl,
    disEchoControl: disEchoControl,

    support: support,

    getController: getController
};

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

var _util = __webpack_require__(15);
var _logger = _util.tagLogger("Mouse");

var MouseTrigger = __webpack_require__(32);

/**
 * { target:
 *   onMouseButton:
 *   onMouseMove:
 * }
 *
 */

module.exports = _util.prototypeExtend({
    __init__: function __init__() {
        var self = this;

        this._handlers = _util.extend({
            mousedown: this._handleMouseDown.bind(this),
            mouseup: this._handleMouseUp.bind(this),
            mousemove: this._handleMouseMove.bind(this),
            mousewheel: this._handleMouseWheel.bind(this),
            mousedisable: this._handleMouseDisable.bind(this),
            mouseover: this._handleMouseOver.bind(this),
            mouseout: this._handleMouseOut.bind(this)
        }, this._handlers || {});
    },

    //target: n,

    /**
     *
     * @param posX
     * @param posY
     * @param oper 1按下 0up
     * @param button 1左键单击 2滚轮按下 4右键 8滚轮向底端滑 16滚轮向顶端滑
     */
    onMouseButton: function onMouseButton(trigger, lastTrigger) {},

    onMouseMove: function onMouseMove(eventXY, lastTrigger) {},

    onMouseEnter: function onMouseEnter() {},

    onMouseExit: function onMouseExit() {},

    _onMouseButton: function _onMouseButton(eventXY, oper, button) {
        var _time = new Date().getTime();

        var trigger = new MouseTrigger({
            xy: eventXY,
            oper: oper,
            btn: button,
            _time: _time
        });

        this.onMouseButton && this.onMouseButton(trigger, this._lastTrigger);

        this._lastTrigger = trigger;
    },

    _onMouseMove: function _onMouseMove(eventXY) {
        this.onMouseMove && this.onMouseMove(eventXY, this._lastTrigger);
    },

    _captureMouse: function _captureMouse() {
        this._target.setCapture && this._target.setCapture();
        this._mouseCaptured = true;
    },
    _releaseMouse: function _releaseMouse() {
        this._target.releaseCapture && this._target.releaseCapture();
        this._mouseCaptured = false;
    },
    _resetDoubleClickTimer: function _resetDoubleClickTimer() {
        this._doubleClickTimer = null;
    },

    _handleMouseOver: function _handleMouseOver(event) {
        if (this._mouseExit !== false) {
            this._mouseExit = false;
            this.onMouseEnter && this.onMouseEnter();
        }
    },
    _handleMouseOut: function _handleMouseOut(event) {
        if (this._mouseExit !== true) {
            this._mouseExit = true;
            this.onMouseExit && this.onMouseExit();
        }

        this._lastTrigger = undefined;
    },
    _handleMouseDown: function _handleMouseDown(event) {
        this._captureMouse();
        this._handleMouseButton(event, MouseTrigger.BTN.KEY_DOWN);
    },
    _handleMouseUp: function _handleMouseUp(event) {
        this._mouseCaptured && (this._handleMouseButton(event, MouseTrigger.BTN.KEY_UP), this._releaseMouse());
    },

    _handleMouseWheel: function _handleMouseWheel(event) {
        if (!this._focused) {
            return;
        }

        var event = event || window.event,
            eventXY = _util.getEventElementXY(event, this._target, this._scale);

        // 8up 16down
        var wheel = (event.detail ? -1 * event.detail : event.wheelDelta / 40) > 0 ? MouseTrigger.BTN.WHEEL_ROLL_UP : MouseTrigger.BTN.WHEEL_ROLL_DOWN;
        this._onMouseButton(eventXY, MouseTrigger.BTN.KEY_DOWN, wheel);
        _util.stopEvent(event);
    },

    _handleMouseMove: function _handleMouseMove(event) {
        if (!this._focused) {
            return;
        }

        var event = event || window.event,
            eventXY = _util.getEventElementXY(event, this._target, this._scale);
        this._onMouseMove(eventXY);
        _util.stopEvent(event);
    },

    _handleMouseDisable: function _handleMouseDisable(event) {
        if (!this._focused) {
            return;
        }

        var event = event || window.event,
            eventXY = _util.getEventElementXY(event, this._target, this._scale);

        try {
            return !(eventXY.realX >= 0 && eventXY.realY >= 0 && eventXY.realX < this._target.offsetWidth && eventXY.realY < this._target.offsetHeight);
        } finally {
            _util.stopEvent(event);
        }
    },

    /**
     *
     * @param event
     * @param oper 1鼠标按下
     * @private
     */
    _handleMouseButton: function _handleMouseButton(event, oper) {
        if (!this._focused) {
            return;
        }

        var button,
            event = event || window.event,
            eventXY = _util.getEventElementXY(event, this._target, this._scale);
        if (event.touches || event.changedTouches) {
            if (oper == MouseTrigger.BTN.KEY_DOWN) {
                if (this._doubleClickTimer === null) this._lastTouchPos = eventXY;else {
                    clearTimeout(this._doubleClickTimer);
                    var distanceX = this._lastTouchPos.x - eventXY.x,
                        distanceY = this._lastTouchPos.y - eventXY.y;
                    Math.sqrt(distanceX * distanceX + distanceY * distanceY) < 20 * window.devicePixelRatio && (eventXY = this._lastTouchPos);
                }
                this._doubleClickTimer = setTimeout(this._resetDoubleClickTimer.bind(this), 500);
            }
            button = MouseTrigger.BTN.LEFT;
        } else button = event.which ? 1 << event.button : (1 & event.button) + 2 * (2 & event.button) + (4 & event.button) / 2;

        this._onMouseButton(eventXY, oper, button);
        _util.stopEvent(event);
    },

    grab: function grab() {
        var element = this._target;

        _util.addEvent(element, "mouseover", this._handlers.mouseover);
        _util.addEvent(element, "mouseout", this._handlers.mouseout);

        _util.addEvent(element, "touchstart", this._handlers.mousedown);
        //_util.addEvent(window, "touchend", this._handlers.mouseup);
        _util.addEvent(element, "touchend", this._handlers.mouseup);
        _util.addEvent(element, "touchmove", this._handlers.mousemove);
        _util.addEvent(element, "mousedown", this._handlers.mousedown);
        //_util.addEvent(window, "mouseup", this._handlers.mouseup);
        _util.addEvent(element, "mouseup", this._handlers.mouseup);
        _util.addEvent(element, "mousemove", this._handlers.mousemove);
        _util.addEvent(element, _util.layoutEngine.gecko ? "DOMMouseScroll" : "mousewheel", this._handlers.mousewheel);
        _util.addEvent(element, "contextmenu", this._handlers.mousedisable);
        //_util.addEvent(document, "click", this._handlers.mousedisable);
        //_util.addEvent(document.body, "contextmenu", this._handlers.mousedisable);
    },
    ungrab: function ungrab() {
        var element = this._target;

        _util.removeEvent(element, "mouseover", this._handlers.mouseover);
        _util.removeEvent(element, "mouseout", this._handlers.mouseout);

        _util.removeEvent(element, "touchstart", this._handlers.mousedown);
        //_util.removeEvent(window, "touchend", this._handlers.mouseup);
        _util.removeEvent(element, "touchend", this._handlers.mouseup);
        _util.removeEvent(element, "touchmove", this._handlers.mousemove);
        _util.removeEvent(element, "mousedown", this._handlers.mousedown);
        //_util.removeEvent(window, "mouseup", this._handlers.mouseup);
        _util.removeEvent(element, "mouseup", this._handlers.mouseup);
        _util.removeEvent(element, "mousemove", this._handlers.mousemove);
        _util.removeEvent(element, _util.layoutEngine.gecko ? "DOMMouseScroll" : "mousewheel", this._handlers.mousewheel);
        _util.removeEvent(element, "contextmenu", this._handlers.mousedisable);
        //_util.removeEvent(document, "click", this._handlers.mousedisable);
        //_util.removeEvent(document.body, "contextmenu", this._handlers.mousedisable);
    }
});

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

var _util = __webpack_require__(15);
var _logger = _util.tagLogger("Keyboard");

module.exports = _util.prototypeExtend({

    __init__: function __init__() {
        var self = this;

        this._eventHandlers = {
            keyup: this._handleKeyUp.bind(this),
            keydown: this._handleKeyDown.bind(this),
            keypress: this._handleKeyPress.bind(this),
            blur: this._allKeysUp.bind(this)
        };
    },

    getKey: function getKey(event) {
        return "keyCode" in event && "key" in event ? event.key + ":" + event.keyCode : "keyCode" in event ? event.keyCode : event.key;
    },

    onKeyPress: function onKeyPress(keyValue, isPressed) {},

    _onKeyPress: function _onKeyPress(keyValue, isPressed) {
        this.onKeyPress && this.onKeyPress(keyValue, isPressed);
    },

    _handleRfbEvent: function _handleRfbEvent(event, type) {
        var shift = event.shiftKey,
            ctrl = event.ctrlKey,
            alt = event.altKey,
            ascii = event.keyCode || event.which;

        this._onKeyPress(ascii, "keydown" == type);
    },

    _handleKeyDown: function _handleKeyDown(event) {
        return !this._focused || !this._handleRfbEvent(event, "keydown") || (_util.stopEvent(event), false);
    },
    _handleKeyPress: function _handleKeyPress(event) {
        return !this._focused || (_util.stopEvent(event), false);
        //return !this._focused || !this._handleRfbEvent.keypress(event) || (_util.stopEvent(event), false);
    },
    _handleKeyUp: function _handleKeyUp(event) {
        return !this._focused || !this._handleRfbEvent(event, "keyup") || (_util.stopEvent(event), false);
    },

    _allKeysUp: function _allKeysUp() {},
    sync: function sync(e) {},

    grab: function grab() {
        var element = this._target;

        _util.addEvent(element, "keydown", this._eventHandlers.keydown);
        _util.addEvent(element, "keyup", this._eventHandlers.keyup);
        _util.addEvent(element, "keypress", this._eventHandlers.keypress);
        _util.addEvent(element, "blur", this._eventHandlers.blur);
        //_util.addEvent(window, "blur", this._eventHandlers.blur);

        _logger.info("keyboard grab at element");
    },
    ungrab: function ungrab() {
        var element = this._target;

        _util.removeEvent(element, "keydown", this._eventHandlers.keydown);
        _util.removeEvent(element, "keyup", this._eventHandlers.keyup);
        _util.removeEvent(element, "keypress", this._eventHandlers.keypress);
        _util.removeEvent(element, "blur", this._eventHandlers.blur);
        //_util.removeEvent(window, "blur", this._eventHandlers.blur);

        this._allKeysUp();

        _logger.info("keyboard upgrab at element");
    }
});

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

var _util = __webpack_require__(15);
var _logger = _util.tagLogger("TotalBuffer");

var EventBuffer = __webpack_require__(240);
var TrackBuffer = __webpack_require__(241);

var MouseTrigger = __webpack_require__(32);

module.exports = _util.prototypeExtend({
    trackBufferSize: 100,
    _trackBufferCompRadio: 0.25,

    _sn: 1,

    __init__: function __init__() {
        this._eventBuffer = new EventBuffer({
            _nextsn: this._nextsn.bind(this)
        });
        this._trackBuffer = new TrackBuffer({
            _nextsn: this._nextsn.bind(this),
            _compRadio: this._trackBufferCompRadio,
            mouseTrackBufferSize: this.trackBufferSize
        });
    },

    _nextsn: function _nextsn() {
        return this._sn++;
    },

    put: function put(event) {
        if (!event || event.oper === undefined) {
            return;
        }

        event.oper === MouseTrigger.BTN.MOVE ? this._trackBuffer.put(event) : this._eventBuffer.put(event);
    },

    getUnread1: function getUnread1(length) {
        function sortby(a, b) {
            return a._time - b.time;
        }

        var result;
        if (!length) {
            var events = this._eventBuffer.getUnread();
            var tracks = this._trackBuffer.getUnread();

            Array.prototype.push.apply(events, tracks);
            result = events;

            result.sort(sortby);
            return result;
        }

        result = [];

        var events = this._eventBuffer._getUnread(length);
        var tracks = this._trackBuffer._getUnread(length);

        Array.prototype.push.apply(result, events);
        Array.prototype.push.apply(result, tracks);

        result.sort(sortby);

        result = result.slice(0, length > result.length ? result.length : length);
        for (var i = 0; i < result.length; i++) {
            if (result[i].oper === MouseTrigger.BTN.MOVE) {
                this._trackBuffer.getUnread(1);
            } else {
                this._eventBuffer.getUnread(1);
            }
        }

        return result;
    },

    getUnread: function getUnread(length) {
        function sortby(a, b) {
            return a.sn - b.sn;
        }

        if (!length) {
            length = this._eventBuffer.getUnreadSize() + this._trackBuffer.getUnreadSize();
        }

        var result = [];
        while (result.length !== length) {
            var event = this._eventBuffer._getUnread(1);
            var track = this._trackBuffer._getUnread(1);

            if (event === undefined && track) {
                result.push(this._trackBuffer.getUnread(1));
            } else if (track === undefined && event) {
                result.push(this._eventBuffer.getUnread(1));
            } else if (track === undefined && event === undefined) {
                return result;
            } else {
                if (event.sn < track.sn) {
                    result.push(this._eventBuffer.getUnread(1));
                } else {
                    result.push(this._trackBuffer.getUnread(1));
                }
            }
        }

        return result;
    },

    getUnreadSize: function getUnreadSize() {
        return this._trackBuffer.getUnreadSize() + this._eventBuffer.getUnreadSize();
    },

    getUnclearSize: function getUnclearSize() {
        return this._trackBuffer.getUnclearSize() + this._eventBuffer.getUnclearSize();
    },

    clearRead: function clearRead(limitSN) {
        // <=
        return this._eventBuffer.clearRead(limitSN) + this._trackBuffer.clearRead(limitSN);
    }
});

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

var _util = __webpack_require__(15);
var _logger = _util.tagLogger("EventBuffer");

module.exports = _util.prototypeExtend({
    _buffer: [],

    _sn: 1,

    _beginIndex: 0,
    _readIndex: 0,
    _endIndex: 0,

    _nextsn: function _nextsn() {
        return this._sn++;
    },

    put: function put(event) {
        if (!event) {
            return;
        }

        event.sn = this._nextsn();

        this._buffer.push(event);
        this._endIndex++;
    },

    _getUnread: function _getUnread(length) {
        if (this._readIndex === this._endIndex) {
            return length === 1 ? undefined : [];
        }

        return this._buffer[this._readIndex];

        var end = this._readIndex + (length || this._endIndex),
            end = end > this._endIndex ? this._endIndex : end;

        return this._buffer.slice(this._readIndex, end);
    },

    getUnread: function getUnread(length) {
        var result;
        try {
            result = this._getUnread(length);
            return result;
        } finally {
            result && (this._readIndex += length === 1 ? 1 : result.length);
        }
    },

    getUnreadSize: function getUnreadSize() {
        return this._endIndex - this._readIndex;
    },

    getUnclearSize: function getUnclearSize() {
        return this._readIndex - this._beginIndex;
    },

    clearRead: function clearRead(limitSN) {
        // <=
        if (this._readIndex === this._beginIndex) {
            return;
        }

        var count = 0;
        for (var i = this._beginIndex; i < this._readIndex; i++) {
            if (this._buffer[i].sn <= limitSN) {
                count++;
            } else {
                break;
            }
        }

        if (count === 0) {
            return 0;
        }

        for (var i = 0; i < count; i++) {
            this._buffer.shift();
        }

        this._beginIndex = 0;
        this._readIndex -= count;
        this._endIndex -= count;

        return count;
    }
});

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

var _util = __webpack_require__(15);
var _logger = _util.tagLogger("TrackBuffer");

module.exports = _util.prototypeExtend({
    mouseTrackBufferSize: 1000,

    _sn: 1,
    _compRadio: 0.25,

    _beginIndex: 0,
    _readIndex: 0,
    _endIndex: 0, //不包含end

    __init__: function __init__() {
        this._mouseTrackBuffer = new Array(this.mouseTrackBufferSize);
    },

    _nextsn: function _nextsn() {
        return this._sn++;
    },

    _index: function _index(_index2) {
        return _index2 % this.mouseTrackBufferSize;
    },

    comp1: function comp1(compRadio) {
        //compRadio 压缩原来的compRadio，如0.25，就是删除其中0.25个元素
        if (compRadio >= 1) {
            return;
        }

        var span = Math.floor(1 / compRadio);

        var _nextIndex = this._beginIndex;
        var _currentIndex = _nextIndex + 1;

        while (_nextIndex < this._endIndex) {
            for (var i = 2; i < span && _nextIndex + i < this._endIndex; i++) {
                this._mouseTrackBuffer[this._index(_currentIndex++)] = this._mouseTrackBuffer[this._index(_nextIndex + i)];
            }

            _nextIndex += span;
        }

        this._endIndex = _currentIndex;
    },

    put1: function put1(track) {
        if (!track) {
            return;
        }

        track.sn = this._nextsn();

        if (this._endIndex - this._readIndex === this.mouseTrackBufferSize) {
            //此时 begin = read, buffer）将原有数组(未发送队列)压缩为原先的0.75
            this.comp1(this._compRadio);
            this._readIndex = this._beginIndex;
        }

        var begin = this._index(this._beginIndex),
            read = this._index(this._readIndex),
            end = this._index(this._endIndex);

        var next = end;
        if (next <= begin && next >= 0 && this._endIndex > this._beginIndex) {
            // buffer不足后，首先覆盖已经发送的
            this._beginIndex++;
        }

        this._mouseTrackBuffer[next] = track;
        this._endIndex++;
    },

    compHalfOfUnread: function compHalfOfUnread() {
        //compRadio 压缩原来的compRadio，如0.25，就是删除其中0.25个元素
        var _nextIndex = this._readIndex + 2;
        var _currentIndex = this._readIndex + 1;

        while (_nextIndex < this._endIndex) {
            this._mouseTrackBuffer[this._index(_currentIndex++)] = this._mouseTrackBuffer[this._index(_nextIndex)];

            _nextIndex += 2;
        }

        this._endIndex = _currentIndex;
    },

    put: function put(track) {
        if (!track) {
            return;
        }

        track.sn = this._nextsn();

        if (this._endIndex - this._beginIndex === this.mouseTrackBufferSize) {
            // begin->read 待清除区，read->end 待发送，如果待清除区+待发送区满，压缩待发送区
            this.compHalfOfUnread();
        }

        var end = this._index(this._endIndex);

        this._mouseTrackBuffer[end] = track;
        this._endIndex++;
    },

    _interval: function _interval(startIndex, endIndex) {
        var read = this._index(startIndex),
            end = this._index(endIndex);

        if (read < end) {
            return this._mouseTrackBuffer.slice(read, end);
        }

        var result = this._mouseTrackBuffer.slice(read);
        Array.prototype.push.apply(result, this._mouseTrackBuffer.slice(0, end));

        return result;
    },

    _getUnread: function _getUnread(length) {
        if (this._readIndex === this._endIndex) {
            return length === 1 ? undefined : [];
        }

        return this._mouseTrackBuffer[this._index(this._readIndex)];

        var end = this._readIndex + (length || this._endIndex),
            end = end > this._endIndex ? this._endIndex : end;

        return this._interval(this._readIndex, end);
    },

    getUnread: function getUnread(length) {
        var result;
        try {
            result = this._getUnread(length);
            return result;
        } finally {
            result && (this._readIndex += length === 1 ? 1 : result.length);
        }
    },

    getUnreadSize: function getUnreadSize() {
        return this._endIndex - this._readIndex;
    },

    getUnclearSize: function getUnclearSize() {
        return this._readIndex - this._beginIndex;
    },

    clearRead: function clearRead(limitSN) {
        // <=
        if (this._readIndex === this._beginIndex) {
            return;
        }

        var count = 0;

        for (var i = this._beginIndex; i < this._readIndex; i++) {
            var index = this._index(i);

            if (this._mouseTrackBuffer[index].sn <= limitSN) {
                this._beginIndex++;
                count++;
            } else {
                break;
            }
        }

        return count;
    }
});

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

var _util = __webpack_require__(15);
var _logger = _util.tagLogger("CompositeCanvas");

function SimpleCanvasRenderingContext2D() {};

for (var key in CanvasRenderingContext2D.prototype) {
    (function (attr) {
        SimpleCanvasRenderingContext2D.prototype[attr] = function () {
            if (typeof this._canvasContext[attr] === "function") {
                this._canvasContext[attr].apply(this._canvasContext, arguments);
            } else {
                var arg = arguments.length >= 1 ? arguments[0] : undefined;
                if (arg) {
                    this._canvasContext[attr] = arg;
                } else {
                    return this._canvasContext[attr];
                }
            }
        };
    })(key);
}

//https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D

var CompositeCanvas = _util.prototypeExtend(SimpleCanvasRenderingContext2D, {
    //compositeCanvasTag:
    //_compositeOperation:
    //_globalAlpha:
    __init__: function __init__() {
        var self = this;

        if (!self.compositeCanvasTag) {
            self.compositeCanvasTag = document.createElement("canvas");
        }

        self._canvasContext = self.compositeCanvasTag.getContext("2d");

        self._canvasContext.globalAlpha = this._globalAlpha !== undefined ? this._globalAlpha : 1;

        self._compositeOperation = self._compositeOperation || operation.source_over;
        self.globalCompositeOperation(self._compositeOperation);
    },

    setCanvas: function setCanvas() {
        var self = this;
        var set;
        for (var i = 0; i < arguments.length; i++) {
            set = arguments[i];

            typeof set === "function" && set(this.compositeCanvasTag, this._canvasContext);
            typeof set !== "function" && _util.isPlainObject(set) && _util.forEach(set, function (key, value) {
                _logger.debug("Canvas set ", key, " = ", value);
                self.compositeCanvasTag.setAttribute(key, value);
            });
        }

        return self;
    },

    getCanvasImageData: function getCanvasImageData(canvas, alpha) {
        var args = [];
        for (var i = 1; i < arguments.length; i++) {
            args.push(arguments[i]);
        }

        var canvasContext = canvas.getContext("2d");
        canvasContext.globalAlpha = alpha || 0;
        return canvasContext.getImageData.apply(canvasContext, args);
    },

    _composite: function _composite(compositeOperation) {
        var self = this;

        return new CompositeCanvas(self, { _compositeOperation: compositeOperation });
    },

    composite: function composite(compositeOperation) {
        var self = this;
        self.globalCompositeOperation(compositeOperation);

        return self;
    },

    requestAnimationFrame: function requestAnimationFrame(time) {
        var self = this;

        self.requestFrame();
        self._requestAnimationFrameStart = window.requestAnimationFrame(function (time) {
            self.requestAnimationFrame(time);
        });

        return self;
    },

    cancelAnimationFrame: function cancelAnimationFrame() {
        var self = this;
        self._requestAnimationFrameStart && window.cancelAnimationFrame(self._requestAnimationFrameStart);

        return self;
    },

    requestFrame: function requestFrame(_frameRate) {
        var self = this;
        if (typeof this.requestOneFrame !== "function") {
            _logger.error("Pleas implement requestOneFrame()");
            throw "Pleas implement requestOneFrame()";
        }

        try {
            this.requestOneFrame();
        } catch (e) {
            _logger.error(e);
        }

        var timeoutMillis;
        if (_frameRate) {
            timeoutMillis = Math.floor(1000 / _frameRate);
        }

        if (!timeoutMillis) {
            return self;
        }

        var requestFrame = this.requestFrame.bind(this);
        this.intervalId = setInterval(function () {
            requestFrame(_frameRate);
        }, timeoutMillis);

        return self;
    },
    stopRequestFrame: function stopRequestFrame() {
        this.intervalId && clearInterval(this.intervalId);
        return this;
    }

    // getImageData: function(x, y, width, height){
    //     x = x || 0,
    //         y = y || 0,
    //         width = width || this.compositeCanvasTag.width,
    //         height = height || this.compositeCanvasTag.height;
    //
    //     var imageData = this._canvasContext.getImageData(x, y, width, height);
    //     return imageData;
    // },

    /**
     * https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/putImageData
     *
     * @param imageData ImageData ，包含像素值的数组对象。
     * @param dx 源图像数据在目标画布中的位置偏移量（x 轴方向的偏移量）。
     * @param dy 源图像数据在目标画布中的位置偏移量（y 轴方向的偏移量）。
     * @param dirtyX 在源图像数据中，矩形区域左上角的位置。默认是整个图像数据的左上角（x 坐标）。
     * @param dirtyY 在源图像数据中，矩形区域左上角的位置。默认是整个图像数据的左上角（y 坐标）。
     * @param dirtyWidth 在源图像数据中，矩形区域的宽度。默认是图像数据的宽度。
     * @param dirtyHeight 在源图像数据中，矩形区域的高度。默认是图像数据的高度。
     * @returns {CompositeCanvas}
     */
    // putImageData: function(imageData, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight){
    //     dx = dx || 0,
    //         dy = dy || 0;
    //
    //     if(arguments.length >= 7){
    //         this._canvasContext.putImageData(imageData, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
    //     }else{
    //         this._canvasContext.putImageData(imageData, dx, dy);
    //     }
    //
    //     return this;
    // },

    /**
     * https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/drawImage
     *
     * @param image 绘制到上下文的元素。允许任何的 canvas 图像源(CanvasImageSource)，例如：HTMLImageElement，HTMLVideoElement，或者 HTMLCanvasElement。
     * @param dx 目标画布的左上角在目标canvas上 X 轴的位置。
     * @param dy 目标画布的左上角在目标canvas上 Y 轴的位置。
     * @param dWidth 在目标画布上绘制图像的宽度。 允许对绘制的图像进行缩放。 如果不说明， 在绘制时图片宽度不会缩放。
     * @param dHeight 在目标画布上绘制图像的高度。 允许对绘制的图像进行缩放。 如果不说明， 在绘制时图片高度不会缩放。
     * @param sx 需要绘制到目标上下文中的，源图像的矩形选择框的左上角 X 坐标。
     * @param sy 需要绘制到目标上下文中的，源图像的矩形选择框的左上角 Y 坐标。
     * @param sWidth 需要绘制到目标上下文中的，源图像的矩形选择框的宽度。如果不说明，整个矩形从坐标的sx和sy开始，到图像的右下角结束。
     * @param sHeight 需要绘制到目标上下文中的，源图像的矩形选择框的高度。
     * @returns {CompositeCanvas}
     */
    // drawImage: function(image, dx, dy, dWidth, dHeight, sx, sy, sWidth, sHeight){
    //     if(arguments.length >= 9){
    //         this._canvasContext.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
    //     }else if(arguments.length >= 5){
    //         this._canvasContext.drawImage(image, dx, dy, dWidth, dHeight);
    //     }else{
    //         dx = dx || 0, dy = dy || 0;
    //         this._canvasContext.drawImage(image, dx, dy);
    //     }
    //
    //     return this;
    // }
});

CompositeCanvas.CompositeOperation = ['source-atop', 'source-in', 'source-out', 'source-over', 'destination-atop', 'destination-in', 'destination-out', 'destination-over', 'lighter', 'darker', 'xor', 'copy'];

var operation = CompositeCanvas.operation = {
    source_atop: 'source-atop',
    source_in: 'source-in',
    source_out: 'source-out',
    source_over: 'source-over',
    destination_atop: 'destination-atop',
    destination_in: 'destination-in',
    destination_out: 'destination-out',
    destination_over: 'destination-over',
    lighter: 'lighter',
    darker: 'darker',
    xor: 'xor',
    copy: 'copy'
};

CompositeCanvas.compositeVideoOverCanvas = function (compositeCanvasTag, video, canvas) {
    var compositeCanvas;
    if (!(compositeCanvas = compositeCanvasTag.compositeCanvas)) {
        compositeCanvas = new CompositeCanvas({
            compositeCanvasTag: compositeCanvasTag,

            requestOneFrame: function requestOneFrame() {
                video && compositeCanvas.drawImage(video, 0, 0, compositeCanvasTag.width, compositeCanvasTag.height);
                canvas && compositeCanvas.drawImage(canvas, 0, 0, compositeCanvasTag.width, compositeCanvasTag.height);
            }
        });

        compositeCanvasTag.compositeCanvas = compositeCanvas;
    }

    return compositeCanvas;
};

module.exports = CompositeCanvas;

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

var _util = __webpack_require__(15);
var _logger = _util.tagLogger("Keyboard");

module.exports = _util.prototypeExtend({
    onKeyDown: function onKeyDown(btn) {},

    onKeyUp: function onKeyUp(btn) {}
});

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

var _util = __webpack_require__(15);
var _logger = _util.tagLogger("PCStats");

/**
 * outbound-rtp
 *  bytesSent
 *  packetsSent
 *  qpSum
 *  pliCount
 * inbound-rtp
 *  bytesReceived
 *  framesDecoded
 *  packetsLost
 *  packetsReceived
 *  pliCount
 * track
 *  framesDecoded
 *  framesReceived
 *  framesDropped
 * transport
 *  bytesReceived
 *  bytesSent
 * candidate-pair
 *  bytesReceived
 *  bytesSent
 *  totalRoundTripTime
 *  requestsReceived
 *  responsesSent
 *  requestsSent
 *  responsesReceived
 * local-candidate
 *  networkType
 *  protocol
 *  port
 * remote-candidate
 *  ip
 * codec
 *  clockRate
 *  mimeType
 *
 *
 */

var PCStats;
module.exports = PCStats = _util.prototypeExtend({
    //_webrtc:
    //_stream:

    __init__: function __init__() {
        if (!this._webrtc) {
            this._stream && (this._webrtc = this._stream._webrtc);
        }

        this.samplesDatas = {};
        this.gatherResults = {};

        this._bysamples = {};
        if (this._inbound_ !== false) {
            //this._bysamples["inbound-rtp"] = ["bytesReceived", "framesDecoded", "packetsLost", "packetsReceived", "pliCount", "packageLossRate"];
            this._bysamples["inbound-rtp"] = ["bytesReceived", "packetsLost", "packetsReceived", "packageLossRate"];
        }
        if (this._outbound_ !== false) {
            //this._bysamples["outbound-rtp"] = ["bytesSent", "packetsSent", "qpSum", "pliCount"];
            this._bysamples["outbound-rtp"] = ["bytesSent"];
        }
    },

    onGatherResult: function onGatherResult(trackId, type, subtype, data) {
        _logger.info(trackId, type, subtype, data);
    },

    stats: function stats(selector) {
        if (!this._webrtc || !this._webrtc._rtcPeerConnection) {
            _logger.warn("not found webrtc or peer connection").return;
        }

        return this._webrtc._rtcPeerConnection.getStats(selector);
    },

    statsOfTrack: function statsOfTrack(selector) {
        if (!selector instanceof window.MediaStreamTrack) {
            _logger.error("selector not a MediaStreamTrack");
            throw "selector not a MediaStreamTrack";
        }

        return this.stats(selector);
    },

    audioTrack: function audioTrack(mediaStream) {
        var tracks = mediaStream && mediaStream.getAudioTracks();
        return tracks && tracks.length ? tracks[0] : undefined;
    },

    videoTrack: function videoTrack(mediaStream) {
        var tracks = mediaStream && mediaStream.getVideoTracks();
        return tracks && tracks.length ? tracks[0] : undefined;
    },

    // samplingTrack: function (track) {
    //     var self = this;
    //
    //     var trackId = track.id;
    //     this.statsOfTrack(track).then(function(_stats){
    //         self._trackSamples[trackId] || (self._trackSamples[trackId] = []);
    //
    //         var statsParms = self._trackSamples[trackId];
    //
    //         _stats.forEach(function(_stat, name){
    //             var samplings = _bysamples[_stat.type];
    //
    //             var tmp;
    //             if(samplings && samplings.length){
    //                 var statParms = (tmp || (tmp = {}))[_stat.type] = {type:_stat.type, timestamp: _stat.timestamp};
    //
    //                 samplings.forEach(function(_param){
    //                     statParms[_param] = _stat[_param];
    //                 });
    //             }
    //             tmp && statsParms.push(tmp);
    //         });
    //     });
    // },

    gatherTrack: function gatherTrack(track, mediaType) {
        var self = this;

        mediaType = track.kind || mediaType;
        mediaType = mediaType && mediaType.toLowerCase();

        var trackId = track.id;
        this.statsOfTrack(track).then(function (_stats) {
            self.samplesDatas[trackId] || (self.samplesDatas[trackId] = {});

            var statsParms = self.samplesDatas[trackId];

            _stats.forEach(function (_stat, name) {
                var samplings = self._bysamples[_stat.type];

                var statMediaType = _stat.mediaType || name.indexOf("ideo") >= 0 && "video" || name.indexOf("udio") >= 0 && "audio" || undefined;

                if (samplings && samplings.length) {
                    if (emedia.config._printDebugStats === true) {
                        _logger.debug(name, _stat, track, statMediaType, mediaType);
                    }

                    if (!statMediaType || statMediaType === mediaType) {
                        var tmp = statsParms[_stat.type] || (statsParms[_stat.type] = {});

                        samplings.forEach(function (_param) {
                            var items = tmp[_param] || (tmp[_param] = []);

                            var item = { timestamp: _stat.timestamp, kind: _stat.mediaType || track.kind || mediaType };
                            if ("packageLossRate" === _param) {
                                item[_param] = { packetsLost: _stat["packetsLost"], packetsReceived: _stat["packetsReceived"] };
                            } else {
                                item[_param] = _stat[_param];
                            }

                            items.push(item);
                        });
                    }
                }
            });
        });
    },

    gatherWebrtcMediaStream: function gatherWebrtcMediaStream(_mediaStream, type) {
        var self = this;

        if (!type) {
            _mediaStream.getTracks().forEach(function (track) {
                self.gatherTrack(track);
            });
            return;
        }

        if ("audio" === type.toLowerCase()) {
            _mediaStream.getAudioTracks().forEach(function (track) {
                self.gatherTrack(track, track.kind || type.toLowerCase());
            });
            return;
        }

        if ("video" === type.toLowerCase()) {
            _mediaStream.getVideoTracks().forEach(function (track) {
                self.gatherTrack(track, track.kind || type.toLowerCase());
            });
            return;
        }
    },

    gatherWebrtc: function gatherWebrtc() {
        this._webrtc._localStream && this.gatherWebrtcMediaStream(this._webrtc._localStream);
        this._webrtc._remoteStream && this.gatherWebrtcMediaStream(this._webrtc._remoteStream);
    },

    _gather_inbound_rtp_pliCount: function _gather_inbound_rtp_pliCount(dataArray) {
        var data = dataArray.shift();
        return data && data.pliCount || 0;
    },
    _gather_inbound_rtp_packetsLost: function _gather_inbound_rtp_packetsLost(dataArray) {
        var data = dataArray.shift();
        return data && data.packetsLost || 0;
    },
    _gather_inbound_rtp_packetsReceived: function _gather_inbound_rtp_packetsReceived(dataArray) {
        var data = dataArray.shift();
        return data && data.packetsReceived || 0;
    },
    _gather_inbound_rtp_packageLossRate: function _gather_inbound_rtp_packageLossRate(dataArray) {
        if (!dataArray || dataArray.length === 0) {
            return 0;
        }

        var data = dataArray[dataArray.length - 1];
        var firstData;
        if (dataArray.length < emedia.config.statsSeconds) {
            return 0;
        } else {
            firstData = dataArray.shift();
        }

        return (data.packageLossRate.packetsLost - firstData.packageLossRate.packetsLost) / (data.packageLossRate.packetsReceived - firstData.packageLossRate.packetsReceived);
    },

    _gather: function _gather(type, subtype, dataArray) {
        type = type.replace(/[^\w]/g, "_");
        subtype = subtype.replace(/[^\w]/g, "_");

        var func = _util.list("_gather", type, subtype).join("_");
        if (typeof this[func] === "function") {
            return this[func](dataArray);
        }

        var count = emedia.config.statsSeconds;
        if (dataArray.length < count) {
            return 0;
        }

        var data = dataArray[count - 1][subtype] - dataArray[0][subtype];
        var time = dataArray[count - 1].timestamp - dataArray[0].timestamp;

        dataArray.shift();

        return time === 0 ? 0 : parseFloat(data * 1000 / time).toFixed(2);
    },

    _statsCount: function _statsCount() {
        var self = this;

        function gatherByTrack() {
            _util.forEach(self.samplesDatas, function (trackId, _samples) {
                var trackGathers = self.gatherResults[trackId] = self.gatherResults[trackId] || {};
                gatherByType(trackId, trackGathers, _samples);
            });
        }

        function gatherByType(trackId, trackGathers, _trackSamples) {
            _util.forEach(_trackSamples, function (type, _data) {
                var typeGathers = trackGathers[type] || (trackGathers[type] = {});
                gatherBySubtype(trackId, typeGathers, type, _data);
            });
        }

        function gatherBySubtype(trackId, typeGathers, type, _data) {
            _util.forEach(_data, function (subtype, dataArray) {
                var result = typeGathers[subtype] = self._gather(type, subtype, dataArray);
                self.onGatherResult(trackId, type, subtype, result);
            });
        }

        gatherByTrack();
    },

    gather: function gather() {
        this.gatherWebrtc();
        this._statsCount();
    },

    intervalGather: function intervalGather(intervalMillis) {
        this._intervalId && clearInterval(this._intervalId);
        this._intervalId = setInterval(this.gather.bind(this), intervalMillis || 1000);
    },

    stopIntervalGather: function stopIntervalGather() {
        this._intervalId && clearInterval(this._intervalId);
    }
});

var statsMap = {};
var echo = PCStats.echo = function (easemobStreams) {
    _util.forEach(easemobStreams, function (_k, _stream) {
        if (!statsMap[_stream.id] && _stream._webrtc && !_stream._webrtc.closed && _stream.getMediaStream()) {

            var pcstats;
            statsMap[_stream.id] = pcstats = new PCStats({ _webrtc: _stream._webrtc });
            pcstats._mediaStream = _stream.getMediaStream();
        } else if (statsMap[_stream.id] && (!_stream._webrtc || _stream._webrtc.closed || !_stream.getMediaStream())) {
            _util.removeAttribute(statsMap, _stream.id);
        }
    });

    var clearStats = [];
    _util.forEach(statsMap, function (_sid, stats) {
        if (!easemobStreams || !easemobStreams[_sid]) {
            clearStats.push(_sid);
        } else {
            stats.gatherWebrtcMediaStream(stats._mediaStream);
            stats._statsCount();
        }
    });

    _util.forEach(clearStats, function (_index, _sid) {
        _util.removeAttribute(statsMap, _sid);
    });
};

PCStats.intervalEcho = function (easemobStreams, intervalMillis) {
    return setInterval(function () {
        echo(easemobStreams);
    }, intervalMillis);
};

_util.forEach(["inbound", "outbound"], function (_typeIndex, gatherType) {
    _util.forEach(["Audio", "Video"], function (_trackTypeIndex, trackType) {
        (function gather(gatherType, trackType) {
            var _gatherTrack;
            PCStats[gatherType + trackType] = _gatherTrack = function gatherTrack(easemobStream, onNotify, intervalMillis) {
                _gatherTrack.__intervalIds || (_gatherTrack.__intervalIds = {});

                var intervalId = _gatherTrack.__intervalIds && _gatherTrack.__intervalIds[easemobStream.id];
                intervalId && clearInterval(intervalId);

                intervalId = setInterval(function () {
                    var pcstats = _gatherTrack[easemobStream.id];
                    if (!pcstats && easemobStream && easemobStream._webrtc && !easemobStream._webrtc.closed && easemobStream.getMediaStream()) {

                        _gatherTrack[easemobStream.id] = pcstats = new PCStats({
                            _webrtc: easemobStream._webrtc,
                            _inbound_: gatherType === "inbound",
                            _outbound_: gatherType === "outbound"
                        });
                        onNotify && (pcstats.onGatherResult = onNotify);
                        pcstats._mediaStream = easemobStream.getMediaStream();
                    } else if (pcstats && (!easemobStream || !easemobStream._webrtc || easemobStream._webrtc.closed || easemobStream._webrtc.__id !== pcstats._webrtc.__id || !easemobStream.getMediaStream() || !pcstats._mediaStream || pcstats._mediaStream.id !== easemobStream.getMediaStream().id)) {
                        _util.removeAttribute(_gatherTrack, easemobStream.id);
                        pcstats = null;
                    }

                    if (!pcstats) {
                        var cacheStream;
                        if (easemobStream && emedia.__easemob_current_mservice && (cacheStream = emedia.__easemob_current_mservice.getStreamById(easemobStream.id))) {
                            easemobStream = cacheStream;
                        } else {
                            intervalId && clearInterval(intervalId);
                        }

                        return;
                    }

                    pcstats.gatherWebrtcMediaStream(pcstats._mediaStream, trackType);
                    pcstats._statsCount();
                }, intervalMillis);

                _gatherTrack.__intervalIds[easemobStream.id] = intervalId;

                return intervalId;
            };
        })(gatherType, trackType);
    });
});

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

window.emedia = window.emedia || {};

var _util = __webpack_require__(15);
var _logger = _util.tagLogger("electron");

emedia.electron = window.require('electron');

emedia.chooseElectronDesktopMedia = function (sources, accessApproved, accessDenied) {
    _logger.info("Choose desktop. ", sources[0]);
    accessApproved(sources[0]);
};

/***/ })
/******/ ]);
});
//2.1.1_Git.29f2187
window._emediaVersion = '2.1.1_Git.29f2187'; 
console && console.warn('EMedia version', '2.1.1_Git.29f2187');

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(5)))

/***/ }),
/* 5 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

var Util = (__webpack_require__(2).default);
var RTCIQHandler = __webpack_require__(7);
var API = __webpack_require__(8);
var WebRTC = (__webpack_require__(9).default);
var CommonPattern = __webpack_require__(10);

var RouteTo = API.RouteTo;
var Api = API.Api;
var _logger = Util.logger;


var _Call = {
    api: null,
    caller: '',
    connection: null,

    pattern: null,

    listener: {
        onAcceptCall: function (from, options) {
        },

        onRinging: function (caller) {
        },

        onTermCall: function () {
        },

        onIceConnectionStateChange: function (iceState) {
        }
    },

    mediaStreamConstaints: {
        audio: true,
        video: true
    },

    init: function () {
        var self = this;

        if (typeof self.connection === "undefined") {
            throw "Caller need a instance of Easemob.im.Connection"
        }

        self.api = self.api || new Api({
                imConnection: self.connection,

                rtcHandler: new RTCIQHandler({
                    imConnection: self.connection
                })
            });

        self.api.onInitC = function () {
            self._onInitC.apply(self, arguments);
        },

        self.api.onInvite = function(){
            self.listener.onInvite.apply(self, arguments);
        },

        self.api.onIceConnectionStateChange = function () {
            self.listener.onIceConnectionStateChange.apply(self, arguments);
        }
    },

    createConference: function(pwd, _callback){
        var rt = new RouteTo({
            rtKey: ""
        })
        this.api.reqTkt(
            rt, 
            true,
            undefined,
            pwd, 
            function(from, rtcOptions){
                var ticketStr = rtcOptions.ticket
                rtcOptions.conferenceId = rtcOptions.confrId
                _callback && _callback(from, rtcOptions)
        })
    },

    inviteConference: function(confrId, pwd, to, gid, _callback){
        var rt = new RouteTo({
            to: to,
            rtKey: "",
            rtflag: 0
        })
        this.api.invite(
            rt, 
            confrId, 
            pwd, 
            gid,
            function(from, rtcOptions){
                _callback && _callback(from, rtcOptions)
            }
        );
    },

    getConferenceTkt: function(confrId, pwd, _callback){
        var rt = new RouteTo({
            rtKey: ""
        });
        this.api.reqTkt(
            rt,
            false,
            confrId,
            pwd,
            function(from, rtcOptions){
                _callback && _callback(from, rtcOptions)
            }
        );
    },

    makeVideoCall: function (callee, accessSid) {
        var self = this;

        var mediaStreamConstaints = {};
        Util.extend(mediaStreamConstaints, self.mediaStreamConstaints);
        self.mediaStreamConstaints.video = true;

        this.call(callee, mediaStreamConstaints, accessSid);
    },

    makeVoiceCall: function (callee, accessSid) {
        console.log('ScareCrow');
        var self = this;

        var mediaStreamConstaints = {};
        Util.extend(mediaStreamConstaints, self.mediaStreamConstaints);
        self.mediaStreamConstaints.video = false;

        self.call(callee, mediaStreamConstaints, accessSid);
    },

    acceptCall: function () {
        var self = this;
        self.pattern.accept();
    },

    endCall: function (callee) {
        var self = this;
        self.caller = '';
        self.pattern.termCall();
    },

    call: function (callee, mediaStreamConstaints, accessSid) {
        var self = this;
        this.callee = this.api.jid(callee);

        var rt = new RouteTo({
            rtKey: "",
            sid: accessSid,

            success: function (result) {
                _logger.debug("iq to server success", result);
            },
            fail: function (error) {
                _logger.debug("iq to server error", error);
                self.onError(error);
            }
        });

        this.api.reqP2P(
            rt,
            mediaStreamConstaints.video ? 1 : 0,
            mediaStreamConstaints.audio ? 1 : 0,
            this.api.jid(callee),
            function (from, rtcOptions) {
                if (rtcOptions.online == "0") {
                    self.listener.onError({message: "callee is not online!"});
                    return;
                }
                self._onGotServerP2PConfig(from, rtcOptions);
                self.pattern.initC(self.mediaStreamConstaints, accessSid);
            });
    },

    _onInitC: function (from, options, rtkey, tsxId, fromSid) {
        var self = this;

        self.callee = from;
        self._rtcCfg = options.rtcCfg;
        self._WebRTCCfg = options.WebRTC;

        self.sessId = options.sessId;
        self.rtcId = options.rtcId;

        self.switchPattern(options.streamType == "VIDEO" ? "VIDEO" : "VOICE");
        self.pattern._onInitC(from, options, rtkey, tsxId, fromSid);
    },

    _onInvite: function(){

    },

    _onGotServerP2PConfig: function (from, rtcOptions) {
        var self = this;

        if (rtcOptions.result == 0) {
            self._p2pConfig = rtcOptions;
            self._rtcCfg = rtcOptions.rtcCfg;
            self._rtcCfg2 = rtcOptions.rtcCfg2;

            self.sessId = rtcOptions.sessId;
            self.rtcId = "Channel_webIM";

            self._rtKey = self._rtkey = rtcOptions.rtKey || rtcOptions.rtkey;
            self._rtFlag = self._rtflag = rtcOptions.rtFlag || rtcOptions.rtflag;

            self._WebRTCCfg = rtcOptions.WebRTC;
            self.admtok = rtcOptions.admtok;
            self.tkt = rtcOptions.tkt;


            self.switchPattern(self.mediaStreamConstaints.audio && self.mediaStreamConstaints.video ? "VIDEO" : "VOICE");
        } else {
            //
        }
    },

    switchPattern: function (streamType) {
        var self = this;

        (!self._WebRTCCfg) && (self.pattern = new CommonPattern({
            callee: self.callee,

            _p2pConfig: self._p2pConfig,
            _rtcCfg: self._rtcCfg,
            _rtcCfg2: self._rtcCfg2,

            _rtKey: self._rtKey || self._rtkey,
            _rtFlag: self._rtFlag || self._rtflag,

            _sessId: self.sessId,
            _rtcId: self.rtcId,

            webRtc: new WebRTC({
                streamType: streamType,
                subArgs:{
                    subSVideo: "VIDEO" === streamType,
                    subSAudio: true
                },
                onGotLocalStream: self.listener.onGotLocalStream,
                onGotRemoteStream: function(remoteStream, event){
                    self.listener.onGotRemoteStream(remoteStream, streamType);
                },
                onError: self.listener.onError
            }),

            api: self.api,

            onAcceptCall: (self.listener && self.listener.onAcceptCall) || function () {

            },
            onRinging: (self.listener && self.listener.onRinging) || function () {

            },
            onTermCall: (self.listener && self.listener.onTermCall) || function () {

            },
            onOtherUserOpenVoice: (self.listener && self.listener.onOtherUserOpenVoice) || function () {

            },
            onOtherUserOpenVideo: (self.listener && self.listener.onOtherUserOpenVideo) || function () {

            }
        }));
    }
};


module.exports = function (initConfigs) {
    Util.extend(true, this, _Call, initConfigs || {});

    this.init();
};


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * IQ Message，IM -> CMServer --> IM
 */

var _util = (__webpack_require__(2).default);
var _logger = _util.logger;
var API = __webpack_require__(8);
var RouteTo = API.RouteTo;

var CONFERENCE_XMLNS = "urn:xmpp:media-conference";


var _RtcHandler = {
    _apiCallbacks: {},

    imConnection: null,

    _connectedSid: '',


    init: function () {
        var self = this;

        var _conn = self.imConnection;

        _conn.registerConfrIQHandler = function(){
            var handleConferenceIQ = function (msginfo) {
                try {
                    self.handleRtcMessage(msginfo);
                } catch (error) {
                    _logger.error(error);
                    //throw error;
                }

                return true;
            };

            _conn.addHandler(handleConferenceIQ, CONFERENCE_XMLNS, 'iq', "set");
            _conn.addHandler(handleConferenceIQ, CONFERENCE_XMLNS, 'iq', "get");

            _logger.warn("Conference iq handler. registered.");
        }
    },

    handleRtcMessage: function (msginfo) {
        var self = this;

        var id = msginfo.getAttribute('id');
        var from = msginfo.getAttribute('from') || '';

        // remove resource
        from.lastIndexOf("/") >= 0 && (from = from.substring(0, from.lastIndexOf("/")));


        var rtkey = msginfo.getElementsByTagName('rtkey')[0].innerHTML;

        var fromSessionId = msginfo.getElementsByTagName('sid')[0].innerHTML;

        (self._fromSessionID || (self._fromSessionID = {}))[from] = fromSessionId;

        var contentTags = msginfo.getElementsByTagName('content');



        var contentString = contentTags[0].innerHTML;

        var content = _util.parseJSON(contentString);

        var rtcOptions = content;

        var streamType = msginfo.getElementsByTagName('stream_type')[0].innerHTML; //VOICE, VIDEO

        if(streamType == ""){
            streamType = "VOICE";
        }

        rtcOptions.streamType = streamType;

        if(rtcOptions.op == 102){
            self.singalStreamType = streamType;
        }


        var tsxId = content.tsxId;

        self.ctx = content.ctx;

        _logger.debug("Recv [op = " + rtcOptions.op + "] [tsxId=" + tsxId + "]\r\n json :", msginfo);


        //if a->b already, c->a/b should be termiated with 'busy' reason
        if (from.indexOf("@") >= 0) {
            if (self._connectedSid == '' && (rtcOptions.op == 102 || rtcOptions.op == 202)) {
                self._connectedSid = fromSessionId;
            } else {
                if (self._connectedSid != fromSessionId) {
                    _logger.debug("Error recv [op = " + rtcOptions.op + "] [tsxId=" + tsxId + "]. caused by _connectedSid != fromSessionId :",
                        self._connectedSid, fromSessionId);

                    //onInitC
                    if (rtcOptions.op == 102) {
                        var rt = new RouteTo({
                            to: from,
                            rtKey: rtkey,
                            sid: fromSessionId,
                            success: function (result) {
                                _logger.debug("iq to server success", result);
                            },
                            fail: function (error) {
                                _logger.debug("iq to server error", error);
                                self.onError(error);
                            }
                        });

                        var options = {
                            data: {
                                op: 107,
                                sessId: rtcOptions.sessId,
                                rtcId: rtcOptions.rtcId,
                                reason: 'busy'

                            },
                            reason: 'busy'
                        };
                        self.sendRtcMessage(rt, options)
                    }
                    return;
                }
            }
        }

        //onTermC
        if (rtcOptions.op == 107) {
            self._connectedSid = '';
            self._fromSessionID = {};

            var reasonObj = msginfo.getElementsByTagName('reason');
            //var endReason = msginfo.getElementsByTagName('reason')[0].innerHTML;
            reasonObj && reasonObj.length > 0 && (rtcOptions.reason = reasonObj[0].innerHTML);
        }

        if (rtcOptions.sdp) {
            if (typeof rtcOptions.sdp === 'string') {
                rtcOptions.sdp = _util.parseJSON(rtcOptions.sdp);
            }
            rtcOptions.sdp.type && (rtcOptions.sdp.type = rtcOptions.sdp.type.toLowerCase());
        }
        if (rtcOptions.cands) {
            if (typeof rtcOptions.cands === 'string') {
                rtcOptions.cands = _util.parseJSON(rtcOptions.cands);
            }

            for (var i = 0; i < rtcOptions.cands.length; i++) {
                if(typeof rtcOptions.cands[i] === 'string'){
                    try{
                        rtcOptions.cands[i] = _util.parseJSON(rtcOptions.cands[i]);
                    }catch(e){
                        rtcOptions.cands[i] = {candidate: rtcOptions.cands[i]}
                    }
                }

                rtcOptions.cands[i].sdpMLineIndex = rtcOptions.cands[i].sdpMLineIndex !== undefined ?
                    rtcOptions.cands[i].sdpMLineIndex : rtcOptions.cands[i].mlineindex;
                rtcOptions.cands[i].sdpMid = rtcOptions.cands[i].sdpMid !== undefined ?
                    rtcOptions.cands[i].sdpMid : rtcOptions.cands[i].mid;

                delete rtcOptions.cands[i].mlineindex;
                delete rtcOptions.cands[i].mid;
            }
        }

        rtcOptions.rtcCfg && (typeof rtcOptions.rtcCfg === 'string') && (rtcOptions.rtcCfg = _util.parseJSON(rtcOptions.rtcCfg));
        rtcOptions.rtcCfg2 && (typeof rtcOptions.rtcCfg2 === 'string') && (rtcOptions.rtcCfg2 = _util.parseJSON(rtcOptions.rtcCfg2));
        rtcOptions.WebRTC && (typeof rtcOptions.WebRTC === 'string') && (rtcOptions.WebRTC = _util.parseJSON(rtcOptions.WebRTC));
        rtcOptions.confrId && (rtcOptions.conferenceId = rtcOptions.confrId)

        if (tsxId && self._apiCallbacks[tsxId]) {
            try {
                self._apiCallbacks[tsxId].callback && self._apiCallbacks[tsxId].callback(from, rtcOptions);
            } catch (err) {
                throw err;
            } finally {
                delete self._apiCallbacks[tsxId]
            }
        } else {
            self.onRecvRtcMessage(from, rtcOptions, rtkey, tsxId, fromSessionId);
        }

        return true;
    },


    onRecvRtcMessage: function (from, rtcOptions, rtkey, tsxId, fromSessionId) {
        _logger.debug(' form : ' + from + " \r\n json :" + _util.stringifyJSON(rtcJSON));
    },

    convertRtcOptions: function (options) {
        var sdp = options.data.sdp;
        if (sdp) {
            var _sdp = {
                type: sdp.type,
                sdp: sdp.sdp
            };

            sdp = _sdp;

            sdp.type = sdp.type.toUpperCase();
            sdp = _util.stringifyJSON(sdp);

            options.data.sdp = sdp;
        }


        var cands = options.data.cands;

        if (cands) {
            if (_util.isArray(cands)) {

            } else {
                var _cands = [];
                _cands.push(cands);
                cands = _cands;
            }

            for (var i in cands) {
                var cand = cands[i];

                if (cand.candidate !== undefined
                    && cand.sdpMLineIndex !== undefined
                    && cand.sdpMid !== undefined) {
                    var _cand = {
                        type: "candidate",
                        candidate: cand.candidate,
                        mlineindex: cand.sdpMLineIndex,
                        mid: cand.sdpMid,
                        // seq: i
                    };

                    cands[i] = _util.stringifyJSON(_cand);
                }
            }

            options.data.cands = cands;
        } else {
            // options.data.cands = [];
        }

        var rtcCfg = options.data.rtcCfg;
        if (rtcCfg) {
            typeof rtcCfg !== 'string' && (options.data.rtcCfg = _util.stringifyJSON(rtcCfg));
        }

        var _webrtc = options.data.WebRTC;
        if (_webrtc) {
            typeof _webrtc !== 'string' && (options.data.WebRTC = _util.stringifyJSON(_webrtc));
        }
    },

    getShortId: function (jid) {
        var begin;
        if((begin = (jid.indexOf('_') + 1)) < 1){
            begin = 0;
        }

        var end;
        if((end = jid.indexOf('@', -1)) < 0){
            end = jid.length;
        }

        return jid.substring(begin, end);
    },

    /**
     * rt: { id: , to: , rtKey: , rtflag: , sid: , tsxId: , type: , }
     *
     * rtcOptions: { data : { op : 'reqP2P', video : 1, audio : 1, peer :
     * curChatUserId, //appKey + "_" + curChatUserId + "@" + this.domain, } }
     *
     */
    sendRtcMessage: function (rt, options, callback) {
        var self = this;

        var _conn = self.imConnection;

        var tsxId = rt.tsxId || _conn.getUniqueId();

        var to = rt.to || _conn.domain;

        var sid = rt.sid || self._fromSessionID && self._fromSessionID[to];
        //sid = sid || ((self._fromSessionID || (self._fromSessionID = {}))[to] = _conn.getUniqueId("CONFR_"));
        sid = sid || _conn.getUniqueId("CONFR_");
        (self._fromSessionID || (self._fromSessionID = {}))[to] = sid;

        if (to.indexOf("@") >= 0) {
            if (self._connectedSid == '' && options.data.op == 102) {
                self._connectedSid = sid;
            }
        }
        var rtKey = rt.rtKey || rt.rtkey;
        // rtKey && delete rt.rtKey;
        rtKey || (rtKey = "");

        var rtflag = rt.rtflag;
        // rtflag && delete rt.rtflag;
        !isNaN(rtflag) || (rtflag = 1);

        options.data || (options.data = {});
        options.data.tsxId = tsxId;

        self.ctx && (options.data.ctx = self.ctx);
        self.convertRtcOptions(options);

        var streamType = options.streamType || self.singalStreamType || "VIDEO"; // "VIDEO"; //VOICE, VIDEO
        if (options.data.op == 102) {
            self.singalStreamType = streamType;
        }


        var id = rt.id || _conn.getUniqueId("CONFR_");
        var iq = $iq({
            // xmlns: CONFERENCE_XMLNS,
            id: id,
            to: to,
            from: _conn.context.jid,
            type: rt.type || "get"
        }).c("query", {
            xmlns: CONFERENCE_XMLNS
        }).c("MediaReqExt").c('rtkey').t(rtKey)
            .up().c('rtflag').t(rtflag)
            .up().c('stream_type').t(streamType)
            .up().c('sid').t(sid)
            .up().c('content').t(_util.stringifyJSON(options.data));

        if (options.data.op == 107 && options.reason) {
            iq.up().c('reason').t(options.reason);
        }
        _logger.debug("Send [op = " + options.data.op + "] : \r\n", iq.tree());


        callback && (
            self._apiCallbacks[tsxId] = {
                callback: callback
            }
        );

        var completeFn = function (result) {
                rt.success(result);
            } || function (result) {
                _logger.debug("send result. op:" + options.data.op + ".", result);
            };

        var errFn = function (ele) {
                rt.fail(ele);
            } || function (ele) {
                _logger.debug(ele);
            };

        if(options.data.op != 202){
            _conn.context.stropheConn.sendIQ(iq.tree(), completeFn, errFn);
        }

        //onTermC
        if (options.data.op == 107 && self._connectedSid) {
            if (!rt.sid || self._connectedSid == rt.sid) {
                self._connectedSid = '';
                self._fromSessionID = {};
            }
        }

        if (options.data.op == 202){
            var msg = _util.list("Invite", self.getShortId(to), "join conference:", options.data.confrId).join(" ");
            var id = _conn.getUniqueId("CONFR_INVITE");                 // 生成本地消息id
            var inviteMessage = $msg({
                xmlns: 'jabber:client',
                id: id,
                type: 'chat',
                to: to,
                from: _conn.context.jid
            }).c('body').t(JSON.stringify({
                data: msg,
                bodies:[
                    {
                        msg: msg,
                        type: "txt"
                    }
                ],
                ext: {
                    conferenceId: options.data.confrId,
                    password: options.data.password,
                    msg_extension: {
                        group_id: options.data.gid,
                        inviter: self.getShortId(_conn.context.jid)
                    }
                },
                from: self.getShortId(_conn.context.jid),
                to: self.getShortId(to)
            }));

            _conn.sendCommand(inviteMessage.tree(), inviteMessage.id);
        }
    }
};


var RTCIQHandler = function (initConfigs) {
    _util.extend(true, this, _RtcHandler, initConfigs || {});

    this.init();
};
module.exports = RTCIQHandler;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * API
 */
var _util = (__webpack_require__(2).default);
var _logger = _util.logger;


var _RouteTo = {
    // to : null,
    // rtKey: null,
    rtFlag: 1,

    success: function (result) {

    },
    fail: function (error) {

    }
};

var RouteTo = function (extendCfg) {
    if (this instanceof RouteTo) {
        var self = this;
        _util.extend(true, self, _RouteTo, extendCfg || {});

    } else {
        var sub = function (extendCfg) {
            var self = this;
            _util.extend(true, self, extendCfg || {});
        };

        _util.extend(true, sub.prototype, _RouteTo, extendCfg || {});

        return sub;
    }
};
exports.RouteTo = RouteTo;


var _clazz = {
    imConnection: null,
    // webRtc: null,

    rtcHandler: null,

    events: {
        '0': 'onReqP2P',
        '1': 'onNewCfr',
        '2': 'onDelCfr',
        '3': 'onReqTkt',

        '100': 'onPing',
        '101': 'onPong',
        '102': 'onInitC',
        '103': 'onReqC',
        '104': 'onAcptC',
        '105': 'onTcklC',
        '106': 'onAnsC',
        '107': 'onTermC',

        // '200' : 'onEnter',
        // '201' : 'onExit',
        '202' : 'onInvite',
        // '203' : 'onGetMems',

        // '205' : 'onSubC',
        // '206' : 'onUsubC',

        '300': 'onEvEnter',
        '301': 'onEvExit',
        '302': 'onEvPub',
        '303': 'onEvUnpub',
        '304': 'onEvMems',
        '204': 'onEvClose',
        '400': 'onStreamControl',
        '401': 'onEvJoin',

        'onServerError': 'onServerError'
    },

    register: function (listener) {
        if (typeof listener === "object") {
            for (var event in listener) {
                this.bind(event, listener[event]);
            }
        }
    },

    bind: function (event, func) {
        var self = this;

        var onFunc;
        if ((onFunc = self.events[event])) {
            self[onFunc] = func;
        } else {
            onFunc = self.events[event] = 'on_' + event;
            self[onFunc] = func;
        }
    },

    jid: function (shortUserName) {
        if(/^.+#.+_.+@.+$/g.test(shortUserName)){
            return shortUserName;
        }
        // if (shortUserName.indexOf(this.imConnection.context.appKey) >= 0) {
        //     return shortUserName;
        // }
        return this.imConnection.context.appKey + "_" + shortUserName + "@" + this.imConnection.domain;
    },

    /**
     * ReqP2P 0
     *
     * @param rt
     *            {to: , rtKey: , rtflag: , success(result), fail(error)}
     *
     * @param callback(from, rtcOptions)
     *
     *
     * @param video
     *            1 0
     * @param audio
     *            1 0
     * @param peer
     *
     */
    reqP2P: function (rt, video, audio, peer, callback) {
        _logger.debug("req p2p ...");


        var rtcOptions = {
            data: {
                op: 0,
                video: video,
                audio: audio,
                peer: peer // appKey + "_" + curChatUserId + "@" + this.domain,
            }
        };

        this.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);
    },

    /**
     * NewCfr 1
     *
     * @param rt
     *            {to: , rtKey: , rtflag: , success(result), fail(error)}
     *
     * @param callback(from, rtcOptions)
     *
     *
     * @param reqTkt
     *            1 null
     * @param password
     *            string null
     *
     */
    newCfr: function (rt, reqTkt, password, callback) {
        _logger.debug("newCfr ...");

        var self = this;

        var rtcOptions = {
            data: {
                op: 1
            }
        };

        reqTkt && (rtcOptions.data.reqTkt = reqTkt);
        password && (rtcOptions.data.password = password);

        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);
    },

    /**
     * Enter 200
     *
     * @param rt
     *            {to: , rtKey: , rtflag: , success(result), fail(error)}
     *
     * @param callback(from, rtcOptions)
     *
     *
     * @param WebRTCId
     * @param reqMembers !=
     *            0 members
     * @param tkt
     * @param nonce
     * @param digest
     *
     */
    enter: function (rt, WebRTCId, reqMembers, tkt, nonce, digest, callback) {
        _logger.debug("enter ...");

        var self = this;

        var rtcOptions = {
            data: {
                op: 200
            }
        };

        WebRTCId && (rtcOptions.data.WebRTCId = WebRTCId);
        reqMembers && (rtcOptions.data.reqMembers = reqMembers);
        tkt && (rtcOptions.data.tkt = tkt);
        nonce && (rtcOptions.data.nonce = nonce);
        digest && (rtcOptions.data.digest = digest);

        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);
    },

    /**
     * Ping 100
     *
     * @param rt
     *            {to: , rtKey: , rtflag: , success(result), fail(error)}
     *
     * @param callback(from, rtcOptions)
     *
     *
     * @param sessId
     *
     */
    ping: function (rt, sessId, callback) {
        _logger.debug("ping ...");

        var self = this;

        var rtcOptions = {
            data: {
                op: 100
            }
        };

        sessId && (rtcOptions.data.sessId = sessId);

        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);
    },

    /**
     * 通知对方 我已经关闭/打开 麦卡，摄像头
     *
     * PAUSE_VOICE(0, 0), RESUME_VOICE(1, 1), PAUSE_VIDEO(2, 2), RESUME_VIDEO(3, 3)
     *
     *
     * @param rt
     * @param sessId
     * @param rtcId
     * @param controlType
     * @param callback
     */
    streamControl: function (rt, sessId, rtcId, controlType, callback) {
        _logger.debug("streamControl ...");

        var self = this;

        var rtcOptions = {
            data: {
                op: 400
            }
        };

        sessId && (rtcOptions.data.sessId = sessId);
        rtcId && (rtcOptions.data.rtcId = rtcId);
        (typeof controlType !== 'undefined' &&  controlType != null ) && (rtcOptions.data.controlType = controlType);

        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);
    },

    /**
     * ReqTkt 3
     *
     * @param rt
     *            {to: , rtKey: , rtflag: , success(result), fail(error)}
     *
     * @param callback(from, rtcOptions)
     *
     *
     * @param WebRTCId
     * @param success(from,
     *            rtcOptions)
     *
     */
    reqTkt: function (rt, isCreate, confrId, password, callback) {
        _logger.debug("reqTkt ...");

        var self = this;

        var rtcOptions = {
            data: {
                op: 3
            }
        };

        isCreate && (rtcOptions.data.isCreate = isCreate);
        confrId && (rtcOptions.data.confrId = confrId);
        typeof password === "string" && (rtcOptions.data.password = password);

        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);
    },

    invite: function (rt, confrId, password, gid, callback) {
        _logger.debug("reqTkt ...");

        var self = this;

        var rtcOptions = {
            data: {
                op:  202
            }
        };

        confrId && (rtcOptions.data.confrId = confrId); // 格式需要跟雅洁确定
        typeof password === "string" && (rtcOptions.data.password = password);
        gid && (rtcOptions.data.gid = gid);
        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);
    },

    /**
     * InitC 102
     *
     * @param rt
     *            {to: , rtKey: , rtflag: , success(result), fail(error)}
     *
     * @param callback(from, rtcOptions)
     *
     *
     * @param WebRTCId
     * @param tkt
     * @param sessId
     * @param rtcId
     * @param pubS
     *            {name: streamName, video:1, audio:1, type: 0}
     * @param subS
     *            {memId: , rtcId: }
     * @param sdp
     *            sdp:sdpstring
     * @param cands [ ]
     *
     */
    initC: function (rt, streamType, WebRTCId, tkt, sessId, rtcId, pubS, subS, sdp, cands, rtcCfg, WebRTC, callback) {
        _logger.debug("initC ...");


        var rtcOptions = {
            data: {
                op: 102
            }
        };

        rtcOptions.streamType = streamType || "VIDEO";

        WebRTCId && (rtcOptions.data.WebRTCId = WebRTCId);
        tkt && (rtcOptions.data.tkt = tkt);
        sessId && (rtcOptions.data.sessId = sessId);
        rtcId && (rtcOptions.data.rtcId = rtcId);
        pubS && (rtcOptions.data.pubS = pubS);
        subS && (rtcOptions.data.subS = subS);
        sdp && (rtcOptions.data.sdp = sdp);
        cands && (rtcOptions.data.cands = cands);
        rtcCfg && (rtcOptions.data.rtcCfg = rtcCfg);
        WebRTC && (rtcOptions.data.WebRTC = WebRTC);

        rtcOptions.data.expr = !emedia.supportPRAnswer ? 0 : 1; //Firefox 和 Edge不希望sdk回复 pranswer

        this.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);
    },

    /**
     * TcklC 105
     *
     * @param rt
     *            {to: , rtKey: , rtflag: , success(result), fail(error)}
     *
     * @param callback(from, rtcOptions)
     *
     *
     * @param sessId
     * @param rtcId
     * @param cands
     * @param success(from,
     *            rtcOptions)
     *
     */
    tcklC: function (rt, sessId, rtcId, sdp, cands, callback) {
        _logger.debug("tcklC ...");

        var self = this;

        var rtcOptions = {
            data: {
                op: 105
            }
        };

        sessId && (rtcOptions.data.sessId = sessId);
        rtcId && (rtcOptions.data.rtcId = rtcId);
        sdp && (rtcOptions.data.sdp = sdp);
        cands && (rtcOptions.data.cands = cands);

        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);
    },

    /**
     * AnsC 106
     *
     * @param rt
     *            {to: , rtKey: , rtflag: , success(result), fail(error)}
     *
     * @param callback(from, rtcOptions)
     *
     *
     * @param sessId
     * @param rtcId
     * @param sdp
     * @param cands
     *
     */
    ansC: function (rt, sessId, rtcId, sdp, cands, callback, enableVoice, enableVideo) {
        _logger.debug("ansC ...");

        var self = this;

        var rtcOptions = {
            data: {
                op: 106
            }
        };

        sessId && (rtcOptions.data.sessId = sessId);
        rtcId && (rtcOptions.data.rtcId = rtcId);
        sdp && (rtcOptions.data.sdp = sdp);
        cands && (rtcOptions.data.cands = cands);

        enableVoice === false && (rtcOptions.data.enableVoice = enableVoice);
        enableVideo === false && (rtcOptions.data.enableVideo = enableVideo);



        // rtcOptions.data.enableVoice = false;
        // rtcOptions.data.enableVideo = false;

        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);
    },

    /**
     * AcptC 104
     *
     * @param rt
     *            {to: , rtKey: , rtflag: , success(result), fail(error)}
     *
     * @param callback(from, rtcOptions)
     *
     *
     * @param sessId
     * @param rtcId
     * @param sdp
     * @param ans
     *            1
     *
     */
    acptC: function (rt, sessId, rtcId, sdp, cands, ans, callback, enableVoice, enableVideo) {
        _logger.debug("acptC ...");

        var self = this;

        var rtcOptions = {
            data: {
                op: 104
            }
        };

        sessId && (rtcOptions.data.sessId = sessId);
        rtcId && (rtcOptions.data.rtcId = rtcId);
        sdp && (rtcOptions.data.sdp = sdp);
        cands && (rtcOptions.data.cands = cands);
        ans && (rtcOptions.data.ans = ans);

        enableVoice === false && (rtcOptions.data.enableVoice = enableVoice);
        enableVideo === false && (rtcOptions.data.enableVideo = enableVideo);

        // rtcOptions.data.enableVoice = false;
        // rtcOptions.data.enableVideo = false;

        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);
    },

    /**
     * GetMems 203
     *
     * @param rt
     *            {to: , rtKey: , rtflag: , success(result), fail(error)}
     *
     * @param callback(from, rtcOptions)
     *
     *
     * @param WebRTCId
     * @param sessId
     * @param success(from,
     *            rtcOptions)
     *
     */
    getMems: function (rt, WebRTCId, sessId, callback) {
        _logger.debug("getMems ...");

        var self = this;

        var rtcOptions = {
            data: {
                op: 203
            }
        };

        WebRTCId && (rtcOptions.data.WebRTCId = WebRTCId);
        sessId && (rtcOptions.data.sessId = sessId);

        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);
    },

    /**
     * SubC 205
     *
     * @param rt
     *            {to: , rtKey: , rtflag: , success(result), fail(error)}
     *
     * @param callback(from, rtcOptions)
     *
     *
     * @param sessId
     * @param rtcId
     * @param subS
     *            {memId:m001, rtcId:r001}
     *
     */
    subC: function (rt, sessId, rtcId, subS, callback) {
        _logger.debug("subC ...");

        var self = this;

        var rtcOptions = {
            data: {
                op: 205
            }
        };

        sessId && (rtcOptions.data.sessId = sessId);
        rtcId && (rtcOptions.data.rtcId = rtcId);
        subS && (rtcOptions.data.subS = subS);

        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);
    },

    /**
     * UsubC 206
     *
     * @param rt
     *            {to: , rtKey: , rtflag: , success(result), fail(error)}
     *
     * @param callback(from, rtcOptions)
     *
     *
     * @param sessId
     * @param rtcId
     *
     */
    usubC: function (rt, sessId, rtcId, callback) {
        _logger.debug("usubC ...");

        var self = this;

        var rtcOptions = {
            data: {
                op: 206
            }
        };

        sessId && (rtcOptions.data.sessId = sessId);
        rtcId && (rtcOptions.data.rtcId = rtcId);

        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);
    },

    /**
     * TermC 107
     *
     * @param rt
     *            {to: , rtKey: , rtflag: , success(result), fail(error)}
     *
     * @param callback(from, rtcOptions)
     *
     *
     * @param sessId
     * @param rtcId
     * @param reason
     *               "ok"      -> 'HANGUP'     "success" -> 'HANGUP'   "timeout"          -> 'NORESPONSE'
     *               "decline" -> 'REJECT'     "busy"    -> 'BUSY'     "failed-transport" -> 'FAIL'
     *
     */
    termC: function (rt, sessId, rtcId, reason, callback) {
        _logger.debug("termC ...");

        var self = this;

        var rtcOptions = {
            data: {
                op: 107
            }
        };

        sessId && (rtcOptions.data.sessId = sessId);
        rtcId && (rtcOptions.data.rtcId = rtcId);
        reason && (rtcOptions.reason = reason);

        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);
    },

    /**
     * Exit 201
     *
     * @param rt
     *            {to: , rtKey: , rtflag: , success(result), fail(error)}
     *
     * @param callback(from, rtcOptions)
     *
     *
     * @param WebRTCId
     * @param sessId
     * @param success(from,
     *            rtcOptions)
     *
     */
    exit: function (rt, WebRTCId, sessId, callback) {
        _logger.debug("exit ...");

        var self = this;

        var rtcOptions = {
            data: {
                op: 201
            }
        };

        WebRTCId && (rtcOptions.data.WebRTCId = WebRTCId);
        sessId && (rtcOptions.data.sessId = sessId);

        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);
    },

    /**
     * DelCfr 2
     *
     * @param rt
     *            {to: , rtKey: , rtflag: , success(result), fail(error)}
     *
     * @param callback(from, rtcOptions)
     *
     *
     * @param WebRTCId
     * @param admtok
     * @param success(from,
     *            rtcOptions)
     *
     */
    delCfr: function (rt, WebRTCId, admtok, callback) {
        _logger.debug("delCfr ...");

        var self = this;

        var rtcOptions = {
            data: {
                op: 2
            }
        };

        WebRTCId && (rtcOptions.data.WebRTCId = WebRTCId);
        admtok && (rtcOptions.data.admtok = admtok);

        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);
    }
};

exports.Api = function (initConfigs) {
    var self = this;

    _util.extend(true, this, _clazz, initConfigs || {});


    function _onRecvRtcMessage(from, rtcOptions, rtkey, tsxId, fromSessionId) {
        if (rtcOptions.result != 0 && self['onServerError']) {
            self['onServerError'].call(self, from, rtcOptions, rtkey, tsxId, fromSessionId);
        } else {
            var onFunction;

            if (self.events[rtcOptions.op] && (onFunction = self[self.events[rtcOptions.op]])) {
                onFunction.call(self, from, rtcOptions, rtkey, tsxId, fromSessionId);
            } else {
                _logger.info("can not handle(recvRtcMessage) the op: " + rtcOptions.op, rtcOptions);
            }
        }
    }

    this.rtcHandler.onRecvRtcMessage = _onRecvRtcMessage;
};


/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var easemob_emedia__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var easemob_emedia__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(easemob_emedia__WEBPACK_IMPORTED_MODULE_0__);


easemob_emedia__WEBPACK_IMPORTED_MODULE_0__["Webrtc"].prototype.AVPubstream = easemob_emedia__WEBPACK_IMPORTED_MODULE_0__["Service"].prototype.AVPubstream;

easemob_emedia__WEBPACK_IMPORTED_MODULE_0__["Webrtc"].prototype._openCamera = function(){
    easemob_emedia__WEBPACK_IMPORTED_MODULE_0__["Service"].prototype._openCamera.apply(this, arguments);
}
easemob_emedia__WEBPACK_IMPORTED_MODULE_0__["Webrtc"].prototype.__getUserMedia = function(){
    easemob_emedia__WEBPACK_IMPORTED_MODULE_0__["Service"].prototype.__getUserMedia.apply(this, arguments);
}
easemob_emedia__WEBPACK_IMPORTED_MODULE_0__["Webrtc"].prototype.__controlStream = function(){
    easemob_emedia__WEBPACK_IMPORTED_MODULE_0__["Service"].prototype.__controlStream.apply(this, arguments);
}
easemob_emedia__WEBPACK_IMPORTED_MODULE_0__["Webrtc"].prototype.__sysGetUserMedia = function(){
    easemob_emedia__WEBPACK_IMPORTED_MODULE_0__["Service"].prototype.__sysGetUserMedia.apply(this, arguments);
}

//callback (rtc, stream)
easemob_emedia__WEBPACK_IMPORTED_MODULE_0__["Webrtc"].prototype.createMedia = function(constaints, callback){
    var self = this;

    var pubS = new self.AVPubstream({
        constaints: constaints,
        aoff: 0,
        voff: 0
    });

    var openUserMedia = easemob_emedia__WEBPACK_IMPORTED_MODULE_0__["Service"].prototype.openUserMedia.bind(this);
    openUserMedia(pubS).then(function (_service, stream) {
        WebIM.__alreadyOpenMedias.push(stream);
        callback && callback(self, stream)
    }, function fail(evt) {
        easemob_emedia__WEBPACK_IMPORTED_MODULE_0__["util"].logger.debug('[WebRTC-API] getUserMedia() error: ', evt);
        self.onError(evt);
    });
}

var createMedia;
easemob_emedia__WEBPACK_IMPORTED_MODULE_0__["Webrtc"].prototype.createMedia =
    createMedia = function(constaints, callback){
    var self = this;

    var mediaStream = new MediaStream();

    function __callback() {
        if(--__callback.count === 0){
            WebIM.__alreadyOpenMedias.push(mediaStream);
            callback && callback(self, mediaStream);
        }
    }

    function __cloneTrack(destStream) {
        destStream && destStream.getTracks().forEach(function(track) {
            mediaStream.addTrack(track);
        });
    }

    var audio = !constaints || constaints.audio;
    var video = !constaints || constaints.video;

    if(!audio && !video){
        __callback.count = 0;
        return __callback();
    }

    if(!!audio && !!video){ //两个true
        __callback.count = 2;
        createMedia.call(this, {video: constaints.video, audio: false}, function (obj, stream) {
            __cloneTrack(stream);
            __callback();
        });
        createMedia.call(this, {video: false, audio: constaints.audio}, function (obj, stream) {
            __cloneTrack(stream);
            __callback();
        });

        return;
    }

    __callback.count = 1;

    var pubS = new self.AVPubstream({
        constaints: constaints
    });

    var openUserMedia = easemob_emedia__WEBPACK_IMPORTED_MODULE_0__["Service"].prototype.openUserMedia.bind(this);
    openUserMedia(pubS).then(function (_service, stream) {
        __cloneTrack(stream);
        __callback();
    }, function fail(evt) {
        __callback();
        easemob_emedia__WEBPACK_IMPORTED_MODULE_0__["util"].logger.debug('[WebRTC-API] getUserMedia() error: ', evt);

        if(typeof evt.message === 'function'){
            evt.message = evt.message();
        }else if(typeof evt.message === 'string' && evt.message !== ""){
            evt.message = evt.message;
        }else{
            evt.message = "open media error. " + evt.name;
        }

        evt.message = evt.message + " when get " + (video ? "carma" : "microphone");

        self.onError(evt);
    });
}

easemob_emedia__WEBPACK_IMPORTED_MODULE_0__["Webrtc"].prototype.setLocalVideoSrcObject = function (stream) {
    var self = this;

    self._localStream = stream;

    self.onGotLocalStream(stream, this.streamType);
    self.setLocalStream(stream);

    easemob_emedia__WEBPACK_IMPORTED_MODULE_0__["util"].logger.debug('[WebRTC-API] you can see yourself !');
}

var _setRemoteDescription = easemob_emedia__WEBPACK_IMPORTED_MODULE_0__["Webrtc"].prototype.setRemoteDescription;
easemob_emedia__WEBPACK_IMPORTED_MODULE_0__["Webrtc"].prototype.setRemoteDescription = function (desc) {
    var self = this;

    if(self.streamType === "VOICE"){ //将remote sdp中 video中改为 a=mid:video -》 a=sendrecv|a=sendonly--recvonly
        function videoSectionReplace(regx, use) {
            var videoSectionIndex = desc.sdp.indexOf("m=video");
            var audioSectionIndex = desc.sdp.indexOf("m=audio");
            var end = audioSectionIndex > videoSectionIndex ? audioSectionIndex : desc.sdp.length;

            desc.sdp = desc.sdp.replace(regx, function (match, offset, string) {
                if(offset >= videoSectionIndex && offset < end){
                    return use;
                }else{
                    return match;
                }
            });
        }

        videoSectionReplace(/a=sendrecv|a=sendonly/g, "a=inactive");
    }
    return _setRemoteDescription.call(self, desc);
}


/* harmony default export */ __webpack_exports__["default"] = (easemob_emedia__WEBPACK_IMPORTED_MODULE_0__["Webrtc"]);

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * P2P
 */
var _util = (__webpack_require__(2).default);
var RouteTo = __webpack_require__(8).RouteTo;
var _logger = _util.logger;


var P2PRouteTo = RouteTo({
    success: function (result) {
        _logger.debug("iq to server success", result);
    },
    fail: function (error) {
        _logger.debug("iq to server error", error);
    }
});


var CommonPattern = {
    _pingIntervalId: null,
    _p2pConfig: null,
    _rtcCfg: null,
    _rtcCfg2: null,
    _rtKey: null,
    _rtFlag: null,


    webRtc: null,
    api: null,

    callee: null,


    isCaller: false,
    accepted: false,

    setLocalSDP: false,
    setRemoteSDP: false,

    hangup: false,


    init: function () {
        var self = this;

        self.api.onPing = function () {
            self._onPing.apply(self, arguments);
        };
        self.api.onTcklC = function () {
            self._onTcklC.apply(self, arguments);
        };
        self.api.onAcptC = function () {
            self._onAcptC.apply(self, arguments);
        };
        self.api.onAnsC = function () {
            self._onAnsC.apply(self, arguments);
        };
        self.api.onTermC = function () {
            self._onTermC.apply(self, arguments);
        };
        self.api.onEvJoin = function() {
            self._onEvJoin.apply(self, arguments);
        };
        self.api.onStreamControl = function() {
            self._onStreamControl.apply(self, arguments);
        };
        self.webRtc.onIceCandidate = function () {
            self._onIceCandidate.apply(self, arguments);
        };
        self.webRtc.onIceStateChange = function () {
            self._onIceStateChange.apply(self, arguments);
        };
    },

    _ping: function () {
        var self = this;

        var index = 0;

        function ping() {
            var rt = new P2PRouteTo({
                to: self.callee,
                rtKey: self._rtKey
            });

            self.api.ping(rt, self._sessId, function (from, rtcOptions) {
                _logger.debug("ping result", rtcOptions);

            });
            // self.api.streamControl(rt, self._sessId, "rtcId", (index++) % 4, function (from, rtcOptions) {
            //     _logger.debug("streamControl result", rtcOptions);
            //
            // });
        }

        self._pingIntervalId = window.setInterval(ping, 50000);
    },

    _onPing: function (from, options, rtkey, tsxId, fromSid) {
        _logger.debug('_onPing from', fromSid);
    },

    initC: function (mediaStreamConstaints, accessSid) {
        var self = this;
        self.sid = accessSid;

        self.isCaller = true;
        self.accepted = false;
        self.setLocalSDP = false;
        self.setRemoteSDP = false;
        self.hangup = false;

        self.streamType = mediaStreamConstaints.audio && mediaStreamConstaints.video ? "VIDEO" : "VOICE";

        self.createLocalMedia(mediaStreamConstaints);
    },

    createLocalMedia: function (mediaStreamConstaints) {
        var self = this;

        this.webRtc.createMedia(mediaStreamConstaints, function (webrtc, stream) {
            self.webRtc.createRtcPeerConnection(self._rtcCfg);

            webrtc.setLocalVideoSrcObject(stream);

            self.webRtc.createOffer(function (offer) {
                self._onGotWebRtcOffer(offer);
            });
        });
    },

    _onGotWebRtcOffer: function (offer) {
        var self = this;

        var rt = new P2PRouteTo({
            sid: self.sid,
            to: self.callee,
            rtKey: self._rtKey
        });

        self.api.initC(rt, self.streamType, null, null, self._sessId, self._rtcId, null, null, offer, null, self._rtcCfg2, null, function (from, rtcOptions) {
            _logger.debug("initc result", rtcOptions);
        });

        self.setLocalSDP = true;

        self._ping();
    },

    _onAcptC: function (from, options) {
        var self = this;

        if (options.ans && options.ans == 1) {
            _logger.info("[WebRTC-API] _onAcptC : 104, ans = 1, it is a answer. will onAcceptCall");
            self.onAcceptCall(from, options, options.enableVoice !== false, options.enableVideo !== false);
            self._onAnsC(from, options);
        } else if (!WebIM.WebRTC.supportPRAnswer) {
            _logger.info("[WebRTC-API] _onAcptC : not supported pranswer. drop it. will onAcceptCall");

            self.setRemoteSDP = false;
            self._handRecvCandsOrSend(from, options);

            self.onAcceptCall(from, options, options.enableVoice !== false, options.enableVideo !== false);
        } else {
            _logger.info("[WebRTC-API] _onAcptC : recv pranswer. ");

            if (options.sdp || options.cands) {
                // options.sdp && (options.sdp.type = "pranswer");
                options.sdp && self.webRtc.setRemoteDescription(options.sdp);

                self.setRemoteSDP = true;
                self._handRecvCandsOrSend(from, options);

                self.onAcceptCall(from, options, options.enableVoice !== false, options.enableVideo !== false);
            }
        }
    },

    _onEvJoin: function (from, options, rtkey, tsxId, fromSid) {
        var self = this;

        _logger.debug('_onEvJoin from', fromSid, from);

        self.onAcceptCall(from, options, options.enableVoice !== false, options.enableVideo !== false);
    },

    onAcceptCall: function (from, options, enableVoice, enableVideo) {

    },

    __onVoiceOrVideo: function(from, options, fromSid){
        var self = this;

        options.enableVoice === false ? (self.onOtherUserOpenVoice(from, false)) : (self.onOtherUserOpenVoice(from, true));
        options.enableVideo === false ? (self.onOtherUserOpenVideo(from, false)) : (self.onOtherUserOpenVideo(from, true));
    },

    /*
     * { verison : MSYNC_V1, compress_algorimth : 0, command : SYNC, payload : { meta : { id : 2326, to : easemob-demo#chatdemoui_xyj002@easemob.com, ns : CONFERENCE, payload : { session_id : xyj0011494320598055, operation : MEDIA_REQUEST, peer_name : xyj001, route_flag : 1, route_key : --X--, content : {"op":400,"callVersion":"2.0.0","sessId":"128542826909667328","rtcId":"Channel1494320598056","tsxId":"1494320622866-6","controlType":0}, control_type : PAUSE_VOICE } } } }
     * PAUSE_VOICE(0, 0), RESUME_VOICE(1, 1), PAUSE_VIDEO(2, 2), RESUME_VIDEO(3, 3)
     *
     */
    _onStreamControl: function (from, options, rtkey, tsxId, fromSid){
        var self = this;
        var controlType = options.controlType;

        controlType === 0 && (self.onOtherUserOpenVoice(from, false));
        controlType === 1 && (self.onOtherUserOpenVoice(from, true));
        controlType === 2 && (self.onOtherUserOpenVideo(from, false));
        controlType === 3 && (self.onOtherUserOpenVideo(from, true));

        self.onStreamControl(from, options, rtkey, tsxId, fromSid);
    },
    onStreamControl: function (from, options, rtkey, tsxId, fromSid){

    },

    onOtherUserOpenVoice: function (from, opened){
        _logger.debug("from open:", opened, " voice .", from)
    },
    onOtherUserOpenVideo: function (from, opened){
        _logger.debug("from open:", opened, " voideo .", from)
    },


    _onAnsC: function (from, options) { // answer
        var self = this;

        _logger.info("[WebRTC-API] _onAnsC : recv answer. ");

        self.accepted = true;

        options.sdp && self.webRtc.setRemoteDescription(options.sdp);

        self.setRemoteSDP = true;
        self._handRecvCandsOrSend(from, options);


        self.__onVoiceOrVideo(from, options);
    },


    _onInitC: function (from, options, rtkey, tsxId, fromSid) {
        var self = this;

        self.isCaller = false;
        self.accepted = false;
        self.setLocalSDP = false;
        self.setRemoteSDP = false;
        self.hangup = false;

        self.callee = from;
        self._rtcCfg2 = options.rtcCfg;
        self._rtKey = rtkey;
        self._tsxId = tsxId;
        self._fromSid = fromSid;

        self._rtcId = options.rtcId;
        self._sessId = options.sessId;

        self.streamType = options.streamType;

        self.webRtc.createRtcPeerConnection(self._rtcCfg2);

        self.callerNotPranswer = (options.expr === 0);
        _logger.warn("caller not pranswer ", self.callerNotPranswer);

        options.sdp && _logger.debug(options.sdp.sdp);

        options.sdp && (self.webRtc.setRemoteDescription(options.sdp).then(function () {

            self.setRemoteSDP = true;
            self._handRecvCandsOrSend(from, options);

            /*
             * chrome 版本 大于 50时，可以使用pranswer。
             * 小于50 不支持pranswer，此时处理逻辑是，直接进入振铃状态
             *
             */
            if (WebIM.WebRTC.supportPRAnswer) {
                self.webRtc.createPRAnswer(function (prAnswer) {
                    self._onGotWebRtcPRAnswer(prAnswer);

                    setTimeout(function () { //由于 chrome 在 pranswer时，ice状态只是 checking，并不能像sdk那样 期待 connected 振铃；所以目前改为 发送完pranswer后，直接振铃
                        _logger.info("[WebRTC-API] onRinging : after send pranswer. ", self.callee);
                        self.onRinging(self.callee, self.streamType);
                    }, 500);
                });
            } else {
                setTimeout(function () {
                    _logger.info("[WebRTC-API] onRinging : After iniC, cause by: not supported pranswer. ", self.callee);
                    self.onRinging(self.callee, self.streamType);
                }, 500)
                self._ping();
            }
        }));
    },


    _onGotWebRtcPRAnswer: function (prAnswer) {
        var self = this;

        var rt = new P2PRouteTo({
            //tsxId: self._tsxId,
            to: self.callee,
            rtKey: self._rtKey
        });

        //self.api.acptC(rt, self._sessId, self._rtcId, prAnswer, null, 1);
        self.api.acptC(rt, self._sessId, self._rtcId, prAnswer);

        self.setLocalSDP = true;
        self._handRecvCandsOrSend();

        self._ping();
    },

    onRinging: function (caller, streamType) {
    },

    accept: function () {
        var self = this;

        function createAndSendAnswer() {
            _logger.info("createAndSendAnswer : ...... ");

            self.webRtc.createAnswer(function (answer) {
                var rt = new P2PRouteTo({
                    //tsxId: self._tsxId,
                    to: self.callee,
                    rtKey: self._rtKey
                });

                if (WebIM.WebRTC.supportPRAnswer) {
                    if(self.webRtc.isConnected() || self.callerNotPranswer){
                        _logger.info("[WebRTC-API] ice connected or caller not pranswer, may send answer");
                        self.api.ansC(rt, self._sessId, self._rtcId, answer);
                    }else{
                        _logger.info("[WebRTC-API] ice state not connected, send answer waiting.");
                        self.webRtc._hookWhenICEReady = function () {
                            _logger.info("[WebRTC-API] ice connected, send answer");
                            self.api.ansC(rt, self._sessId, self._rtcId, answer);
                        }
                    }
                } else {
                    self.api.acptC(rt, self._sessId, self._rtcId, answer, null, 1);
                }

                if (!WebIM.WebRTC.supportPRAnswer) {
                    self.setLocalSDP = true;
                }
                self._handRecvCandsOrSend();

                self.accepted = true;
            });
        }

        var constaints = {
            audio: true
        };
        if(self.streamType == "VIDEO"){
            constaints.video = true;
        }

        self.webRtc.createMedia(constaints, function (webrtc, stream) {
            webrtc.setLocalVideoSrcObject(stream);

            createAndSendAnswer();
        });
    },

    _handRecvCandsOrSend: function (from, options) {
        var self = this;

        setTimeout(function () {
            self._onTcklC(from, options);
        }, 50);

        setTimeout(function () {
            self._onIceCandidate();
        }, 50);
    },

    _onTcklC: function (from, options) { // setRemoteSDP，才可以添加 添加 对方 cands
        var self = this;

        // options.sdp && self.webRtc.setRemoteDescription(options.sdp);

        if (self.setRemoteSDP) {
            _logger.info("[WebRTC-API] recv and add cands.");

            self._recvCands && self._recvCands.length > 0 && self.webRtc.addIceCandidate(self._recvCands);
            self._recvCands && self._recvCands.length > 0 && (self._recvCands = []);
            options && options.cands && self.webRtc.addIceCandidate(options.cands);
        } else if (options && options.cands && options.cands.length > 0) {
            for (var i = 0; i < options.cands.length; i++) {
                (self._recvCands || (self._recvCands = [])).push(options.cands[i]);
            }
            _logger.debug("[_onTcklC] temporary memory[recv] ice candidate. util setRemoteSDP = true");
        }
    },

    _onIceStateChange: function (iceState) {
        var self = this;
        _logger.debug("[WebRTC-API] ice state is " + iceState);

        if(self.webRtc.isConnected()){ //出发hook
            self.webRtc._hookWhenICEReady && self.webRtc._hookWhenICEReady();
            self.webRtc._hookWhenICEReady = undefined;
        }

        if(iceState === "closed"){
            self.setLocalSDP = false;
            self.setRemoteSDP = false;
        }

        self.api.onIceConnectionStateChange(iceState);
    },

    _onIceCandidate: function (_candidate) { //在本地sdp set 发送完成后，发送 cands
        var self = this;

        if (self.setLocalSDP) {
            function sendIceCandidate(candidate) {
                _logger.debug("send ice candidate...");

                var rt = new P2PRouteTo({
                    to: self.callee,
                    rtKey: self._rtKey
                });

                if (candidate) {
                    self.api.tcklC(rt, self._sessId, self._rtcId, null, candidate);
                }
            }

            if (self._cands && self._cands.length > 0) {

                sendIceCandidate(self._cands);

                self._cands = [];
            }
            _candidate && sendIceCandidate(_candidate);
        } else {
            _candidate && (self._cands || (self._cands = [])).push(_candidate);
            _logger.debug("[_onIceCandidate] temporary memory[send] ice candidate. util setLocalSDP = true");
        }
    },


    __termCall1: function (reason) {
        var self = this;

        self._pingIntervalId && window.clearInterval(self._pingIntervalId);

        var rt = new P2PRouteTo({
            to: self.callee,
            rtKey: self._rtKey
        });

        var sendReason;
        reason || (!self.isCaller && !self.accepted && (sendReason = 'decline')) || (sendReason = 'success');

        self.hangup || self.api.termC(rt, self._sessId, self._rtcId, sendReason);

        self.webRtc.close();

        self.hangup = true;

        self.setLocalSDP = false;
        self.setRemoteSDP = false;

        self.onTermCall(reason);
    },

    termCall: function (reason) {
        var self = this;
        try{
            self.__termCall1(reason);
        }finally{
            if(WebIM.__alreadyOpenMedias && WebIM.__alreadyOpenMedias.length > 0){
                for(var index in WebIM.__alreadyOpenMedias){
                    var stream = WebIM.__alreadyOpenMedias[index];
                    try{
                        emedia.stopTracks(stream);
                    }catch(e){

                    }
                }

                WebIM.__alreadyOpenMedias = [];
            }
        }
    },

    /**
     *
     * @param from
     * @param options
     * @param options.reason
     *               "ok"      -> 'HANGUP'     "success" -> 'HANGUP'   "timeout"          -> 'NORESPONSE'
     *               "decline" -> 'REJECT'     "busy"    -> 'BUSY'     "failed-transport" -> 'FAIL'
     * @private
     */
    _onTermC: function (from, options) {
        _logger.debug("[_onTermC] options.reason = " + options.reason);

        var self = this;

        self.hangup = true;

        self.setLocalSDP = false;
        self.setRemoteSDP = false;

        self.termCall(options.reason);

    },

    onTermCall: function () {
        //to be overwrited by call.listener.onTermCall
    }
};

module.exports = function (initConfigs) {
    var self = this;

    _util.extend(true, this, CommonPattern, initConfigs || {});

    self.init();
};

/**
 * TODO: Conference
 */


/***/ })
/******/ ]);