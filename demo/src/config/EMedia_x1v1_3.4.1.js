(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["webrtc"] = factory();
	else
		root["webrtc"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/Users/suqin/Desktop/软件开发文档/环信/project/websdk/packages/webrtc";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(1);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof2 = __webpack_require__(3);

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Util = __webpack_require__(70).default;
var Call = __webpack_require__(440);

var emedia = __webpack_require__(71);

window.WebIM = typeof WebIM !== 'undefined' ? WebIM : {};
WebIM.WebRTC = WebIM.WebRTC || {};
WebIM.WebRTC.Call = Call;
WebIM.WebRTC.Util = Util;
WebIM.WebRTC.emedia = emedia;

WebIM.__alreadyOpenMedias = [];

if (( false ? undefined : (0, _typeof3.default)(module)) === 'object' && (0, _typeof3.default)(module.exports) === 'object') {
    module.exports = WebIM.WebRTC;
} else if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
        return WebIM.WebRTC;
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}
WebIM.WebRTC.config = function (obj) {
    if (obj instanceof Object == false) {
        return;
    }

    for (var key in obj) {
        this[key] = obj[key];
    }
};

// /**
//  * 判断是否支持pranswer
//  */
// if (/Firefox/.test(navigator.userAgent)) {
//     //WebIM.WebRTC.supportPRAnswer = (navigator.userAgent.split("Chrome/")[1].split(".")[0] >= 50) ? true : false;
//     WebIM.WebRTC.supportPRAnswer = false;
// }else{
//     WebIM.WebRTC.supportPRAnswer = true;
// }
WebIM.WebRTC.supportPRAnswer = emedia.supportPRAnswer;

console && console.warn('Webrtc version', 'Git.e4f0006');
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(2)(module)))

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__(4);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(55);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(5), __esModule: true };

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(6);
__webpack_require__(50);
module.exports = __webpack_require__(54).f('iterator');


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__(7)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(10)(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(8);
var defined = __webpack_require__(9);
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),
/* 8 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),
/* 9 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(11);
var $export = __webpack_require__(12);
var redefine = __webpack_require__(28);
var hide = __webpack_require__(17);
var Iterators = __webpack_require__(29);
var $iterCreate = __webpack_require__(30);
var setToStringTag = __webpack_require__(46);
var getPrototypeOf = __webpack_require__(48);
var ITERATOR = __webpack_require__(47)('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = true;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(13);
var core = __webpack_require__(14);
var ctx = __webpack_require__(15);
var hide = __webpack_require__(17);
var has = __webpack_require__(27);
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),
/* 13 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),
/* 14 */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.6.11' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(16);
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),
/* 16 */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(18);
var createDesc = __webpack_require__(26);
module.exports = __webpack_require__(22) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(19);
var IE8_DOM_DEFINE = __webpack_require__(21);
var toPrimitive = __webpack_require__(25);
var dP = Object.defineProperty;

exports.f = __webpack_require__(22) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(20);
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),
/* 20 */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(22) && !__webpack_require__(23)(function () {
  return Object.defineProperty(__webpack_require__(24)('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(23)(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 23 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(20);
var document = __webpack_require__(13).document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(20);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),
/* 26 */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),
/* 27 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(17);


/***/ }),
/* 29 */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(31);
var descriptor = __webpack_require__(26);
var setToStringTag = __webpack_require__(46);
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(17)(IteratorPrototype, __webpack_require__(47)('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(19);
var dPs = __webpack_require__(32);
var enumBugKeys = __webpack_require__(44);
var IE_PROTO = __webpack_require__(41)('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(24)('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(45).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(18);
var anObject = __webpack_require__(19);
var getKeys = __webpack_require__(33);

module.exports = __webpack_require__(22) ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(34);
var enumBugKeys = __webpack_require__(44);

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(27);
var toIObject = __webpack_require__(35);
var arrayIndexOf = __webpack_require__(38)(false);
var IE_PROTO = __webpack_require__(41)('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(36);
var defined = __webpack_require__(9);
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(37);
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),
/* 37 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(35);
var toLength = __webpack_require__(39);
var toAbsoluteIndex = __webpack_require__(40);
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(8);
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(8);
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(42)('keys');
var uid = __webpack_require__(43);
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(14);
var global = __webpack_require__(13);
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__(11) ? 'pure' : 'global',
  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
});


/***/ }),
/* 43 */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),
/* 44 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(13).document;
module.exports = document && document.documentElement;


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(18).f;
var has = __webpack_require__(27);
var TAG = __webpack_require__(47)('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(42)('wks');
var uid = __webpack_require__(43);
var Symbol = __webpack_require__(13).Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(27);
var toObject = __webpack_require__(49);
var IE_PROTO = __webpack_require__(41)('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(9);
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(51);
var global = __webpack_require__(13);
var hide = __webpack_require__(17);
var Iterators = __webpack_require__(29);
var TO_STRING_TAG = __webpack_require__(47)('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(52);
var step = __webpack_require__(53);
var Iterators = __webpack_require__(29);
var toIObject = __webpack_require__(35);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(10)(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),
/* 52 */
/***/ (function(module, exports) {

module.exports = function () { /* empty */ };


/***/ }),
/* 53 */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(47);


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(56), __esModule: true };

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(57);
__webpack_require__(67);
__webpack_require__(68);
__webpack_require__(69);
module.exports = __webpack_require__(14).Symbol;


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __webpack_require__(13);
var has = __webpack_require__(27);
var DESCRIPTORS = __webpack_require__(22);
var $export = __webpack_require__(12);
var redefine = __webpack_require__(28);
var META = __webpack_require__(58).KEY;
var $fails = __webpack_require__(23);
var shared = __webpack_require__(42);
var setToStringTag = __webpack_require__(46);
var uid = __webpack_require__(43);
var wks = __webpack_require__(47);
var wksExt = __webpack_require__(54);
var wksDefine = __webpack_require__(59);
var enumKeys = __webpack_require__(60);
var isArray = __webpack_require__(63);
var anObject = __webpack_require__(19);
var isObject = __webpack_require__(20);
var toObject = __webpack_require__(49);
var toIObject = __webpack_require__(35);
var toPrimitive = __webpack_require__(25);
var createDesc = __webpack_require__(26);
var _create = __webpack_require__(31);
var gOPNExt = __webpack_require__(64);
var $GOPD = __webpack_require__(66);
var $GOPS = __webpack_require__(61);
var $DP = __webpack_require__(18);
var $keys = __webpack_require__(33);
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function' && !!$GOPS.f;
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(65).f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(62).f = $propertyIsEnumerable;
  $GOPS.f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(11)) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
var FAILS_ON_PRIMITIVES = $fails(function () { $GOPS.f(1); });

$export($export.S + $export.F * FAILS_ON_PRIMITIVES, 'Object', {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return $GOPS.f(toObject(it));
  }
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(17)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(43)('meta');
var isObject = __webpack_require__(20);
var has = __webpack_require__(27);
var setDesc = __webpack_require__(18).f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__(23)(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(13);
var core = __webpack_require__(14);
var LIBRARY = __webpack_require__(11);
var wksExt = __webpack_require__(54);
var defineProperty = __webpack_require__(18).f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(33);
var gOPS = __webpack_require__(61);
var pIE = __webpack_require__(62);
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),
/* 61 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),
/* 62 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(37);
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(35);
var gOPN = __webpack_require__(65).f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(34);
var hiddenKeys = __webpack_require__(44).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(62);
var createDesc = __webpack_require__(26);
var toIObject = __webpack_require__(35);
var toPrimitive = __webpack_require__(25);
var has = __webpack_require__(27);
var IE8_DOM_DEFINE = __webpack_require__(21);
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(22) ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),
/* 67 */
/***/ (function(module, exports) {



/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(59)('asyncIterator');


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(59)('observable');


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _easemobEmedia = __webpack_require__(71);

exports.default = _easemobEmedia.util;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//console.  emedia.useCurrentXService.current


var emedia = window.emedia = window.emedia || {};

var util = emedia.util = __webpack_require__(72);

/**
 * webpack.config.js
 *     module: {
        noParse: [/adapter.js$/],
        rules: [
            {
                test: require.resolve('zepto'),
                loader: 'exports-loader?window.Zepto!script-loader'
            }
        ]
    },
 *
 * var zepto = require("zepto");
 * // var zepto = require('exports-loader?window.Zepto!script-loader!zepto');
 *
 * 或者
 * npm install zepto-webpack
 *
 *
 */
var zepto = __webpack_require__(146);

emedia.config = function (cfg) {
    cfg = util.extend({}, cfg);

    for (var key in cfg) {
        emedia.config[key] = cfg[key];
        if (key === "logLevel") {
            emedia.LOG_LEVEL = cfg[key];
        }
    }

    if (emedia.config.loglastConfrCount && !emedia._logContext) {
        emedia._logContext = new Array(emedia.config.loglastConfrCount);
        emedia._logContextIndex = -1; //代表没有日志
    }
};
emedia.config({
    autoSub: true,

    onlyEnter: false,

    reconnect: 13, //重连次数
    reconnectDelay: 3000, //重连间隔 毫秒

    getCopyIntervalMillis: 30000,
    checkConnectIntervalMillis: 1000,

    iceRebuildCount: 3,
    iceRebuildIntervalMillis: 500,
    //iceWaitBuildMillis: 30000,

    enterTimeout: 20000,

    useRTCCfgIfServerReturn: false,
    forceUseRTCCfgIfServerReturnWhenP2P: true,

    allowRepeatAudioMixerPublish: false,

    logVolumeWhenInstantGE: 0.5,
    getMediaMeterIntervalMillis: 400,
    _useRequestAnimationFrame: false,

    meterWithTrackAudioLevel: false,
    judgeTalkingByInstantGE: 0.05,

    _printSoundData: false,

    trackBufferSize: 20,
    allowSendWhenLessThan: 4,
    disableTrack: false,

    ctrlCheckIntervalMillis: 10 * 1000,
    ctrlTimeoutMillis: 30 * 1000,

    _printDebugStats: false,
    statsSeconds: 10,
    remainLastStatsCount: 120,
    //wsorigin

    loglastConfrCount: 2,
    loglastStoreArray: true,
    consoleLogger: true,

    printStatsWhenPCClose: true,
    rebuildPeerConnectionWhenNetworkChanaged: true,
    useDeployMore: false,
    useDTX: true, // 开启 DTX
    uploadStats: true, // 开启 数据上报
    liveCfgs: [], // 多路推流数组
    rtcStatsTypeMath: function rtcStatsTypeMath(_stat, name) {
        switch (_stat.type) {
            case "remote-candidate":
            case "local-candidate":
            case "track":
            case "stream":
            case "inbound-rtp":
            case "outbound-rtp":
            case "transport":
                return true;
        }
        return false;
    }

    // forceUseVideoCodecs: [],
    // forceUseAudioCodecs: [],
    // forceVideoBitrate: ,
    // forceAudioBitrate: ,
});

util.logger.count();
//util.logger.info(navigator.userAgent);

(function requireWebrtcAdapter() {
    var adapter = __webpack_require__(147).default;
    emedia.browser = adapter.__browser; // firefox chrome safari IE
    emedia.browserVersion = adapter.__browserVersion;

    if (emedia.browser === undefined) {
        throw "Not discern browser. may require adapter error. eg. it.default";
    }
})();
util.logger.info("Current browser", emedia.browser, emedia.browserVersion);

emedia.AudioContext = window.AudioContext || window.webkitAudioContext;

if (emedia.config.getMediaMeterIntervalMillis) {
    // https://stackoverflow.com/questions/46363048/onaudioprocess-not-called-on-ios11/46534088#46534088
    // There are two problems.
    // The main one is that Safari on iOS 11 seems to automatically suspend new AudioContext's that aren't created in response to a tap.
    // You can resume() them, but only in response to a tap.
    //
    // So, you have to either create it before you get the MediaStream, or else get the user to tap again later.
    try {
        if (typeof emedia.AudioContext === 'function') {
            emedia.__audioContext = new emedia.AudioContext();
            emedia.__usingWebAudio = true;
        } else {
            emedia.__usingWebAudio = false;
        }
    } catch (e) {
        emedia.__usingWebAudio = false;
    }

    // context state at this time is `undefined` in iOS8 Safari
    if (emedia.__usingWebAudio && emedia.__audioContext.state === 'suspended') {
        zepto(function () {
            var resume = function resume() {
                emedia.__audioContext.state === 'suspended' && emedia.__audioContext.resume();
                util.logger.warn("AudioContext state suspended ->", emedia.__audioContext.state);

                setTimeout(function () {
                    if (emedia.__audioContext.state === 'running') {
                        document.body.removeEventListener('touchend', resume, false);
                        document.body.removeEventListener('click', resume, false);
                    }
                }, 0);
            };

            document.body.addEventListener('touchend', resume, false);
            //document.body.addEventListener('load', resume, false);
            document.body.addEventListener('click', resume, false);
        });
    }

    if (!emedia.__usingWebAudio) {
        console.warn("'new AudioContext()' failed. can not know who talking.");
    }
    if (emedia.__audioContext && emedia.__audioContext.state === 'suspended') {
        console.warn("audioContext.state is suspended. can not know who talking. You can resume() emedia.__audioContext, but only in response to a tap.");
    }
}

if (!window.requestAnimationFrame || !emedia.config._useRequestAnimationFrame) {
    emedia.requestAnimationFrame = function (fn, timeoutMillis) {
        return setTimeout(fn, timeoutMillis || emedia.config.getMediaMeterIntervalMillis);
    };
} else {
    emedia.requestAnimationFrame = function (callback) {
        window.requestAnimationFrame(callback);
    };
}

if (!window.cancelAnimationFrame || !emedia.config._useRequestAnimationFrame) {
    emedia.cancelAnimationFrame = function (id) {
        clearTimeout(id);
    };
} else {
    emedia.cancelAnimationFrame = function (id) {
        window.cancelAnimationFrame(id);
    };
}

emedia.isWifi = function isWifi() {
    try {
        var wifi = true;
        var ua = window.navigator.userAgent;
        var con = window.navigator.connection || window.navigator.mozConnection || window.navigator.webkitConnection;
        // 如果是微信
        if (/MicroMessenger/.test(ua)) {
            if (ua.indexOf('WIFI') >= 0) {
                return true;
            } else {
                wifi = false;
            }
        } else if (con) {
            //navigator.connection //type: unknown, ethernet, wifi, 2g, 3g, 4g, none.
            var network = con.type;
            if (network !== 'wifi' && network !== '2' && network !== 'unknown') {
                wifi = false;
            }
        }
        return wifi;
    } catch (e) {
        return false;
    }
};

emedia.stopAudioTracks = function (_stream) {
    _stream && _stream.getAudioTracks().forEach(function (track) {
        track.stop();
        util.logger.info("Media stream stop audio track. stream =", _stream.id, "track =", track.id, track.kind);
    });
};
emedia.stopAndRemoveAudioTracks = function (_stream) {
    var tracks = [];
    _stream && _stream.getAudioTracks().forEach(function (track) {
        track.stop();
        tracks.push(track);
        util.logger.info("Media stream stop and remove audio tracks. stream =", _stream.id, "track =", track.id, track.kind);
    });

    util.forEach(tracks, function (_index, track) {
        _stream.removeTrack(track);
    });
};

emedia.stopTracks = function (_stream) {
    try {
        var stop = function stop() {
            _stream.getTracks().forEach(function (track) {
                track.stop();
                util.logger.info("Media stream stop track. stream =", _stream.id, " track =", track.id, track.kind);
            });

            if (_stream._bindAttendee) {
                //push stream时，由于异步，在未返回成功后，退出会议，摄像头不会被关闭问题
                util.removeAttribute(_stream._bindAttendee._openedRtcMediaStreams, _stream.id);
                _stream._bindAttendee = null;
            }
            util.logger.info("stream tracks stoped. it ", _stream.id);
        };

        if (!_stream || _stream.active === false) {
            util.logger.debug("stream tracks had been stoped. it ", _stream && _stream.id);
            return;
        }

        stop();
        //setTimeout(stop, 300);
    } catch (e) {
        util.logger.error(e);
    }
};

emedia.enableVideoTracks = function (_stream, enabled) {
    _stream && _stream.getVideoTracks().forEach(function (track) {
        if (typeof track.enable === "function") {
            track.enable();
            util.logger.info("Media stream enable video track. stream =", _stream.id, "track =", track.kind, track.enabled, track.id);
            track.enabled === enabled || track.enable(enabled);
            return;
        }

        track.enabled === enabled || (track.enabled = enabled);
        util.logger.info("Media stream enable video track. stream =", _stream.id, "track =", track.kind, track.enabled, track.id);
    });
};

emedia.enableAudioTracks = function (_stream, enabled) {
    _stream && _stream.getAudioTracks().forEach(function (track) {
        if (typeof track.enable === "function") {
            track.enable();
            util.logger.info("Media stream enable audio track. stream =", _stream.id, "track =", track.kind, track.enabled, track.id);
            track.enabled === enabled || track.enable(enabled);
            return;
        }

        track.enabled === enabled || (track.enabled = enabled);
        util.logger.info("Media stream enable audio track. stream =", _stream.id, "track =", track.kind, track.enabled, track.id);
    });
};

emedia.hasEnabledTracks = function (mediaStream) {
    if (!mediaStream || typeof mediaStream.getAudioTracks !== 'function') {
        return false;
    }

    if (!mediaStream.active) {
        return false;
    }

    var tracks = mediaStream.getAudioTracks();

    if (tracks.length === 0) {
        return false;
    }

    for (var i in tracks) {
        if (typeof tracks[i].enable === "function") {
            tracks[i].enable();
        }
        if (tracks[i].enabled) {
            return true;
        }
    }

    return false;
};

emedia.genReportName = function () {

    var date = emedia._lastSetupDate || new Date();
    //date = date.toLocaleString().replace(/[\/\s]/g, '-');
    return (emedia._lastSetupTktId || emedia._lastSetupConfr) + "_" + emedia._lastSetupMemName + "_" + date.getTime() + ".log";
};

emedia.getReportUploadUrl = function (method, url, cb) {
    var xhr = new XMLHttpRequest();
    xhr.open(method, url, true);
    xhr.addEventListener('load', function (response) {
        cb && cb(response);
    }, false);

    xhr.send(null);
};

emedia.uploadReport = function (fileName, url, commitData, success, error, addHeader) {
    var fileContent = emedia.genReport();
    if (!fileContent) {
        error && error("not logs");
        return;
    }

    if (typeof commitData === "function") {
        addHeader = error;
        error = success;
        success = commitData;
        commitData = undefined;
    }

    function onUploadFile(response) {
        console.info("log begin upload. result = ", response.currentTarget.status, fileName, " > ", url);

        if (response.currentTarget.status === 200) {
            //response.currentTarget.getResponseHeader('response-text');
            success && success(response);
        } else {
            //this.reportError = response.currentTarget.status;
            error && error(response);
        }
    }

    // Create report file.
    var blob = new Blob([fileContent], { type: 'text/plain' });
    var formData = new FormData();
    formData.append(fileName, blob, fileName);
    if (commitData && typeof formData.set === "function") {
        util.forEach(commitData, function (key, value) {
            formData.set(key, value);
        });
    }

    // Upload the report file using the URL in the response-text header.
    var xhr = new XMLHttpRequest();
    xhr.open('POST', url, true);

    xhr.setRequestHeader('X-File-Name', fileName);
    addHeader && addHeader(xhr);
    xhr.addEventListener('load', onUploadFile, false);
    xhr.send(formData);

    console.info("log begin upload. ", fileName, " > ", url);
};

emedia.genReport = function () {
    if (!emedia._logContext) {
        return;
    }
    if (!(emedia._logContext instanceof Array)) {
        return;
    }
    if (typeof emedia._logContextIndex === 'undefined' || emedia._logContextIndex < 0) {
        return;
    }

    var start = 0;
    var end = emedia._logContextIndex;
    if (emedia._logContextIndex >= emedia._logContext.length) {
        start = emedia._logContextIndex - emedia._logContext.length + 1;
    }

    var report = "";
    for (var i = start; i <= end; i++) {
        var index = i % emedia._logContext.length;
        var oneConfrLogs = emedia._logContext[index];
        report += oneConfrLogs.join("\r\n") + "\r\n";
    }

    if (emedia._logContext.loadlogs && emedia._logContext.loadlogs instanceof Array) {
        report += "-------------------------------------------------------------\r\n";
        report += emedia._logContext.loadlogs.join("\r\n") + "\r\n";
    }

    return report;
};

emedia.fileReport = function (filename, exception) {
    var fileContent = emedia.genReport();
    if (!fileContent) {
        return;
    }

    if (exception) {
        //遇到的异常加到日志
        fileContent = "\u9047\u5230\u7684\u5F02\u5E38\u63CF\u8FF0\u5982\u4E0B\uFF1A\r\n " + exception + " \r\n " + fileContent;
    }

    var content = encodeURIComponent(fileContent);

    var link = document.createElement('a');
    link.style.display = 'none';
    link.download = filename || 'emedia-' + new Date().toJSON() + '.log';
    link.href = 'data:text/plain;charset=utf-8,' + content;
    //link.setAttribute('download', link.download);
    //link.setAttribute('href', 'data:text/plain;charset=utf-8,' + content); //'data:attachment/file;charset=utf-8,' + content

    document.body.appendChild(link);
    link.click();
    link.parentNode.removeChild(link);
};

if (navigator.mediaDevices) {
    var supportedConstraints = navigator.mediaDevices.getSupportedConstraints();
    util.logger.info("Supported constraints", supportedConstraints);
}

emedia.config({
    globalConstraints: {
        // audio:{
        //
        // }
    }
});

var Service = __webpack_require__(200);
var __event = __webpack_require__(208);

emedia.Webrtc = __webpack_require__(213);

emedia.Service = Service;
emedia.P2P = __webpack_require__(223);
// var cloneService = util.extend({}, Service).extend(Service);
emedia.XService = Service;
emedia.XServiceWithP2P = emedia.P2P(Service);

// emedia.mgr = require("./components/mgr/Manager");
// emedia.mgr = emedia.mgr.single;
emedia.mgr = __webpack_require__(224).outer;

emedia.ctrl = __webpack_require__(431);
emedia.CompositeCanvas = __webpack_require__(437);

emedia.pannel || (emedia.pannel = {});
emedia.pannel.DefaultMouseTrack = __webpack_require__(220);
emedia.pannel.MouseTrack = __webpack_require__(221);
emedia.pannel.KeyboardTrack = __webpack_require__(438);

var PCStats = emedia.PCStats = __webpack_require__(219);

emedia.helper = emedia.helper || {};

emedia.helper.PCStats = PCStats;

emedia.helper.pcstats = PCStats.echo;
emedia.helper.intervalPcstats = PCStats.intervalEcho;

emedia.helper.inboundAudio = PCStats.inboundAudio;
emedia.helper.inboundVideo = PCStats.inboundVideo;

emedia.helper.outboundAudio = PCStats.outboundAudio;
emedia.helper.outboundVideo = PCStats.outboundVideo;

emedia.event = __event;

emedia.LOG_LEVEL = 0;

emedia.isFirefox = 'firefox' === emedia.browser;
emedia.isChrome = 'chrome' === emedia.browser;
emedia.isSafari = 'safari' === emedia.browser;
emedia.isEdge = 'edge' === emedia.browser;

emedia.isElectron = /Electron/.test(navigator.userAgent);
if (emedia.isElectron) {
    try {
        __webpack_require__(439);
    } catch (e) {
        util.logger.error(e);
    }
}

emedia.youInSomeBrowsers = function () {
    //return emedia.isSafari;
    //|| (emedia.isChrome && emedia.browserVersion >= 75);

    if (emedia.isSafari) {
        // return true;
        // safari 从13起，不在需要先打开摄像头获取权限，后再去订阅了, webrtc 可以生成canidata了
        // 但是只有audio时 订阅成功但是无法播放声音，还是需要先去getUserMedia下
        var reg = new RegExp("(Version)/([0-9\.]+)", "i");
        var r = navigator.userAgent.match(reg);
        if (r != null) {
            var version = unescape(r[2]);
            version = parseInt(version);

            return version < 13;
        }
    }

    return false;
};

//candidate:3 1 UDP 2013266431 116.62.36.187 31574 typ host
//candidate:4006386702 1 udp 41819903 39.107.152.84 33631 typ relay raddr 0.0.0.0 rport 0 generation 0 ufrag zOjH network-id 1 network-cost 10
emedia.replaceIpAndPortOfCandidate = function (candidate, ip, port) {
    var str = typeof candidate === "string" ? candidate : candidate.candidate;
    str = str.replace(/(candidate:\d+\s+\d+\s+udp\s+\d+\s+)([\d\.]+)\s+(\d+)(\s+.*)/g, function (all, $pre, $ip, $port, $after) {
        // console.log(all);
        // console.log(pre, ip, port, after);
        return $pre + ip + " " + port + $after;
    });

    if (candidate.candidate) {
        candidate = util.extend(true, {}, candidate);
        candidate.candidate = str;
    } else {
        candidate = str;
    }
    return candidate;
};
emedia.replaceIpAndPort = function (candidate, cb) {
    if (typeof cb !== 'function') {
        return candidate;
    }

    var str = typeof candidate === "string" ? candidate : candidate.candidate;
    str = str.replace(/(candidate:\d+\s+\d+\s+udp\s+\d+\s+)([\d\.]+)\s+(\d+)(\s+.*)/g, function (all, $pre, $ip, $port, $after) {
        var newIpPort = cb($ip, $port);
        if (typeof newIpPort === 'string') {
            newIpPort = newIpPort.replace(':', ' ');
            return $pre + newIpPort + $after;
        }
        return $pre + $ip + " " + $port + $after;
    });

    if (candidate.candidate) {
        candidate = util.extend(true, {}, candidate);
        candidate.candidate = str;
    } else {
        candidate = str;
    }
    return candidate;
};

emedia.replaceURL = function (wsUrl, cb) {
    if (typeof cb !== 'function') {
        return wsUrl;
    }

    return wsUrl.replace(/([^:\/?&#=]+):\/\/([^\/:?#]+)(:\d+)?(\/[^?#]*)?(\?[^\/#]*)?(#[^\/?]*)?/g, function (all, $protocol, $host, $port, $path, $query, $fragment) {
        if ($port) {
            $port = $port.substring(1);
        }

        var url = cb(all, $protocol, $host, $port, $path, $query, $fragment);
        if (!url) {
            return wsUrl;
        }
        if (typeof url === 'string') {
            return url;
        }

        var protocol = url.protocol || $protocol;
        var host = url.host || $host;
        var port = url.port || $port;
        var path = url.path || $path;
        var query = url.query || $query;
        var fragment = url.fragment || $fragment;

        return protocol + "://" + host + (port ? ":" + port : "") + (path ? path : "") + (query ? query : "") + (fragment ? fragment : "");
    });
};

emedia.requireTrustBeforeJoin = function () {
    //return (/windows|win32/i.test(navigator.userAgent) && emedia.isChrome && emedia.browserVersion >= 75);
    return false;
};

emedia.isWebRTC = window.RTCPeerConnection && /^https\:$/.test(window.location.protocol);

/**
 * 判断是否支持pranswer
 */
if (emedia.isChrome || emedia.isSafari) {
    emedia.supportPRAnswer = true;
}
/**
 * 2019.02.21
 * 发现chrome72版本 对pranswer支持有问题，https://webrtc.github.io/samples/src/content/peerconnection/pr-answer 事例也不能正显示视频
 * video.srcObject [remote media stream] active: false.
 *
 * 统一设置为不支持pranswer
 *
 */
emedia.supportPRAnswer = false;

emedia.config({
    baseAcptOps: [102, 104, 105, 106, 107, 300, 302, 303, 304, 301, 204, 206, 400, 401, 1001, 100221, 100222, 100223, 100224, 100201, 100202, 100203]
    // baseAcptOps: [107, 300, 302, 303, 304, 301, 204, 206, 400, 401, 1001]
});
emedia.config({
    clientType: 'WEB',
    version: '3.2.2',

    userAgent: navigator.userAgent,
    isHttpDNS: true, // 是否从 DNS 获取restUrl

    acptOps: [100230, //远程控制
    100205, //远程抓图
    1003, //透传消息
    1004]
});

// emedia.config({
//     reconfigRTCConfiguration: function(iceServerConfig){
//         window.coturnIp || (window.coturnIp = "39.105.132.217");
//         iceServerConfig.iceTransportPolicy = 'relay';
//         iceServerConfig.iceServers && emedia.util.forEach(iceServerConfig.iceServers, function(_i, iceServer){
//             iceServer.url = "turn:" + window.coturnIp + ":3478";
//         });
//         return iceServerConfig;
//     },
//     reChanageCandidate: function (candidate) {
//         // return emedia.replaceIpAndPortOfCandidate(candidate, "121.41.55.114", 41111);
//         //或者
//         return emedia.replaceIpAndPort(candidate, function(ip, port){ //ip, port是从 candidate中解析出来的
//             // if(ip === '39.107.157.65'){
//             //     ip = '10.66.204.222';
//             // }
//             // if(ip === '39.107.152.84'){
//             //     ip = '10.66.178.216';
//             // }
//             if(ip === '39.105.132.217'){
//                 ip = '172.16.0.69';
//             }
//             if(ip === '39.97.115.231'){
//                 ip = '172.16.0.105';
//             }
//             // if(port == 1234){
//             //     port = 新端口replaceIpAndPortOfCandidate
//             // }
//             return ip + ":" + port;
//         });
//     }
// });


// /**
//  *  Enter 客户端携带，进入
//  *  服务端可支持，Json字符串，或Json数据
//  */
// var res = {
//     type: 'ios|android|web',
//     ver: '1.0.2',
//     agent: '', //ios android可以不传，web navigator.userAgent
//     //可缺省，缺省默认支持
//     //107 300 302 303 304 301 204 206 400 401 1001
//     ops:[
//         1003, //透传消息
//         100201, //缩放
//         100202, //聚焦
//         100203, //曝光
//         100204, //定格
//         100205 //远程抓图
//     ],
//
//     vcodes:['H264', 'VP8'] //客户端进入，可以携带，也可以不携带。携带了，就使用这个广播给其他人。
//                            // A进入，没有携带此参数，服务端通过 type ver agent 补全此字段，广播给B C
// }


module.exports = emedia;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof2 = __webpack_require__(73);

var _typeof3 = _interopRequireDefault(_typeof2);

var _getPrototypeOf = __webpack_require__(140);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _stringify = __webpack_require__(144);

var _stringify2 = _interopRequireDefault(_stringify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * ! Math.uuid.js (v1.4) http://www.broofa.com mailto:robert@broofa.com
 *
 * Copyright (c) 2010 Robert Kieffer Dual licensed under the MIT and GPL
 * licenses.
 */

/*
 * Generate a random uuid.
 *
 * USAGE: Math.uuid(length, radix) length - the desired number of characters
 * radix - the number of allowable values for each character.
 *
 * EXAMPLES: // No arguments - returns RFC4122, version 4 ID >>> Math.uuid()
 * "92329D39-6F5C-4520-ABFC-AAB64544E172" // One argument - returns ID of the
 * specified length >>> Math.uuid(15) // 15 character ID (default base=62)
 * "VcydxgltxrVZSTV" // Two arguments - returns ID of the specified length, and
 * radix. (Radix must be <= 62) >>> Math.uuid(8, 2) // 8 character ID (base=2)
 * "01001010" >>> Math.uuid(8, 10) // 8 character ID (base=10) "47473046" >>>
 * Math.uuid(8, 16) // 8 character ID (base=16) "098F4D35"
 */
(function () {
    // Private array of chars to use
    var CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');

    Math.uuid = function (len, radix) {
        var chars = CHARS,
            uuid = [],
            i;
        radix = radix || chars.length;

        if (len) {
            // Compact form
            for (i = 0; i < len; i++) {
                uuid[i] = chars[0 | Math.random() * radix];
            }
        } else {
            // rfc4122, version 4 form
            var r;

            // rfc4122 requires these characters
            uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';
            uuid[14] = '4';

            // Fill in random data. At i==19 set the high bits of clock sequence
            // as
            // per rfc4122, sec. 4.1.5
            for (i = 0; i < 36; i++) {
                if (!uuid[i]) {
                    r = 0 | Math.random() * 16;
                    uuid[i] = chars[i == 19 ? r & 0x3 | 0x8 : r];
                }
            }
        }

        return uuid.join('');
    };

    // A more performant, but slightly bulkier, RFC4122v4 solution. We boost
    // performance
    // by minimizing calls to random()
    Math.uuidFast = function () {
        var chars = CHARS,
            uuid = new Array(36),
            rnd = 0,
            r;
        for (var i = 0; i < 36; i++) {
            if (i == 8 || i == 13 || i == 18 || i == 23) {
                uuid[i] = '-';
            } else if (i == 14) {
                uuid[i] = '4';
            } else {
                if (rnd <= 0x02) rnd = 0x2000000 + Math.random() * 0x1000000 | 0;
                r = rnd & 0xf;
                rnd = rnd >> 4;
                uuid[i] = chars[i == 19 ? r & 0x3 | 0x8 : r];
            }
        }
        return uuid.join('');
    };

    // A more compact, but less performant, RFC4122v4 solution:
    Math.uuidCompact = function () {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            var r = Math.random() * 16 | 0,
                v = c == 'x' ? r : r & 0x3 | 0x8;
            return v.toString(16);
        });
    };
})();

if (!String.prototype.startsWith) {
    String.prototype.startsWith = function (searchString, position) {
        position = position || 0;
        return this.indexOf(searchString, position) === position;
    };
}

/**
 * Util
 *
 * @constructor
 */
function Util() {}

/**
 * Function Logger
 *
 * @constructor
 */
var Logger = function Logger(tag) {
    var self = this;

    var LogLevel = {
        TRACE: 0,
        DEBUG: 1,
        INFO: 2,
        WARN: 3,
        ERROR: 4,
        FATAL: 5
    };

    var LogLevelName = ['TRACE', 'DEBUG', 'INFO', 'WARN', 'ERROR', 'FATAL'];

    this._log = function () {
        var level = arguments[0];

        level = arguments[0] = LogLevelName[level];

        emedia._logContext && sdklog.apply(null, arguments);
        if (emedia.config.consoleLogger !== true) {
            return;
        }

        if (emedia && emedia.isElectron) {
            console.log.apply(console, arguments);
            return;
        }
        if (console && level) {
            (console[level.toLowerCase()] || console.warn).apply(console, arguments);
        }
    };

    function callLog(level, args) {
        try {
            _callLog(level, args);
        } catch (e) {
            if (console) {
                if (console.error) {
                    console.error(e);
                    return;
                }
                if (console.log) {
                    console.log(e);
                    return;
                }
            }

            throw e;
        }
    }

    function _sdklog() {
        if (emedia._logContextIndex < 0) {
            return;
        }
        if (!emedia._logContext || !(emedia._logContext instanceof Array)) {
            return;
        }

        var contextIndex = emedia._logContextIndex % emedia._logContext.length;
        var logInfos = emedia._logContext[contextIndex];
        if (!logInfos || !(logInfos instanceof Array)) {
            logInfos = emedia._logContext[contextIndex] = [];
        }

        var info = [];
        info.push(emedia._logContextIndex);

        var now = new Date();
        if (typeof now.toLocaleString === 'function') {
            info.push(now.toLocaleString());
        } else if (now.toJSON) {
            info.push(now.toJSON());
        } else if (now.toISOString) {
            info.push(now.toISOString());
        } else {
            info.push(now + "");
        }

        for (var i = 0; i < arguments.length; i++) {
            var arg = arguments[i];

            if (typeof arg === "string") {
                info.push(arg);
                continue;
            }
            if (!arg) {
                info.push(arg);
                continue;
            }

            if (typeof arg.message === "string") {
                info.push(arg.message);
                continue;
            }
            if (typeof arg.message === "function") {
                info.push(arg.message());
                continue;
            }
            if (typeof arg.stack === "string") {
                info.push(arg.stack);
                continue;
            }
            if (arg.event && typeof arg.event.toString === "function") {
                info.push(arg.event.toString());
                continue;
            }
            if (arg.event && typeof arg.event.toString === "function") {
                info.push(arg.event.toString());
                continue;
            }

            if (typeof arg.candidate === "string") {
                info.push(arg.candidate);
                continue;
            }
            if (typeof arg.sdp === "string") {
                info.push(arg.sdp);
                continue;
            }

            if (isPlainObject(arg)) {
                info.push((0, _stringify2.default)(arg));
            } else {
                info.push(String(arg));
            }
        }

        var infoString;
        if (emedia.config.loglastStoreArray) {
            logInfos.push(infoString = info.join(' '));
        }

        if (typeof emedia.config.onSdkLog === 'function') {
            try {
                infoString || (infoString = info.join(' '));
                emedia.config.onSdkLog(infoString);
            } catch (e) {
                console.error(e);
            }
        }
    }

    function sdklog() {
        try {
            _sdklog.apply(null, arguments);
        } catch (e) {
            console.warn(e);
        }
    };

    function _callLog(level, args) {
        if (emedia && emedia.LOG_LEVEL && level < emedia.LOG_LEVEL) {
            return;
        }

        var _args = [];

        _args.push(level);
        tag && _args.push(tag);

        for (var i = 0; i < args.length; i++) {
            _args.push(args[i] && args[i]._toString ? args[i]._toString.call(args[i]) : args[i]);
        }

        //_args.caller && _args.push(_args.caller);

        self._log.apply(self, _args);
    };

    this.log = function () {
        this._log && callLog(LogLevel.INFO, arguments);
    };

    this.trace = function () {
        this._log && callLog(LogLevel.TRACE, arguments);
    };

    this.debug = function () {
        this._log && callLog(LogLevel.DEBUG, arguments);
    };

    this.info = function () {
        this._log && callLog(LogLevel.INFO, arguments);
    };

    this.warn = function () {
        this._log && callLog(LogLevel.WARN, arguments);
    };

    this.error = function () {
        this._log && callLog(LogLevel.ERROR, arguments);
    };

    this.fatal = function () {
        this._log && callLog(LogLevel.FATAL, arguments);
    };
};

Logger.prototype.count = function () {
    if (emedia._logContext) {
        emedia._logContextIndex++;

        var contextIndex = emedia._logContextIndex % emedia._logContext.length;

        if (contextIndex === 0 && emedia._logContextIndex !== 0) {
            emedia._logContext.loadlogs = emedia._logContext[contextIndex];
        }
        emedia._logContext[contextIndex] = [];
    }
};

Util.prototype.logger = new Logger();

Util.prototype.tagLogger = function (tag) {
    return new Logger(tag);
};

/**
 * parse json
 *
 * @param jsonString
 */
Util.prototype.parseJSON = function (jsonString) {
    return JSON.parse(jsonString);
};

/**
 * json to string
 *
 * @type {Util.stringifyJSON}
 */
var stringifyJSON = Util.prototype.stringifyJSON = function (jsonObj) {
    return (0, _stringify2.default)(jsonObj);
};

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call(Object);

/**
 * check object type
 *
 * @type {Util.isPlainObject}
 */
var isPlainObject = Util.prototype.isPlainObject = function (obj) {
    var proto, Ctor;

    // Detect obvious negatives
    // Use toString instead of jQuery.type to catch host objects
    var objectString;
    if (!obj || (objectString = toString.call(obj)) !== "[object Object]" || obj.toString() === "<JSAPI-Auto Javascript Object>" || obj.toString() === "[object IFBComJavascriptObject]") {
        return false;
    }

    proto = (0, _getPrototypeOf2.default)(obj);

    // Objects with no prototype (e.g., `Object.create( null )`) are plain
    if (!proto) {
        return true;
    }

    // Objects with prototype are plain iff they were constructed by a
    // global Object function
    Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
    return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
};

Util.prototype.isArray = Array.isArray;

/**
 * check empty object
 *
 * @param obj
 * @returns {boolean}
 */
Util.prototype.isEmptyObject = function (obj) {
    var name;
    for (name in obj) {
        return false;
    }
    return true;
};

Util.prototype.type = function (obj) {
    if (obj == null) {
        return obj + "";
    }
    return (typeof obj === 'undefined' ? 'undefined' : (0, _typeof3.default)(obj)) === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj === 'undefined' ? 'undefined' : (0, _typeof3.default)(obj);
};

/**
 * Function extend
 *
 * @returns {*|{}}
 */
Util.prototype.extend = function () {
    var self = this;
    var options,
        name,
        src,
        copy,
        copyIsArray,
        clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;

    // Handle a deep copy situation
    if (typeof target === "boolean") {
        deep = target;

        // Skip the boolean and the target
        target = arguments[i] || {};
        i++;
    }

    // Handle case when target is a string or something (possible in deep
    // copy)
    if ((typeof target === 'undefined' ? 'undefined' : (0, _typeof3.default)(target)) !== "object" && !self.isFunction(target)) {
        target = {};
    }

    // Extend self itself if only one argument is passed
    if (i === length) {
        target = this;
        i--;
    }

    for (; i < length; i++) {

        // Only deal with non-null/undefined values
        if ((options = arguments[i]) != null) {

            // Extend the base object
            for (name in options) {
                src = target[name];
                copy = options[name];

                // Prevent never-ending loop
                if (target === copy) {
                    continue;
                }

                // Recurse if we're merging plain objects or arrays
                if (deep && copy && (self.isPlainObject(copy) || (copyIsArray = self.isArray(copy)))) {

                    if (copyIsArray) {
                        copyIsArray = false;
                        clone = src && self.isArray(src) ? src : [];
                    } else {
                        clone = src && self.isPlainObject(src) ? src : {};
                    }

                    // Never move original objects, clone them
                    target[name] = self.extend(deep, clone, copy);

                    // Don't bring in undefined values
                } else if (copy !== undefined) {
                    target[name] = copy;
                }
            }
        }
    }

    // Return the modified object
    return target;
};

Util.prototype.removeAttribute = function (elem, key) {
    if (elem === null || elem === undefined) {
        return;
    }

    var obj = elem[key];

    // if(emedia.isSafari && obj && obj.__undefinedEQDelete){ // safari delete stream时，地址栏会有个小喇叭; 要延迟删除
    //     emedia._stream_garbages || (emedia._stream_garbages = [])
    //     emedia._stream_garbages.push(obj);
    // }
    delete elem[key];

    return obj;
};

Util.prototype.prototypeExtend_000 = Util.prototype.classExtend = function () {
    var self = this;

    function _Obj__() {
        for (var i = 0; i < arguments.length; i++) {
            var cfg = arguments[i] || {};
            self.extend(true, this, cfg);
        }

        this.__init__ && this.__init__.apply(this, arguments);
    }

    var lastConstructor;

    for (var i = 0; i < arguments.length; i++) {
        var cfg = arguments[i] || {};

        if (typeof cfg === "function") {
            if (lastConstructor) {
                cfg.constructor = lastConstructor;
                cfg.__proto__ = lastConstructor.prototype;
            } else {
                lastConstructor = cfg;
            }
        } else {
            self.extend(true, _Obj__.prototype, cfg);
        }
    }

    lastConstructor && (_Obj__.prototype.__proto__ = lastConstructor.prototype);
    lastConstructor && (_Obj__.prototype.constructor = lastConstructor);

    _Obj__.extend || (_Obj__.extend = function (_prototypeExtend) {
        return self.prototypeExtend(_Obj__, _prototypeExtend);
    });

    return _Obj__;
};

Util.prototype.prototypeExtend = Util.prototype.classExtend = function () {
    var self = this;

    function _Obj__() {
        for (var i = 0; i < arguments.length; i++) {
            var cfg = arguments[i] || {};
            self.extend(true, this, cfg);
        }

        this.__init__ && this.__init__.apply(this, arguments);
    }

    for (var i = 0; i < arguments.length; i++) {
        var cfg = arguments[i] || {};
        if (typeof cfg === "function") {
            cfg = cfg.prototype;
        }

        self.extend(true, _Obj__.prototype, cfg);
    }

    _Obj__.extend || (_Obj__.extend = function (_prototypeExtend) {
        return self.prototypeExtend(_Obj__, _prototypeExtend);
    });

    return _Obj__;
};

/**
 * get local cache
 *
 * @memberOf tool
 * @name hasLocalData
 * @param key{string}
 *            localStorage的key值
 * @return boolean
 */
Util.prototype.hasLocalStorage = function (key) {
    // null -> localStorage.removeItem时
    // '{}' -> collection.models.destroy时
    if (localStorage.getItem(key) == null || localStorage.getItem(key) == '{}') {
        return false;
    }
    return true;
};

Util.prototype.toggleClass = function (node, className) {
    if (node.hasClass(className)) {
        node.removeClass(className);
        return;
    }
    node.addClass(className);
};

/**
 * set cookie
 *
 * @param name{String}
 *
 * @param value{String}
 *
 * @param hour{Number}
 *
 * @return void
 */
Util.prototype.setCookie = function (name, value, hour) {
    var exp = new Date();
    exp.setTime(exp.getTime() + hour * 60 * 60 * 1000);
    document.cookie = name + "=" + escape(value) + ";expires=" + exp.toGMTString();
};

/**
 * read cookie
 *
 * @param name(String)
 *            cookie key
 * @return cookie value
 * @memberOf Tool
 */
Util.prototype.getCookie = function (name) {
    var arr = document.cookie.match(new RegExp("(^| )" + name + "=([^;]*)(;|$)"));
    if (arr != null) {
        return unescape(arr[2]);
    }
    return null;
};

/**
 * query parameter from url
 *
 * @name parseURL
 * @memberof C.Tools
 * @param {string}
 *
 * @return {string}
 * @type function
 * @public
 */
Util.prototype.parseURL = function (name) {
    var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)", "i");
    var r = window.location.search.substr(1).match(reg);
    if (r != null) {
        return unescape(r[2]);
    }
    return null;
};

/**
 * function(index, value){

}
 * @param obj
 */
Util.prototype.forEach = function (obj, func) {
    if (!obj) {
        return;
    }

    if (this.isArray(obj) && obj.length === 0) {
        return;
    }
    if (obj.length !== undefined && obj.length === 0) {
        return;
    }
    if (obj.length) {
        for (var i = 0; i < obj.length; i++) {
            func(i, obj[i]);
        }
        return;
    }

    if (!obj || this.isEmptyObject(obj)) {
        return;
    }

    obj = obj || {};

    var copy = this.extend(false, {}, obj);

    for (var index in copy) {
        func(index, obj[index]);
    }
};

Util.prototype.isInt = function (n) {
    return Number(n) === n && n % 1 === 0;
};

Util.prototype.isFloat = function (n) {
    return Number(n) === n && n % 1 !== 0;
};

Util.prototype.list = function () {
    var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
    return args;
};

Util.prototype.addEvent = function (element, name, func) {
    if (element.attachEvent) return element.attachEvent("on" + name, func);
    if (element.addEventListener) return element.addEventListener(name, func, false);
    throw "Handler could not be attached";
};

Util.prototype.removeEvent = function (element, name, func) {
    if (element.detachEvent) return element.detachEvent("on" + name, func);
    if (element.removeEventListener) return element.removeEventListener(name, func, false);
    throw "Handler could not be removed";
};

Util.prototype.stopEvent = function (event) {
    event.stopPropagation ? event.stopPropagation() : event.cancelBubble = true;
    event.preventDefault ? event.preventDefault() : event.returnValue = false;
};

Util.prototype.getDomPageRect = function (element) {
    var domRect = element.getBoundingClientRect();
    return {
        x: domRect.left + (window.pageXOffset || window.document.documentElement.scrollLeft),
        y: domRect.top + (window.pageYOffset || window.document.documentElement.scrollTop),
        width: domRect.width || element.offsetWidth,
        height: domRect.height || element.offsetHeight
    };
};

Util.prototype.getEventElementXY = function (event, element, scale) {
    event = event || window.event;

    var touch = event.changedTouches ? event.changedTouches[0] : event.touches ? event.touches[0] : event;

    var pageX, pageY;
    if (touch.pageX != undefined && touch.pageY != undefined) {
        pageX = touch.pageX;
        pageY = touch.pageY;
    } else if (touch.clientX != undefined && touch.clientY != undefined) {
        pageX = touch.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
        pageY = touch.clientY + document.body.scrollTop + document.documentElement.scrollTop;
    }

    var elementPageXY = this.getDomPageRect(element);

    var relativeX = pageX - elementPageXY.x;
    var relativeY = pageY - elementPageXY.y;

    (scale === 0 || scale == undefined) && (scale = 1);
    return {
        x: Math.round(Math.max(Math.min(relativeX, elementPageXY.width - 1), 0) / scale),
        y: Math.round(Math.max(Math.min(relativeY, elementPageXY.height - 1), 0) / scale),
        width: Math.round(elementPageXY.width / scale),
        height: Math.round(elementPageXY.height / scale),

        realX: relativeX,
        realY: relativeY
    };
};

Util.prototype.layoutEngine = function () {
    var engine = {
        presto: !!window.opera,
        trident: !!window.ActiveXObject && (window.XMLHttpRequest ? document.querySelectorAll ? 6 : 5 : 4),
        webkit: function () {
            try {
                return !navigator.taintEnabled && (i.Features.xpath ? i.Features.query ? 525 : 420 : 419);
            } catch (e) {
                return !1;
            }
        }(),
        gecko: !(!document.getBoxObjectFor && null == window.mozInnerScreenX) && (document.getElementsByClassName ? 19 : 18)
    };

    engine.webkit && (engine.webkit = function (e) {
        var n = (navigator.userAgent.match(/WebKit\/([0-9\.]*) /) || ["", e])[1];
        return parseFloat(n, 10);
    }(engine));

    return engine;
}();

Util.prototype.targetDOM = (typeof HTMLElement === 'undefined' ? 'undefined' : (0, _typeof3.default)(HTMLElement)) === 'object' ? function (obj) {
    return obj instanceof HTMLElement;
} : function (obj) {
    return obj && (typeof obj === 'undefined' ? 'undefined' : (0, _typeof3.default)(obj)) === 'object' && obj.nodeType === 1 && typeof obj.nodeName === 'string';
};

Util.prototype.cloneCSS = function (srcElement, destElement) {
    /**
     * IE8不支持window.getComputedStyle
     * IE9~11中，window.getComputedStyle().cssText返回的总为空字符串
     * 默认的window.getComputedStyle || dom.currentStyle, 返回的css键值对中，键是驼峰命名的。
     */
    var oStyle = window.getComputedStyle && window.getComputedStyle(srcElement, null) || srcElement.currentStyle;
    for (var key in oStyle) {
        var v = oStyle[key];
        if (/^[a-z]/i.test(key) && [null, '', undefined].indexOf(v) < 0) {
            destElement.style[key] = v;
        }
    }
};

Util.prototype.canYield = function () {
    try {
        return eval("!!Function('yield true;')().next()");
    } catch (e) {
        return false;
    }
}();

module.exports = new Util();

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__(74);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(125);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(75), __esModule: true };

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(76);
__webpack_require__(120);
module.exports = __webpack_require__(124).f('iterator');


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__(77)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(80)(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(78);
var defined = __webpack_require__(79);
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),
/* 78 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),
/* 79 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(81);
var $export = __webpack_require__(82);
var redefine = __webpack_require__(98);
var hide = __webpack_require__(87);
var Iterators = __webpack_require__(99);
var $iterCreate = __webpack_require__(100);
var setToStringTag = __webpack_require__(116);
var getPrototypeOf = __webpack_require__(118);
var ITERATOR = __webpack_require__(117)('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),
/* 81 */
/***/ (function(module, exports) {

module.exports = true;


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(83);
var core = __webpack_require__(84);
var ctx = __webpack_require__(85);
var hide = __webpack_require__(87);
var has = __webpack_require__(97);
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),
/* 83 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),
/* 84 */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.6.10' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(86);
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),
/* 86 */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(88);
var createDesc = __webpack_require__(96);
module.exports = __webpack_require__(92) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(89);
var IE8_DOM_DEFINE = __webpack_require__(91);
var toPrimitive = __webpack_require__(95);
var dP = Object.defineProperty;

exports.f = __webpack_require__(92) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(90);
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),
/* 90 */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(92) && !__webpack_require__(93)(function () {
  return Object.defineProperty(__webpack_require__(94)('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(93)(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 93 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(90);
var document = __webpack_require__(83).document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(90);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),
/* 96 */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),
/* 97 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(87);


/***/ }),
/* 99 */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(101);
var descriptor = __webpack_require__(96);
var setToStringTag = __webpack_require__(116);
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(87)(IteratorPrototype, __webpack_require__(117)('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(89);
var dPs = __webpack_require__(102);
var enumBugKeys = __webpack_require__(114);
var IE_PROTO = __webpack_require__(111)('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(94)('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(115).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(88);
var anObject = __webpack_require__(89);
var getKeys = __webpack_require__(103);

module.exports = __webpack_require__(92) ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(104);
var enumBugKeys = __webpack_require__(114);

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(97);
var toIObject = __webpack_require__(105);
var arrayIndexOf = __webpack_require__(108)(false);
var IE_PROTO = __webpack_require__(111)('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(106);
var defined = __webpack_require__(79);
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(107);
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),
/* 107 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(105);
var toLength = __webpack_require__(109);
var toAbsoluteIndex = __webpack_require__(110);
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(78);
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(78);
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(112)('keys');
var uid = __webpack_require__(113);
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(84);
var global = __webpack_require__(83);
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__(81) ? 'pure' : 'global',
  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
});


/***/ }),
/* 113 */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),
/* 114 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(83).document;
module.exports = document && document.documentElement;


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(88).f;
var has = __webpack_require__(97);
var TAG = __webpack_require__(117)('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(112)('wks');
var uid = __webpack_require__(113);
var Symbol = __webpack_require__(83).Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(97);
var toObject = __webpack_require__(119);
var IE_PROTO = __webpack_require__(111)('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(79);
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(121);
var global = __webpack_require__(83);
var hide = __webpack_require__(87);
var Iterators = __webpack_require__(99);
var TO_STRING_TAG = __webpack_require__(117)('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(122);
var step = __webpack_require__(123);
var Iterators = __webpack_require__(99);
var toIObject = __webpack_require__(105);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(80)(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),
/* 122 */
/***/ (function(module, exports) {

module.exports = function () { /* empty */ };


/***/ }),
/* 123 */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(117);


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(126), __esModule: true };

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(127);
__webpack_require__(137);
__webpack_require__(138);
__webpack_require__(139);
module.exports = __webpack_require__(84).Symbol;


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __webpack_require__(83);
var has = __webpack_require__(97);
var DESCRIPTORS = __webpack_require__(92);
var $export = __webpack_require__(82);
var redefine = __webpack_require__(98);
var META = __webpack_require__(128).KEY;
var $fails = __webpack_require__(93);
var shared = __webpack_require__(112);
var setToStringTag = __webpack_require__(116);
var uid = __webpack_require__(113);
var wks = __webpack_require__(117);
var wksExt = __webpack_require__(124);
var wksDefine = __webpack_require__(129);
var enumKeys = __webpack_require__(130);
var isArray = __webpack_require__(133);
var anObject = __webpack_require__(89);
var isObject = __webpack_require__(90);
var toObject = __webpack_require__(119);
var toIObject = __webpack_require__(105);
var toPrimitive = __webpack_require__(95);
var createDesc = __webpack_require__(96);
var _create = __webpack_require__(101);
var gOPNExt = __webpack_require__(134);
var $GOPD = __webpack_require__(136);
var $GOPS = __webpack_require__(131);
var $DP = __webpack_require__(88);
var $keys = __webpack_require__(103);
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function' && !!$GOPS.f;
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(135).f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(132).f = $propertyIsEnumerable;
  $GOPS.f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(81)) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
var FAILS_ON_PRIMITIVES = $fails(function () { $GOPS.f(1); });

$export($export.S + $export.F * FAILS_ON_PRIMITIVES, 'Object', {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return $GOPS.f(toObject(it));
  }
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(87)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(113)('meta');
var isObject = __webpack_require__(90);
var has = __webpack_require__(97);
var setDesc = __webpack_require__(88).f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__(93)(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(83);
var core = __webpack_require__(84);
var LIBRARY = __webpack_require__(81);
var wksExt = __webpack_require__(124);
var defineProperty = __webpack_require__(88).f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(103);
var gOPS = __webpack_require__(131);
var pIE = __webpack_require__(132);
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),
/* 131 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),
/* 132 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(107);
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(105);
var gOPN = __webpack_require__(135).f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(104);
var hiddenKeys = __webpack_require__(114).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(132);
var createDesc = __webpack_require__(96);
var toIObject = __webpack_require__(105);
var toPrimitive = __webpack_require__(95);
var has = __webpack_require__(97);
var IE8_DOM_DEFINE = __webpack_require__(91);
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(92) ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),
/* 137 */
/***/ (function(module, exports) {



/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(129)('asyncIterator');


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(129)('observable');


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(141), __esModule: true };

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(142);
module.exports = __webpack_require__(84).Object.getPrototypeOf;


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = __webpack_require__(119);
var $getPrototypeOf = __webpack_require__(118);

__webpack_require__(143)('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(82);
var core = __webpack_require__(84);
var fails = __webpack_require__(93);
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(145), __esModule: true };

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(84);
var $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });
module.exports = function stringify(it) { // eslint-disable-line no-unused-vars
  return $JSON.stringify.apply($JSON, arguments);
};


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/* Zepto v1.2.0 - zepto event ajax form ie - zeptojs.com/license */
(function(global, factory) {
  if (true)
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return factory(global) }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
  else
    {}
}(this, function() {
  var Zepto = (function() {
  var undefined, key, $, classList, emptyArray = [], concat = emptyArray.concat, filter = emptyArray.filter, slice = emptyArray.slice,
    document = window.document,
    elementDisplay = {}, classCache = {},
    cssNumber = { 'column-count': 1, 'columns': 1, 'font-weight': 1, 'line-height': 1,'opacity': 1, 'z-index': 1, 'zoom': 1 },
    fragmentRE = /^\s*<(\w+|!)[^>]*>/,
    singleTagRE = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
    tagExpanderRE = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
    rootNodeRE = /^(?:body|html)$/i,
    capitalRE = /([A-Z])/g,

    // special attributes that should be get/set via method calls
    methodAttributes = ['val', 'css', 'html', 'text', 'data', 'width', 'height', 'offset'],

    adjacencyOperators = [ 'after', 'prepend', 'before', 'append' ],
    table = document.createElement('table'),
    tableRow = document.createElement('tr'),
    containers = {
      'tr': document.createElement('tbody'),
      'tbody': table, 'thead': table, 'tfoot': table,
      'td': tableRow, 'th': tableRow,
      '*': document.createElement('div')
    },
    readyRE = /complete|loaded|interactive/,
    simpleSelectorRE = /^[\w-]*$/,
    class2type = {},
    toString = class2type.toString,
    zepto = {},
    camelize, uniq,
    tempParent = document.createElement('div'),
    propMap = {
      'tabindex': 'tabIndex',
      'readonly': 'readOnly',
      'for': 'htmlFor',
      'class': 'className',
      'maxlength': 'maxLength',
      'cellspacing': 'cellSpacing',
      'cellpadding': 'cellPadding',
      'rowspan': 'rowSpan',
      'colspan': 'colSpan',
      'usemap': 'useMap',
      'frameborder': 'frameBorder',
      'contenteditable': 'contentEditable'
    },
    isArray = Array.isArray ||
      function(object){ return object instanceof Array }

  zepto.matches = function(element, selector) {
    if (!selector || !element || element.nodeType !== 1) return false
    var matchesSelector = element.matches || element.webkitMatchesSelector ||
                          element.mozMatchesSelector || element.oMatchesSelector ||
                          element.matchesSelector
    if (matchesSelector) return matchesSelector.call(element, selector)
    // fall back to performing a selector:
    var match, parent = element.parentNode, temp = !parent
    if (temp) (parent = tempParent).appendChild(element)
    match = ~zepto.qsa(parent, selector).indexOf(element)
    temp && tempParent.removeChild(element)
    return match
  }

  function type(obj) {
    return obj == null ? String(obj) :
      class2type[toString.call(obj)] || "object"
  }

  function isFunction(value) { return type(value) == "function" }
  function isWindow(obj)     { return obj != null && obj == obj.window }
  function isDocument(obj)   { return obj != null && obj.nodeType == obj.DOCUMENT_NODE }
  function isObject(obj)     { return type(obj) == "object" }
  function isPlainObject(obj) {
    return isObject(obj) && !isWindow(obj) && Object.getPrototypeOf(obj) == Object.prototype
  }

  function likeArray(obj) {
    var length = !!obj && 'length' in obj && obj.length,
      type = $.type(obj)

    return 'function' != type && !isWindow(obj) && (
      'array' == type || length === 0 ||
        (typeof length == 'number' && length > 0 && (length - 1) in obj)
    )
  }

  function compact(array) { return filter.call(array, function(item){ return item != null }) }
  function flatten(array) { return array.length > 0 ? $.fn.concat.apply([], array) : array }
  camelize = function(str){ return str.replace(/-+(.)?/g, function(match, chr){ return chr ? chr.toUpperCase() : '' }) }
  function dasherize(str) {
    return str.replace(/::/g, '/')
           .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')
           .replace(/([a-z\d])([A-Z])/g, '$1_$2')
           .replace(/_/g, '-')
           .toLowerCase()
  }
  uniq = function(array){ return filter.call(array, function(item, idx){ return array.indexOf(item) == idx }) }

  function classRE(name) {
    return name in classCache ?
      classCache[name] : (classCache[name] = new RegExp('(^|\\s)' + name + '(\\s|$)'))
  }

  function maybeAddPx(name, value) {
    return (typeof value == "number" && !cssNumber[dasherize(name)]) ? value + "px" : value
  }

  function defaultDisplay(nodeName) {
    var element, display
    if (!elementDisplay[nodeName]) {
      element = document.createElement(nodeName)
      document.body.appendChild(element)
      display = getComputedStyle(element, '').getPropertyValue("display")
      element.parentNode.removeChild(element)
      display == "none" && (display = "block")
      elementDisplay[nodeName] = display
    }
    return elementDisplay[nodeName]
  }

  function children(element) {
    return 'children' in element ?
      slice.call(element.children) :
      $.map(element.childNodes, function(node){ if (node.nodeType == 1) return node })
  }

  function Z(dom, selector) {
    var i, len = dom ? dom.length : 0
    for (i = 0; i < len; i++) this[i] = dom[i]
    this.length = len
    this.selector = selector || ''
  }

  // `$.zepto.fragment` takes a html string and an optional tag name
  // to generate DOM nodes from the given html string.
  // The generated DOM nodes are returned as an array.
  // This function can be overridden in plugins for example to make
  // it compatible with browsers that don't support the DOM fully.
  zepto.fragment = function(html, name, properties) {
    var dom, nodes, container

    // A special case optimization for a single tag
    if (singleTagRE.test(html)) dom = $(document.createElement(RegExp.$1))

    if (!dom) {
      if (html.replace) html = html.replace(tagExpanderRE, "<$1></$2>")
      if (name === undefined) name = fragmentRE.test(html) && RegExp.$1
      if (!(name in containers)) name = '*'

      container = containers[name]
      container.innerHTML = '' + html
      dom = $.each(slice.call(container.childNodes), function(){
        container.removeChild(this)
      })
    }

    if (isPlainObject(properties)) {
      nodes = $(dom)
      $.each(properties, function(key, value) {
        if (methodAttributes.indexOf(key) > -1) nodes[key](value)
        else nodes.attr(key, value)
      })
    }

    return dom
  }

  // `$.zepto.Z` swaps out the prototype of the given `dom` array
  // of nodes with `$.fn` and thus supplying all the Zepto functions
  // to the array. This method can be overridden in plugins.
  zepto.Z = function(dom, selector) {
    return new Z(dom, selector)
  }

  // `$.zepto.isZ` should return `true` if the given object is a Zepto
  // collection. This method can be overridden in plugins.
  zepto.isZ = function(object) {
    return object instanceof zepto.Z
  }

  // `$.zepto.init` is Zepto's counterpart to jQuery's `$.fn.init` and
  // takes a CSS selector and an optional context (and handles various
  // special cases).
  // This method can be overridden in plugins.
  zepto.init = function(selector, context) {
    var dom
    // If nothing given, return an empty Zepto collection
    if (!selector) return zepto.Z()
    // Optimize for string selectors
    else if (typeof selector == 'string') {
      selector = selector.trim()
      // If it's a html fragment, create nodes from it
      // Note: In both Chrome 21 and Firefox 15, DOM error 12
      // is thrown if the fragment doesn't begin with <
      if (selector[0] == '<' && fragmentRE.test(selector))
        dom = zepto.fragment(selector, RegExp.$1, context), selector = null
      // If there's a context, create a collection on that context first, and select
      // nodes from there
      else if (context !== undefined) return $(context).find(selector)
      // If it's a CSS selector, use it to select nodes.
      else dom = zepto.qsa(document, selector)
    }
    // If a function is given, call it when the DOM is ready
    else if (isFunction(selector)) return $(document).ready(selector)
    // If a Zepto collection is given, just return it
    else if (zepto.isZ(selector)) return selector
    else {
      // normalize array if an array of nodes is given
      if (isArray(selector)) dom = compact(selector)
      // Wrap DOM nodes.
      else if (isObject(selector))
        dom = [selector], selector = null
      // If it's a html fragment, create nodes from it
      else if (fragmentRE.test(selector))
        dom = zepto.fragment(selector.trim(), RegExp.$1, context), selector = null
      // If there's a context, create a collection on that context first, and select
      // nodes from there
      else if (context !== undefined) return $(context).find(selector)
      // And last but no least, if it's a CSS selector, use it to select nodes.
      else dom = zepto.qsa(document, selector)
    }
    // create a new Zepto collection from the nodes found
    return zepto.Z(dom, selector)
  }

  // `$` will be the base `Zepto` object. When calling this
  // function just call `$.zepto.init, which makes the implementation
  // details of selecting nodes and creating Zepto collections
  // patchable in plugins.
  $ = function(selector, context){
    return zepto.init(selector, context)
  }

  function extend(target, source, deep) {
    for (key in source)
      if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {
        if (isPlainObject(source[key]) && !isPlainObject(target[key]))
          target[key] = {}
        if (isArray(source[key]) && !isArray(target[key]))
          target[key] = []
        extend(target[key], source[key], deep)
      }
      else if (source[key] !== undefined) target[key] = source[key]
  }

  // Copy all but undefined properties from one or more
  // objects to the `target` object.
  $.extend = function(target){
    var deep, args = slice.call(arguments, 1)
    if (typeof target == 'boolean') {
      deep = target
      target = args.shift()
    }
    args.forEach(function(arg){ extend(target, arg, deep) })
    return target
  }

  // `$.zepto.qsa` is Zepto's CSS selector implementation which
  // uses `document.querySelectorAll` and optimizes for some special cases, like `#id`.
  // This method can be overridden in plugins.
  zepto.qsa = function(element, selector){
    var found,
        maybeID = selector[0] == '#',
        maybeClass = !maybeID && selector[0] == '.',
        nameOnly = maybeID || maybeClass ? selector.slice(1) : selector, // Ensure that a 1 char tag name still gets checked
        isSimple = simpleSelectorRE.test(nameOnly)
    return (element.getElementById && isSimple && maybeID) ? // Safari DocumentFragment doesn't have getElementById
      ( (found = element.getElementById(nameOnly)) ? [found] : [] ) :
      (element.nodeType !== 1 && element.nodeType !== 9 && element.nodeType !== 11) ? [] :
      slice.call(
        isSimple && !maybeID && element.getElementsByClassName ? // DocumentFragment doesn't have getElementsByClassName/TagName
          maybeClass ? element.getElementsByClassName(nameOnly) : // If it's simple, it could be a class
          element.getElementsByTagName(selector) : // Or a tag
          element.querySelectorAll(selector) // Or it's not simple, and we need to query all
      )
  }

  function filtered(nodes, selector) {
    return selector == null ? $(nodes) : $(nodes).filter(selector)
  }

  $.contains = document.documentElement.contains ?
    function(parent, node) {
      return parent !== node && parent.contains(node)
    } :
    function(parent, node) {
      while (node && (node = node.parentNode))
        if (node === parent) return true
      return false
    }

  function funcArg(context, arg, idx, payload) {
    return isFunction(arg) ? arg.call(context, idx, payload) : arg
  }

  function setAttribute(node, name, value) {
    value == null ? node.removeAttribute(name) : node.setAttribute(name, value)
  }

  // access className property while respecting SVGAnimatedString
  function className(node, value){
    var klass = node.className || '',
        svg   = klass && klass.baseVal !== undefined

    if (value === undefined) return svg ? klass.baseVal : klass
    svg ? (klass.baseVal = value) : (node.className = value)
  }

  // "true"  => true
  // "false" => false
  // "null"  => null
  // "42"    => 42
  // "42.5"  => 42.5
  // "08"    => "08"
  // JSON    => parse if valid
  // String  => self
  function deserializeValue(value) {
    try {
      return value ?
        value == "true" ||
        ( value == "false" ? false :
          value == "null" ? null :
          +value + "" == value ? +value :
          /^[\[\{]/.test(value) ? $.parseJSON(value) :
          value )
        : value
    } catch(e) {
      return value
    }
  }

  $.type = type
  $.isFunction = isFunction
  $.isWindow = isWindow
  $.isArray = isArray
  $.isPlainObject = isPlainObject

  $.isEmptyObject = function(obj) {
    var name
    for (name in obj) return false
    return true
  }

  $.isNumeric = function(val) {
    var num = Number(val), type = typeof val
    return val != null && type != 'boolean' &&
      (type != 'string' || val.length) &&
      !isNaN(num) && isFinite(num) || false
  }

  $.inArray = function(elem, array, i){
    return emptyArray.indexOf.call(array, elem, i)
  }

  $.camelCase = camelize
  $.trim = function(str) {
    return str == null ? "" : String.prototype.trim.call(str)
  }

  // plugin compatibility
  $.uuid = 0
  $.support = { }
  $.expr = { }
  $.noop = function() {}

  $.map = function(elements, callback){
    var value, values = [], i, key
    if (likeArray(elements))
      for (i = 0; i < elements.length; i++) {
        value = callback(elements[i], i)
        if (value != null) values.push(value)
      }
    else
      for (key in elements) {
        value = callback(elements[key], key)
        if (value != null) values.push(value)
      }
    return flatten(values)
  }

  $.each = function(elements, callback){
    var i, key
    if (likeArray(elements)) {
      for (i = 0; i < elements.length; i++)
        if (callback.call(elements[i], i, elements[i]) === false) return elements
    } else {
      for (key in elements)
        if (callback.call(elements[key], key, elements[key]) === false) return elements
    }

    return elements
  }

  $.grep = function(elements, callback){
    return filter.call(elements, callback)
  }

  if (window.JSON) $.parseJSON = JSON.parse

  // Populate the class2type map
  $.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
    class2type[ "[object " + name + "]" ] = name.toLowerCase()
  })

  // Define methods that will be available on all
  // Zepto collections
  $.fn = {
    constructor: zepto.Z,
    length: 0,

    // Because a collection acts like an array
    // copy over these useful array functions.
    forEach: emptyArray.forEach,
    reduce: emptyArray.reduce,
    push: emptyArray.push,
    sort: emptyArray.sort,
    splice: emptyArray.splice,
    indexOf: emptyArray.indexOf,
    concat: function(){
      var i, value, args = []
      for (i = 0; i < arguments.length; i++) {
        value = arguments[i]
        args[i] = zepto.isZ(value) ? value.toArray() : value
      }
      return concat.apply(zepto.isZ(this) ? this.toArray() : this, args)
    },

    // `map` and `slice` in the jQuery API work differently
    // from their array counterparts
    map: function(fn){
      return $($.map(this, function(el, i){ return fn.call(el, i, el) }))
    },
    slice: function(){
      return $(slice.apply(this, arguments))
    },

    ready: function(callback){
      // need to check if document.body exists for IE as that browser reports
      // document ready when it hasn't yet created the body element
      if (readyRE.test(document.readyState) && document.body) callback($)
      else document.addEventListener('DOMContentLoaded', function(){ callback($) }, false)
      return this
    },
    get: function(idx){
      return idx === undefined ? slice.call(this) : this[idx >= 0 ? idx : idx + this.length]
    },
    toArray: function(){ return this.get() },
    size: function(){
      return this.length
    },
    remove: function(){
      return this.each(function(){
        if (this.parentNode != null)
          this.parentNode.removeChild(this)
      })
    },
    each: function(callback){
      emptyArray.every.call(this, function(el, idx){
        return callback.call(el, idx, el) !== false
      })
      return this
    },
    filter: function(selector){
      if (isFunction(selector)) return this.not(this.not(selector))
      return $(filter.call(this, function(element){
        return zepto.matches(element, selector)
      }))
    },
    add: function(selector,context){
      return $(uniq(this.concat($(selector,context))))
    },
    is: function(selector){
      return this.length > 0 && zepto.matches(this[0], selector)
    },
    not: function(selector){
      var nodes=[]
      if (isFunction(selector) && selector.call !== undefined)
        this.each(function(idx){
          if (!selector.call(this,idx)) nodes.push(this)
        })
      else {
        var excludes = typeof selector == 'string' ? this.filter(selector) :
          (likeArray(selector) && isFunction(selector.item)) ? slice.call(selector) : $(selector)
        this.forEach(function(el){
          if (excludes.indexOf(el) < 0) nodes.push(el)
        })
      }
      return $(nodes)
    },
    has: function(selector){
      return this.filter(function(){
        return isObject(selector) ?
          $.contains(this, selector) :
          $(this).find(selector).size()
      })
    },
    eq: function(idx){
      return idx === -1 ? this.slice(idx) : this.slice(idx, + idx + 1)
    },
    first: function(){
      var el = this[0]
      return el && !isObject(el) ? el : $(el)
    },
    last: function(){
      var el = this[this.length - 1]
      return el && !isObject(el) ? el : $(el)
    },
    find: function(selector){
      var result, $this = this
      if (!selector) result = $()
      else if (typeof selector == 'object')
        result = $(selector).filter(function(){
          var node = this
          return emptyArray.some.call($this, function(parent){
            return $.contains(parent, node)
          })
        })
      else if (this.length == 1) result = $(zepto.qsa(this[0], selector))
      else result = this.map(function(){ return zepto.qsa(this, selector) })
      return result
    },
    closest: function(selector, context){
      var nodes = [], collection = typeof selector == 'object' && $(selector)
      this.each(function(_, node){
        while (node && !(collection ? collection.indexOf(node) >= 0 : zepto.matches(node, selector)))
          node = node !== context && !isDocument(node) && node.parentNode
        if (node && nodes.indexOf(node) < 0) nodes.push(node)
      })
      return $(nodes)
    },
    parents: function(selector){
      var ancestors = [], nodes = this
      while (nodes.length > 0)
        nodes = $.map(nodes, function(node){
          if ((node = node.parentNode) && !isDocument(node) && ancestors.indexOf(node) < 0) {
            ancestors.push(node)
            return node
          }
        })
      return filtered(ancestors, selector)
    },
    parent: function(selector){
      return filtered(uniq(this.pluck('parentNode')), selector)
    },
    children: function(selector){
      return filtered(this.map(function(){ return children(this) }), selector)
    },
    contents: function() {
      return this.map(function() { return this.contentDocument || slice.call(this.childNodes) })
    },
    siblings: function(selector){
      return filtered(this.map(function(i, el){
        return filter.call(children(el.parentNode), function(child){ return child!==el })
      }), selector)
    },
    empty: function(){
      return this.each(function(){ this.innerHTML = '' })
    },
    // `pluck` is borrowed from Prototype.js
    pluck: function(property){
      return $.map(this, function(el){ return el[property] })
    },
    show: function(){
      return this.each(function(){
        this.style.display == "none" && (this.style.display = '')
        if (getComputedStyle(this, '').getPropertyValue("display") == "none")
          this.style.display = defaultDisplay(this.nodeName)
      })
    },
    replaceWith: function(newContent){
      return this.before(newContent).remove()
    },
    wrap: function(structure){
      var func = isFunction(structure)
      if (this[0] && !func)
        var dom   = $(structure).get(0),
            clone = dom.parentNode || this.length > 1

      return this.each(function(index){
        $(this).wrapAll(
          func ? structure.call(this, index) :
            clone ? dom.cloneNode(true) : dom
        )
      })
    },
    wrapAll: function(structure){
      if (this[0]) {
        $(this[0]).before(structure = $(structure))
        var children
        // drill down to the inmost element
        while ((children = structure.children()).length) structure = children.first()
        $(structure).append(this)
      }
      return this
    },
    wrapInner: function(structure){
      var func = isFunction(structure)
      return this.each(function(index){
        var self = $(this), contents = self.contents(),
            dom  = func ? structure.call(this, index) : structure
        contents.length ? contents.wrapAll(dom) : self.append(dom)
      })
    },
    unwrap: function(){
      this.parent().each(function(){
        $(this).replaceWith($(this).children())
      })
      return this
    },
    clone: function(){
      return this.map(function(){ return this.cloneNode(true) })
    },
    hide: function(){
      return this.css("display", "none")
    },
    toggle: function(setting){
      return this.each(function(){
        var el = $(this)
        ;(setting === undefined ? el.css("display") == "none" : setting) ? el.show() : el.hide()
      })
    },
    prev: function(selector){ return $(this.pluck('previousElementSibling')).filter(selector || '*') },
    next: function(selector){ return $(this.pluck('nextElementSibling')).filter(selector || '*') },
    html: function(html){
      return 0 in arguments ?
        this.each(function(idx){
          var originHtml = this.innerHTML
          $(this).empty().append( funcArg(this, html, idx, originHtml) )
        }) :
        (0 in this ? this[0].innerHTML : null)
    },
    text: function(text){
      return 0 in arguments ?
        this.each(function(idx){
          var newText = funcArg(this, text, idx, this.textContent)
          this.textContent = newText == null ? '' : ''+newText
        }) :
        (0 in this ? this.pluck('textContent').join("") : null)
    },
    attr: function(name, value){
      var result
      return (typeof name == 'string' && !(1 in arguments)) ?
        (0 in this && this[0].nodeType == 1 && (result = this[0].getAttribute(name)) != null ? result : undefined) :
        this.each(function(idx){
          if (this.nodeType !== 1) return
          if (isObject(name)) for (key in name) setAttribute(this, key, name[key])
          else setAttribute(this, name, funcArg(this, value, idx, this.getAttribute(name)))
        })
    },
    removeAttr: function(name){
      return this.each(function(){ this.nodeType === 1 && name.split(' ').forEach(function(attribute){
        setAttribute(this, attribute)
      }, this)})
    },
    prop: function(name, value){
      name = propMap[name] || name
      return (1 in arguments) ?
        this.each(function(idx){
          this[name] = funcArg(this, value, idx, this[name])
        }) :
        (this[0] && this[0][name])
    },
    removeProp: function(name){
      name = propMap[name] || name
      return this.each(function(){ delete this[name] })
    },
    data: function(name, value){
      var attrName = 'data-' + name.replace(capitalRE, '-$1').toLowerCase()

      var data = (1 in arguments) ?
        this.attr(attrName, value) :
        this.attr(attrName)

      return data !== null ? deserializeValue(data) : undefined
    },
    val: function(value){
      if (0 in arguments) {
        if (value == null) value = ""
        return this.each(function(idx){
          this.value = funcArg(this, value, idx, this.value)
        })
      } else {
        return this[0] && (this[0].multiple ?
           $(this[0]).find('option').filter(function(){ return this.selected }).pluck('value') :
           this[0].value)
      }
    },
    offset: function(coordinates){
      if (coordinates) return this.each(function(index){
        var $this = $(this),
            coords = funcArg(this, coordinates, index, $this.offset()),
            parentOffset = $this.offsetParent().offset(),
            props = {
              top:  coords.top  - parentOffset.top,
              left: coords.left - parentOffset.left
            }

        if ($this.css('position') == 'static') props['position'] = 'relative'
        $this.css(props)
      })
      if (!this.length) return null
      if (document.documentElement !== this[0] && !$.contains(document.documentElement, this[0]))
        return {top: 0, left: 0}
      var obj = this[0].getBoundingClientRect()
      return {
        left: obj.left + window.pageXOffset,
        top: obj.top + window.pageYOffset,
        width: Math.round(obj.width),
        height: Math.round(obj.height)
      }
    },
    css: function(property, value){
      if (arguments.length < 2) {
        var element = this[0]
        if (typeof property == 'string') {
          if (!element) return
          return element.style[camelize(property)] || getComputedStyle(element, '').getPropertyValue(property)
        } else if (isArray(property)) {
          if (!element) return
          var props = {}
          var computedStyle = getComputedStyle(element, '')
          $.each(property, function(_, prop){
            props[prop] = (element.style[camelize(prop)] || computedStyle.getPropertyValue(prop))
          })
          return props
        }
      }

      var css = ''
      if (type(property) == 'string') {
        if (!value && value !== 0)
          this.each(function(){ this.style.removeProperty(dasherize(property)) })
        else
          css = dasherize(property) + ":" + maybeAddPx(property, value)
      } else {
        for (key in property)
          if (!property[key] && property[key] !== 0)
            this.each(function(){ this.style.removeProperty(dasherize(key)) })
          else
            css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';'
      }

      return this.each(function(){ this.style.cssText += ';' + css })
    },
    index: function(element){
      return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0])
    },
    hasClass: function(name){
      if (!name) return false
      return emptyArray.some.call(this, function(el){
        return this.test(className(el))
      }, classRE(name))
    },
    addClass: function(name){
      if (!name) return this
      return this.each(function(idx){
        if (!('className' in this)) return
        classList = []
        var cls = className(this), newName = funcArg(this, name, idx, cls)
        newName.split(/\s+/g).forEach(function(klass){
          if (!$(this).hasClass(klass)) classList.push(klass)
        }, this)
        classList.length && className(this, cls + (cls ? " " : "") + classList.join(" "))
      })
    },
    removeClass: function(name){
      return this.each(function(idx){
        if (!('className' in this)) return
        if (name === undefined) return className(this, '')
        classList = className(this)
        funcArg(this, name, idx, classList).split(/\s+/g).forEach(function(klass){
          classList = classList.replace(classRE(klass), " ")
        })
        className(this, classList.trim())
      })
    },
    toggleClass: function(name, when){
      if (!name) return this
      return this.each(function(idx){
        var $this = $(this), names = funcArg(this, name, idx, className(this))
        names.split(/\s+/g).forEach(function(klass){
          (when === undefined ? !$this.hasClass(klass) : when) ?
            $this.addClass(klass) : $this.removeClass(klass)
        })
      })
    },
    scrollTop: function(value){
      if (!this.length) return
      var hasScrollTop = 'scrollTop' in this[0]
      if (value === undefined) return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset
      return this.each(hasScrollTop ?
        function(){ this.scrollTop = value } :
        function(){ this.scrollTo(this.scrollX, value) })
    },
    scrollLeft: function(value){
      if (!this.length) return
      var hasScrollLeft = 'scrollLeft' in this[0]
      if (value === undefined) return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset
      return this.each(hasScrollLeft ?
        function(){ this.scrollLeft = value } :
        function(){ this.scrollTo(value, this.scrollY) })
    },
    position: function() {
      if (!this.length) return

      var elem = this[0],
        // Get *real* offsetParent
        offsetParent = this.offsetParent(),
        // Get correct offsets
        offset       = this.offset(),
        parentOffset = rootNodeRE.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset()

      // Subtract element margins
      // note: when an element has margin: auto the offsetLeft and marginLeft
      // are the same in Safari causing offset.left to incorrectly be 0
      offset.top  -= parseFloat( $(elem).css('margin-top') ) || 0
      offset.left -= parseFloat( $(elem).css('margin-left') ) || 0

      // Add offsetParent borders
      parentOffset.top  += parseFloat( $(offsetParent[0]).css('border-top-width') ) || 0
      parentOffset.left += parseFloat( $(offsetParent[0]).css('border-left-width') ) || 0

      // Subtract the two offsets
      return {
        top:  offset.top  - parentOffset.top,
        left: offset.left - parentOffset.left
      }
    },
    offsetParent: function() {
      return this.map(function(){
        var parent = this.offsetParent || document.body
        while (parent && !rootNodeRE.test(parent.nodeName) && $(parent).css("position") == "static")
          parent = parent.offsetParent
        return parent
      })
    }
  }

  // for now
  $.fn.detach = $.fn.remove

  // Generate the `width` and `height` functions
  ;['width', 'height'].forEach(function(dimension){
    var dimensionProperty =
      dimension.replace(/./, function(m){ return m[0].toUpperCase() })

    $.fn[dimension] = function(value){
      var offset, el = this[0]
      if (value === undefined) return isWindow(el) ? el['inner' + dimensionProperty] :
        isDocument(el) ? el.documentElement['scroll' + dimensionProperty] :
        (offset = this.offset()) && offset[dimension]
      else return this.each(function(idx){
        el = $(this)
        el.css(dimension, funcArg(this, value, idx, el[dimension]()))
      })
    }
  })

  function traverseNode(node, fun) {
    fun(node)
    for (var i = 0, len = node.childNodes.length; i < len; i++)
      traverseNode(node.childNodes[i], fun)
  }

  // Generate the `after`, `prepend`, `before`, `append`,
  // `insertAfter`, `insertBefore`, `appendTo`, and `prependTo` methods.
  adjacencyOperators.forEach(function(operator, operatorIndex) {
    var inside = operatorIndex % 2 //=> prepend, append

    $.fn[operator] = function(){
      // arguments can be nodes, arrays of nodes, Zepto objects and HTML strings
      var argType, nodes = $.map(arguments, function(arg) {
            var arr = []
            argType = type(arg)
            if (argType == "array") {
              arg.forEach(function(el) {
                if (el.nodeType !== undefined) return arr.push(el)
                else if ($.zepto.isZ(el)) return arr = arr.concat(el.get())
                arr = arr.concat(zepto.fragment(el))
              })
              return arr
            }
            return argType == "object" || arg == null ?
              arg : zepto.fragment(arg)
          }),
          parent, copyByClone = this.length > 1
      if (nodes.length < 1) return this

      return this.each(function(_, target){
        parent = inside ? target : target.parentNode

        // convert all methods to a "before" operation
        target = operatorIndex == 0 ? target.nextSibling :
                 operatorIndex == 1 ? target.firstChild :
                 operatorIndex == 2 ? target :
                 null

        var parentInDocument = $.contains(document.documentElement, parent)

        nodes.forEach(function(node){
          if (copyByClone) node = node.cloneNode(true)
          else if (!parent) return $(node).remove()

          parent.insertBefore(node, target)
          if (parentInDocument) traverseNode(node, function(el){
            if (el.nodeName != null && el.nodeName.toUpperCase() === 'SCRIPT' &&
               (!el.type || el.type === 'text/javascript') && !el.src){
              var target = el.ownerDocument ? el.ownerDocument.defaultView : window
              target['eval'].call(target, el.innerHTML)
            }
          })
        })
      })
    }

    // after    => insertAfter
    // prepend  => prependTo
    // before   => insertBefore
    // append   => appendTo
    $.fn[inside ? operator+'To' : 'insert'+(operatorIndex ? 'Before' : 'After')] = function(html){
      $(html)[operator](this)
      return this
    }
  })

  zepto.Z.prototype = Z.prototype = $.fn

  // Export internal API functions in the `$.zepto` namespace
  zepto.uniq = uniq
  zepto.deserializeValue = deserializeValue
  $.zepto = zepto

  return $
})()

window.Zepto = Zepto
window.$ === undefined && (window.$ = Zepto)
    module.exports = Zepto
    
;(function($){
  var _zid = 1, undefined,
      slice = Array.prototype.slice,
      isFunction = $.isFunction,
      isString = function(obj){ return typeof obj == 'string' },
      handlers = {},
      specialEvents={},
      focusinSupported = 'onfocusin' in window,
      focus = { focus: 'focusin', blur: 'focusout' },
      hover = { mouseenter: 'mouseover', mouseleave: 'mouseout' }

  specialEvents.click = specialEvents.mousedown = specialEvents.mouseup = specialEvents.mousemove = 'MouseEvents'

  function zid(element) {
    return element._zid || (element._zid = _zid++)
  }
  function findHandlers(element, event, fn, selector) {
    event = parse(event)
    if (event.ns) var matcher = matcherFor(event.ns)
    return (handlers[zid(element)] || []).filter(function(handler) {
      return handler
        && (!event.e  || handler.e == event.e)
        && (!event.ns || matcher.test(handler.ns))
        && (!fn       || zid(handler.fn) === zid(fn))
        && (!selector || handler.sel == selector)
    })
  }
  function parse(event) {
    var parts = ('' + event).split('.')
    return {e: parts[0], ns: parts.slice(1).sort().join(' ')}
  }
  function matcherFor(ns) {
    return new RegExp('(?:^| )' + ns.replace(' ', ' .* ?') + '(?: |$)')
  }

  function eventCapture(handler, captureSetting) {
    return handler.del &&
      (!focusinSupported && (handler.e in focus)) ||
      !!captureSetting
  }

  function realEvent(type) {
    return hover[type] || (focusinSupported && focus[type]) || type
  }

  function add(element, events, fn, data, selector, delegator, capture){
    var id = zid(element), set = (handlers[id] || (handlers[id] = []))
    events.split(/\s/).forEach(function(event){
      if (event == 'ready') return $(document).ready(fn)
      var handler   = parse(event)
      handler.fn    = fn
      handler.sel   = selector
      // emulate mouseenter, mouseleave
      if (handler.e in hover) fn = function(e){
        var related = e.relatedTarget
        if (!related || (related !== this && !$.contains(this, related)))
          return handler.fn.apply(this, arguments)
      }
      handler.del   = delegator
      var callback  = delegator || fn
      handler.proxy = function(e){
        e = compatible(e)
        if (e.isImmediatePropagationStopped()) return
        e.data = data
        var result = callback.apply(element, e._args == undefined ? [e] : [e].concat(e._args))
        if (result === false) e.preventDefault(), e.stopPropagation()
        return result
      }
      handler.i = set.length
      set.push(handler)
      if ('addEventListener' in element)
        element.addEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))
    })
  }
  function remove(element, events, fn, selector, capture){
    var id = zid(element)
    ;(events || '').split(/\s/).forEach(function(event){
      findHandlers(element, event, fn, selector).forEach(function(handler){
        delete handlers[id][handler.i]
      if ('removeEventListener' in element)
        element.removeEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))
      })
    })
  }

  $.event = { add: add, remove: remove }

  $.proxy = function(fn, context) {
    var args = (2 in arguments) && slice.call(arguments, 2)
    if (isFunction(fn)) {
      var proxyFn = function(){ return fn.apply(context, args ? args.concat(slice.call(arguments)) : arguments) }
      proxyFn._zid = zid(fn)
      return proxyFn
    } else if (isString(context)) {
      if (args) {
        args.unshift(fn[context], fn)
        return $.proxy.apply(null, args)
      } else {
        return $.proxy(fn[context], fn)
      }
    } else {
      throw new TypeError("expected function")
    }
  }

  $.fn.bind = function(event, data, callback){
    return this.on(event, data, callback)
  }
  $.fn.unbind = function(event, callback){
    return this.off(event, callback)
  }
  $.fn.one = function(event, selector, data, callback){
    return this.on(event, selector, data, callback, 1)
  }

  var returnTrue = function(){return true},
      returnFalse = function(){return false},
      ignoreProperties = /^([A-Z]|returnValue$|layer[XY]$|webkitMovement[XY]$)/,
      eventMethods = {
        preventDefault: 'isDefaultPrevented',
        stopImmediatePropagation: 'isImmediatePropagationStopped',
        stopPropagation: 'isPropagationStopped'
      }

  function compatible(event, source) {
    if (source || !event.isDefaultPrevented) {
      source || (source = event)

      $.each(eventMethods, function(name, predicate) {
        var sourceMethod = source[name]
        event[name] = function(){
          this[predicate] = returnTrue
          return sourceMethod && sourceMethod.apply(source, arguments)
        }
        event[predicate] = returnFalse
      })

      event.timeStamp || (event.timeStamp = Date.now())

      if (source.defaultPrevented !== undefined ? source.defaultPrevented :
          'returnValue' in source ? source.returnValue === false :
          source.getPreventDefault && source.getPreventDefault())
        event.isDefaultPrevented = returnTrue
    }
    return event
  }

  function createProxy(event) {
    var key, proxy = { originalEvent: event }
    for (key in event)
      if (!ignoreProperties.test(key) && event[key] !== undefined) proxy[key] = event[key]

    return compatible(proxy, event)
  }

  $.fn.delegate = function(selector, event, callback){
    return this.on(event, selector, callback)
  }
  $.fn.undelegate = function(selector, event, callback){
    return this.off(event, selector, callback)
  }

  $.fn.live = function(event, callback){
    $(document.body).delegate(this.selector, event, callback)
    return this
  }
  $.fn.die = function(event, callback){
    $(document.body).undelegate(this.selector, event, callback)
    return this
  }

  $.fn.on = function(event, selector, data, callback, one){
    var autoRemove, delegator, $this = this
    if (event && !isString(event)) {
      $.each(event, function(type, fn){
        $this.on(type, selector, data, fn, one)
      })
      return $this
    }

    if (!isString(selector) && !isFunction(callback) && callback !== false)
      callback = data, data = selector, selector = undefined
    if (callback === undefined || data === false)
      callback = data, data = undefined

    if (callback === false) callback = returnFalse

    return $this.each(function(_, element){
      if (one) autoRemove = function(e){
        remove(element, e.type, callback)
        return callback.apply(this, arguments)
      }

      if (selector) delegator = function(e){
        var evt, match = $(e.target).closest(selector, element).get(0)
        if (match && match !== element) {
          evt = $.extend(createProxy(e), {currentTarget: match, liveFired: element})
          return (autoRemove || callback).apply(match, [evt].concat(slice.call(arguments, 1)))
        }
      }

      add(element, event, callback, data, selector, delegator || autoRemove)
    })
  }
  $.fn.off = function(event, selector, callback){
    var $this = this
    if (event && !isString(event)) {
      $.each(event, function(type, fn){
        $this.off(type, selector, fn)
      })
      return $this
    }

    if (!isString(selector) && !isFunction(callback) && callback !== false)
      callback = selector, selector = undefined

    if (callback === false) callback = returnFalse

    return $this.each(function(){
      remove(this, event, callback, selector)
    })
  }

  $.fn.trigger = function(event, args){
    event = (isString(event) || $.isPlainObject(event)) ? $.Event(event) : compatible(event)
    event._args = args
    return this.each(function(){
      // handle focus(), blur() by calling them directly
      if (event.type in focus && typeof this[event.type] == "function") this[event.type]()
      // items in the collection might not be DOM elements
      else if ('dispatchEvent' in this) this.dispatchEvent(event)
      else $(this).triggerHandler(event, args)
    })
  }

  // triggers event handlers on current element just as if an event occurred,
  // doesn't trigger an actual event, doesn't bubble
  $.fn.triggerHandler = function(event, args){
    var e, result
    this.each(function(i, element){
      e = createProxy(isString(event) ? $.Event(event) : event)
      e._args = args
      e.target = element
      $.each(findHandlers(element, event.type || event), function(i, handler){
        result = handler.proxy(e)
        if (e.isImmediatePropagationStopped()) return false
      })
    })
    return result
  }

  // shortcut methods for `.bind(event, fn)` for each event type
  ;('focusin focusout focus blur load resize scroll unload click dblclick '+
  'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave '+
  'change select keydown keypress keyup error').split(' ').forEach(function(event) {
    $.fn[event] = function(callback) {
      return (0 in arguments) ?
        this.bind(event, callback) :
        this.trigger(event)
    }
  })

  $.Event = function(type, props) {
    if (!isString(type)) props = type, type = props.type
    var event = document.createEvent(specialEvents[type] || 'Events'), bubbles = true
    if (props) for (var name in props) (name == 'bubbles') ? (bubbles = !!props[name]) : (event[name] = props[name])
    event.initEvent(type, bubbles, true)
    return compatible(event)
  }

})(Zepto)

;(function($){
  var jsonpID = +new Date(),
      document = window.document,
      key,
      name,
      rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
      scriptTypeRE = /^(?:text|application)\/javascript/i,
      xmlTypeRE = /^(?:text|application)\/xml/i,
      jsonType = 'application/json',
      htmlType = 'text/html',
      blankRE = /^\s*$/,
      originAnchor = document.createElement('a')

  originAnchor.href = window.location.href

  // trigger a custom event and return false if it was cancelled
  function triggerAndReturn(context, eventName, data) {
    var event = $.Event(eventName)
    $(context).trigger(event, data)
    return !event.isDefaultPrevented()
  }

  // trigger an Ajax "global" event
  function triggerGlobal(settings, context, eventName, data) {
    if (settings.global) return triggerAndReturn(context || document, eventName, data)
  }

  // Number of active Ajax requests
  $.active = 0

  function ajaxStart(settings) {
    if (settings.global && $.active++ === 0) triggerGlobal(settings, null, 'ajaxStart')
  }
  function ajaxStop(settings) {
    if (settings.global && !(--$.active)) triggerGlobal(settings, null, 'ajaxStop')
  }

  // triggers an extra global event "ajaxBeforeSend" that's like "ajaxSend" but cancelable
  function ajaxBeforeSend(xhr, settings) {
    var context = settings.context
    if (settings.beforeSend.call(context, xhr, settings) === false ||
        triggerGlobal(settings, context, 'ajaxBeforeSend', [xhr, settings]) === false)
      return false

    triggerGlobal(settings, context, 'ajaxSend', [xhr, settings])
  }
  function ajaxSuccess(data, xhr, settings, deferred) {
    var context = settings.context, status = 'success'
    settings.success.call(context, data, status, xhr)
    if (deferred) deferred.resolveWith(context, [data, status, xhr])
    triggerGlobal(settings, context, 'ajaxSuccess', [xhr, settings, data])
    ajaxComplete(status, xhr, settings)
  }
  // type: "timeout", "error", "abort", "parsererror"
  function ajaxError(error, type, xhr, settings, deferred) {
    var context = settings.context
    settings.error.call(context, xhr, type, error)
    if (deferred) deferred.rejectWith(context, [xhr, type, error])
    triggerGlobal(settings, context, 'ajaxError', [xhr, settings, error || type])
    ajaxComplete(type, xhr, settings)
  }
  // status: "success", "notmodified", "error", "timeout", "abort", "parsererror"
  function ajaxComplete(status, xhr, settings) {
    var context = settings.context
    settings.complete.call(context, xhr, status)
    triggerGlobal(settings, context, 'ajaxComplete', [xhr, settings])
    ajaxStop(settings)
  }

  function ajaxDataFilter(data, type, settings) {
    if (settings.dataFilter == empty) return data
    var context = settings.context
    return settings.dataFilter.call(context, data, type)
  }

  // Empty function, used as default callback
  function empty() {}

  $.ajaxJSONP = function(options, deferred){
    if (!('type' in options)) return $.ajax(options)

    var _callbackName = options.jsonpCallback,
      callbackName = ($.isFunction(_callbackName) ?
        _callbackName() : _callbackName) || ('Zepto' + (jsonpID++)),
      script = document.createElement('script'),
      originalCallback = window[callbackName],
      responseData,
      abort = function(errorType) {
        $(script).triggerHandler('error', errorType || 'abort')
      },
      xhr = { abort: abort }, abortTimeout

    if (deferred) deferred.promise(xhr)

    $(script).on('load error', function(e, errorType){
      clearTimeout(abortTimeout)
      $(script).off().remove()

      if (e.type == 'error' || !responseData) {
        ajaxError(null, errorType || 'error', xhr, options, deferred)
      } else {
        ajaxSuccess(responseData[0], xhr, options, deferred)
      }

      window[callbackName] = originalCallback
      if (responseData && $.isFunction(originalCallback))
        originalCallback(responseData[0])

      originalCallback = responseData = undefined
    })

    if (ajaxBeforeSend(xhr, options) === false) {
      abort('abort')
      return xhr
    }

    window[callbackName] = function(){
      responseData = arguments
    }

    script.src = options.url.replace(/\?(.+)=\?/, '?$1=' + callbackName)
    document.head.appendChild(script)

    if (options.timeout > 0) abortTimeout = setTimeout(function(){
      abort('timeout')
    }, options.timeout)

    return xhr
  }

  $.ajaxSettings = {
    // Default type of request
    type: 'GET',
    // Callback that is executed before request
    beforeSend: empty,
    // Callback that is executed if the request succeeds
    success: empty,
    // Callback that is executed the the server drops error
    error: empty,
    // Callback that is executed on request complete (both: error and success)
    complete: empty,
    // The context for the callbacks
    context: null,
    // Whether to trigger "global" Ajax events
    global: true,
    // Transport
    xhr: function () {
      return new window.XMLHttpRequest()
    },
    // MIME types mapping
    // IIS returns Javascript as "application/x-javascript"
    accepts: {
      script: 'text/javascript, application/javascript, application/x-javascript',
      json:   jsonType,
      xml:    'application/xml, text/xml',
      html:   htmlType,
      text:   'text/plain'
    },
    // Whether the request is to another domain
    crossDomain: false,
    // Default timeout
    timeout: 0,
    // Whether data should be serialized to string
    processData: true,
    // Whether the browser should be allowed to cache GET responses
    cache: true,
    //Used to handle the raw response data of XMLHttpRequest.
    //This is a pre-filtering function to sanitize the response.
    //The sanitized response should be returned
    dataFilter: empty
  }

  function mimeToDataType(mime) {
    if (mime) mime = mime.split(';', 2)[0]
    return mime && ( mime == htmlType ? 'html' :
      mime == jsonType ? 'json' :
      scriptTypeRE.test(mime) ? 'script' :
      xmlTypeRE.test(mime) && 'xml' ) || 'text'
  }

  function appendQuery(url, query) {
    if (query == '') return url
    return (url + '&' + query).replace(/[&?]{1,2}/, '?')
  }

  // serialize payload and append it to the URL for GET requests
  function serializeData(options) {
    if (options.processData && options.data && $.type(options.data) != "string")
      options.data = $.param(options.data, options.traditional)
    if (options.data && (!options.type || options.type.toUpperCase() == 'GET' || 'jsonp' == options.dataType))
      options.url = appendQuery(options.url, options.data), options.data = undefined
  }

  $.ajax = function(options){
    var settings = $.extend({}, options || {}),
        deferred = $.Deferred && $.Deferred(),
        urlAnchor, hashIndex
    for (key in $.ajaxSettings) if (settings[key] === undefined) settings[key] = $.ajaxSettings[key]

    ajaxStart(settings)

    if (!settings.crossDomain) {
      urlAnchor = document.createElement('a')
      urlAnchor.href = settings.url
      // cleans up URL for .href (IE only), see https://github.com/madrobby/zepto/pull/1049
      urlAnchor.href = urlAnchor.href
      settings.crossDomain = (originAnchor.protocol + '//' + originAnchor.host) !== (urlAnchor.protocol + '//' + urlAnchor.host)
    }

    if (!settings.url) settings.url = window.location.toString()
    if ((hashIndex = settings.url.indexOf('#')) > -1) settings.url = settings.url.slice(0, hashIndex)
    serializeData(settings)

    var dataType = settings.dataType, hasPlaceholder = /\?.+=\?/.test(settings.url)
    if (hasPlaceholder) dataType = 'jsonp'

    if (settings.cache === false || (
         (!options || options.cache !== true) &&
         ('script' == dataType || 'jsonp' == dataType)
        ))
      settings.url = appendQuery(settings.url, '_=' + Date.now())

    if ('jsonp' == dataType) {
      if (!hasPlaceholder)
        settings.url = appendQuery(settings.url,
          settings.jsonp ? (settings.jsonp + '=?') : settings.jsonp === false ? '' : 'callback=?')
      return $.ajaxJSONP(settings, deferred)
    }

    var mime = settings.accepts[dataType],
        headers = { },
        setHeader = function(name, value) { headers[name.toLowerCase()] = [name, value] },
        protocol = /^([\w-]+:)\/\//.test(settings.url) ? RegExp.$1 : window.location.protocol,
        xhr = settings.xhr(),
        nativeSetHeader = xhr.setRequestHeader,
        abortTimeout

    if (deferred) deferred.promise(xhr)

    if (!settings.crossDomain) setHeader('X-Requested-With', 'XMLHttpRequest')
    setHeader('Accept', mime || '*/*')
    if (mime = settings.mimeType || mime) {
      if (mime.indexOf(',') > -1) mime = mime.split(',', 2)[0]
      xhr.overrideMimeType && xhr.overrideMimeType(mime)
    }
    if (settings.contentType || (settings.contentType !== false && settings.data && settings.type.toUpperCase() != 'GET'))
      setHeader('Content-Type', settings.contentType || 'application/x-www-form-urlencoded')

    if (settings.headers) for (name in settings.headers) setHeader(name, settings.headers[name])
    xhr.setRequestHeader = setHeader

    xhr.onreadystatechange = function(){
      if (xhr.readyState == 4) {
        xhr.onreadystatechange = empty
        clearTimeout(abortTimeout)
        var result, error = false
        if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304 || (xhr.status == 0 && protocol == 'file:')) {
          dataType = dataType || mimeToDataType(settings.mimeType || xhr.getResponseHeader('content-type'))

          if (xhr.responseType == 'arraybuffer' || xhr.responseType == 'blob')
            result = xhr.response
          else {
            result = xhr.responseText

            try {
              // http://perfectionkills.com/global-eval-what-are-the-options/
              // sanitize response accordingly if data filter callback provided
              result = ajaxDataFilter(result, dataType, settings)
              if (dataType == 'script')    (1,eval)(result)
              else if (dataType == 'xml')  result = xhr.responseXML
              else if (dataType == 'json') result = blankRE.test(result) ? null : $.parseJSON(result)
            } catch (e) { error = e }

            if (error) return ajaxError(error, 'parsererror', xhr, settings, deferred)
          }

          ajaxSuccess(result, xhr, settings, deferred)
        } else {
          ajaxError(xhr.statusText || null, xhr.status ? 'error' : 'abort', xhr, settings, deferred)
        }
      }
    }

    if (ajaxBeforeSend(xhr, settings) === false) {
      xhr.abort()
      ajaxError(null, 'abort', xhr, settings, deferred)
      return xhr
    }

    var async = 'async' in settings ? settings.async : true
    xhr.open(settings.type, settings.url, async, settings.username, settings.password)

    if (settings.xhrFields) for (name in settings.xhrFields) xhr[name] = settings.xhrFields[name]

    for (name in headers) nativeSetHeader.apply(xhr, headers[name])

    if (settings.timeout > 0) abortTimeout = setTimeout(function(){
        xhr.onreadystatechange = empty
        xhr.abort()
        ajaxError(null, 'timeout', xhr, settings, deferred)
      }, settings.timeout)

    // avoid sending empty string (#319)
    xhr.send(settings.data ? settings.data : null)
    return xhr
  }

  // handle optional data/success arguments
  function parseArguments(url, data, success, dataType) {
    if ($.isFunction(data)) dataType = success, success = data, data = undefined
    if (!$.isFunction(success)) dataType = success, success = undefined
    return {
      url: url
    , data: data
    , success: success
    , dataType: dataType
    }
  }

  $.get = function(/* url, data, success, dataType */){
    return $.ajax(parseArguments.apply(null, arguments))
  }

  $.post = function(/* url, data, success, dataType */){
    var options = parseArguments.apply(null, arguments)
    options.type = 'POST'
    return $.ajax(options)
  }

  $.getJSON = function(/* url, data, success */){
    var options = parseArguments.apply(null, arguments)
    options.dataType = 'json'
    return $.ajax(options)
  }

  $.fn.load = function(url, data, success){
    if (!this.length) return this
    var self = this, parts = url.split(/\s/), selector,
        options = parseArguments(url, data, success),
        callback = options.success
    if (parts.length > 1) options.url = parts[0], selector = parts[1]
    options.success = function(response){
      self.html(selector ?
        $('<div>').html(response.replace(rscript, "")).find(selector)
        : response)
      callback && callback.apply(self, arguments)
    }
    $.ajax(options)
    return this
  }

  var escape = encodeURIComponent

  function serialize(params, obj, traditional, scope){
    var type, array = $.isArray(obj), hash = $.isPlainObject(obj)
    $.each(obj, function(key, value) {
      type = $.type(value)
      if (scope) key = traditional ? scope :
        scope + '[' + (hash || type == 'object' || type == 'array' ? key : '') + ']'
      // handle data in serializeArray() format
      if (!scope && array) params.add(value.name, value.value)
      // recurse into nested objects
      else if (type == "array" || (!traditional && type == "object"))
        serialize(params, value, traditional, key)
      else params.add(key, value)
    })
  }

  $.param = function(obj, traditional){
    var params = []
    params.add = function(key, value) {
      if ($.isFunction(value)) value = value()
      if (value == null) value = ""
      this.push(escape(key) + '=' + escape(value))
    }
    serialize(params, obj, traditional)
    return params.join('&').replace(/%20/g, '+')
  }
})(Zepto)

;(function($){
  $.fn.serializeArray = function() {
    var name, type, result = [],
      add = function(value) {
        if (value.forEach) return value.forEach(add)
        result.push({ name: name, value: value })
      }
    if (this[0]) $.each(this[0].elements, function(_, field){
      type = field.type, name = field.name
      if (name && field.nodeName.toLowerCase() != 'fieldset' &&
        !field.disabled && type != 'submit' && type != 'reset' && type != 'button' && type != 'file' &&
        ((type != 'radio' && type != 'checkbox') || field.checked))
          add($(field).val())
    })
    return result
  }

  $.fn.serialize = function(){
    var result = []
    this.serializeArray().forEach(function(elm){
      result.push(encodeURIComponent(elm.name) + '=' + encodeURIComponent(elm.value))
    })
    return result.join('&')
  }

  $.fn.submit = function(callback) {
    if (0 in arguments) this.bind('submit', callback)
    else if (this.length) {
      var event = $.Event('submit')
      this.eq(0).trigger(event)
      if (!event.isDefaultPrevented()) this.get(0).submit()
    }
    return this
  }

})(Zepto)

;(function(){
  // getComputedStyle shouldn't freak out when called
  // without a valid element as argument
  try {
    getComputedStyle(undefined)
  } catch(e) {
    var nativeGetComputedStyle = getComputedStyle
    window.getComputedStyle = function(element, pseudoElement){
      try {
        return nativeGetComputedStyle(element, pseudoElement)
      } catch(e) {
        return null
      }
    }
  }
})()
  return Zepto
}))


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
// import adapter from 'webrtc-adapter';
// console.error("webrtc-adapter load");

var adapter = emedia.singleWebrtcAdapter;

function warn() {
    emedia.util.logger.warn("webrtc-adapter must load once. if more, safari may initC sdp error(too many audio video, easemob server dont work)");
}

function requireWebrtcAdapter() {
    if (!!document.documentMode) {
        // Detect IE (6-11)
        var hasMatch = /\brv[ :]+(\d+)/g.exec(navigator.userAgent) || [];

        var webrtcDetectedBrowser = 'IE';
        var webrtcDetectedVersion = parseInt(hasMatch[1], 10);
        var webrtcMinimumVersion = 9;
        var webrtcDetectedType = 'plugin';
        var webrtcDetectedDCSupport = 'SCTP';

        if (!webrtcDetectedVersion) {
            hasMatch = /\bMSIE[ :]+(\d+)/g.exec(navigator.userAgent) || [];

            webrtcDetectedVersion = parseInt(hasMatch[1] || '0', 10);
        }

        //adapter = require('./adapter.ie');
        emedia.util.logger.error("adapter.ie not required");

        adapter.__browser = webrtcDetectedBrowser;
        adapter.__browserVersion = webrtcDetectedVersion;

        //adapter = require('./Temasys.wrapper'); //6.0.3
    } else {
        //adapter = require('./adapter-6.2.0'); //6.2.0
        //adapter = require('webrtc-adapter').default; //webim demo minify 时 util报错
        adapter = __webpack_require__(148);
        emedia.util.logger.info("webrtc-adapter load first");

        wrapAttachMediaStream();
    }

    emedia.singleWebrtcAdapter = adapter;
}

warn();
if (!adapter) {
    requireWebrtcAdapter();
} else {
    emedia.util.logger.error("webrtc-adapter repeated load, safari may dont work");
}

adapter.__browser = adapter.__browser || adapter.browserDetails.browser; // firefox chrome safari
adapter.__browserVersion = adapter.__browserVersion || adapter.browserDetails.version;

emedia.util.logger.info("Current browser", adapter.__browser, adapter.__browserVersion);

if ("Not a supported browser." === adapter.__browser) {
    emedia.util.logger.error("Not a supported browser");
}

//module.exports = adapter;
exports.default = adapter;


function wrapAttachMediaStream() {
    function _attachMediaStream(element, stream) {
        element.srcObject = stream;

        if (emedia.isSafari) {
            // var hasActivedTrack = false;
            // stream.getVideoTracks().forEach((track)=>{
            //     if(!hasActivedTrack){
            //         hasActivedTrack = track.enabled;
            //     }
            // });
            //
            // if(!hasActivedTrack){
            //     element.pause();
            //     element.play();
            // }

            element.pause();
            element.play();
        }

        var logger = emedia.util.logger || window.console || console;

        if (logger) {
            stream && logger.info("stream attach videoTag.", stream.id, stream._located, ">>", element.id, element.muted, element.volume, element);
            stream || logger.info("stream(null) attach videoTag.", element.id, element.muted, element.volume, element);

            if (!element.hxSetOnvolumechange) {
                var preonvolumechange = element.onvolumechange;
                element.onvolumechange = function () {
                    logger.debug("stream attach detail: video tag volume chanage", element.volume, stream ? stream.id : stream);
                    preonvolumechange && preonvolumechange.apply(element, arguments);
                };
                element.hxSetOnvolumechange = true;
            }

            if (!element.hxSetOnstalled) {
                var preonstalled = element.onstalled;
                element.onstalled = function () {
                    logger.debug("stream attach detail: video tag onstalled", stream ? stream.id : stream);
                    preonstalled && preonstalled.apply(element, arguments);
                };
                element.hxSetOnstalled = true;
            }

            if (!element.hxSetOnabort) {
                var preonabort = element.onabort;
                element.onabort = function () {
                    logger.debug("stream attach detail: video tag onabort", stream ? stream.id : stream);
                    preonabort && preonabort.apply(element, arguments);
                };
                element.hxSetOnabort = true;
            }

            if (!element.hxSetOncanplay) {
                var preOncanplay = element.oncanplay;
                element.oncanplay = function () {
                    stream && stream.getTracks().forEach(function (track) {
                        if (typeof track.getSettings === 'function') {
                            logger.debug('stream attach detail', stream.id, " track setting =", track.enabled, track.id, track.kind, track.label, track.getSettings());
                        }
                    });

                    logger.debug("stream attach detail: video tag", element.videoWidth, "x", element.videoHeight, stream ? stream.id : stream);

                    preOncanplay && preOncanplay.apply(element, arguments);
                };
                element.hxSetOncanplay = true;
            }
        }
    }

    /**
     * muted undefined, stream _located true 时muted
     *
     * @param element
     * @param stream
     * @param muted
     * @returns {*}
     */
    function hxbAttachMediaStream(element, stream, muted, _fun) {
        function mute() {
            muted = !!(muted === undefined ? stream._located : muted);

            //为了解决某些手机mute造成本地图像卡的问题
            element.muted = false;
            if (muted !== element.muted) {
                element.muted = true;
            }
        }

        _fun || (_fun = window.__attachMediaStream) || (_fun = _attachMediaStream.bind(this));

        if (!element) {
            return;
        }

        if (!stream) {
            _fun(element, stream);
            return;
        }

        if (!element.srcObject) {
            mute();
            _fun(element, stream);
            return element;
        }

        if (element.srcObject._located //old stream 也是 _located
        && stream._located && element.srcObject.id === stream.id) {
            return element.srcObject;
        }

        mute();
        _fun(element, stream);

        return element;
    }

    if (window.attachMediaStream && window.attachMediaStream._wrapped !== true) {
        window.__attachMediaStream = window.attachMediaStream;
    }

    window.attachMediaStream = hxbAttachMediaStream;
    window.attachMediaStream._wrapped = true;
    console && typeof console.info === "function" && console.info("Wrap the attachMediaStream ", adapter.__browser, adapter.__browserVersion);
}

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;var require;

var _assign = __webpack_require__(149);

var _assign2 = _interopRequireDefault2(_assign);

var _stringify = __webpack_require__(144);

var _stringify2 = _interopRequireDefault2(_stringify);

var _getOwnPropertyDescriptor = __webpack_require__(153);

var _getOwnPropertyDescriptor2 = _interopRequireDefault2(_getOwnPropertyDescriptor);

var _promise = __webpack_require__(156);

var _promise2 = _interopRequireDefault2(_promise);

var _keys = __webpack_require__(178);

var _keys2 = _interopRequireDefault2(_keys);

var _map = __webpack_require__(181);

var _map2 = _interopRequireDefault2(_map);

var _defineProperty2 = __webpack_require__(197);

var _defineProperty3 = _interopRequireDefault2(_defineProperty2);

var _iterator = __webpack_require__(74);

var _iterator2 = _interopRequireDefault2(_iterator);

var _symbol = __webpack_require__(125);

var _symbol2 = _interopRequireDefault2(_symbol);

var _typeof3 = __webpack_require__(73);

var _typeof4 = _interopRequireDefault2(_typeof3);

function _interopRequireDefault2(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(function (f) {
  if (( false ? undefined : (0, _typeof4.default)(exports)) === "object" && typeof module !== "undefined") {
    module.exports = f();
  } else if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var g; }
})(function () {
  var define, module, exports;return function () {
    function r(e, n, t) {
      function o(i, f) {
        if (!n[i]) {
          if (!e[i]) {
            var c = "function" == typeof require && require;if (!f && c) return require(i, !0);if (u) return u(i, !0);var a = new Error("Cannot find module '" + i + "'");throw a.code = "MODULE_NOT_FOUND", a;
          }var p = n[i] = { exports: {} };e[i][0].call(p.exports, function (r) {
            var n = e[i][1][r];return o(n || r);
          }, p, p.exports, r, e, n, t);
        }return n[i].exports;
      }for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) {
        o(t[i]);
      }return o;
    }return r;
  }()({ 1: [function (require, module, exports) {
      /*
       *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
       *
       *  Use of this source code is governed by a BSD-style license
       *  that can be found in the LICENSE file in the root of the source
       *  tree.
       */
      /* eslint-env node */

      'use strict';

      console.warn("webrtc adapter version: 7.6.1");

      var _adapter_factory = require('./adapter_factory.js');

      var adapter = (0, _adapter_factory.adapterFactory)({ window: window });
      module.exports = adapter; // this is the difference from adapter_core.
    }, { "./adapter_factory.js": 2 }], 2: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.adapterFactory = adapterFactory;

      var _utils = require('./utils');

      var utils = _interopRequireWildcard(_utils);

      var _chrome_shim = require('./chrome/chrome_shim');

      var chromeShim = _interopRequireWildcard(_chrome_shim);

      var _edge_shim = require('./edge/edge_shim');

      var edgeShim = _interopRequireWildcard(_edge_shim);

      var _firefox_shim = require('./firefox/firefox_shim');

      var firefoxShim = _interopRequireWildcard(_firefox_shim);

      var _safari_shim = require('./safari/safari_shim');

      var safariShim = _interopRequireWildcard(_safari_shim);

      var _common_shim = require('./common_shim');

      var commonShim = _interopRequireWildcard(_common_shim);

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }newObj.default = obj;return newObj;
        }
      }

      // Shimming starts here.
      /*
       *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
       *
       *  Use of this source code is governed by a BSD-style license
       *  that can be found in the LICENSE file in the root of the source
       *  tree.
       */
      function adapterFactory() {
        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            window = _ref.window;

        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
          shimChrome: true,
          shimFirefox: true,
          shimEdge: true,
          shimSafari: true
        };

        // Utils.
        var logging = utils.log;
        var browserDetails = utils.detectBrowser(window);

        var adapter = {
          browserDetails: browserDetails,
          commonShim: commonShim,
          extractVersion: utils.extractVersion,
          disableLog: utils.disableLog,
          disableWarnings: utils.disableWarnings
        };

        // Shim browser if found.
        switch (browserDetails.browser) {
          case 'chrome':
            if (!chromeShim || !chromeShim.shimPeerConnection || !options.shimChrome) {
              logging('Chrome shim is not included in this adapter release.');
              return adapter;
            }
            if (browserDetails.version === null) {
              logging('Chrome shim can not determine version, not shimming.');
              return adapter;
            }
            logging('adapter.js shimming chrome.');
            // Export to the adapter global object visible in the browser.
            adapter.browserShim = chromeShim;

            chromeShim.shimGetUserMedia(window);
            chromeShim.shimMediaStream(window);
            chromeShim.shimPeerConnection(window);
            chromeShim.shimOnTrack(window);
            chromeShim.shimAddTrackRemoveTrack(window);
            chromeShim.shimGetSendersWithDtmf(window);
            chromeShim.shimGetStats(window);
            chromeShim.shimSenderReceiverGetStats(window);
            chromeShim.fixNegotiationNeeded(window);

            commonShim.shimRTCIceCandidate(window);
            commonShim.shimConnectionState(window);
            commonShim.shimMaxMessageSize(window);
            commonShim.shimSendThrowTypeError(window);
            commonShim.removeAllowExtmapMixed(window);
            break;
          case 'firefox':
            if (!firefoxShim || !firefoxShim.shimPeerConnection || !options.shimFirefox) {
              logging('Firefox shim is not included in this adapter release.');
              return adapter;
            }
            logging('adapter.js shimming firefox.');
            // Export to the adapter global object visible in the browser.
            adapter.browserShim = firefoxShim;

            firefoxShim.shimGetUserMedia(window);
            firefoxShim.shimPeerConnection(window);
            firefoxShim.shimOnTrack(window);
            firefoxShim.shimRemoveStream(window);
            firefoxShim.shimSenderGetStats(window);
            firefoxShim.shimReceiverGetStats(window);
            firefoxShim.shimRTCDataChannel(window);
            firefoxShim.shimAddTransceiver(window);
            firefoxShim.shimCreateOffer(window);
            firefoxShim.shimCreateAnswer(window);

            commonShim.shimRTCIceCandidate(window);
            commonShim.shimConnectionState(window);
            commonShim.shimMaxMessageSize(window);
            commonShim.shimSendThrowTypeError(window);
            break;
          case 'edge':
            if (!edgeShim || !edgeShim.shimPeerConnection || !options.shimEdge) {
              logging('MS edge shim is not included in this adapter release.');
              return adapter;
            }
            logging('adapter.js shimming edge.');
            // Export to the adapter global object visible in the browser.
            adapter.browserShim = edgeShim;

            edgeShim.shimGetUserMedia(window);
            edgeShim.shimGetDisplayMedia(window);
            edgeShim.shimPeerConnection(window);
            edgeShim.shimReplaceTrack(window);

            // the edge shim implements the full RTCIceCandidate object.

            commonShim.shimMaxMessageSize(window);
            commonShim.shimSendThrowTypeError(window);
            break;
          case 'safari':
            if (!safariShim || !options.shimSafari) {
              logging('Safari shim is not included in this adapter release.');
              return adapter;
            }
            logging('adapter.js shimming safari.');
            // Export to the adapter global object visible in the browser.
            adapter.browserShim = safariShim;

            safariShim.shimRTCIceServerUrls(window);
            safariShim.shimCreateOfferLegacy(window);
            safariShim.shimCallbacksAPI(window);
            safariShim.shimLocalStreamsAPI(window);
            safariShim.shimRemoteStreamsAPI(window);
            safariShim.shimTrackEventTransceiver(window);
            safariShim.shimGetUserMedia(window);
            safariShim.shimAudioContext(window);

            commonShim.shimRTCIceCandidate(window);
            commonShim.shimMaxMessageSize(window);
            commonShim.shimSendThrowTypeError(window);
            commonShim.removeAllowExtmapMixed(window);
            break;
          default:
            logging('Unsupported browser!');
            break;
        }

        return adapter;
      }

      // Browser shims.
    }, { "./chrome/chrome_shim": 3, "./common_shim": 6, "./edge/edge_shim": 7, "./firefox/firefox_shim": 11, "./safari/safari_shim": 14, "./utils": 15 }], 3: [function (require, module, exports) {
      /*
       *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
       *
       *  Use of this source code is governed by a BSD-style license
       *  that can be found in the LICENSE file in the root of the source
       *  tree.
       */
      /* eslint-env node */
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.shimGetDisplayMedia = exports.shimGetUserMedia = undefined;

      var _typeof = typeof _symbol2.default === "function" && (0, _typeof4.default)(_iterator2.default) === "symbol" ? function (obj) {
        return typeof obj === "undefined" ? "undefined" : (0, _typeof4.default)(obj);
      } : function (obj) {
        return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : (0, _typeof4.default)(obj);
      };

      var _getusermedia = require('./getusermedia');

      Object.defineProperty(exports, 'shimGetUserMedia', {
        enumerable: true,
        get: function get() {
          return _getusermedia.shimGetUserMedia;
        }
      });

      var _getdisplaymedia = require('./getdisplaymedia');

      Object.defineProperty(exports, 'shimGetDisplayMedia', {
        enumerable: true,
        get: function get() {
          return _getdisplaymedia.shimGetDisplayMedia;
        }
      });
      exports.shimMediaStream = shimMediaStream;
      exports.shimOnTrack = shimOnTrack;
      exports.shimGetSendersWithDtmf = shimGetSendersWithDtmf;
      exports.shimGetStats = shimGetStats;
      exports.shimSenderReceiverGetStats = shimSenderReceiverGetStats;
      exports.shimAddTrackRemoveTrackWithNative = shimAddTrackRemoveTrackWithNative;
      exports.shimAddTrackRemoveTrack = shimAddTrackRemoveTrack;
      exports.shimPeerConnection = shimPeerConnection;
      exports.fixNegotiationNeeded = fixNegotiationNeeded;

      var _utils = require('../utils.js');

      var utils = _interopRequireWildcard(_utils);

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }newObj.default = obj;return newObj;
        }
      }

      function _defineProperty(obj, key, value) {
        if (key in obj) {
          (0, _defineProperty3.default)(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }return obj;
      }

      function shimMediaStream(window) {
        window.MediaStream = window.MediaStream || window.webkitMediaStream;
      }

      function shimOnTrack(window) {
        if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && !('ontrack' in window.RTCPeerConnection.prototype)) {
          Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
            get: function get() {
              return this._ontrack;
            },
            set: function set(f) {
              if (this._ontrack) {
                this.removeEventListener('track', this._ontrack);
              }
              this.addEventListener('track', this._ontrack = f);
            },

            enumerable: true,
            configurable: true
          });
          var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
          window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
            var _this = this;

            if (!this._ontrackpoly) {
              this._ontrackpoly = function (e) {
                // onaddstream does not fire when a track is added to an existing
                // stream. But stream.onaddtrack is implemented so we use that.
                e.stream.addEventListener('addtrack', function (te) {
                  var receiver = void 0;
                  if (window.RTCPeerConnection.prototype.getReceivers) {
                    receiver = _this.getReceivers().find(function (r) {
                      return r.track && r.track.id === te.track.id;
                    });
                  } else {
                    receiver = { track: te.track };
                  }

                  var event = new Event('track');
                  event.track = te.track;
                  event.receiver = receiver;
                  event.transceiver = { receiver: receiver };
                  event.streams = [e.stream];
                  _this.dispatchEvent(event);
                });
                e.stream.getTracks().forEach(function (track) {
                  var receiver = void 0;
                  if (window.RTCPeerConnection.prototype.getReceivers) {
                    receiver = _this.getReceivers().find(function (r) {
                      return r.track && r.track.id === track.id;
                    });
                  } else {
                    receiver = { track: track };
                  }
                  var event = new Event('track');
                  event.track = track;
                  event.receiver = receiver;
                  event.transceiver = { receiver: receiver };
                  event.streams = [e.stream];
                  _this.dispatchEvent(event);
                });
              };
              this.addEventListener('addstream', this._ontrackpoly);
            }
            return origSetRemoteDescription.apply(this, arguments);
          };
        } else {
          // even if RTCRtpTransceiver is in window, it is only used and
          // emitted in unified-plan. Unfortunately this means we need
          // to unconditionally wrap the event.
          utils.wrapPeerConnectionEvent(window, 'track', function (e) {
            if (!e.transceiver) {
              Object.defineProperty(e, 'transceiver', { value: { receiver: e.receiver } });
            }
            return e;
          });
        }
      }

      function shimGetSendersWithDtmf(window) {
        // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.
        if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && !('getSenders' in window.RTCPeerConnection.prototype) && 'createDTMFSender' in window.RTCPeerConnection.prototype) {
          var shimSenderWithDtmf = function shimSenderWithDtmf(pc, track) {
            return {
              track: track,
              get dtmf() {
                if (this._dtmf === undefined) {
                  if (track.kind === 'audio') {
                    this._dtmf = pc.createDTMFSender(track);
                  } else {
                    this._dtmf = null;
                  }
                }
                return this._dtmf;
              },
              _pc: pc
            };
          };

          // augment addTrack when getSenders is not available.
          if (!window.RTCPeerConnection.prototype.getSenders) {
            window.RTCPeerConnection.prototype.getSenders = function getSenders() {
              this._senders = this._senders || [];
              return this._senders.slice(); // return a copy of the internal state.
            };
            var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
            window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
              var sender = origAddTrack.apply(this, arguments);
              if (!sender) {
                sender = shimSenderWithDtmf(this, track);
                this._senders.push(sender);
              }
              return sender;
            };

            var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
            window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
              origRemoveTrack.apply(this, arguments);
              var idx = this._senders.indexOf(sender);
              if (idx !== -1) {
                this._senders.splice(idx, 1);
              }
            };
          }
          var origAddStream = window.RTCPeerConnection.prototype.addStream;
          window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
            var _this2 = this;

            this._senders = this._senders || [];
            origAddStream.apply(this, [stream]);
            stream.getTracks().forEach(function (track) {
              _this2._senders.push(shimSenderWithDtmf(_this2, track));
            });
          };

          var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
          window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
            var _this3 = this;

            this._senders = this._senders || [];
            origRemoveStream.apply(this, [stream]);

            stream.getTracks().forEach(function (track) {
              var sender = _this3._senders.find(function (s) {
                return s.track === track;
              });
              if (sender) {
                // remove sender
                _this3._senders.splice(_this3._senders.indexOf(sender), 1);
              }
            });
          };
        } else if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && 'getSenders' in window.RTCPeerConnection.prototype && 'createDTMFSender' in window.RTCPeerConnection.prototype && window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {
          var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
          window.RTCPeerConnection.prototype.getSenders = function getSenders() {
            var _this4 = this;

            var senders = origGetSenders.apply(this, []);
            senders.forEach(function (sender) {
              return sender._pc = _this4;
            });
            return senders;
          };

          Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
            get: function get() {
              if (this._dtmf === undefined) {
                if (this.track.kind === 'audio') {
                  this._dtmf = this._pc.createDTMFSender(this.track);
                } else {
                  this._dtmf = null;
                }
              }
              return this._dtmf;
            }
          });
        }
      }

      function shimGetStats(window) {
        if (!window.RTCPeerConnection) {
          return;
        }

        var origGetStats = window.RTCPeerConnection.prototype.getStats;
        window.RTCPeerConnection.prototype.getStats = function getStats() {
          var _this5 = this;

          var _arguments = Array.prototype.slice.call(arguments),
              selector = _arguments[0],
              onSucc = _arguments[1],
              onErr = _arguments[2];

          // If selector is a function then we are in the old style stats so just
          // pass back the original getStats format to avoid breaking old users.


          if (arguments.length > 0 && typeof selector === 'function') {
            return origGetStats.apply(this, arguments);
          }

          // When spec-style getStats is supported, return those when called with
          // either no arguments or the selector argument is null.
          if (origGetStats.length === 0 && (arguments.length === 0 || typeof selector !== 'function')) {
            return origGetStats.apply(this, []);
          }

          var fixChromeStats_ = function fixChromeStats_(response) {
            var standardReport = {};
            var reports = response.result();
            reports.forEach(function (report) {
              var standardStats = {
                id: report.id,
                timestamp: report.timestamp,
                type: {
                  localcandidate: 'local-candidate',
                  remotecandidate: 'remote-candidate'
                }[report.type] || report.type
              };
              report.names().forEach(function (name) {
                standardStats[name] = report.stat(name);
              });
              standardReport[standardStats.id] = standardStats;
            });

            return standardReport;
          };

          // shim getStats with maplike support
          var makeMapStats = function makeMapStats(stats) {
            return new _map2.default((0, _keys2.default)(stats).map(function (key) {
              return [key, stats[key]];
            }));
          };

          if (arguments.length >= 2) {
            var successCallbackWrapper_ = function successCallbackWrapper_(response) {
              onSucc(makeMapStats(fixChromeStats_(response)));
            };

            return origGetStats.apply(this, [successCallbackWrapper_, selector]);
          }

          // promise-support
          return new _promise2.default(function (resolve, reject) {
            origGetStats.apply(_this5, [function (response) {
              resolve(makeMapStats(fixChromeStats_(response)));
            }, reject]);
          }).then(onSucc, onErr);
        };
      }

      function shimSenderReceiverGetStats(window) {
        if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender && window.RTCRtpReceiver)) {
          return;
        }

        // shim sender stats.
        if (!('getStats' in window.RTCRtpSender.prototype)) {
          var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
          if (origGetSenders) {
            window.RTCPeerConnection.prototype.getSenders = function getSenders() {
              var _this6 = this;

              var senders = origGetSenders.apply(this, []);
              senders.forEach(function (sender) {
                return sender._pc = _this6;
              });
              return senders;
            };
          }

          var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
          if (origAddTrack) {
            window.RTCPeerConnection.prototype.addTrack = function addTrack() {
              var sender = origAddTrack.apply(this, arguments);
              sender._pc = this;
              return sender;
            };
          }
          window.RTCRtpSender.prototype.getStats = function getStats() {
            var sender = this;
            return this._pc.getStats().then(function (result) {
              return (
                /* Note: this will include stats of all senders that
                 *   send a track with the same id as sender.track as
                 *   it is not possible to identify the RTCRtpSender.
                 */
                utils.filterStats(result, sender.track, true)
              );
            });
          };
        }

        // shim receiver stats.
        if (!('getStats' in window.RTCRtpReceiver.prototype)) {
          var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
          if (origGetReceivers) {
            window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
              var _this7 = this;

              var receivers = origGetReceivers.apply(this, []);
              receivers.forEach(function (receiver) {
                return receiver._pc = _this7;
              });
              return receivers;
            };
          }
          utils.wrapPeerConnectionEvent(window, 'track', function (e) {
            e.receiver._pc = e.srcElement;
            return e;
          });
          window.RTCRtpReceiver.prototype.getStats = function getStats() {
            var receiver = this;
            return this._pc.getStats().then(function (result) {
              return utils.filterStats(result, receiver.track, false);
            });
          };
        }

        if (!('getStats' in window.RTCRtpSender.prototype && 'getStats' in window.RTCRtpReceiver.prototype)) {
          return;
        }

        // shim RTCPeerConnection.getStats(track).
        var origGetStats = window.RTCPeerConnection.prototype.getStats;
        window.RTCPeerConnection.prototype.getStats = function getStats() {
          if (arguments.length > 0 && arguments[0] instanceof window.MediaStreamTrack) {
            var track = arguments[0];
            var sender = void 0;
            var receiver = void 0;
            var err = void 0;
            this.getSenders().forEach(function (s) {
              if (s.track === track) {
                if (sender) {
                  err = true;
                } else {
                  sender = s;
                }
              }
            });
            this.getReceivers().forEach(function (r) {
              if (r.track === track) {
                if (receiver) {
                  err = true;
                } else {
                  receiver = r;
                }
              }
              return r.track === track;
            });
            if (err || sender && receiver) {
              return _promise2.default.reject(new DOMException('There are more than one sender or receiver for the track.', 'InvalidAccessError'));
            } else if (sender) {
              return sender.getStats();
            } else if (receiver) {
              return receiver.getStats();
            }
            return _promise2.default.reject(new DOMException('There is no sender or receiver for the track.', 'InvalidAccessError'));
          }
          return origGetStats.apply(this, arguments);
        };
      }

      function shimAddTrackRemoveTrackWithNative(window) {
        // shim addTrack/removeTrack with native variants in order to make
        // the interactions with legacy getLocalStreams behave as in other browsers.
        // Keeps a mapping stream.id => [stream, rtpsenders...]
        window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
          var _this8 = this;

          this._shimmedLocalStreams = this._shimmedLocalStreams || {};
          return (0, _keys2.default)(this._shimmedLocalStreams).map(function (streamId) {
            return _this8._shimmedLocalStreams[streamId][0];
          });
        };

        var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
        window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
          if (!stream) {
            return origAddTrack.apply(this, arguments);
          }
          this._shimmedLocalStreams = this._shimmedLocalStreams || {};

          var sender = origAddTrack.apply(this, arguments);
          if (!this._shimmedLocalStreams[stream.id]) {
            this._shimmedLocalStreams[stream.id] = [stream, sender];
          } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {
            this._shimmedLocalStreams[stream.id].push(sender);
          }
          return sender;
        };

        var origAddStream = window.RTCPeerConnection.prototype.addStream;
        window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
          var _this9 = this;

          this._shimmedLocalStreams = this._shimmedLocalStreams || {};

          stream.getTracks().forEach(function (track) {
            var alreadyExists = _this9.getSenders().find(function (s) {
              return s.track === track;
            });
            if (alreadyExists) {
              throw new DOMException('Track already exists.', 'InvalidAccessError');
            }
          });
          var existingSenders = this.getSenders();
          origAddStream.apply(this, arguments);
          var newSenders = this.getSenders().filter(function (newSender) {
            return existingSenders.indexOf(newSender) === -1;
          });
          this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);
        };

        var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
        window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
          this._shimmedLocalStreams = this._shimmedLocalStreams || {};
          delete this._shimmedLocalStreams[stream.id];
          return origRemoveStream.apply(this, arguments);
        };

        var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
        window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
          var _this10 = this;

          this._shimmedLocalStreams = this._shimmedLocalStreams || {};
          if (sender) {
            (0, _keys2.default)(this._shimmedLocalStreams).forEach(function (streamId) {
              var idx = _this10._shimmedLocalStreams[streamId].indexOf(sender);
              if (idx !== -1) {
                _this10._shimmedLocalStreams[streamId].splice(idx, 1);
              }
              if (_this10._shimmedLocalStreams[streamId].length === 1) {
                delete _this10._shimmedLocalStreams[streamId];
              }
            });
          }
          return origRemoveTrack.apply(this, arguments);
        };
      }

      function shimAddTrackRemoveTrack(window) {
        if (!window.RTCPeerConnection) {
          return;
        }
        var browserDetails = utils.detectBrowser(window);
        // shim addTrack and removeTrack.
        if (window.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {
          return shimAddTrackRemoveTrackWithNative(window);
        }

        // also shim pc.getLocalStreams when addTrack is shimmed
        // to return the original streams.
        var origGetLocalStreams = window.RTCPeerConnection.prototype.getLocalStreams;
        window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
          var _this11 = this;

          var nativeStreams = origGetLocalStreams.apply(this);
          this._reverseStreams = this._reverseStreams || {};
          return nativeStreams.map(function (stream) {
            return _this11._reverseStreams[stream.id];
          });
        };

        var origAddStream = window.RTCPeerConnection.prototype.addStream;
        window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
          var _this12 = this;

          this._streams = this._streams || {};
          this._reverseStreams = this._reverseStreams || {};

          stream.getTracks().forEach(function (track) {
            var alreadyExists = _this12.getSenders().find(function (s) {
              return s.track === track;
            });
            if (alreadyExists) {
              throw new DOMException('Track already exists.', 'InvalidAccessError');
            }
          });
          // Add identity mapping for consistency with addTrack.
          // Unless this is being used with a stream from addTrack.
          if (!this._reverseStreams[stream.id]) {
            var newStream = new window.MediaStream(stream.getTracks());
            this._streams[stream.id] = newStream;
            this._reverseStreams[newStream.id] = stream;
            stream = newStream;
          }
          origAddStream.apply(this, [stream]);
        };

        var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
        window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
          this._streams = this._streams || {};
          this._reverseStreams = this._reverseStreams || {};

          origRemoveStream.apply(this, [this._streams[stream.id] || stream]);
          delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];
          delete this._streams[stream.id];
        };

        window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
          var _this13 = this;

          if (this.signalingState === 'closed') {
            throw new DOMException('The RTCPeerConnection\'s signalingState is \'closed\'.', 'InvalidStateError');
          }
          var streams = [].slice.call(arguments, 1);
          if (streams.length !== 1 || !streams[0].getTracks().find(function (t) {
            return t === track;
          })) {
            // this is not fully correct but all we can manage without
            // [[associated MediaStreams]] internal slot.
            throw new DOMException('The adapter.js addTrack polyfill only supports a single ' + ' stream which is associated with the specified track.', 'NotSupportedError');
          }

          var alreadyExists = this.getSenders().find(function (s) {
            return s.track === track;
          });
          if (alreadyExists) {
            throw new DOMException('Track already exists.', 'InvalidAccessError');
          }

          this._streams = this._streams || {};
          this._reverseStreams = this._reverseStreams || {};
          var oldStream = this._streams[stream.id];
          if (oldStream) {
            // this is using odd Chrome behaviour, use with caution:
            // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815
            // Note: we rely on the high-level addTrack/dtmf shim to
            // create the sender with a dtmf sender.
            oldStream.addTrack(track);

            // Trigger ONN async.
            _promise2.default.resolve().then(function () {
              _this13.dispatchEvent(new Event('negotiationneeded'));
            });
          } else {
            var newStream = new window.MediaStream([track]);
            this._streams[stream.id] = newStream;
            this._reverseStreams[newStream.id] = stream;
            this.addStream(newStream);
          }
          return this.getSenders().find(function (s) {
            return s.track === track;
          });
        };

        // replace the internal stream id with the external one and
        // vice versa.
        function replaceInternalStreamId(pc, description) {
          var sdp = description.sdp;
          (0, _keys2.default)(pc._reverseStreams || []).forEach(function (internalId) {
            var externalStream = pc._reverseStreams[internalId];
            var internalStream = pc._streams[externalStream.id];
            sdp = sdp.replace(new RegExp(internalStream.id, 'g'), externalStream.id);
          });
          return new RTCSessionDescription({
            type: description.type,
            sdp: sdp
          });
        }
        function replaceExternalStreamId(pc, description) {
          var sdp = description.sdp;
          (0, _keys2.default)(pc._reverseStreams || []).forEach(function (internalId) {
            var externalStream = pc._reverseStreams[internalId];
            var internalStream = pc._streams[externalStream.id];
            sdp = sdp.replace(new RegExp(externalStream.id, 'g'), internalStream.id);
          });
          return new RTCSessionDescription({
            type: description.type,
            sdp: sdp
          });
        }
        ['createOffer', 'createAnswer'].forEach(function (method) {
          var nativeMethod = window.RTCPeerConnection.prototype[method];
          var methodObj = _defineProperty({}, method, function () {
            var _this14 = this;

            var args = arguments;
            var isLegacyCall = arguments.length && typeof arguments[0] === 'function';
            if (isLegacyCall) {
              return nativeMethod.apply(this, [function (description) {
                var desc = replaceInternalStreamId(_this14, description);
                args[0].apply(null, [desc]);
              }, function (err) {
                if (args[1]) {
                  args[1].apply(null, err);
                }
              }, arguments[2]]);
            }
            return nativeMethod.apply(this, arguments).then(function (description) {
              return replaceInternalStreamId(_this14, description);
            });
          });
          window.RTCPeerConnection.prototype[method] = methodObj[method];
        });

        var origSetLocalDescription = window.RTCPeerConnection.prototype.setLocalDescription;
        window.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
          if (!arguments.length || !arguments[0].type) {
            return origSetLocalDescription.apply(this, arguments);
          }
          arguments[0] = replaceExternalStreamId(this, arguments[0]);
          return origSetLocalDescription.apply(this, arguments);
        };

        // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier

        var origLocalDescription = (0, _getOwnPropertyDescriptor2.default)(window.RTCPeerConnection.prototype, 'localDescription');
        Object.defineProperty(window.RTCPeerConnection.prototype, 'localDescription', {
          get: function get() {
            var description = origLocalDescription.get.apply(this);
            if (description.type === '') {
              return description;
            }
            return replaceInternalStreamId(this, description);
          }
        });

        window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
          var _this15 = this;

          if (this.signalingState === 'closed') {
            throw new DOMException('The RTCPeerConnection\'s signalingState is \'closed\'.', 'InvalidStateError');
          }
          // We can not yet check for sender instanceof RTCRtpSender
          // since we shim RTPSender. So we check if sender._pc is set.
          if (!sender._pc) {
            throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' + 'does not implement interface RTCRtpSender.', 'TypeError');
          }
          var isLocal = sender._pc === this;
          if (!isLocal) {
            throw new DOMException('Sender was not created by this connection.', 'InvalidAccessError');
          }

          // Search for the native stream the senders track belongs to.
          this._streams = this._streams || {};
          var stream = void 0;
          (0, _keys2.default)(this._streams).forEach(function (streamid) {
            var hasTrack = _this15._streams[streamid].getTracks().find(function (track) {
              return sender.track === track;
            });
            if (hasTrack) {
              stream = _this15._streams[streamid];
            }
          });

          if (stream) {
            if (stream.getTracks().length === 1) {
              // if this is the last track of the stream, remove the stream. This
              // takes care of any shimmed _senders.
              this.removeStream(this._reverseStreams[stream.id]);
            } else {
              // relying on the same odd chrome behaviour as above.
              stream.removeTrack(sender.track);
            }
            this.dispatchEvent(new Event('negotiationneeded'));
          }
        };
      }

      function shimPeerConnection(window) {
        var browserDetails = utils.detectBrowser(window);

        if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {
          // very basic support for old versions.
          window.RTCPeerConnection = window.webkitRTCPeerConnection;
        }
        if (!window.RTCPeerConnection) {
          return;
        }

        var addIceCandidateNullSupported = window.RTCPeerConnection.prototype.addIceCandidate.length === 0;

        // shim implicit creation of RTCSessionDescription/RTCIceCandidate
        if (browserDetails.version < 53) {
          ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {
            var nativeMethod = window.RTCPeerConnection.prototype[method];
            var methodObj = _defineProperty({}, method, function () {
              arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);
              return nativeMethod.apply(this, arguments);
            });
            window.RTCPeerConnection.prototype[method] = methodObj[method];
          });
        }

        // support for addIceCandidate(null or undefined)
        var nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;
        window.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {
          if (!addIceCandidateNullSupported && !arguments[0]) {
            if (arguments[1]) {
              arguments[1].apply(null);
            }
            return _promise2.default.resolve();
          }
          // Firefox 68+ emits and processes {candidate: "", ...}, ignore
          // in older versions. Native support planned for Chrome M77.
          if (browserDetails.version < 78 && arguments[0] && arguments[0].candidate === '') {
            return _promise2.default.resolve();
          }
          return nativeAddIceCandidate.apply(this, arguments);
        };
      }

      // Attempt to fix ONN in plan-b mode.
      function fixNegotiationNeeded(window) {
        var browserDetails = utils.detectBrowser(window);
        utils.wrapPeerConnectionEvent(window, 'negotiationneeded', function (e) {
          var pc = e.target;
          if (browserDetails.version < 72 || pc.getConfiguration && pc.getConfiguration().sdpSemantics === 'plan-b') {
            if (pc.signalingState !== 'stable') {
              return;
            }
          }
          return e;
        });
      }
    }, { "../utils.js": 15, "./getdisplaymedia": 4, "./getusermedia": 5 }], 4: [function (require, module, exports) {
      /*
       *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
       *
       *  Use of this source code is governed by a BSD-style license
       *  that can be found in the LICENSE file in the root of the source
       *  tree.
       */
      /* eslint-env node */
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.shimGetDisplayMedia = shimGetDisplayMedia;
      function shimGetDisplayMedia(window, getSourceId) {
        if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {
          return;
        }
        if (!window.navigator.mediaDevices) {
          return;
        }
        // getSourceId is a function that returns a promise resolving with
        // the sourceId of the screen/window/tab to be shared.
        if (typeof getSourceId !== 'function') {
          console.error('shimGetDisplayMedia: getSourceId argument is not ' + 'a function');
          return;
        }
        window.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
          return getSourceId(constraints).then(function (sourceId) {
            var widthSpecified = constraints.video && constraints.video.width;
            var heightSpecified = constraints.video && constraints.video.height;
            var frameRateSpecified = constraints.video && constraints.video.frameRate;
            constraints.video = {
              mandatory: {
                chromeMediaSource: 'desktop',
                chromeMediaSourceId: sourceId,
                maxFrameRate: frameRateSpecified || 3
              }
            };
            if (widthSpecified) {
              constraints.video.mandatory.maxWidth = widthSpecified;
            }
            if (heightSpecified) {
              constraints.video.mandatory.maxHeight = heightSpecified;
            }
            return window.navigator.mediaDevices.getUserMedia(constraints);
          });
        };
      }
    }, {}], 5: [function (require, module, exports) {
      /*
       *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
       *
       *  Use of this source code is governed by a BSD-style license
       *  that can be found in the LICENSE file in the root of the source
       *  tree.
       */
      /* eslint-env node */
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _typeof = typeof _symbol2.default === "function" && (0, _typeof4.default)(_iterator2.default) === "symbol" ? function (obj) {
        return typeof obj === "undefined" ? "undefined" : (0, _typeof4.default)(obj);
      } : function (obj) {
        return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : (0, _typeof4.default)(obj);
      };

      exports.shimGetUserMedia = shimGetUserMedia;

      var _utils = require('../utils.js');

      var utils = _interopRequireWildcard(_utils);

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }newObj.default = obj;return newObj;
        }
      }

      var logging = utils.log;

      function shimGetUserMedia(window) {
        var navigator = window && window.navigator;

        if (!navigator.mediaDevices) {
          return;
        }

        var browserDetails = utils.detectBrowser(window);

        var constraintsToChrome_ = function constraintsToChrome_(c) {
          if ((typeof c === 'undefined' ? 'undefined' : _typeof(c)) !== 'object' || c.mandatory || c.optional) {
            return c;
          }
          var cc = {};
          (0, _keys2.default)(c).forEach(function (key) {
            if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
              return;
            }
            var r = _typeof(c[key]) === 'object' ? c[key] : { ideal: c[key] };
            if (r.exact !== undefined && typeof r.exact === 'number') {
              r.min = r.max = r.exact;
            }
            var oldname_ = function oldname_(prefix, name) {
              if (prefix) {
                return prefix + name.charAt(0).toUpperCase() + name.slice(1);
              }
              return name === 'deviceId' ? 'sourceId' : name;
            };
            if (r.ideal !== undefined) {
              cc.optional = cc.optional || [];
              var oc = {};
              if (typeof r.ideal === 'number') {
                oc[oldname_('min', key)] = r.ideal;
                cc.optional.push(oc);
                oc = {};
                oc[oldname_('max', key)] = r.ideal;
                cc.optional.push(oc);
              } else {
                oc[oldname_('', key)] = r.ideal;
                cc.optional.push(oc);
              }
            }
            if (r.exact !== undefined && typeof r.exact !== 'number') {
              cc.mandatory = cc.mandatory || {};
              cc.mandatory[oldname_('', key)] = r.exact;
            } else {
              ['min', 'max'].forEach(function (mix) {
                if (r[mix] !== undefined) {
                  cc.mandatory = cc.mandatory || {};
                  cc.mandatory[oldname_(mix, key)] = r[mix];
                }
              });
            }
          });
          if (c.advanced) {
            cc.optional = (cc.optional || []).concat(c.advanced);
          }
          return cc;
        };

        var shimConstraints_ = function shimConstraints_(constraints, func) {
          if (browserDetails.version >= 61) {
            return func(constraints);
          }
          constraints = JSON.parse((0, _stringify2.default)(constraints));
          if (constraints && _typeof(constraints.audio) === 'object') {
            var remap = function remap(obj, a, b) {
              if (a in obj && !(b in obj)) {
                obj[b] = obj[a];
                delete obj[a];
              }
            };
            constraints = JSON.parse((0, _stringify2.default)(constraints));
            remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');
            remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');
            constraints.audio = constraintsToChrome_(constraints.audio);
          }
          if (constraints && _typeof(constraints.video) === 'object') {
            // Shim facingMode for mobile & surface pro.
            var face = constraints.video.facingMode;
            face = face && ((typeof face === 'undefined' ? 'undefined' : _typeof(face)) === 'object' ? face : { ideal: face });
            var getSupportedFacingModeLies = browserDetails.version < 66;

            if (face && (face.exact === 'user' || face.exact === 'environment' || face.ideal === 'user' || face.ideal === 'environment') && !(navigator.mediaDevices.getSupportedConstraints && navigator.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {
              delete constraints.video.facingMode;
              var matches = void 0;
              if (face.exact === 'environment' || face.ideal === 'environment') {
                matches = ['back', 'rear'];
              } else if (face.exact === 'user' || face.ideal === 'user') {
                matches = ['front'];
              }
              if (matches) {
                // Look for matches in label, or use last cam for back (typical).
                return navigator.mediaDevices.enumerateDevices().then(function (devices) {
                  devices = devices.filter(function (d) {
                    return d.kind === 'videoinput';
                  });
                  var dev = devices.find(function (d) {
                    return matches.some(function (match) {
                      return d.label.toLowerCase().includes(match);
                    });
                  });
                  if (!dev && devices.length && matches.includes('back')) {
                    dev = devices[devices.length - 1]; // more likely the back cam
                  }
                  if (dev) {
                    constraints.video.deviceId = face.exact ? { exact: dev.deviceId } : { ideal: dev.deviceId };
                  }
                  constraints.video = constraintsToChrome_(constraints.video);
                  logging('chrome: ' + (0, _stringify2.default)(constraints));
                  return func(constraints);
                });
              }
            }
            constraints.video = constraintsToChrome_(constraints.video);
          }
          logging('chrome: ' + (0, _stringify2.default)(constraints));
          return func(constraints);
        };

        var shimError_ = function shimError_(e) {
          if (browserDetails.version >= 64) {
            return e;
          }
          return {
            name: {
              PermissionDeniedError: 'NotAllowedError',
              PermissionDismissedError: 'NotAllowedError',
              InvalidStateError: 'NotAllowedError',
              DevicesNotFoundError: 'NotFoundError',
              ConstraintNotSatisfiedError: 'OverconstrainedError',
              TrackStartError: 'NotReadableError',
              MediaDeviceFailedDueToShutdown: 'NotAllowedError',
              MediaDeviceKillSwitchOn: 'NotAllowedError',
              TabCaptureError: 'AbortError',
              ScreenCaptureError: 'AbortError',
              DeviceCaptureError: 'AbortError'
            }[e.name] || e.name,
            message: e.message,
            constraint: e.constraint || e.constraintName,
            toString: function toString() {
              return this.name + (this.message && ': ') + this.message;
            }
          };
        };

        var getUserMedia_ = function getUserMedia_(constraints, onSuccess, onError) {
          shimConstraints_(constraints, function (c) {
            navigator.webkitGetUserMedia(c, onSuccess, function (e) {
              if (onError) {
                onError(shimError_(e));
              }
            });
          });
        };
        navigator.getUserMedia = getUserMedia_.bind(navigator);

        // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
        // function which returns a Promise, it does not accept spec-style
        // constraints.
        if (navigator.mediaDevices.getUserMedia) {
          var origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
          navigator.mediaDevices.getUserMedia = function (cs) {
            return shimConstraints_(cs, function (c) {
              return origGetUserMedia(c).then(function (stream) {
                if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {
                  stream.getTracks().forEach(function (track) {
                    track.stop();
                  });
                  throw new DOMException('', 'NotFoundError');
                }
                return stream;
              }, function (e) {
                return _promise2.default.reject(shimError_(e));
              });
            });
          };
        }
      }
    }, { "../utils.js": 15 }], 6: [function (require, module, exports) {
      /*
       *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
       *
       *  Use of this source code is governed by a BSD-style license
       *  that can be found in the LICENSE file in the root of the source
       *  tree.
       */
      /* eslint-env node */
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _typeof = typeof _symbol2.default === "function" && (0, _typeof4.default)(_iterator2.default) === "symbol" ? function (obj) {
        return typeof obj === "undefined" ? "undefined" : (0, _typeof4.default)(obj);
      } : function (obj) {
        return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : (0, _typeof4.default)(obj);
      };

      exports.shimRTCIceCandidate = shimRTCIceCandidate;
      exports.shimMaxMessageSize = shimMaxMessageSize;
      exports.shimSendThrowTypeError = shimSendThrowTypeError;
      exports.shimConnectionState = shimConnectionState;
      exports.removeAllowExtmapMixed = removeAllowExtmapMixed;

      var _sdp = require('sdp');

      var _sdp2 = _interopRequireDefault(_sdp);

      var _utils = require('./utils');

      var utils = _interopRequireWildcard(_utils);

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }newObj.default = obj;return newObj;
        }
      }

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function shimRTCIceCandidate(window) {
        // foundation is arbitrarily chosen as an indicator for full support for
        // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface
        if (!window.RTCIceCandidate || window.RTCIceCandidate && 'foundation' in window.RTCIceCandidate.prototype) {
          return;
        }

        var NativeRTCIceCandidate = window.RTCIceCandidate;
        window.RTCIceCandidate = function RTCIceCandidate(args) {
          // Remove the a= which shouldn't be part of the candidate string.
          if ((typeof args === 'undefined' ? 'undefined' : _typeof(args)) === 'object' && args.candidate && args.candidate.indexOf('a=') === 0) {
            args = JSON.parse((0, _stringify2.default)(args));
            args.candidate = args.candidate.substr(2);
          }

          if (args.candidate && args.candidate.length) {
            // Augment the native candidate with the parsed fields.
            var nativeCandidate = new NativeRTCIceCandidate(args);
            var parsedCandidate = _sdp2.default.parseCandidate(args.candidate);
            var augmentedCandidate = (0, _assign2.default)(nativeCandidate, parsedCandidate);

            // Add a serializer that does not serialize the extra attributes.
            augmentedCandidate.toJSON = function toJSON() {
              return {
                candidate: augmentedCandidate.candidate,
                sdpMid: augmentedCandidate.sdpMid,
                sdpMLineIndex: augmentedCandidate.sdpMLineIndex,
                usernameFragment: augmentedCandidate.usernameFragment
              };
            };
            return augmentedCandidate;
          }
          return new NativeRTCIceCandidate(args);
        };
        window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;

        // Hook up the augmented candidate in onicecandidate and
        // addEventListener('icecandidate', ...)
        utils.wrapPeerConnectionEvent(window, 'icecandidate', function (e) {
          if (e.candidate) {
            Object.defineProperty(e, 'candidate', {
              value: new window.RTCIceCandidate(e.candidate),
              writable: 'false'
            });
          }
          return e;
        });
      }

      function shimMaxMessageSize(window) {
        if (!window.RTCPeerConnection) {
          return;
        }
        var browserDetails = utils.detectBrowser(window);

        if (!('sctp' in window.RTCPeerConnection.prototype)) {
          Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {
            get: function get() {
              return typeof this._sctp === 'undefined' ? null : this._sctp;
            }
          });
        }

        var sctpInDescription = function sctpInDescription(description) {
          if (!description || !description.sdp) {
            return false;
          }
          var sections = _sdp2.default.splitSections(description.sdp);
          sections.shift();
          return sections.some(function (mediaSection) {
            var mLine = _sdp2.default.parseMLine(mediaSection);
            return mLine && mLine.kind === 'application' && mLine.protocol.indexOf('SCTP') !== -1;
          });
        };

        var getRemoteFirefoxVersion = function getRemoteFirefoxVersion(description) {
          // TODO: Is there a better solution for detecting Firefox?
          var match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
          if (match === null || match.length < 2) {
            return -1;
          }
          var version = parseInt(match[1], 10);
          // Test for NaN (yes, this is ugly)
          return version !== version ? -1 : version;
        };

        var getCanSendMaxMessageSize = function getCanSendMaxMessageSize(remoteIsFirefox) {
          // Every implementation we know can send at least 64 KiB.
          // Note: Although Chrome is technically able to send up to 256 KiB, the
          //       data does not reach the other peer reliably.
          //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419
          var canSendMaxMessageSize = 65536;
          if (browserDetails.browser === 'firefox') {
            if (browserDetails.version < 57) {
              if (remoteIsFirefox === -1) {
                // FF < 57 will send in 16 KiB chunks using the deprecated PPID
                // fragmentation.
                canSendMaxMessageSize = 16384;
              } else {
                // However, other FF (and RAWRTC) can reassemble PPID-fragmented
                // messages. Thus, supporting ~2 GiB when sending.
                canSendMaxMessageSize = 2147483637;
              }
            } else if (browserDetails.version < 60) {
              // Currently, all FF >= 57 will reset the remote maximum message size
              // to the default value when a data channel is created at a later
              // stage. :(
              // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831
              canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;
            } else {
              // FF >= 60 supports sending ~2 GiB
              canSendMaxMessageSize = 2147483637;
            }
          }
          return canSendMaxMessageSize;
        };

        var getMaxMessageSize = function getMaxMessageSize(description, remoteIsFirefox) {
          // Note: 65536 bytes is the default value from the SDP spec. Also,
          //       every implementation we know supports receiving 65536 bytes.
          var maxMessageSize = 65536;

          // FF 57 has a slightly incorrect default remote max message size, so
          // we need to adjust it here to avoid a failure when sending.
          // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697
          if (browserDetails.browser === 'firefox' && browserDetails.version === 57) {
            maxMessageSize = 65535;
          }

          var match = _sdp2.default.matchPrefix(description.sdp, 'a=max-message-size:');
          if (match.length > 0) {
            maxMessageSize = parseInt(match[0].substr(19), 10);
          } else if (browserDetails.browser === 'firefox' && remoteIsFirefox !== -1) {
            // If the maximum message size is not present in the remote SDP and
            // both local and remote are Firefox, the remote peer can receive
            // ~2 GiB.
            maxMessageSize = 2147483637;
          }
          return maxMessageSize;
        };

        var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
        window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
          this._sctp = null;
          // Chrome decided to not expose .sctp in plan-b mode.
          // As usual, adapter.js has to do an 'ugly worakaround'
          // to cover up the mess.
          if (browserDetails.browser === 'chrome' && browserDetails.version >= 76) {
            var _getConfiguration = this.getConfiguration(),
                sdpSemantics = _getConfiguration.sdpSemantics;

            if (sdpSemantics === 'plan-b') {
              Object.defineProperty(this, 'sctp', {
                get: function get() {
                  return typeof this._sctp === 'undefined' ? null : this._sctp;
                },

                enumerable: true,
                configurable: true
              });
            }
          }

          if (sctpInDescription(arguments[0])) {
            // Check if the remote is FF.
            var isFirefox = getRemoteFirefoxVersion(arguments[0]);

            // Get the maximum message size the local peer is capable of sending
            var canSendMMS = getCanSendMaxMessageSize(isFirefox);

            // Get the maximum message size of the remote peer.
            var remoteMMS = getMaxMessageSize(arguments[0], isFirefox);

            // Determine final maximum message size
            var maxMessageSize = void 0;
            if (canSendMMS === 0 && remoteMMS === 0) {
              maxMessageSize = Number.POSITIVE_INFINITY;
            } else if (canSendMMS === 0 || remoteMMS === 0) {
              maxMessageSize = Math.max(canSendMMS, remoteMMS);
            } else {
              maxMessageSize = Math.min(canSendMMS, remoteMMS);
            }

            // Create a dummy RTCSctpTransport object and the 'maxMessageSize'
            // attribute.
            var sctp = {};
            Object.defineProperty(sctp, 'maxMessageSize', {
              get: function get() {
                return maxMessageSize;
              }
            });
            this._sctp = sctp;
          }

          return origSetRemoteDescription.apply(this, arguments);
        };
      }

      function shimSendThrowTypeError(window) {
        if (!(window.RTCPeerConnection && 'createDataChannel' in window.RTCPeerConnection.prototype)) {
          return;
        }

        // Note: Although Firefox >= 57 has a native implementation, the maximum
        //       message size can be reset for all data channels at a later stage.
        //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831

        function wrapDcSend(dc, pc) {
          var origDataChannelSend = dc.send;
          dc.send = function send() {
            var data = arguments[0];
            var length = data.length || data.size || data.byteLength;
            if (dc.readyState === 'open' && pc.sctp && length > pc.sctp.maxMessageSize) {
              throw new TypeError('Message too large (can send a maximum of ' + pc.sctp.maxMessageSize + ' bytes)');
            }
            return origDataChannelSend.apply(dc, arguments);
          };
        }
        var origCreateDataChannel = window.RTCPeerConnection.prototype.createDataChannel;
        window.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {
          var dataChannel = origCreateDataChannel.apply(this, arguments);
          wrapDcSend(dataChannel, this);
          return dataChannel;
        };
        utils.wrapPeerConnectionEvent(window, 'datachannel', function (e) {
          wrapDcSend(e.channel, e.target);
          return e;
        });
      }

      /* shims RTCConnectionState by pretending it is the same as iceConnectionState.
       * See https://bugs.chromium.org/p/webrtc/issues/detail?id=6145#c12
       * for why this is a valid hack in Chrome. In Firefox it is slightly incorrect
       * since DTLS failures would be hidden. See
       * https://bugzilla.mozilla.org/show_bug.cgi?id=1265827
       * for the Firefox tracking bug.
       */
      function shimConnectionState(window) {
        if (!window.RTCPeerConnection || 'connectionState' in window.RTCPeerConnection.prototype) {
          return;
        }
        var proto = window.RTCPeerConnection.prototype;
        Object.defineProperty(proto, 'connectionState', {
          get: function get() {
            return {
              completed: 'connected',
              checking: 'connecting'
            }[this.iceConnectionState] || this.iceConnectionState;
          },

          enumerable: true,
          configurable: true
        });
        Object.defineProperty(proto, 'onconnectionstatechange', {
          get: function get() {
            return this._onconnectionstatechange || null;
          },
          set: function set(cb) {
            if (this._onconnectionstatechange) {
              this.removeEventListener('connectionstatechange', this._onconnectionstatechange);
              delete this._onconnectionstatechange;
            }
            if (cb) {
              this.addEventListener('connectionstatechange', this._onconnectionstatechange = cb);
            }
          },

          enumerable: true,
          configurable: true
        });

        ['setLocalDescription', 'setRemoteDescription'].forEach(function (method) {
          var origMethod = proto[method];
          proto[method] = function () {
            if (!this._connectionstatechangepoly) {
              this._connectionstatechangepoly = function (e) {
                var pc = e.target;
                if (pc._lastConnectionState !== pc.connectionState) {
                  pc._lastConnectionState = pc.connectionState;
                  var newEvent = new Event('connectionstatechange', e);
                  pc.dispatchEvent(newEvent);
                }
                return e;
              };
              this.addEventListener('iceconnectionstatechange', this._connectionstatechangepoly);
            }
            return origMethod.apply(this, arguments);
          };
        });
      }

      function removeAllowExtmapMixed(window) {
        /* remove a=extmap-allow-mixed for Chrome < M71 */
        if (!window.RTCPeerConnection) {
          return;
        }
        var browserDetails = utils.detectBrowser(window);
        if (browserDetails.browser === 'chrome' && browserDetails.version >= 71) {
          return;
        }
        var nativeSRD = window.RTCPeerConnection.prototype.setRemoteDescription;
        window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {
          if (desc && desc.sdp && desc.sdp.indexOf('\na=extmap-allow-mixed') !== -1) {
            desc.sdp = desc.sdp.split('\n').filter(function (line) {
              return line.trim() !== 'a=extmap-allow-mixed';
            }).join('\n');
          }
          return nativeSRD.apply(this, arguments);
        };
      }
    }, { "./utils": 15, "sdp": 17 }], 7: [function (require, module, exports) {
      /*
       *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
       *
       *  Use of this source code is governed by a BSD-style license
       *  that can be found in the LICENSE file in the root of the source
       *  tree.
       */
      /* eslint-env node */
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.shimGetDisplayMedia = exports.shimGetUserMedia = undefined;

      var _getusermedia = require('./getusermedia');

      Object.defineProperty(exports, 'shimGetUserMedia', {
        enumerable: true,
        get: function get() {
          return _getusermedia.shimGetUserMedia;
        }
      });

      var _getdisplaymedia = require('./getdisplaymedia');

      Object.defineProperty(exports, 'shimGetDisplayMedia', {
        enumerable: true,
        get: function get() {
          return _getdisplaymedia.shimGetDisplayMedia;
        }
      });
      exports.shimPeerConnection = shimPeerConnection;
      exports.shimReplaceTrack = shimReplaceTrack;

      var _utils = require('../utils');

      var utils = _interopRequireWildcard(_utils);

      var _filtericeservers = require('./filtericeservers');

      var _rtcpeerconnectionShim = require('rtcpeerconnection-shim');

      var _rtcpeerconnectionShim2 = _interopRequireDefault(_rtcpeerconnectionShim);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }newObj.default = obj;return newObj;
        }
      }

      function shimPeerConnection(window) {
        var browserDetails = utils.detectBrowser(window);

        if (window.RTCIceGatherer) {
          if (!window.RTCIceCandidate) {
            window.RTCIceCandidate = function RTCIceCandidate(args) {
              return args;
            };
          }
          if (!window.RTCSessionDescription) {
            window.RTCSessionDescription = function RTCSessionDescription(args) {
              return args;
            };
          }
          // this adds an additional event listener to MediaStrackTrack that signals
          // when a tracks enabled property was changed. Workaround for a bug in
          // addStream, see below. No longer required in 15025+
          if (browserDetails.version < 15025) {
            var origMSTEnabled = (0, _getOwnPropertyDescriptor2.default)(window.MediaStreamTrack.prototype, 'enabled');
            Object.defineProperty(window.MediaStreamTrack.prototype, 'enabled', {
              set: function set(value) {
                origMSTEnabled.set.call(this, value);
                var ev = new Event('enabled');
                ev.enabled = value;
                this.dispatchEvent(ev);
              }
            });
          }
        }

        // ORTC defines the DTMF sender a bit different.
        // https://github.com/w3c/ortc/issues/714
        if (window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {
          Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
            get: function get() {
              if (this._dtmf === undefined) {
                if (this.track.kind === 'audio') {
                  this._dtmf = new window.RTCDtmfSender(this);
                } else if (this.track.kind === 'video') {
                  this._dtmf = null;
                }
              }
              return this._dtmf;
            }
          });
        }
        // Edge currently only implements the RTCDtmfSender, not the
        // RTCDTMFSender alias. See http://draft.ortc.org/#rtcdtmfsender2*
        if (window.RTCDtmfSender && !window.RTCDTMFSender) {
          window.RTCDTMFSender = window.RTCDtmfSender;
        }

        var RTCPeerConnectionShim = (0, _rtcpeerconnectionShim2.default)(window, browserDetails.version);
        window.RTCPeerConnection = function RTCPeerConnection(config) {
          if (config && config.iceServers) {
            config.iceServers = (0, _filtericeservers.filterIceServers)(config.iceServers, browserDetails.version);
            utils.log('ICE servers after filtering:', config.iceServers);
          }
          return new RTCPeerConnectionShim(config);
        };
        window.RTCPeerConnection.prototype = RTCPeerConnectionShim.prototype;
      }

      function shimReplaceTrack(window) {
        // ORTC has replaceTrack -- https://github.com/w3c/ortc/issues/614
        if (window.RTCRtpSender && !('replaceTrack' in window.RTCRtpSender.prototype)) {
          window.RTCRtpSender.prototype.replaceTrack = window.RTCRtpSender.prototype.setTrack;
        }
      }
    }, { "../utils": 15, "./filtericeservers": 8, "./getdisplaymedia": 9, "./getusermedia": 10, "rtcpeerconnection-shim": 16 }], 8: [function (require, module, exports) {
      /*
       *  Copyright (c) 2018 The WebRTC project authors. All Rights Reserved.
       *
       *  Use of this source code is governed by a BSD-style license
       *  that can be found in the LICENSE file in the root of the source
       *  tree.
       */
      /* eslint-env node */
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.filterIceServers = filterIceServers;

      var _utils = require('../utils');

      var utils = _interopRequireWildcard(_utils);

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }newObj.default = obj;return newObj;
        }
      }

      // Edge does not like
      // 1) stun: filtered after 14393 unless ?transport=udp is present
      // 2) turn: that does not have all of turn:host:port?transport=udp
      // 3) turn: with ipv6 addresses
      // 4) turn: occurring muliple times
      function filterIceServers(iceServers, edgeVersion) {
        var hasTurn = false;
        iceServers = JSON.parse((0, _stringify2.default)(iceServers));
        return iceServers.filter(function (server) {
          if (server && (server.urls || server.url)) {
            var urls = server.urls || server.url;
            if (server.url && !server.urls) {
              utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
            }
            var isString = typeof urls === 'string';
            if (isString) {
              urls = [urls];
            }
            urls = urls.filter(function (url) {
              // filter STUN unconditionally.
              if (url.indexOf('stun:') === 0) {
                return false;
              }

              var validTurn = url.startsWith('turn') && !url.startsWith('turn:[') && url.includes('transport=udp');
              if (validTurn && !hasTurn) {
                hasTurn = true;
                return true;
              }
              return validTurn && !hasTurn;
            });

            delete server.url;
            server.urls = isString ? urls[0] : urls;
            return !!urls.length;
          }
        });
      }
    }, { "../utils": 15 }], 9: [function (require, module, exports) {
      /*
       *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
       *
       *  Use of this source code is governed by a BSD-style license
       *  that can be found in the LICENSE file in the root of the source
       *  tree.
       */
      /* eslint-env node */
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.shimGetDisplayMedia = shimGetDisplayMedia;
      function shimGetDisplayMedia(window) {
        if (!('getDisplayMedia' in window.navigator)) {
          return;
        }
        if (!window.navigator.mediaDevices) {
          return;
        }
        if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {
          return;
        }
        window.navigator.mediaDevices.getDisplayMedia = window.navigator.getDisplayMedia.bind(window.navigator);
      }
    }, {}], 10: [function (require, module, exports) {
      /*
       *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
       *
       *  Use of this source code is governed by a BSD-style license
       *  that can be found in the LICENSE file in the root of the source
       *  tree.
       */
      /* eslint-env node */
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.shimGetUserMedia = shimGetUserMedia;
      function shimGetUserMedia(window) {
        var navigator = window && window.navigator;

        var shimError_ = function shimError_(e) {
          return {
            name: { PermissionDeniedError: 'NotAllowedError' }[e.name] || e.name,
            message: e.message,
            constraint: e.constraint,
            toString: function toString() {
              return this.name;
            }
          };
        };

        // getUserMedia error shim.
        var origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
        navigator.mediaDevices.getUserMedia = function (c) {
          return origGetUserMedia(c).catch(function (e) {
            return _promise2.default.reject(shimError_(e));
          });
        };
      }
    }, {}], 11: [function (require, module, exports) {
      /*
       *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
       *
       *  Use of this source code is governed by a BSD-style license
       *  that can be found in the LICENSE file in the root of the source
       *  tree.
       */
      /* eslint-env node */
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.shimGetDisplayMedia = exports.shimGetUserMedia = undefined;

      var _typeof = typeof _symbol2.default === "function" && (0, _typeof4.default)(_iterator2.default) === "symbol" ? function (obj) {
        return typeof obj === "undefined" ? "undefined" : (0, _typeof4.default)(obj);
      } : function (obj) {
        return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : (0, _typeof4.default)(obj);
      };

      var _getusermedia = require('./getusermedia');

      Object.defineProperty(exports, 'shimGetUserMedia', {
        enumerable: true,
        get: function get() {
          return _getusermedia.shimGetUserMedia;
        }
      });

      var _getdisplaymedia = require('./getdisplaymedia');

      Object.defineProperty(exports, 'shimGetDisplayMedia', {
        enumerable: true,
        get: function get() {
          return _getdisplaymedia.shimGetDisplayMedia;
        }
      });
      exports.shimOnTrack = shimOnTrack;
      exports.shimPeerConnection = shimPeerConnection;
      exports.shimSenderGetStats = shimSenderGetStats;
      exports.shimReceiverGetStats = shimReceiverGetStats;
      exports.shimRemoveStream = shimRemoveStream;
      exports.shimRTCDataChannel = shimRTCDataChannel;
      exports.shimAddTransceiver = shimAddTransceiver;
      exports.shimCreateOffer = shimCreateOffer;
      exports.shimCreateAnswer = shimCreateAnswer;

      var _utils = require('../utils');

      var utils = _interopRequireWildcard(_utils);

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }newObj.default = obj;return newObj;
        }
      }

      function _defineProperty(obj, key, value) {
        if (key in obj) {
          (0, _defineProperty3.default)(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }return obj;
      }

      function shimOnTrack(window) {
        if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {
          Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
            get: function get() {
              return { receiver: this.receiver };
            }
          });
        }
      }

      function shimPeerConnection(window) {
        var browserDetails = utils.detectBrowser(window);

        if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !(window.RTCPeerConnection || window.mozRTCPeerConnection)) {
          return; // probably media.peerconnection.enabled=false in about:config
        }
        if (!window.RTCPeerConnection && window.mozRTCPeerConnection) {
          // very basic support for old versions.
          window.RTCPeerConnection = window.mozRTCPeerConnection;
        }

        if (browserDetails.version < 53) {
          // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.
          ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {
            var nativeMethod = window.RTCPeerConnection.prototype[method];
            var methodObj = _defineProperty({}, method, function () {
              arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);
              return nativeMethod.apply(this, arguments);
            });
            window.RTCPeerConnection.prototype[method] = methodObj[method];
          });
        }

        // support for addIceCandidate(null or undefined)
        // as well as ignoring {sdpMid, candidate: ""}
        if (browserDetails.version < 68) {
          var nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;
          window.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {
            if (!arguments[0]) {
              if (arguments[1]) {
                arguments[1].apply(null);
              }
              return _promise2.default.resolve();
            }
            // Firefox 68+ emits and processes {candidate: "", ...}, ignore
            // in older versions.
            if (arguments[0] && arguments[0].candidate === '') {
              return _promise2.default.resolve();
            }
            return nativeAddIceCandidate.apply(this, arguments);
          };
        }

        var modernStatsTypes = {
          inboundrtp: 'inbound-rtp',
          outboundrtp: 'outbound-rtp',
          candidatepair: 'candidate-pair',
          localcandidate: 'local-candidate',
          remotecandidate: 'remote-candidate'
        };

        var nativeGetStats = window.RTCPeerConnection.prototype.getStats;
        window.RTCPeerConnection.prototype.getStats = function getStats() {
          var _arguments = Array.prototype.slice.call(arguments),
              selector = _arguments[0],
              onSucc = _arguments[1],
              onErr = _arguments[2];

          return nativeGetStats.apply(this, [selector || null]).then(function (stats) {
            if (browserDetails.version < 53 && !onSucc) {
              // Shim only promise getStats with spec-hyphens in type names
              // Leave callback version alone; misc old uses of forEach before Map
              try {
                stats.forEach(function (stat) {
                  stat.type = modernStatsTypes[stat.type] || stat.type;
                });
              } catch (e) {
                if (e.name !== 'TypeError') {
                  throw e;
                }
                // Avoid TypeError: "type" is read-only, in old versions. 34-43ish
                stats.forEach(function (stat, i) {
                  stats.set(i, (0, _assign2.default)({}, stat, {
                    type: modernStatsTypes[stat.type] || stat.type
                  }));
                });
              }
            }
            return stats;
          }).then(onSucc, onErr);
        };
      }

      function shimSenderGetStats(window) {
        if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {
          return;
        }
        if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {
          return;
        }
        var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
        if (origGetSenders) {
          window.RTCPeerConnection.prototype.getSenders = function getSenders() {
            var _this = this;

            var senders = origGetSenders.apply(this, []);
            senders.forEach(function (sender) {
              return sender._pc = _this;
            });
            return senders;
          };
        }

        var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
        if (origAddTrack) {
          window.RTCPeerConnection.prototype.addTrack = function addTrack() {
            var sender = origAddTrack.apply(this, arguments);
            sender._pc = this;
            return sender;
          };
        }
        window.RTCRtpSender.prototype.getStats = function getStats() {
          return this.track ? this._pc.getStats(this.track) : _promise2.default.resolve(new _map2.default());
        };
      }

      function shimReceiverGetStats(window) {
        if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {
          return;
        }
        if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {
          return;
        }
        var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
        if (origGetReceivers) {
          window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
            var _this2 = this;

            var receivers = origGetReceivers.apply(this, []);
            receivers.forEach(function (receiver) {
              return receiver._pc = _this2;
            });
            return receivers;
          };
        }
        utils.wrapPeerConnectionEvent(window, 'track', function (e) {
          e.receiver._pc = e.srcElement;
          return e;
        });
        window.RTCRtpReceiver.prototype.getStats = function getStats() {
          return this._pc.getStats(this.track);
        };
      }

      function shimRemoveStream(window) {
        if (!window.RTCPeerConnection || 'removeStream' in window.RTCPeerConnection.prototype) {
          return;
        }
        window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
          var _this3 = this;

          utils.deprecated('removeStream', 'removeTrack');
          this.getSenders().forEach(function (sender) {
            if (sender.track && stream.getTracks().includes(sender.track)) {
              _this3.removeTrack(sender);
            }
          });
        };
      }

      function shimRTCDataChannel(window) {
        // rename DataChannel to RTCDataChannel (native fix in FF60):
        // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851
        if (window.DataChannel && !window.RTCDataChannel) {
          window.RTCDataChannel = window.DataChannel;
        }
      }

      function shimAddTransceiver(window) {
        // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
        // Firefox ignores the init sendEncodings options passed to addTransceiver
        // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
        if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection)) {
          return;
        }
        var origAddTransceiver = window.RTCPeerConnection.prototype.addTransceiver;
        if (origAddTransceiver) {
          window.RTCPeerConnection.prototype.addTransceiver = function addTransceiver() {
            this.setParametersPromises = [];
            var initParameters = arguments[1];
            var shouldPerformCheck = initParameters && 'sendEncodings' in initParameters;
            if (shouldPerformCheck) {
              // If sendEncodings params are provided, validate grammar
              initParameters.sendEncodings.forEach(function (encodingParam) {
                if ('rid' in encodingParam) {
                  var ridRegex = /^[a-z0-9]{0,16}$/i;
                  if (!ridRegex.test(encodingParam.rid)) {
                    throw new TypeError('Invalid RID value provided.');
                  }
                }
                if ('scaleResolutionDownBy' in encodingParam) {
                  if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1.0)) {
                    throw new RangeError('scale_resolution_down_by must be >= 1.0');
                  }
                }
                if ('maxFramerate' in encodingParam) {
                  if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {
                    throw new RangeError('max_framerate must be >= 0.0');
                  }
                }
              });
            }
            var transceiver = origAddTransceiver.apply(this, arguments);
            if (shouldPerformCheck) {
              // Check if the init options were applied. If not we do this in an
              // asynchronous way and save the promise reference in a global object.
              // This is an ugly hack, but at the same time is way more robust than
              // checking the sender parameters before and after the createOffer
              // Also note that after the createoffer we are not 100% sure that
              // the params were asynchronously applied so we might miss the
              // opportunity to recreate offer.
              var sender = transceiver.sender;

              var params = sender.getParameters();
              if (!('encodings' in params)) {
                params.encodings = initParameters.sendEncodings;
                this.setParametersPromises.push(sender.setParameters(params).catch(function () {}));
              }
            }
            return transceiver;
          };
        }
      }

      function shimCreateOffer(window) {
        // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
        // Firefox ignores the init sendEncodings options passed to addTransceiver
        // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
        if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection)) {
          return;
        }
        var origCreateOffer = window.RTCPeerConnection.prototype.createOffer;
        window.RTCPeerConnection.prototype.createOffer = function createOffer() {
          var _this4 = this,
              _arguments2 = arguments;

          if (this.setParametersPromises && this.setParametersPromises.length) {
            return _promise2.default.all(this.setParametersPromises).then(function () {
              return origCreateOffer.apply(_this4, _arguments2);
            }).finally(function () {
              _this4.setParametersPromises = [];
            });
          }
          return origCreateOffer.apply(this, arguments);
        };
      }

      function shimCreateAnswer(window) {
        // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
        // Firefox ignores the init sendEncodings options passed to addTransceiver
        // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
        if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection)) {
          return;
        }
        var origCreateAnswer = window.RTCPeerConnection.prototype.createAnswer;
        window.RTCPeerConnection.prototype.createAnswer = function createAnswer() {
          var _this5 = this,
              _arguments3 = arguments;

          if (this.setParametersPromises && this.setParametersPromises.length) {
            return _promise2.default.all(this.setParametersPromises).then(function () {
              return origCreateAnswer.apply(_this5, _arguments3);
            }).finally(function () {
              _this5.setParametersPromises = [];
            });
          }
          return origCreateAnswer.apply(this, arguments);
        };
      }
    }, { "../utils": 15, "./getdisplaymedia": 12, "./getusermedia": 13 }], 12: [function (require, module, exports) {
      /*
       *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
       *
       *  Use of this source code is governed by a BSD-style license
       *  that can be found in the LICENSE file in the root of the source
       *  tree.
       */
      /* eslint-env node */
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.shimGetDisplayMedia = shimGetDisplayMedia;
      function shimGetDisplayMedia(window, preferredMediaSource) {
        if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {
          return;
        }
        if (!window.navigator.mediaDevices) {
          return;
        }
        window.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
          if (!(constraints && constraints.video)) {
            var err = new DOMException('getDisplayMedia without video ' + 'constraints is undefined');
            err.name = 'NotFoundError';
            // from https://heycam.github.io/webidl/#idl-DOMException-error-names
            err.code = 8;
            return _promise2.default.reject(err);
          }
          if (constraints.video === true) {
            constraints.video = { mediaSource: preferredMediaSource };
          } else {
            constraints.video.mediaSource = preferredMediaSource;
          }
          return window.navigator.mediaDevices.getUserMedia(constraints);
        };
      }
    }, {}], 13: [function (require, module, exports) {
      /*
       *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
       *
       *  Use of this source code is governed by a BSD-style license
       *  that can be found in the LICENSE file in the root of the source
       *  tree.
       */
      /* eslint-env node */
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _typeof = typeof _symbol2.default === "function" && (0, _typeof4.default)(_iterator2.default) === "symbol" ? function (obj) {
        return typeof obj === "undefined" ? "undefined" : (0, _typeof4.default)(obj);
      } : function (obj) {
        return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : (0, _typeof4.default)(obj);
      };

      exports.shimGetUserMedia = shimGetUserMedia;

      var _utils = require('../utils');

      var utils = _interopRequireWildcard(_utils);

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }newObj.default = obj;return newObj;
        }
      }

      function shimGetUserMedia(window) {
        var browserDetails = utils.detectBrowser(window);
        var navigator = window && window.navigator;
        var MediaStreamTrack = window && window.MediaStreamTrack;

        navigator.getUserMedia = function (constraints, onSuccess, onError) {
          // Replace Firefox 44+'s deprecation warning with unprefixed version.
          utils.deprecated('navigator.getUserMedia', 'navigator.mediaDevices.getUserMedia');
          navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
        };

        if (!(browserDetails.version > 55 && 'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {
          var remap = function remap(obj, a, b) {
            if (a in obj && !(b in obj)) {
              obj[b] = obj[a];
              delete obj[a];
            }
          };

          var nativeGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
          navigator.mediaDevices.getUserMedia = function (c) {
            if ((typeof c === 'undefined' ? 'undefined' : _typeof(c)) === 'object' && _typeof(c.audio) === 'object') {
              c = JSON.parse((0, _stringify2.default)(c));
              remap(c.audio, 'autoGainControl', 'mozAutoGainControl');
              remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');
            }
            return nativeGetUserMedia(c);
          };

          if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {
            var nativeGetSettings = MediaStreamTrack.prototype.getSettings;
            MediaStreamTrack.prototype.getSettings = function () {
              var obj = nativeGetSettings.apply(this, arguments);
              remap(obj, 'mozAutoGainControl', 'autoGainControl');
              remap(obj, 'mozNoiseSuppression', 'noiseSuppression');
              return obj;
            };
          }

          if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {
            var nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;
            MediaStreamTrack.prototype.applyConstraints = function (c) {
              if (this.kind === 'audio' && (typeof c === 'undefined' ? 'undefined' : _typeof(c)) === 'object') {
                c = JSON.parse((0, _stringify2.default)(c));
                remap(c, 'autoGainControl', 'mozAutoGainControl');
                remap(c, 'noiseSuppression', 'mozNoiseSuppression');
              }
              return nativeApplyConstraints.apply(this, [c]);
            };
          }
        }
      }
    }, { "../utils": 15 }], 14: [function (require, module, exports) {
      /*
       *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
       *
       *  Use of this source code is governed by a BSD-style license
       *  that can be found in the LICENSE file in the root of the source
       *  tree.
       */
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _typeof = typeof _symbol2.default === "function" && (0, _typeof4.default)(_iterator2.default) === "symbol" ? function (obj) {
        return typeof obj === "undefined" ? "undefined" : (0, _typeof4.default)(obj);
      } : function (obj) {
        return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : (0, _typeof4.default)(obj);
      };

      exports.shimLocalStreamsAPI = shimLocalStreamsAPI;
      exports.shimRemoteStreamsAPI = shimRemoteStreamsAPI;
      exports.shimCallbacksAPI = shimCallbacksAPI;
      exports.shimGetUserMedia = shimGetUserMedia;
      exports.shimConstraints = shimConstraints;
      exports.shimRTCIceServerUrls = shimRTCIceServerUrls;
      exports.shimTrackEventTransceiver = shimTrackEventTransceiver;
      exports.shimCreateOfferLegacy = shimCreateOfferLegacy;
      exports.shimAudioContext = shimAudioContext;

      var _utils = require('../utils');

      var utils = _interopRequireWildcard(_utils);

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }newObj.default = obj;return newObj;
        }
      }

      function shimLocalStreamsAPI(window) {
        if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {
          return;
        }
        if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {
          window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
            if (!this._localStreams) {
              this._localStreams = [];
            }
            return this._localStreams;
          };
        }
        if (!('addStream' in window.RTCPeerConnection.prototype)) {
          var _addTrack = window.RTCPeerConnection.prototype.addTrack;
          window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
            var _this = this;

            if (!this._localStreams) {
              this._localStreams = [];
            }
            if (!this._localStreams.includes(stream)) {
              this._localStreams.push(stream);
            }
            // Try to emulate Chrome's behaviour of adding in audio-video order.
            // Safari orders by track id.
            stream.getAudioTracks().forEach(function (track) {
              return _addTrack.call(_this, track, stream);
            });
            stream.getVideoTracks().forEach(function (track) {
              return _addTrack.call(_this, track, stream);
            });
          };

          window.RTCPeerConnection.prototype.addTrack = function addTrack(track) {
            var _this2 = this;

            for (var _len = arguments.length, streams = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              streams[_key - 1] = arguments[_key];
            }

            if (streams) {
              streams.forEach(function (stream) {
                if (!_this2._localStreams) {
                  _this2._localStreams = [stream];
                } else if (!_this2._localStreams.includes(stream)) {
                  _this2._localStreams.push(stream);
                }
              });
            }
            return _addTrack.apply(this, arguments);
          };
        }
        if (!('removeStream' in window.RTCPeerConnection.prototype)) {
          window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
            var _this3 = this;

            if (!this._localStreams) {
              this._localStreams = [];
            }
            var index = this._localStreams.indexOf(stream);
            if (index === -1) {
              return;
            }
            this._localStreams.splice(index, 1);
            var tracks = stream.getTracks();
            this.getSenders().forEach(function (sender) {
              if (tracks.includes(sender.track)) {
                _this3.removeTrack(sender);
              }
            });
          };
        }
      }

      function shimRemoteStreamsAPI(window) {
        if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {
          return;
        }
        if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {
          window.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {
            return this._remoteStreams ? this._remoteStreams : [];
          };
        }
        if (!('onaddstream' in window.RTCPeerConnection.prototype)) {
          Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {
            get: function get() {
              return this._onaddstream;
            },
            set: function set(f) {
              var _this4 = this;

              if (this._onaddstream) {
                this.removeEventListener('addstream', this._onaddstream);
                this.removeEventListener('track', this._onaddstreampoly);
              }
              this.addEventListener('addstream', this._onaddstream = f);
              this.addEventListener('track', this._onaddstreampoly = function (e) {
                e.streams.forEach(function (stream) {
                  if (!_this4._remoteStreams) {
                    _this4._remoteStreams = [];
                  }
                  if (_this4._remoteStreams.includes(stream)) {
                    return;
                  }
                  _this4._remoteStreams.push(stream);
                  var event = new Event('addstream');
                  event.stream = stream;
                  _this4.dispatchEvent(event);
                });
              });
            }
          });
          var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
          window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
            var pc = this;
            if (!this._onaddstreampoly) {
              this.addEventListener('track', this._onaddstreampoly = function (e) {
                e.streams.forEach(function (stream) {
                  if (!pc._remoteStreams) {
                    pc._remoteStreams = [];
                  }
                  if (pc._remoteStreams.indexOf(stream) >= 0) {
                    return;
                  }
                  pc._remoteStreams.push(stream);
                  var event = new Event('addstream');
                  event.stream = stream;
                  pc.dispatchEvent(event);
                });
              });
            }
            return origSetRemoteDescription.apply(pc, arguments);
          };
        }
      }

      function shimCallbacksAPI(window) {
        if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {
          return;
        }
        var prototype = window.RTCPeerConnection.prototype;
        var origCreateOffer = prototype.createOffer;
        var origCreateAnswer = prototype.createAnswer;
        var setLocalDescription = prototype.setLocalDescription;
        var setRemoteDescription = prototype.setRemoteDescription;
        var addIceCandidate = prototype.addIceCandidate;

        prototype.createOffer = function createOffer(successCallback, failureCallback) {
          var options = arguments.length >= 2 ? arguments[2] : arguments[0];
          var promise = origCreateOffer.apply(this, [options]);
          if (!failureCallback) {
            return promise;
          }
          promise.then(successCallback, failureCallback);
          return _promise2.default.resolve();
        };

        prototype.createAnswer = function createAnswer(successCallback, failureCallback) {
          var options = arguments.length >= 2 ? arguments[2] : arguments[0];
          var promise = origCreateAnswer.apply(this, [options]);
          if (!failureCallback) {
            return promise;
          }
          promise.then(successCallback, failureCallback);
          return _promise2.default.resolve();
        };

        var withCallback = function withCallback(description, successCallback, failureCallback) {
          var promise = setLocalDescription.apply(this, [description]);
          if (!failureCallback) {
            return promise;
          }
          promise.then(successCallback, failureCallback);
          return _promise2.default.resolve();
        };
        prototype.setLocalDescription = withCallback;

        withCallback = function withCallback(description, successCallback, failureCallback) {
          var promise = setRemoteDescription.apply(this, [description]);
          if (!failureCallback) {
            return promise;
          }
          promise.then(successCallback, failureCallback);
          return _promise2.default.resolve();
        };
        prototype.setRemoteDescription = withCallback;

        withCallback = function withCallback(candidate, successCallback, failureCallback) {
          var promise = addIceCandidate.apply(this, [candidate]);
          if (!failureCallback) {
            return promise;
          }
          promise.then(successCallback, failureCallback);
          return _promise2.default.resolve();
        };
        prototype.addIceCandidate = withCallback;
      }

      function shimGetUserMedia(window) {
        var navigator = window && window.navigator;

        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
          // shim not needed in Safari 12.1
          var mediaDevices = navigator.mediaDevices;
          var _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);
          navigator.mediaDevices.getUserMedia = function (constraints) {
            return _getUserMedia(shimConstraints(constraints));
          };
        }

        if (!navigator.getUserMedia && navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
          navigator.getUserMedia = function getUserMedia(constraints, cb, errcb) {
            navigator.mediaDevices.getUserMedia(constraints).then(cb, errcb);
          }.bind(navigator);
        }
      }

      function shimConstraints(constraints) {
        if (constraints && constraints.video !== undefined) {
          return (0, _assign2.default)({}, constraints, { video: utils.compactObject(constraints.video) });
        }

        return constraints;
      }

      function shimRTCIceServerUrls(window) {
        // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
        var OrigPeerConnection = window.RTCPeerConnection;
        window.RTCPeerConnection = function RTCPeerConnection(pcConfig, pcConstraints) {
          if (pcConfig && pcConfig.iceServers) {
            var newIceServers = [];
            for (var i = 0; i < pcConfig.iceServers.length; i++) {
              var server = pcConfig.iceServers[i];
              if (!server.hasOwnProperty('urls') && server.hasOwnProperty('url')) {
                utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
                server = JSON.parse((0, _stringify2.default)(server));
                server.urls = server.url;
                delete server.url;
                newIceServers.push(server);
              } else {
                newIceServers.push(pcConfig.iceServers[i]);
              }
            }
            pcConfig.iceServers = newIceServers;
          }
          return new OrigPeerConnection(pcConfig, pcConstraints);
        };
        window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
        // wrap static methods. Currently just generateCertificate.
        if ('generateCertificate' in window.RTCPeerConnection) {
          Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
            get: function get() {
              return OrigPeerConnection.generateCertificate;
            }
          });
        }
      }

      function shimTrackEventTransceiver(window) {
        // Add event.transceiver member over deprecated event.receiver
        if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {
          Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
            get: function get() {
              return { receiver: this.receiver };
            }
          });
        }
      }

      function shimCreateOfferLegacy(window) {
        var origCreateOffer = window.RTCPeerConnection.prototype.createOffer;
        window.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {
          if (offerOptions) {
            if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {
              // support bit values
              offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;
            }
            var audioTransceiver = this.getTransceivers().find(function (transceiver) {
              return transceiver.receiver.track.kind === 'audio';
            });
            if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
              if (audioTransceiver.direction === 'sendrecv') {
                if (audioTransceiver.setDirection) {
                  audioTransceiver.setDirection('sendonly');
                } else {
                  audioTransceiver.direction = 'sendonly';
                }
              } else if (audioTransceiver.direction === 'recvonly') {
                if (audioTransceiver.setDirection) {
                  audioTransceiver.setDirection('inactive');
                } else {
                  audioTransceiver.direction = 'inactive';
                }
              }
            } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {
              this.addTransceiver('audio');
            }

            if (typeof offerOptions.offerToReceiveVideo !== 'undefined') {
              // support bit values
              offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;
            }
            var videoTransceiver = this.getTransceivers().find(function (transceiver) {
              return transceiver.receiver.track.kind === 'video';
            });
            if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
              if (videoTransceiver.direction === 'sendrecv') {
                if (videoTransceiver.setDirection) {
                  videoTransceiver.setDirection('sendonly');
                } else {
                  videoTransceiver.direction = 'sendonly';
                }
              } else if (videoTransceiver.direction === 'recvonly') {
                if (videoTransceiver.setDirection) {
                  videoTransceiver.setDirection('inactive');
                } else {
                  videoTransceiver.direction = 'inactive';
                }
              }
            } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {
              this.addTransceiver('video');
            }
          }
          return origCreateOffer.apply(this, arguments);
        };
      }

      function shimAudioContext(window) {
        if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || window.AudioContext) {
          return;
        }
        window.AudioContext = window.webkitAudioContext;
      }
    }, { "../utils": 15 }], 15: [function (require, module, exports) {
      /*
       *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
       *
       *  Use of this source code is governed by a BSD-style license
       *  that can be found in the LICENSE file in the root of the source
       *  tree.
       */
      /* eslint-env node */
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _typeof = typeof _symbol2.default === "function" && (0, _typeof4.default)(_iterator2.default) === "symbol" ? function (obj) {
        return typeof obj === "undefined" ? "undefined" : (0, _typeof4.default)(obj);
      } : function (obj) {
        return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : (0, _typeof4.default)(obj);
      };

      exports.extractVersion = extractVersion;
      exports.wrapPeerConnectionEvent = wrapPeerConnectionEvent;
      exports.disableLog = disableLog;
      exports.disableWarnings = disableWarnings;
      exports.log = log;
      exports.deprecated = deprecated;
      exports.detectBrowser = detectBrowser;
      exports.compactObject = compactObject;
      exports.walkStats = walkStats;
      exports.filterStats = filterStats;

      function _defineProperty(obj, key, value) {
        if (key in obj) {
          (0, _defineProperty3.default)(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }return obj;
      }

      var logDisabled_ = true;
      var deprecationWarnings_ = true;

      /**
       * Extract browser version out of the provided user agent string.
       *
       * @param {!string} uastring userAgent string.
       * @param {!string} expr Regular expression used as match criteria.
       * @param {!number} pos position in the version string to be returned.
       * @return {!number} browser version.
       */
      function extractVersion(uastring, expr, pos) {
        var match = uastring.match(expr);
        return match && match.length >= pos && parseInt(match[pos], 10);
      }

      // Wraps the peerconnection event eventNameToWrap in a function
      // which returns the modified event object (or false to prevent
      // the event).
      function wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {
        if (!window.RTCPeerConnection) {
          return;
        }
        var proto = window.RTCPeerConnection.prototype;
        var nativeAddEventListener = proto.addEventListener;
        proto.addEventListener = function (nativeEventName, cb) {
          if (nativeEventName !== eventNameToWrap) {
            return nativeAddEventListener.apply(this, arguments);
          }
          var wrappedCallback = function wrappedCallback(e) {
            var modifiedEvent = wrapper(e);
            if (modifiedEvent) {
              cb(modifiedEvent);
            }
          };
          this._eventMap = this._eventMap || {};
          this._eventMap[cb] = wrappedCallback;
          return nativeAddEventListener.apply(this, [nativeEventName, wrappedCallback]);
        };

        var nativeRemoveEventListener = proto.removeEventListener;
        proto.removeEventListener = function (nativeEventName, cb) {
          if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[cb]) {
            return nativeRemoveEventListener.apply(this, arguments);
          }
          var unwrappedCb = this._eventMap[cb];
          delete this._eventMap[cb];
          return nativeRemoveEventListener.apply(this, [nativeEventName, unwrappedCb]);
        };

        (0, _defineProperty3.default)(proto, 'on' + eventNameToWrap, {
          get: function get() {
            return this['_on' + eventNameToWrap];
          },
          set: function set(cb) {
            if (this['_on' + eventNameToWrap]) {
              this.removeEventListener(eventNameToWrap, this['_on' + eventNameToWrap]);
              delete this['_on' + eventNameToWrap];
            }
            if (cb) {
              this.addEventListener(eventNameToWrap, this['_on' + eventNameToWrap] = cb);
            }
          },

          enumerable: true,
          configurable: true
        });
      }

      function disableLog(bool) {
        if (typeof bool !== 'boolean') {
          return new Error('Argument type: ' + (typeof bool === 'undefined' ? 'undefined' : _typeof(bool)) + '. Please use a boolean.');
        }
        logDisabled_ = bool;
        return bool ? 'adapter.js logging disabled' : 'adapter.js logging enabled';
      }

      /**
       * Disable or enable deprecation warnings
       * @param {!boolean} bool set to true to disable warnings.
       */
      function disableWarnings(bool) {
        if (typeof bool !== 'boolean') {
          return new Error('Argument type: ' + (typeof bool === 'undefined' ? 'undefined' : _typeof(bool)) + '. Please use a boolean.');
        }
        deprecationWarnings_ = !bool;
        return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');
      }

      function log() {
        if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object') {
          if (logDisabled_) {
            return;
          }
          if (typeof console !== 'undefined' && typeof console.log === 'function') {
            console.log.apply(console, arguments);
          }
        }
      }

      /**
       * Shows a deprecation warning suggesting the modern and spec-compatible API.
       */
      function deprecated(oldMethod, newMethod) {
        if (!deprecationWarnings_) {
          return;
        }
        console.warn(oldMethod + ' is deprecated, please use ' + newMethod + ' instead.');
      }

      /**
       * Browser detector.
       *
       * @return {object} result containing browser and version
       *     properties.
       */
      function detectBrowser(window) {
        var navigator = window.navigator;

        // Returned result object.

        var result = { browser: null, version: null };

        // Fail early if it's not a browser
        if (typeof window === 'undefined' || !window.navigator) {
          result.browser = 'Not a browser.';
          return result;
        }

        if (navigator.mozGetUserMedia) {
          // Firefox.
          result.browser = 'firefox';
          result.version = extractVersion(navigator.userAgent, /Firefox\/(\d+)\./, 1);
        } else if (navigator.webkitGetUserMedia || window.isSecureContext === false && window.webkitRTCPeerConnection && !window.RTCIceGatherer) {
          // Chrome, Chromium, Webview, Opera.
          // Version matches Chrome/WebRTC version.
          // Chrome 74 removed webkitGetUserMedia on http as well so we need the
          // more complicated fallback to webkitRTCPeerConnection.
          result.browser = 'chrome';
          result.version = extractVersion(navigator.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
        } else if (navigator.mediaDevices && navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)) {
          // Edge.
          result.browser = 'edge';
          result.version = extractVersion(navigator.userAgent, /Edge\/(\d+).(\d+)$/, 2);
        } else if (window.RTCPeerConnection && navigator.userAgent.match(/AppleWebKit\/(\d+)\./)) {
          // Safari.
          result.browser = 'safari';
          result.version = extractVersion(navigator.userAgent, /AppleWebKit\/(\d+)\./, 1);
          result.supportsUnifiedPlan = window.RTCRtpTransceiver && 'currentDirection' in window.RTCRtpTransceiver.prototype;
        } else {
          // Default fallthrough: not supported.
          result.browser = 'Not a supported browser.';
          return result;
        }

        return result;
      }

      /**
       * Checks if something is an object.
       *
       * @param {*} val The something you want to check.
       * @return true if val is an object, false otherwise.
       */
      function isObject(val) {
        return Object.prototype.toString.call(val) === '[object Object]';
      }

      /**
       * Remove all empty objects and undefined values
       * from a nested object -- an enhanced and vanilla version
       * of Lodash's `compact`.
       */
      function compactObject(data) {
        if (!isObject(data)) {
          return data;
        }

        return (0, _keys2.default)(data).reduce(function (accumulator, key) {
          var isObj = isObject(data[key]);
          var value = isObj ? compactObject(data[key]) : data[key];
          var isEmptyObject = isObj && !(0, _keys2.default)(value).length;
          if (value === undefined || isEmptyObject) {
            return accumulator;
          }
          return (0, _assign2.default)(accumulator, _defineProperty({}, key, value));
        }, {});
      }

      /* iterates the stats graph recursively. */
      function walkStats(stats, base, resultSet) {
        if (!base || resultSet.has(base.id)) {
          return;
        }
        resultSet.set(base.id, base);
        (0, _keys2.default)(base).forEach(function (name) {
          if (name.endsWith('Id')) {
            walkStats(stats, stats.get(base[name]), resultSet);
          } else if (name.endsWith('Ids')) {
            base[name].forEach(function (id) {
              walkStats(stats, stats.get(id), resultSet);
            });
          }
        });
      }

      /* filter getStats for a sender/receiver track. */
      function filterStats(result, track, outbound) {
        var streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';
        var filteredResult = new _map2.default();
        if (track === null) {
          return filteredResult;
        }
        var trackStats = [];
        result.forEach(function (value) {
          if (value.type === 'track' && value.trackIdentifier === track.id) {
            trackStats.push(value);
          }
        });
        trackStats.forEach(function (trackStat) {
          result.forEach(function (stats) {
            if (stats.type === streamStatsType && stats.trackId === trackStat.id) {
              walkStats(result, stats, filteredResult);
            }
          });
        });
        return filteredResult;
      }
    }, {}], 16: [function (require, module, exports) {
      /*
       *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
       *
       *  Use of this source code is governed by a BSD-style license
       *  that can be found in the LICENSE file in the root of the source
       *  tree.
       */
      /* eslint-env node */
      'use strict';

      var SDPUtils = require('sdp');

      function fixStatsType(stat) {
        return {
          inboundrtp: 'inbound-rtp',
          outboundrtp: 'outbound-rtp',
          candidatepair: 'candidate-pair',
          localcandidate: 'local-candidate',
          remotecandidate: 'remote-candidate'
        }[stat.type] || stat.type;
      }

      function writeMediaSection(transceiver, caps, type, stream, dtlsRole) {
        var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

        // Map ICE parameters (ufrag, pwd) to SDP.
        sdp += SDPUtils.writeIceParameters(transceiver.iceGatherer.getLocalParameters());

        // Map DTLS parameters to SDP.
        sdp += SDPUtils.writeDtlsParameters(transceiver.dtlsTransport.getLocalParameters(), type === 'offer' ? 'actpass' : dtlsRole || 'active');

        sdp += 'a=mid:' + transceiver.mid + '\r\n';

        if (transceiver.rtpSender && transceiver.rtpReceiver) {
          sdp += 'a=sendrecv\r\n';
        } else if (transceiver.rtpSender) {
          sdp += 'a=sendonly\r\n';
        } else if (transceiver.rtpReceiver) {
          sdp += 'a=recvonly\r\n';
        } else {
          sdp += 'a=inactive\r\n';
        }

        if (transceiver.rtpSender) {
          var trackId = transceiver.rtpSender._initialTrackId || transceiver.rtpSender.track.id;
          transceiver.rtpSender._initialTrackId = trackId;
          // spec.
          var msid = 'msid:' + (stream ? stream.id : '-') + ' ' + trackId + '\r\n';
          sdp += 'a=' + msid;
          // for Chrome. Legacy should no longer be required.
          sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc + ' ' + msid;

          // RTX
          if (transceiver.sendEncodingParameters[0].rtx) {
            sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc + ' ' + msid;
            sdp += 'a=ssrc-group:FID ' + transceiver.sendEncodingParameters[0].ssrc + ' ' + transceiver.sendEncodingParameters[0].rtx.ssrc + '\r\n';
          }
        }
        // FIXME: this should be written by writeRtpDescription.
        sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc + ' cname:' + SDPUtils.localCName + '\r\n';
        if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
          sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc + ' cname:' + SDPUtils.localCName + '\r\n';
        }
        return sdp;
      }

      // Edge does not like
      // 1) stun: filtered after 14393 unless ?transport=udp is present
      // 2) turn: that does not have all of turn:host:port?transport=udp
      // 3) turn: with ipv6 addresses
      // 4) turn: occurring muliple times
      function filterIceServers(iceServers, edgeVersion) {
        var hasTurn = false;
        iceServers = JSON.parse((0, _stringify2.default)(iceServers));
        return iceServers.filter(function (server) {
          if (server && (server.urls || server.url)) {
            var urls = server.urls || server.url;
            if (server.url && !server.urls) {
              console.warn('RTCIceServer.url is deprecated! Use urls instead.');
            }
            var isString = typeof urls === 'string';
            if (isString) {
              urls = [urls];
            }
            urls = urls.filter(function (url) {
              var validTurn = url.indexOf('turn:') === 0 && url.indexOf('transport=udp') !== -1 && url.indexOf('turn:[') === -1 && !hasTurn;

              if (validTurn) {
                hasTurn = true;
                return true;
              }
              return url.indexOf('stun:') === 0 && edgeVersion >= 14393 && url.indexOf('?transport=udp') === -1;
            });

            delete server.url;
            server.urls = isString ? urls[0] : urls;
            return !!urls.length;
          }
        });
      }

      // Determines the intersection of local and remote capabilities.
      function getCommonCapabilities(localCapabilities, remoteCapabilities) {
        var commonCapabilities = {
          codecs: [],
          headerExtensions: [],
          fecMechanisms: []
        };

        var findCodecByPayloadType = function findCodecByPayloadType(pt, codecs) {
          pt = parseInt(pt, 10);
          for (var i = 0; i < codecs.length; i++) {
            if (codecs[i].payloadType === pt || codecs[i].preferredPayloadType === pt) {
              return codecs[i];
            }
          }
        };

        var rtxCapabilityMatches = function rtxCapabilityMatches(lRtx, rRtx, lCodecs, rCodecs) {
          var lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs);
          var rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs);
          return lCodec && rCodec && lCodec.name.toLowerCase() === rCodec.name.toLowerCase();
        };

        localCapabilities.codecs.forEach(function (lCodec) {
          for (var i = 0; i < remoteCapabilities.codecs.length; i++) {
            var rCodec = remoteCapabilities.codecs[i];
            if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() && lCodec.clockRate === rCodec.clockRate) {
              if (lCodec.name.toLowerCase() === 'rtx' && lCodec.parameters && rCodec.parameters.apt) {
                // for RTX we need to find the local rtx that has a apt
                // which points to the same local codec as the remote one.
                if (!rtxCapabilityMatches(lCodec, rCodec, localCapabilities.codecs, remoteCapabilities.codecs)) {
                  continue;
                }
              }
              rCodec = JSON.parse((0, _stringify2.default)(rCodec)); // deepcopy
              // number of channels is the highest common number of channels
              rCodec.numChannels = Math.min(lCodec.numChannels, rCodec.numChannels);
              // push rCodec so we reply with offerer payload type
              commonCapabilities.codecs.push(rCodec);

              // determine common feedback mechanisms
              rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function (fb) {
                for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {
                  if (lCodec.rtcpFeedback[j].type === fb.type && lCodec.rtcpFeedback[j].parameter === fb.parameter) {
                    return true;
                  }
                }
                return false;
              });
              // FIXME: also need to determine .parameters
              //  see https://github.com/openpeer/ortc/issues/569
              break;
            }
          }
        });

        localCapabilities.headerExtensions.forEach(function (lHeaderExtension) {
          for (var i = 0; i < remoteCapabilities.headerExtensions.length; i++) {
            var rHeaderExtension = remoteCapabilities.headerExtensions[i];
            if (lHeaderExtension.uri === rHeaderExtension.uri) {
              commonCapabilities.headerExtensions.push(rHeaderExtension);
              break;
            }
          }
        });

        // FIXME: fecMechanisms
        return commonCapabilities;
      }

      // is action=setLocalDescription with type allowed in signalingState
      function isActionAllowedInSignalingState(action, type, signalingState) {
        return {
          offer: {
            setLocalDescription: ['stable', 'have-local-offer'],
            setRemoteDescription: ['stable', 'have-remote-offer']
          },
          answer: {
            setLocalDescription: ['have-remote-offer', 'have-local-pranswer'],
            setRemoteDescription: ['have-local-offer', 'have-remote-pranswer']
          }
        }[type][action].indexOf(signalingState) !== -1;
      }

      function maybeAddCandidate(iceTransport, candidate) {
        // Edge's internal representation adds some fields therefore
        // not all fieldѕ are taken into account.
        var alreadyAdded = iceTransport.getRemoteCandidates().find(function (remoteCandidate) {
          return candidate.foundation === remoteCandidate.foundation && candidate.ip === remoteCandidate.ip && candidate.port === remoteCandidate.port && candidate.priority === remoteCandidate.priority && candidate.protocol === remoteCandidate.protocol && candidate.type === remoteCandidate.type;
        });
        if (!alreadyAdded) {
          iceTransport.addRemoteCandidate(candidate);
        }
        return !alreadyAdded;
      }

      function makeError(name, description) {
        var e = new Error(description);
        e.name = name;
        // legacy error codes from https://heycam.github.io/webidl/#idl-DOMException-error-names
        e.code = {
          NotSupportedError: 9,
          InvalidStateError: 11,
          InvalidAccessError: 15,
          TypeError: undefined,
          OperationError: undefined
        }[name];
        return e;
      }

      module.exports = function (window, edgeVersion) {
        // https://w3c.github.io/mediacapture-main/#mediastream
        // Helper function to add the track to the stream and
        // dispatch the event ourselves.
        function addTrackToStreamAndFireEvent(track, stream) {
          stream.addTrack(track);
          stream.dispatchEvent(new window.MediaStreamTrackEvent('addtrack', { track: track }));
        }

        function removeTrackFromStreamAndFireEvent(track, stream) {
          stream.removeTrack(track);
          stream.dispatchEvent(new window.MediaStreamTrackEvent('removetrack', { track: track }));
        }

        function fireAddTrack(pc, track, receiver, streams) {
          var trackEvent = new Event('track');
          trackEvent.track = track;
          trackEvent.receiver = receiver;
          trackEvent.transceiver = { receiver: receiver };
          trackEvent.streams = streams;
          window.setTimeout(function () {
            pc._dispatchEvent('track', trackEvent);
          });
        }

        var RTCPeerConnection = function RTCPeerConnection(config) {
          var pc = this;

          var _eventTarget = document.createDocumentFragment();
          ['addEventListener', 'removeEventListener', 'dispatchEvent'].forEach(function (method) {
            pc[method] = _eventTarget[method].bind(_eventTarget);
          });

          this.canTrickleIceCandidates = null;

          this.needNegotiation = false;

          this.localStreams = [];
          this.remoteStreams = [];

          this._localDescription = null;
          this._remoteDescription = null;

          this.signalingState = 'stable';
          this.iceConnectionState = 'new';
          this.connectionState = 'new';
          this.iceGatheringState = 'new';

          config = JSON.parse((0, _stringify2.default)(config || {}));

          this.usingBundle = config.bundlePolicy === 'max-bundle';
          if (config.rtcpMuxPolicy === 'negotiate') {
            throw makeError('NotSupportedError', 'rtcpMuxPolicy \'negotiate\' is not supported');
          } else if (!config.rtcpMuxPolicy) {
            config.rtcpMuxPolicy = 'require';
          }

          switch (config.iceTransportPolicy) {
            case 'all':
            case 'relay':
              break;
            default:
              config.iceTransportPolicy = 'all';
              break;
          }

          switch (config.bundlePolicy) {
            case 'balanced':
            case 'max-compat':
            case 'max-bundle':
              break;
            default:
              config.bundlePolicy = 'balanced';
              break;
          }

          config.iceServers = filterIceServers(config.iceServers || [], edgeVersion);

          this._iceGatherers = [];
          if (config.iceCandidatePoolSize) {
            for (var i = config.iceCandidatePoolSize; i > 0; i--) {
              this._iceGatherers.push(new window.RTCIceGatherer({
                iceServers: config.iceServers,
                gatherPolicy: config.iceTransportPolicy
              }));
            }
          } else {
            config.iceCandidatePoolSize = 0;
          }

          this._config = config;

          // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...
          // everything that is needed to describe a SDP m-line.
          this.transceivers = [];

          this._sdpSessionId = SDPUtils.generateSessionId();
          this._sdpSessionVersion = 0;

          this._dtlsRole = undefined; // role for a=setup to use in answers.

          this._isClosed = false;
        };

        Object.defineProperty(RTCPeerConnection.prototype, 'localDescription', {
          configurable: true,
          get: function get() {
            return this._localDescription;
          }
        });
        Object.defineProperty(RTCPeerConnection.prototype, 'remoteDescription', {
          configurable: true,
          get: function get() {
            return this._remoteDescription;
          }
        });

        // set up event handlers on prototype
        RTCPeerConnection.prototype.onicecandidate = null;
        RTCPeerConnection.prototype.onaddstream = null;
        RTCPeerConnection.prototype.ontrack = null;
        RTCPeerConnection.prototype.onremovestream = null;
        RTCPeerConnection.prototype.onsignalingstatechange = null;
        RTCPeerConnection.prototype.oniceconnectionstatechange = null;
        RTCPeerConnection.prototype.onconnectionstatechange = null;
        RTCPeerConnection.prototype.onicegatheringstatechange = null;
        RTCPeerConnection.prototype.onnegotiationneeded = null;
        RTCPeerConnection.prototype.ondatachannel = null;

        RTCPeerConnection.prototype._dispatchEvent = function (name, event) {
          if (this._isClosed) {
            return;
          }
          this.dispatchEvent(event);
          if (typeof this['on' + name] === 'function') {
            this['on' + name](event);
          }
        };

        RTCPeerConnection.prototype._emitGatheringStateChange = function () {
          var event = new Event('icegatheringstatechange');
          this._dispatchEvent('icegatheringstatechange', event);
        };

        RTCPeerConnection.prototype.getConfiguration = function () {
          return this._config;
        };

        RTCPeerConnection.prototype.getLocalStreams = function () {
          return this.localStreams;
        };

        RTCPeerConnection.prototype.getRemoteStreams = function () {
          return this.remoteStreams;
        };

        // internal helper to create a transceiver object.
        // (which is not yet the same as the WebRTC 1.0 transceiver)
        RTCPeerConnection.prototype._createTransceiver = function (kind, doNotAdd) {
          var hasBundleTransport = this.transceivers.length > 0;
          var transceiver = {
            track: null,
            iceGatherer: null,
            iceTransport: null,
            dtlsTransport: null,
            localCapabilities: null,
            remoteCapabilities: null,
            rtpSender: null,
            rtpReceiver: null,
            kind: kind,
            mid: null,
            sendEncodingParameters: null,
            recvEncodingParameters: null,
            stream: null,
            associatedRemoteMediaStreams: [],
            wantReceive: true
          };
          if (this.usingBundle && hasBundleTransport) {
            transceiver.iceTransport = this.transceivers[0].iceTransport;
            transceiver.dtlsTransport = this.transceivers[0].dtlsTransport;
          } else {
            var transports = this._createIceAndDtlsTransports();
            transceiver.iceTransport = transports.iceTransport;
            transceiver.dtlsTransport = transports.dtlsTransport;
          }
          if (!doNotAdd) {
            this.transceivers.push(transceiver);
          }
          return transceiver;
        };

        RTCPeerConnection.prototype.addTrack = function (track, stream) {
          if (this._isClosed) {
            throw makeError('InvalidStateError', 'Attempted to call addTrack on a closed peerconnection.');
          }

          var alreadyExists = this.transceivers.find(function (s) {
            return s.track === track;
          });

          if (alreadyExists) {
            throw makeError('InvalidAccessError', 'Track already exists.');
          }

          var transceiver;
          for (var i = 0; i < this.transceivers.length; i++) {
            if (!this.transceivers[i].track && this.transceivers[i].kind === track.kind) {
              transceiver = this.transceivers[i];
            }
          }
          if (!transceiver) {
            transceiver = this._createTransceiver(track.kind);
          }

          this._maybeFireNegotiationNeeded();

          if (this.localStreams.indexOf(stream) === -1) {
            this.localStreams.push(stream);
          }

          transceiver.track = track;
          transceiver.stream = stream;
          transceiver.rtpSender = new window.RTCRtpSender(track, transceiver.dtlsTransport);
          return transceiver.rtpSender;
        };

        RTCPeerConnection.prototype.addStream = function (stream) {
          var pc = this;
          if (edgeVersion >= 15025) {
            stream.getTracks().forEach(function (track) {
              pc.addTrack(track, stream);
            });
          } else {
            // Clone is necessary for local demos mostly, attaching directly
            // to two different senders does not work (build 10547).
            // Fixed in 15025 (or earlier)
            var clonedStream = stream.clone();
            stream.getTracks().forEach(function (track, idx) {
              var clonedTrack = clonedStream.getTracks()[idx];
              track.addEventListener('enabled', function (event) {
                clonedTrack.enabled = event.enabled;
              });
            });
            clonedStream.getTracks().forEach(function (track) {
              pc.addTrack(track, clonedStream);
            });
          }
        };

        RTCPeerConnection.prototype.removeTrack = function (sender) {
          if (this._isClosed) {
            throw makeError('InvalidStateError', 'Attempted to call removeTrack on a closed peerconnection.');
          }

          if (!(sender instanceof window.RTCRtpSender)) {
            throw new TypeError('Argument 1 of RTCPeerConnection.removeTrack ' + 'does not implement interface RTCRtpSender.');
          }

          var transceiver = this.transceivers.find(function (t) {
            return t.rtpSender === sender;
          });

          if (!transceiver) {
            throw makeError('InvalidAccessError', 'Sender was not created by this connection.');
          }
          var stream = transceiver.stream;

          transceiver.rtpSender.stop();
          transceiver.rtpSender = null;
          transceiver.track = null;
          transceiver.stream = null;

          // remove the stream from the set of local streams
          var localStreams = this.transceivers.map(function (t) {
            return t.stream;
          });
          if (localStreams.indexOf(stream) === -1 && this.localStreams.indexOf(stream) > -1) {
            this.localStreams.splice(this.localStreams.indexOf(stream), 1);
          }

          this._maybeFireNegotiationNeeded();
        };

        RTCPeerConnection.prototype.removeStream = function (stream) {
          var pc = this;
          stream.getTracks().forEach(function (track) {
            var sender = pc.getSenders().find(function (s) {
              return s.track === track;
            });
            if (sender) {
              pc.removeTrack(sender);
            }
          });
        };

        RTCPeerConnection.prototype.getSenders = function () {
          return this.transceivers.filter(function (transceiver) {
            return !!transceiver.rtpSender;
          }).map(function (transceiver) {
            return transceiver.rtpSender;
          });
        };

        RTCPeerConnection.prototype.getReceivers = function () {
          return this.transceivers.filter(function (transceiver) {
            return !!transceiver.rtpReceiver;
          }).map(function (transceiver) {
            return transceiver.rtpReceiver;
          });
        };

        RTCPeerConnection.prototype._createIceGatherer = function (sdpMLineIndex, usingBundle) {
          var pc = this;
          if (usingBundle && sdpMLineIndex > 0) {
            return this.transceivers[0].iceGatherer;
          } else if (this._iceGatherers.length) {
            return this._iceGatherers.shift();
          }
          var iceGatherer = new window.RTCIceGatherer({
            iceServers: this._config.iceServers,
            gatherPolicy: this._config.iceTransportPolicy
          });
          Object.defineProperty(iceGatherer, 'state', { value: 'new', writable: true });

          this.transceivers[sdpMLineIndex].bufferedCandidateEvents = [];
          this.transceivers[sdpMLineIndex].bufferCandidates = function (event) {
            var end = !event.candidate || (0, _keys2.default)(event.candidate).length === 0;
            // polyfill since RTCIceGatherer.state is not implemented in
            // Edge 10547 yet.
            iceGatherer.state = end ? 'completed' : 'gathering';
            if (pc.transceivers[sdpMLineIndex].bufferedCandidateEvents !== null) {
              pc.transceivers[sdpMLineIndex].bufferedCandidateEvents.push(event);
            }
          };
          iceGatherer.addEventListener('localcandidate', this.transceivers[sdpMLineIndex].bufferCandidates);
          return iceGatherer;
        };

        // start gathering from an RTCIceGatherer.
        RTCPeerConnection.prototype._gather = function (mid, sdpMLineIndex) {
          var pc = this;
          var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
          if (iceGatherer.onlocalcandidate) {
            return;
          }
          var bufferedCandidateEvents = this.transceivers[sdpMLineIndex].bufferedCandidateEvents;
          this.transceivers[sdpMLineIndex].bufferedCandidateEvents = null;
          iceGatherer.removeEventListener('localcandidate', this.transceivers[sdpMLineIndex].bufferCandidates);
          iceGatherer.onlocalcandidate = function (evt) {
            if (pc.usingBundle && sdpMLineIndex > 0) {
              // if we know that we use bundle we can drop candidates with
              // ѕdpMLineIndex > 0. If we don't do this then our state gets
              // confused since we dispose the extra ice gatherer.
              return;
            }
            var event = new Event('icecandidate');
            event.candidate = { sdpMid: mid, sdpMLineIndex: sdpMLineIndex };

            var cand = evt.candidate;
            // Edge emits an empty object for RTCIceCandidateComplete‥
            var end = !cand || (0, _keys2.default)(cand).length === 0;
            if (end) {
              // polyfill since RTCIceGatherer.state is not implemented in
              // Edge 10547 yet.
              if (iceGatherer.state === 'new' || iceGatherer.state === 'gathering') {
                iceGatherer.state = 'completed';
              }
            } else {
              if (iceGatherer.state === 'new') {
                iceGatherer.state = 'gathering';
              }
              // RTCIceCandidate doesn't have a component, needs to be added
              cand.component = 1;
              // also the usernameFragment. TODO: update SDP to take both variants.
              cand.ufrag = iceGatherer.getLocalParameters().usernameFragment;

              var serializedCandidate = SDPUtils.writeCandidate(cand);
              event.candidate = (0, _assign2.default)(event.candidate, SDPUtils.parseCandidate(serializedCandidate));

              event.candidate.candidate = serializedCandidate;
              event.candidate.toJSON = function () {
                return {
                  candidate: event.candidate.candidate,
                  sdpMid: event.candidate.sdpMid,
                  sdpMLineIndex: event.candidate.sdpMLineIndex,
                  usernameFragment: event.candidate.usernameFragment
                };
              };
            }

            // update local description.
            var sections = SDPUtils.getMediaSections(pc._localDescription.sdp);
            if (!end) {
              sections[event.candidate.sdpMLineIndex] += 'a=' + event.candidate.candidate + '\r\n';
            } else {
              sections[event.candidate.sdpMLineIndex] += 'a=end-of-candidates\r\n';
            }
            pc._localDescription.sdp = SDPUtils.getDescription(pc._localDescription.sdp) + sections.join('');
            var complete = pc.transceivers.every(function (transceiver) {
              return transceiver.iceGatherer && transceiver.iceGatherer.state === 'completed';
            });

            if (pc.iceGatheringState !== 'gathering') {
              pc.iceGatheringState = 'gathering';
              pc._emitGatheringStateChange();
            }

            // Emit candidate. Also emit null candidate when all gatherers are
            // complete.
            if (!end) {
              pc._dispatchEvent('icecandidate', event);
            }
            if (complete) {
              pc._dispatchEvent('icecandidate', new Event('icecandidate'));
              pc.iceGatheringState = 'complete';
              pc._emitGatheringStateChange();
            }
          };

          // emit already gathered candidates.
          window.setTimeout(function () {
            bufferedCandidateEvents.forEach(function (e) {
              iceGatherer.onlocalcandidate(e);
            });
          }, 0);
        };

        // Create ICE transport and DTLS transport.
        RTCPeerConnection.prototype._createIceAndDtlsTransports = function () {
          var pc = this;
          var iceTransport = new window.RTCIceTransport(null);
          iceTransport.onicestatechange = function () {
            pc._updateIceConnectionState();
            pc._updateConnectionState();
          };

          var dtlsTransport = new window.RTCDtlsTransport(iceTransport);
          dtlsTransport.ondtlsstatechange = function () {
            pc._updateConnectionState();
          };
          dtlsTransport.onerror = function () {
            // onerror does not set state to failed by itself.
            Object.defineProperty(dtlsTransport, 'state', { value: 'failed', writable: true });
            pc._updateConnectionState();
          };

          return {
            iceTransport: iceTransport,
            dtlsTransport: dtlsTransport
          };
        };

        // Destroy ICE gatherer, ICE transport and DTLS transport.
        // Without triggering the callbacks.
        RTCPeerConnection.prototype._disposeIceAndDtlsTransports = function (sdpMLineIndex) {
          var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
          if (iceGatherer) {
            delete iceGatherer.onlocalcandidate;
            delete this.transceivers[sdpMLineIndex].iceGatherer;
          }
          var iceTransport = this.transceivers[sdpMLineIndex].iceTransport;
          if (iceTransport) {
            delete iceTransport.onicestatechange;
            delete this.transceivers[sdpMLineIndex].iceTransport;
          }
          var dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport;
          if (dtlsTransport) {
            delete dtlsTransport.ondtlsstatechange;
            delete dtlsTransport.onerror;
            delete this.transceivers[sdpMLineIndex].dtlsTransport;
          }
        };

        // Start the RTP Sender and Receiver for a transceiver.
        RTCPeerConnection.prototype._transceive = function (transceiver, send, recv) {
          var params = getCommonCapabilities(transceiver.localCapabilities, transceiver.remoteCapabilities);
          if (send && transceiver.rtpSender) {
            params.encodings = transceiver.sendEncodingParameters;
            params.rtcp = {
              cname: SDPUtils.localCName,
              compound: transceiver.rtcpParameters.compound
            };
            if (transceiver.recvEncodingParameters.length) {
              params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;
            }
            transceiver.rtpSender.send(params);
          }
          if (recv && transceiver.rtpReceiver && params.codecs.length > 0) {
            // remove RTX field in Edge 14942
            if (transceiver.kind === 'video' && transceiver.recvEncodingParameters && edgeVersion < 15019) {
              transceiver.recvEncodingParameters.forEach(function (p) {
                delete p.rtx;
              });
            }
            if (transceiver.recvEncodingParameters.length) {
              params.encodings = transceiver.recvEncodingParameters;
            } else {
              params.encodings = [{}];
            }
            params.rtcp = {
              compound: transceiver.rtcpParameters.compound
            };
            if (transceiver.rtcpParameters.cname) {
              params.rtcp.cname = transceiver.rtcpParameters.cname;
            }
            if (transceiver.sendEncodingParameters.length) {
              params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;
            }
            transceiver.rtpReceiver.receive(params);
          }
        };

        RTCPeerConnection.prototype.setLocalDescription = function (description) {
          var pc = this;

          // Note: pranswer is not supported.
          if (['offer', 'answer'].indexOf(description.type) === -1) {
            return _promise2.default.reject(makeError('TypeError', 'Unsupported type "' + description.type + '"'));
          }

          if (!isActionAllowedInSignalingState('setLocalDescription', description.type, pc.signalingState) || pc._isClosed) {
            return _promise2.default.reject(makeError('InvalidStateError', 'Can not set local ' + description.type + ' in state ' + pc.signalingState));
          }

          var sections;
          var sessionpart;
          if (description.type === 'offer') {
            // VERY limited support for SDP munging. Limited to:
            // * changing the order of codecs
            sections = SDPUtils.splitSections(description.sdp);
            sessionpart = sections.shift();
            sections.forEach(function (mediaSection, sdpMLineIndex) {
              var caps = SDPUtils.parseRtpParameters(mediaSection);
              pc.transceivers[sdpMLineIndex].localCapabilities = caps;
            });

            pc.transceivers.forEach(function (transceiver, sdpMLineIndex) {
              pc._gather(transceiver.mid, sdpMLineIndex);
            });
          } else if (description.type === 'answer') {
            sections = SDPUtils.splitSections(pc._remoteDescription.sdp);
            sessionpart = sections.shift();
            var isIceLite = SDPUtils.matchPrefix(sessionpart, 'a=ice-lite').length > 0;
            sections.forEach(function (mediaSection, sdpMLineIndex) {
              var transceiver = pc.transceivers[sdpMLineIndex];
              var iceGatherer = transceiver.iceGatherer;
              var iceTransport = transceiver.iceTransport;
              var dtlsTransport = transceiver.dtlsTransport;
              var localCapabilities = transceiver.localCapabilities;
              var remoteCapabilities = transceiver.remoteCapabilities;

              // treat bundle-only as not-rejected.
              var rejected = SDPUtils.isRejected(mediaSection) && SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;

              if (!rejected && !transceiver.rejected) {
                var remoteIceParameters = SDPUtils.getIceParameters(mediaSection, sessionpart);
                var remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection, sessionpart);
                if (isIceLite) {
                  remoteDtlsParameters.role = 'server';
                }

                if (!pc.usingBundle || sdpMLineIndex === 0) {
                  pc._gather(transceiver.mid, sdpMLineIndex);
                  if (iceTransport.state === 'new') {
                    iceTransport.start(iceGatherer, remoteIceParameters, isIceLite ? 'controlling' : 'controlled');
                  }
                  if (dtlsTransport.state === 'new') {
                    dtlsTransport.start(remoteDtlsParameters);
                  }
                }

                // Calculate intersection of capabilities.
                var params = getCommonCapabilities(localCapabilities, remoteCapabilities);

                // Start the RTCRtpSender. The RTCRtpReceiver for this
                // transceiver has already been started in setRemoteDescription.
                pc._transceive(transceiver, params.codecs.length > 0, false);
              }
            });
          }

          pc._localDescription = {
            type: description.type,
            sdp: description.sdp
          };
          if (description.type === 'offer') {
            pc._updateSignalingState('have-local-offer');
          } else {
            pc._updateSignalingState('stable');
          }

          return _promise2.default.resolve();
        };

        RTCPeerConnection.prototype.setRemoteDescription = function (description) {
          var pc = this;

          // Note: pranswer is not supported.
          if (['offer', 'answer'].indexOf(description.type) === -1) {
            return _promise2.default.reject(makeError('TypeError', 'Unsupported type "' + description.type + '"'));
          }

          if (!isActionAllowedInSignalingState('setRemoteDescription', description.type, pc.signalingState) || pc._isClosed) {
            return _promise2.default.reject(makeError('InvalidStateError', 'Can not set remote ' + description.type + ' in state ' + pc.signalingState));
          }

          var streams = {};
          pc.remoteStreams.forEach(function (stream) {
            streams[stream.id] = stream;
          });
          var receiverList = [];
          var sections = SDPUtils.splitSections(description.sdp);
          var sessionpart = sections.shift();
          var isIceLite = SDPUtils.matchPrefix(sessionpart, 'a=ice-lite').length > 0;
          var usingBundle = SDPUtils.matchPrefix(sessionpart, 'a=group:BUNDLE ').length > 0;
          pc.usingBundle = usingBundle;
          var iceOptions = SDPUtils.matchPrefix(sessionpart, 'a=ice-options:')[0];
          if (iceOptions) {
            pc.canTrickleIceCandidates = iceOptions.substr(14).split(' ').indexOf('trickle') >= 0;
          } else {
            pc.canTrickleIceCandidates = false;
          }

          sections.forEach(function (mediaSection, sdpMLineIndex) {
            var lines = SDPUtils.splitLines(mediaSection);
            var kind = SDPUtils.getKind(mediaSection);
            // treat bundle-only as not-rejected.
            var rejected = SDPUtils.isRejected(mediaSection) && SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;
            var protocol = lines[0].substr(2).split(' ')[2];

            var direction = SDPUtils.getDirection(mediaSection, sessionpart);
            var remoteMsid = SDPUtils.parseMsid(mediaSection);

            var mid = SDPUtils.getMid(mediaSection) || SDPUtils.generateIdentifier();

            // Reject datachannels which are not implemented yet.
            if (rejected || kind === 'application' && (protocol === 'DTLS/SCTP' || protocol === 'UDP/DTLS/SCTP')) {
              // TODO: this is dangerous in the case where a non-rejected m-line
              //     becomes rejected.
              pc.transceivers[sdpMLineIndex] = {
                mid: mid,
                kind: kind,
                protocol: protocol,
                rejected: true
              };
              return;
            }

            if (!rejected && pc.transceivers[sdpMLineIndex] && pc.transceivers[sdpMLineIndex].rejected) {
              // recycle a rejected transceiver.
              pc.transceivers[sdpMLineIndex] = pc._createTransceiver(kind, true);
            }

            var transceiver;
            var iceGatherer;
            var iceTransport;
            var dtlsTransport;
            var rtpReceiver;
            var sendEncodingParameters;
            var recvEncodingParameters;
            var localCapabilities;

            var track;
            // FIXME: ensure the mediaSection has rtcp-mux set.
            var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);
            var remoteIceParameters;
            var remoteDtlsParameters;
            if (!rejected) {
              remoteIceParameters = SDPUtils.getIceParameters(mediaSection, sessionpart);
              remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection, sessionpart);
              remoteDtlsParameters.role = 'client';
            }
            recvEncodingParameters = SDPUtils.parseRtpEncodingParameters(mediaSection);

            var rtcpParameters = SDPUtils.parseRtcpParameters(mediaSection);

            var isComplete = SDPUtils.matchPrefix(mediaSection, 'a=end-of-candidates', sessionpart).length > 0;
            var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:').map(function (cand) {
              return SDPUtils.parseCandidate(cand);
            }).filter(function (cand) {
              return cand.component === 1;
            });

            // Check if we can use BUNDLE and dispose transports.
            if ((description.type === 'offer' || description.type === 'answer') && !rejected && usingBundle && sdpMLineIndex > 0 && pc.transceivers[sdpMLineIndex]) {
              pc._disposeIceAndDtlsTransports(sdpMLineIndex);
              pc.transceivers[sdpMLineIndex].iceGatherer = pc.transceivers[0].iceGatherer;
              pc.transceivers[sdpMLineIndex].iceTransport = pc.transceivers[0].iceTransport;
              pc.transceivers[sdpMLineIndex].dtlsTransport = pc.transceivers[0].dtlsTransport;
              if (pc.transceivers[sdpMLineIndex].rtpSender) {
                pc.transceivers[sdpMLineIndex].rtpSender.setTransport(pc.transceivers[0].dtlsTransport);
              }
              if (pc.transceivers[sdpMLineIndex].rtpReceiver) {
                pc.transceivers[sdpMLineIndex].rtpReceiver.setTransport(pc.transceivers[0].dtlsTransport);
              }
            }
            if (description.type === 'offer' && !rejected) {
              transceiver = pc.transceivers[sdpMLineIndex] || pc._createTransceiver(kind);
              transceiver.mid = mid;

              if (!transceiver.iceGatherer) {
                transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex, usingBundle);
              }

              if (cands.length && transceiver.iceTransport.state === 'new') {
                if (isComplete && (!usingBundle || sdpMLineIndex === 0)) {
                  transceiver.iceTransport.setRemoteCandidates(cands);
                } else {
                  cands.forEach(function (candidate) {
                    maybeAddCandidate(transceiver.iceTransport, candidate);
                  });
                }
              }

              localCapabilities = window.RTCRtpReceiver.getCapabilities(kind);

              // filter RTX until additional stuff needed for RTX is implemented
              // in adapter.js
              if (edgeVersion < 15019) {
                localCapabilities.codecs = localCapabilities.codecs.filter(function (codec) {
                  return codec.name !== 'rtx';
                });
              }

              sendEncodingParameters = transceiver.sendEncodingParameters || [{
                ssrc: (2 * sdpMLineIndex + 2) * 1001
              }];

              // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams
              var isNewTrack = false;
              if (direction === 'sendrecv' || direction === 'sendonly') {
                isNewTrack = !transceiver.rtpReceiver;
                rtpReceiver = transceiver.rtpReceiver || new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);

                if (isNewTrack) {
                  var stream;
                  track = rtpReceiver.track;
                  // FIXME: does not work with Plan B.
                  if (remoteMsid && remoteMsid.stream === '-') {
                    // no-op. a stream id of '-' means: no associated stream.
                  } else if (remoteMsid) {
                    if (!streams[remoteMsid.stream]) {
                      streams[remoteMsid.stream] = new window.MediaStream();
                      Object.defineProperty(streams[remoteMsid.stream], 'id', {
                        get: function get() {
                          return remoteMsid.stream;
                        }
                      });
                    }
                    Object.defineProperty(track, 'id', {
                      get: function get() {
                        return remoteMsid.track;
                      }
                    });
                    stream = streams[remoteMsid.stream];
                  } else {
                    if (!streams.default) {
                      streams.default = new window.MediaStream();
                    }
                    stream = streams.default;
                  }
                  if (stream) {
                    addTrackToStreamAndFireEvent(track, stream);
                    transceiver.associatedRemoteMediaStreams.push(stream);
                  }
                  receiverList.push([track, rtpReceiver, stream]);
                }
              } else if (transceiver.rtpReceiver && transceiver.rtpReceiver.track) {
                transceiver.associatedRemoteMediaStreams.forEach(function (s) {
                  var nativeTrack = s.getTracks().find(function (t) {
                    return t.id === transceiver.rtpReceiver.track.id;
                  });
                  if (nativeTrack) {
                    removeTrackFromStreamAndFireEvent(nativeTrack, s);
                  }
                });
                transceiver.associatedRemoteMediaStreams = [];
              }

              transceiver.localCapabilities = localCapabilities;
              transceiver.remoteCapabilities = remoteCapabilities;
              transceiver.rtpReceiver = rtpReceiver;
              transceiver.rtcpParameters = rtcpParameters;
              transceiver.sendEncodingParameters = sendEncodingParameters;
              transceiver.recvEncodingParameters = recvEncodingParameters;

              // Start the RTCRtpReceiver now. The RTPSender is started in
              // setLocalDescription.
              pc._transceive(pc.transceivers[sdpMLineIndex], false, isNewTrack);
            } else if (description.type === 'answer' && !rejected) {
              transceiver = pc.transceivers[sdpMLineIndex];
              iceGatherer = transceiver.iceGatherer;
              iceTransport = transceiver.iceTransport;
              dtlsTransport = transceiver.dtlsTransport;
              rtpReceiver = transceiver.rtpReceiver;
              sendEncodingParameters = transceiver.sendEncodingParameters;
              localCapabilities = transceiver.localCapabilities;

              pc.transceivers[sdpMLineIndex].recvEncodingParameters = recvEncodingParameters;
              pc.transceivers[sdpMLineIndex].remoteCapabilities = remoteCapabilities;
              pc.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters;

              if (cands.length && iceTransport.state === 'new') {
                if ((isIceLite || isComplete) && (!usingBundle || sdpMLineIndex === 0)) {
                  iceTransport.setRemoteCandidates(cands);
                } else {
                  cands.forEach(function (candidate) {
                    maybeAddCandidate(transceiver.iceTransport, candidate);
                  });
                }
              }

              if (!usingBundle || sdpMLineIndex === 0) {
                if (iceTransport.state === 'new') {
                  iceTransport.start(iceGatherer, remoteIceParameters, 'controlling');
                }
                if (dtlsTransport.state === 'new') {
                  dtlsTransport.start(remoteDtlsParameters);
                }
              }

              // If the offer contained RTX but the answer did not,
              // remove RTX from sendEncodingParameters.
              var commonCapabilities = getCommonCapabilities(transceiver.localCapabilities, transceiver.remoteCapabilities);

              var hasRtx = commonCapabilities.codecs.filter(function (c) {
                return c.name.toLowerCase() === 'rtx';
              }).length;
              if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {
                delete transceiver.sendEncodingParameters[0].rtx;
              }

              pc._transceive(transceiver, direction === 'sendrecv' || direction === 'recvonly', direction === 'sendrecv' || direction === 'sendonly');

              // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams
              if (rtpReceiver && (direction === 'sendrecv' || direction === 'sendonly')) {
                track = rtpReceiver.track;
                if (remoteMsid) {
                  if (!streams[remoteMsid.stream]) {
                    streams[remoteMsid.stream] = new window.MediaStream();
                  }
                  addTrackToStreamAndFireEvent(track, streams[remoteMsid.stream]);
                  receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]);
                } else {
                  if (!streams.default) {
                    streams.default = new window.MediaStream();
                  }
                  addTrackToStreamAndFireEvent(track, streams.default);
                  receiverList.push([track, rtpReceiver, streams.default]);
                }
              } else {
                // FIXME: actually the receiver should be created later.
                delete transceiver.rtpReceiver;
              }
            }
          });

          if (pc._dtlsRole === undefined) {
            pc._dtlsRole = description.type === 'offer' ? 'active' : 'passive';
          }

          pc._remoteDescription = {
            type: description.type,
            sdp: description.sdp
          };
          if (description.type === 'offer') {
            pc._updateSignalingState('have-remote-offer');
          } else {
            pc._updateSignalingState('stable');
          }
          (0, _keys2.default)(streams).forEach(function (sid) {
            var stream = streams[sid];
            if (stream.getTracks().length) {
              if (pc.remoteStreams.indexOf(stream) === -1) {
                pc.remoteStreams.push(stream);
                var event = new Event('addstream');
                event.stream = stream;
                window.setTimeout(function () {
                  pc._dispatchEvent('addstream', event);
                });
              }

              receiverList.forEach(function (item) {
                var track = item[0];
                var receiver = item[1];
                if (stream.id !== item[2].id) {
                  return;
                }
                fireAddTrack(pc, track, receiver, [stream]);
              });
            }
          });
          receiverList.forEach(function (item) {
            if (item[2]) {
              return;
            }
            fireAddTrack(pc, item[0], item[1], []);
          });

          // check whether addIceCandidate({}) was called within four seconds after
          // setRemoteDescription.
          window.setTimeout(function () {
            if (!(pc && pc.transceivers)) {
              return;
            }
            pc.transceivers.forEach(function (transceiver) {
              if (transceiver.iceTransport && transceiver.iceTransport.state === 'new' && transceiver.iceTransport.getRemoteCandidates().length > 0) {
                console.warn('Timeout for addRemoteCandidate. Consider sending ' + 'an end-of-candidates notification');
                transceiver.iceTransport.addRemoteCandidate({});
              }
            });
          }, 4000);

          return _promise2.default.resolve();
        };

        RTCPeerConnection.prototype.close = function () {
          this.transceivers.forEach(function (transceiver) {
            /* not yet
            if (transceiver.iceGatherer) {
              transceiver.iceGatherer.close();
            }
            */
            if (transceiver.iceTransport) {
              transceiver.iceTransport.stop();
            }
            if (transceiver.dtlsTransport) {
              transceiver.dtlsTransport.stop();
            }
            if (transceiver.rtpSender) {
              transceiver.rtpSender.stop();
            }
            if (transceiver.rtpReceiver) {
              transceiver.rtpReceiver.stop();
            }
          });
          // FIXME: clean up tracks, local streams, remote streams, etc
          this._isClosed = true;
          this._updateSignalingState('closed');
        };

        // Update the signaling state.
        RTCPeerConnection.prototype._updateSignalingState = function (newState) {
          this.signalingState = newState;
          var event = new Event('signalingstatechange');
          this._dispatchEvent('signalingstatechange', event);
        };

        // Determine whether to fire the negotiationneeded event.
        RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function () {
          var pc = this;
          if (this.signalingState !== 'stable' || this.needNegotiation === true) {
            return;
          }
          this.needNegotiation = true;
          window.setTimeout(function () {
            if (pc.needNegotiation) {
              pc.needNegotiation = false;
              var event = new Event('negotiationneeded');
              pc._dispatchEvent('negotiationneeded', event);
            }
          }, 0);
        };

        // Update the ice connection state.
        RTCPeerConnection.prototype._updateIceConnectionState = function () {
          var newState;
          var states = {
            'new': 0,
            closed: 0,
            checking: 0,
            connected: 0,
            completed: 0,
            disconnected: 0,
            failed: 0
          };
          this.transceivers.forEach(function (transceiver) {
            if (transceiver.iceTransport && !transceiver.rejected) {
              states[transceiver.iceTransport.state]++;
            }
          });

          newState = 'new';
          if (states.failed > 0) {
            newState = 'failed';
          } else if (states.checking > 0) {
            newState = 'checking';
          } else if (states.disconnected > 0) {
            newState = 'disconnected';
          } else if (states.new > 0) {
            newState = 'new';
          } else if (states.connected > 0) {
            newState = 'connected';
          } else if (states.completed > 0) {
            newState = 'completed';
          }

          if (newState !== this.iceConnectionState) {
            this.iceConnectionState = newState;
            var event = new Event('iceconnectionstatechange');
            this._dispatchEvent('iceconnectionstatechange', event);
          }
        };

        // Update the connection state.
        RTCPeerConnection.prototype._updateConnectionState = function () {
          var newState;
          var states = {
            'new': 0,
            closed: 0,
            connecting: 0,
            connected: 0,
            completed: 0,
            disconnected: 0,
            failed: 0
          };
          this.transceivers.forEach(function (transceiver) {
            if (transceiver.iceTransport && transceiver.dtlsTransport && !transceiver.rejected) {
              states[transceiver.iceTransport.state]++;
              states[transceiver.dtlsTransport.state]++;
            }
          });
          // ICETransport.completed and connected are the same for this purpose.
          states.connected += states.completed;

          newState = 'new';
          if (states.failed > 0) {
            newState = 'failed';
          } else if (states.connecting > 0) {
            newState = 'connecting';
          } else if (states.disconnected > 0) {
            newState = 'disconnected';
          } else if (states.new > 0) {
            newState = 'new';
          } else if (states.connected > 0) {
            newState = 'connected';
          }

          if (newState !== this.connectionState) {
            this.connectionState = newState;
            var event = new Event('connectionstatechange');
            this._dispatchEvent('connectionstatechange', event);
          }
        };

        RTCPeerConnection.prototype.createOffer = function () {
          var pc = this;

          if (pc._isClosed) {
            return _promise2.default.reject(makeError('InvalidStateError', 'Can not call createOffer after close'));
          }

          var numAudioTracks = pc.transceivers.filter(function (t) {
            return t.kind === 'audio';
          }).length;
          var numVideoTracks = pc.transceivers.filter(function (t) {
            return t.kind === 'video';
          }).length;

          // Determine number of audio and video tracks we need to send/recv.
          var offerOptions = arguments[0];
          if (offerOptions) {
            // Reject Chrome legacy constraints.
            if (offerOptions.mandatory || offerOptions.optional) {
              throw new TypeError('Legacy mandatory/optional constraints not supported.');
            }
            if (offerOptions.offerToReceiveAudio !== undefined) {
              if (offerOptions.offerToReceiveAudio === true) {
                numAudioTracks = 1;
              } else if (offerOptions.offerToReceiveAudio === false) {
                numAudioTracks = 0;
              } else {
                numAudioTracks = offerOptions.offerToReceiveAudio;
              }
            }
            if (offerOptions.offerToReceiveVideo !== undefined) {
              if (offerOptions.offerToReceiveVideo === true) {
                numVideoTracks = 1;
              } else if (offerOptions.offerToReceiveVideo === false) {
                numVideoTracks = 0;
              } else {
                numVideoTracks = offerOptions.offerToReceiveVideo;
              }
            }
          }

          pc.transceivers.forEach(function (transceiver) {
            if (transceiver.kind === 'audio') {
              numAudioTracks--;
              if (numAudioTracks < 0) {
                transceiver.wantReceive = false;
              }
            } else if (transceiver.kind === 'video') {
              numVideoTracks--;
              if (numVideoTracks < 0) {
                transceiver.wantReceive = false;
              }
            }
          });

          // Create M-lines for recvonly streams.
          while (numAudioTracks > 0 || numVideoTracks > 0) {
            if (numAudioTracks > 0) {
              pc._createTransceiver('audio');
              numAudioTracks--;
            }
            if (numVideoTracks > 0) {
              pc._createTransceiver('video');
              numVideoTracks--;
            }
          }

          var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId, pc._sdpSessionVersion++);
          pc.transceivers.forEach(function (transceiver, sdpMLineIndex) {
            // For each track, create an ice gatherer, ice transport,
            // dtls transport, potentially rtpsender and rtpreceiver.
            var track = transceiver.track;
            var kind = transceiver.kind;
            var mid = transceiver.mid || SDPUtils.generateIdentifier();
            transceiver.mid = mid;

            if (!transceiver.iceGatherer) {
              transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex, pc.usingBundle);
            }

            var localCapabilities = window.RTCRtpSender.getCapabilities(kind);
            // filter RTX until additional stuff needed for RTX is implemented
            // in adapter.js
            if (edgeVersion < 15019) {
              localCapabilities.codecs = localCapabilities.codecs.filter(function (codec) {
                return codec.name !== 'rtx';
              });
            }
            localCapabilities.codecs.forEach(function (codec) {
              // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552
              // by adding level-asymmetry-allowed=1
              if (codec.name === 'H264' && codec.parameters['level-asymmetry-allowed'] === undefined) {
                codec.parameters['level-asymmetry-allowed'] = '1';
              }

              // for subsequent offers, we might have to re-use the payload
              // type of the last offer.
              if (transceiver.remoteCapabilities && transceiver.remoteCapabilities.codecs) {
                transceiver.remoteCapabilities.codecs.forEach(function (remoteCodec) {
                  if (codec.name.toLowerCase() === remoteCodec.name.toLowerCase() && codec.clockRate === remoteCodec.clockRate) {
                    codec.preferredPayloadType = remoteCodec.payloadType;
                  }
                });
              }
            });
            localCapabilities.headerExtensions.forEach(function (hdrExt) {
              var remoteExtensions = transceiver.remoteCapabilities && transceiver.remoteCapabilities.headerExtensions || [];
              remoteExtensions.forEach(function (rHdrExt) {
                if (hdrExt.uri === rHdrExt.uri) {
                  hdrExt.id = rHdrExt.id;
                }
              });
            });

            // generate an ssrc now, to be used later in rtpSender.send
            var sendEncodingParameters = transceiver.sendEncodingParameters || [{
              ssrc: (2 * sdpMLineIndex + 1) * 1001
            }];
            if (track) {
              // add RTX
              if (edgeVersion >= 15019 && kind === 'video' && !sendEncodingParameters[0].rtx) {
                sendEncodingParameters[0].rtx = {
                  ssrc: sendEncodingParameters[0].ssrc + 1
                };
              }
            }

            if (transceiver.wantReceive) {
              transceiver.rtpReceiver = new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);
            }

            transceiver.localCapabilities = localCapabilities;
            transceiver.sendEncodingParameters = sendEncodingParameters;
          });

          // always offer BUNDLE and dispose on return if not supported.
          if (pc._config.bundlePolicy !== 'max-compat') {
            sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function (t) {
              return t.mid;
            }).join(' ') + '\r\n';
          }
          sdp += 'a=ice-options:trickle\r\n';

          pc.transceivers.forEach(function (transceiver, sdpMLineIndex) {
            sdp += writeMediaSection(transceiver, transceiver.localCapabilities, 'offer', transceiver.stream, pc._dtlsRole);
            sdp += 'a=rtcp-rsize\r\n';

            if (transceiver.iceGatherer && pc.iceGatheringState !== 'new' && (sdpMLineIndex === 0 || !pc.usingBundle)) {
              transceiver.iceGatherer.getLocalCandidates().forEach(function (cand) {
                cand.component = 1;
                sdp += 'a=' + SDPUtils.writeCandidate(cand) + '\r\n';
              });

              if (transceiver.iceGatherer.state === 'completed') {
                sdp += 'a=end-of-candidates\r\n';
              }
            }
          });

          var desc = new window.RTCSessionDescription({
            type: 'offer',
            sdp: sdp
          });
          return _promise2.default.resolve(desc);
        };

        RTCPeerConnection.prototype.createAnswer = function () {
          var pc = this;

          if (pc._isClosed) {
            return _promise2.default.reject(makeError('InvalidStateError', 'Can not call createAnswer after close'));
          }

          if (!(pc.signalingState === 'have-remote-offer' || pc.signalingState === 'have-local-pranswer')) {
            return _promise2.default.reject(makeError('InvalidStateError', 'Can not call createAnswer in signalingState ' + pc.signalingState));
          }

          var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId, pc._sdpSessionVersion++);
          if (pc.usingBundle) {
            sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function (t) {
              return t.mid;
            }).join(' ') + '\r\n';
          }
          sdp += 'a=ice-options:trickle\r\n';

          var mediaSectionsInOffer = SDPUtils.getMediaSections(pc._remoteDescription.sdp).length;
          pc.transceivers.forEach(function (transceiver, sdpMLineIndex) {
            if (sdpMLineIndex + 1 > mediaSectionsInOffer) {
              return;
            }
            if (transceiver.rejected) {
              if (transceiver.kind === 'application') {
                if (transceiver.protocol === 'DTLS/SCTP') {
                  // legacy fmt
                  sdp += 'm=application 0 DTLS/SCTP 5000\r\n';
                } else {
                  sdp += 'm=application 0 ' + transceiver.protocol + ' webrtc-datachannel\r\n';
                }
              } else if (transceiver.kind === 'audio') {
                sdp += 'm=audio 0 UDP/TLS/RTP/SAVPF 0\r\n' + 'a=rtpmap:0 PCMU/8000\r\n';
              } else if (transceiver.kind === 'video') {
                sdp += 'm=video 0 UDP/TLS/RTP/SAVPF 120\r\n' + 'a=rtpmap:120 VP8/90000\r\n';
              }
              sdp += 'c=IN IP4 0.0.0.0\r\n' + 'a=inactive\r\n' + 'a=mid:' + transceiver.mid + '\r\n';
              return;
            }

            // FIXME: look at direction.
            if (transceiver.stream) {
              var localTrack;
              if (transceiver.kind === 'audio') {
                localTrack = transceiver.stream.getAudioTracks()[0];
              } else if (transceiver.kind === 'video') {
                localTrack = transceiver.stream.getVideoTracks()[0];
              }
              if (localTrack) {
                // add RTX
                if (edgeVersion >= 15019 && transceiver.kind === 'video' && !transceiver.sendEncodingParameters[0].rtx) {
                  transceiver.sendEncodingParameters[0].rtx = {
                    ssrc: transceiver.sendEncodingParameters[0].ssrc + 1
                  };
                }
              }
            }

            // Calculate intersection of capabilities.
            var commonCapabilities = getCommonCapabilities(transceiver.localCapabilities, transceiver.remoteCapabilities);

            var hasRtx = commonCapabilities.codecs.filter(function (c) {
              return c.name.toLowerCase() === 'rtx';
            }).length;
            if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {
              delete transceiver.sendEncodingParameters[0].rtx;
            }

            sdp += writeMediaSection(transceiver, commonCapabilities, 'answer', transceiver.stream, pc._dtlsRole);
            if (transceiver.rtcpParameters && transceiver.rtcpParameters.reducedSize) {
              sdp += 'a=rtcp-rsize\r\n';
            }
          });

          var desc = new window.RTCSessionDescription({
            type: 'answer',
            sdp: sdp
          });
          return _promise2.default.resolve(desc);
        };

        RTCPeerConnection.prototype.addIceCandidate = function (candidate) {
          var pc = this;
          var sections;
          if (candidate && !(candidate.sdpMLineIndex !== undefined || candidate.sdpMid)) {
            return _promise2.default.reject(new TypeError('sdpMLineIndex or sdpMid required'));
          }

          // TODO: needs to go into ops queue.
          return new _promise2.default(function (resolve, reject) {
            if (!pc._remoteDescription) {
              return reject(makeError('InvalidStateError', 'Can not add ICE candidate without a remote description'));
            } else if (!candidate || candidate.candidate === '') {
              for (var j = 0; j < pc.transceivers.length; j++) {
                if (pc.transceivers[j].rejected) {
                  continue;
                }
                pc.transceivers[j].iceTransport.addRemoteCandidate({});
                sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp);
                sections[j] += 'a=end-of-candidates\r\n';
                pc._remoteDescription.sdp = SDPUtils.getDescription(pc._remoteDescription.sdp) + sections.join('');
                if (pc.usingBundle) {
                  break;
                }
              }
            } else {
              var sdpMLineIndex = candidate.sdpMLineIndex;
              if (candidate.sdpMid) {
                for (var i = 0; i < pc.transceivers.length; i++) {
                  if (pc.transceivers[i].mid === candidate.sdpMid) {
                    sdpMLineIndex = i;
                    break;
                  }
                }
              }
              var transceiver = pc.transceivers[sdpMLineIndex];
              if (transceiver) {
                if (transceiver.rejected) {
                  return resolve();
                }
                var cand = (0, _keys2.default)(candidate.candidate).length > 0 ? SDPUtils.parseCandidate(candidate.candidate) : {};
                // Ignore Chrome's invalid candidates since Edge does not like them.
                if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {
                  return resolve();
                }
                // Ignore RTCP candidates, we assume RTCP-MUX.
                if (cand.component && cand.component !== 1) {
                  return resolve();
                }
                // when using bundle, avoid adding candidates to the wrong
                // ice transport. And avoid adding candidates added in the SDP.
                if (sdpMLineIndex === 0 || sdpMLineIndex > 0 && transceiver.iceTransport !== pc.transceivers[0].iceTransport) {
                  if (!maybeAddCandidate(transceiver.iceTransport, cand)) {
                    return reject(makeError('OperationError', 'Can not add ICE candidate'));
                  }
                }

                // update the remoteDescription.
                var candidateString = candidate.candidate.trim();
                if (candidateString.indexOf('a=') === 0) {
                  candidateString = candidateString.substr(2);
                }
                sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp);
                sections[sdpMLineIndex] += 'a=' + (cand.type ? candidateString : 'end-of-candidates') + '\r\n';
                pc._remoteDescription.sdp = SDPUtils.getDescription(pc._remoteDescription.sdp) + sections.join('');
              } else {
                return reject(makeError('OperationError', 'Can not add ICE candidate'));
              }
            }
            resolve();
          });
        };

        RTCPeerConnection.prototype.getStats = function (selector) {
          if (selector && selector instanceof window.MediaStreamTrack) {
            var senderOrReceiver = null;
            this.transceivers.forEach(function (transceiver) {
              if (transceiver.rtpSender && transceiver.rtpSender.track === selector) {
                senderOrReceiver = transceiver.rtpSender;
              } else if (transceiver.rtpReceiver && transceiver.rtpReceiver.track === selector) {
                senderOrReceiver = transceiver.rtpReceiver;
              }
            });
            if (!senderOrReceiver) {
              throw makeError('InvalidAccessError', 'Invalid selector.');
            }
            return senderOrReceiver.getStats();
          }

          var promises = [];
          this.transceivers.forEach(function (transceiver) {
            ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport', 'dtlsTransport'].forEach(function (method) {
              if (transceiver[method]) {
                promises.push(transceiver[method].getStats());
              }
            });
          });
          return _promise2.default.all(promises).then(function (allStats) {
            var results = new _map2.default();
            allStats.forEach(function (stats) {
              stats.forEach(function (stat) {
                results.set(stat.id, stat);
              });
            });
            return results;
          });
        };

        // fix low-level stat names and return Map instead of object.
        var ortcObjects = ['RTCRtpSender', 'RTCRtpReceiver', 'RTCIceGatherer', 'RTCIceTransport', 'RTCDtlsTransport'];
        ortcObjects.forEach(function (ortcObjectName) {
          var obj = window[ortcObjectName];
          if (obj && obj.prototype && obj.prototype.getStats) {
            var nativeGetstats = obj.prototype.getStats;
            obj.prototype.getStats = function () {
              return nativeGetstats.apply(this).then(function (nativeStats) {
                var mapStats = new _map2.default();
                (0, _keys2.default)(nativeStats).forEach(function (id) {
                  nativeStats[id].type = fixStatsType(nativeStats[id]);
                  mapStats.set(id, nativeStats[id]);
                });
                return mapStats;
              });
            };
          }
        });

        // legacy callback shims. Should be moved to adapter.js some days.
        var methods = ['createOffer', 'createAnswer'];
        methods.forEach(function (method) {
          var nativeMethod = RTCPeerConnection.prototype[method];
          RTCPeerConnection.prototype[method] = function () {
            var args = arguments;
            if (typeof args[0] === 'function' || typeof args[1] === 'function') {
              // legacy
              return nativeMethod.apply(this, [arguments[2]]).then(function (description) {
                if (typeof args[0] === 'function') {
                  args[0].apply(null, [description]);
                }
              }, function (error) {
                if (typeof args[1] === 'function') {
                  args[1].apply(null, [error]);
                }
              });
            }
            return nativeMethod.apply(this, arguments);
          };
        });

        methods = ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'];
        methods.forEach(function (method) {
          var nativeMethod = RTCPeerConnection.prototype[method];
          RTCPeerConnection.prototype[method] = function () {
            var args = arguments;
            if (typeof args[1] === 'function' || typeof args[2] === 'function') {
              // legacy
              return nativeMethod.apply(this, arguments).then(function () {
                if (typeof args[1] === 'function') {
                  args[1].apply(null);
                }
              }, function (error) {
                if (typeof args[2] === 'function') {
                  args[2].apply(null, [error]);
                }
              });
            }
            return nativeMethod.apply(this, arguments);
          };
        });

        // getStats is special. It doesn't have a spec legacy method yet we support
        // getStats(something, cb) without error callbacks.
        ['getStats'].forEach(function (method) {
          var nativeMethod = RTCPeerConnection.prototype[method];
          RTCPeerConnection.prototype[method] = function () {
            var args = arguments;
            if (typeof args[1] === 'function') {
              return nativeMethod.apply(this, arguments).then(function () {
                if (typeof args[1] === 'function') {
                  args[1].apply(null);
                }
              });
            }
            return nativeMethod.apply(this, arguments);
          };
        });

        return RTCPeerConnection;
      };
    }, { "sdp": 17 }], 17: [function (require, module, exports) {
      /* eslint-env node */
      'use strict';

      // SDP helpers.

      var SDPUtils = {};

      // Generate an alphanumeric identifier for cname or mids.
      // TODO: use UUIDs instead? https://gist.github.com/jed/982883
      SDPUtils.generateIdentifier = function () {
        return Math.random().toString(36).substr(2, 10);
      };

      // The RTCP CNAME used by all peerconnections from the same JS.
      SDPUtils.localCName = SDPUtils.generateIdentifier();

      // Splits SDP into lines, dealing with both CRLF and LF.
      SDPUtils.splitLines = function (blob) {
        return blob.trim().split('\n').map(function (line) {
          return line.trim();
        });
      };
      // Splits SDP into sessionpart and mediasections. Ensures CRLF.
      SDPUtils.splitSections = function (blob) {
        var parts = blob.split('\nm=');
        return parts.map(function (part, index) {
          return (index > 0 ? 'm=' + part : part).trim() + '\r\n';
        });
      };

      // returns the session description.
      SDPUtils.getDescription = function (blob) {
        var sections = SDPUtils.splitSections(blob);
        return sections && sections[0];
      };

      // returns the individual media sections.
      SDPUtils.getMediaSections = function (blob) {
        var sections = SDPUtils.splitSections(blob);
        sections.shift();
        return sections;
      };

      // Returns lines that start with a certain prefix.
      SDPUtils.matchPrefix = function (blob, prefix) {
        return SDPUtils.splitLines(blob).filter(function (line) {
          return line.indexOf(prefix) === 0;
        });
      };

      // Parses an ICE candidate line. Sample input:
      // candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
      // rport 55996"
      SDPUtils.parseCandidate = function (line) {
        var parts;
        // Parse both variants.
        if (line.indexOf('a=candidate:') === 0) {
          parts = line.substring(12).split(' ');
        } else {
          parts = line.substring(10).split(' ');
        }

        var candidate = {
          foundation: parts[0],
          component: parseInt(parts[1], 10),
          protocol: parts[2].toLowerCase(),
          priority: parseInt(parts[3], 10),
          ip: parts[4],
          address: parts[4], // address is an alias for ip.
          port: parseInt(parts[5], 10),
          // skip parts[6] == 'typ'
          type: parts[7]
        };

        for (var i = 8; i < parts.length; i += 2) {
          switch (parts[i]) {
            case 'raddr':
              candidate.relatedAddress = parts[i + 1];
              break;
            case 'rport':
              candidate.relatedPort = parseInt(parts[i + 1], 10);
              break;
            case 'tcptype':
              candidate.tcpType = parts[i + 1];
              break;
            case 'ufrag':
              candidate.ufrag = parts[i + 1]; // for backward compability.
              candidate.usernameFragment = parts[i + 1];
              break;
            default:
              // extension handling, in particular ufrag
              candidate[parts[i]] = parts[i + 1];
              break;
          }
        }
        return candidate;
      };

      // Translates a candidate object into SDP candidate attribute.
      SDPUtils.writeCandidate = function (candidate) {
        var sdp = [];
        sdp.push(candidate.foundation);
        sdp.push(candidate.component);
        sdp.push(candidate.protocol.toUpperCase());
        sdp.push(candidate.priority);
        sdp.push(candidate.address || candidate.ip);
        sdp.push(candidate.port);

        var type = candidate.type;
        sdp.push('typ');
        sdp.push(type);
        if (type !== 'host' && candidate.relatedAddress && candidate.relatedPort) {
          sdp.push('raddr');
          sdp.push(candidate.relatedAddress);
          sdp.push('rport');
          sdp.push(candidate.relatedPort);
        }
        if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
          sdp.push('tcptype');
          sdp.push(candidate.tcpType);
        }
        if (candidate.usernameFragment || candidate.ufrag) {
          sdp.push('ufrag');
          sdp.push(candidate.usernameFragment || candidate.ufrag);
        }
        return 'candidate:' + sdp.join(' ');
      };

      // Parses an ice-options line, returns an array of option tags.
      // a=ice-options:foo bar
      SDPUtils.parseIceOptions = function (line) {
        return line.substr(14).split(' ');
      };

      // Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:
      // a=rtpmap:111 opus/48000/2
      SDPUtils.parseRtpMap = function (line) {
        var parts = line.substr(9).split(' ');
        var parsed = {
          payloadType: parseInt(parts.shift(), 10) // was: id
        };

        parts = parts[0].split('/');

        parsed.name = parts[0];
        parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
        parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
        // legacy alias, got renamed back to channels in ORTC.
        parsed.numChannels = parsed.channels;
        return parsed;
      };

      // Generate an a=rtpmap line from RTCRtpCodecCapability or
      // RTCRtpCodecParameters.
      SDPUtils.writeRtpMap = function (codec) {
        var pt = codec.payloadType;
        if (codec.preferredPayloadType !== undefined) {
          pt = codec.preferredPayloadType;
        }
        var channels = codec.channels || codec.numChannels || 1;
        return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate + (channels !== 1 ? '/' + channels : '') + '\r\n';
      };

      // Parses an a=extmap line (headerextension from RFC 5285). Sample input:
      // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
      // a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset
      SDPUtils.parseExtmap = function (line) {
        var parts = line.substr(9).split(' ');
        return {
          id: parseInt(parts[0], 10),
          direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
          uri: parts[1]
        };
      };

      // Generates a=extmap line from RTCRtpHeaderExtensionParameters or
      // RTCRtpHeaderExtension.
      SDPUtils.writeExtmap = function (headerExtension) {
        return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== 'sendrecv' ? '/' + headerExtension.direction : '') + ' ' + headerExtension.uri + '\r\n';
      };

      // Parses an ftmp line, returns dictionary. Sample input:
      // a=fmtp:96 vbr=on;cng=on
      // Also deals with vbr=on; cng=on
      SDPUtils.parseFmtp = function (line) {
        var parsed = {};
        var kv;
        var parts = line.substr(line.indexOf(' ') + 1).split(';');
        for (var j = 0; j < parts.length; j++) {
          kv = parts[j].trim().split('=');
          parsed[kv[0].trim()] = kv[1];
        }
        return parsed;
      };

      // Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
      SDPUtils.writeFmtp = function (codec) {
        var line = '';
        var pt = codec.payloadType;
        if (codec.preferredPayloadType !== undefined) {
          pt = codec.preferredPayloadType;
        }
        if (codec.parameters && (0, _keys2.default)(codec.parameters).length) {
          var params = [];
          (0, _keys2.default)(codec.parameters).forEach(function (param) {
            if (codec.parameters[param]) {
              params.push(param + '=' + codec.parameters[param]);
            } else {
              params.push(param);
            }
          });
          line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
        }
        return line;
      };

      // Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
      // a=rtcp-fb:98 nack rpsi
      SDPUtils.parseRtcpFb = function (line) {
        var parts = line.substr(line.indexOf(' ') + 1).split(' ');
        return {
          type: parts.shift(),
          parameter: parts.join(' ')
        };
      };
      // Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
      SDPUtils.writeRtcpFb = function (codec) {
        var lines = '';
        var pt = codec.payloadType;
        if (codec.preferredPayloadType !== undefined) {
          pt = codec.preferredPayloadType;
        }
        if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
          // FIXME: special handling for trr-int?
          codec.rtcpFeedback.forEach(function (fb) {
            lines += 'a=rtcp-fb:' + pt + ' ' + fb.type + (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') + '\r\n';
          });
        }
        return lines;
      };

      // Parses an RFC 5576 ssrc media attribute. Sample input:
      // a=ssrc:3735928559 cname:something
      SDPUtils.parseSsrcMedia = function (line) {
        var sp = line.indexOf(' ');
        var parts = {
          ssrc: parseInt(line.substr(7, sp - 7), 10)
        };
        var colon = line.indexOf(':', sp);
        if (colon > -1) {
          parts.attribute = line.substr(sp + 1, colon - sp - 1);
          parts.value = line.substr(colon + 1);
        } else {
          parts.attribute = line.substr(sp + 1);
        }
        return parts;
      };

      SDPUtils.parseSsrcGroup = function (line) {
        var parts = line.substr(13).split(' ');
        return {
          semantics: parts.shift(),
          ssrcs: parts.map(function (ssrc) {
            return parseInt(ssrc, 10);
          })
        };
      };

      // Extracts the MID (RFC 5888) from a media section.
      // returns the MID or undefined if no mid line was found.
      SDPUtils.getMid = function (mediaSection) {
        var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];
        if (mid) {
          return mid.substr(6);
        }
      };

      SDPUtils.parseFingerprint = function (line) {
        var parts = line.substr(14).split(' ');
        return {
          algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.
          value: parts[1]
        };
      };

      // Extracts DTLS parameters from SDP media section or sessionpart.
      // FIXME: for consistency with other functions this should only
      //   get the fingerprint line as input. See also getIceParameters.
      SDPUtils.getDtlsParameters = function (mediaSection, sessionpart) {
        var lines = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=fingerprint:');
        // Note: a=setup line is ignored since we use the 'auto' role.
        // Note2: 'algorithm' is not case sensitive except in Edge.
        return {
          role: 'auto',
          fingerprints: lines.map(SDPUtils.parseFingerprint)
        };
      };

      // Serializes DTLS parameters to SDP.
      SDPUtils.writeDtlsParameters = function (params, setupType) {
        var sdp = 'a=setup:' + setupType + '\r\n';
        params.fingerprints.forEach(function (fp) {
          sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
        });
        return sdp;
      };

      // Parses a=crypto lines into
      //   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members
      SDPUtils.parseCryptoLine = function (line) {
        var parts = line.substr(9).split(' ');
        return {
          tag: parseInt(parts[0], 10),
          cryptoSuite: parts[1],
          keyParams: parts[2],
          sessionParams: parts.slice(3)
        };
      };

      SDPUtils.writeCryptoLine = function (parameters) {
        return 'a=crypto:' + parameters.tag + ' ' + parameters.cryptoSuite + ' ' + ((0, _typeof4.default)(parameters.keyParams) === 'object' ? SDPUtils.writeCryptoKeyParams(parameters.keyParams) : parameters.keyParams) + (parameters.sessionParams ? ' ' + parameters.sessionParams.join(' ') : '') + '\r\n';
      };

      // Parses the crypto key parameters into
      //   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*
      SDPUtils.parseCryptoKeyParams = function (keyParams) {
        if (keyParams.indexOf('inline:') !== 0) {
          return null;
        }
        var parts = keyParams.substr(7).split('|');
        return {
          keyMethod: 'inline',
          keySalt: parts[0],
          lifeTime: parts[1],
          mkiValue: parts[2] ? parts[2].split(':')[0] : undefined,
          mkiLength: parts[2] ? parts[2].split(':')[1] : undefined
        };
      };

      SDPUtils.writeCryptoKeyParams = function (keyParams) {
        return keyParams.keyMethod + ':' + keyParams.keySalt + (keyParams.lifeTime ? '|' + keyParams.lifeTime : '') + (keyParams.mkiValue && keyParams.mkiLength ? '|' + keyParams.mkiValue + ':' + keyParams.mkiLength : '');
      };

      // Extracts all SDES paramters.
      SDPUtils.getCryptoParameters = function (mediaSection, sessionpart) {
        var lines = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=crypto:');
        return lines.map(SDPUtils.parseCryptoLine);
      };

      // Parses ICE information from SDP media section or sessionpart.
      // FIXME: for consistency with other functions this should only
      //   get the ice-ufrag and ice-pwd lines as input.
      SDPUtils.getIceParameters = function (mediaSection, sessionpart) {
        var ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=ice-ufrag:')[0];
        var pwd = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=ice-pwd:')[0];
        if (!(ufrag && pwd)) {
          return null;
        }
        return {
          usernameFragment: ufrag.substr(12),
          password: pwd.substr(10)
        };
      };

      // Serializes ICE parameters to SDP.
      SDPUtils.writeIceParameters = function (params) {
        return 'a=ice-ufrag:' + params.usernameFragment + '\r\n' + 'a=ice-pwd:' + params.password + '\r\n';
      };

      // Parses the SDP media section and returns RTCRtpParameters.
      SDPUtils.parseRtpParameters = function (mediaSection) {
        var description = {
          codecs: [],
          headerExtensions: [],
          fecMechanisms: [],
          rtcp: []
        };
        var lines = SDPUtils.splitLines(mediaSection);
        var mline = lines[0].split(' ');
        for (var i = 3; i < mline.length; i++) {
          // find all codecs from mline[3..]
          var pt = mline[i];
          var rtpmapline = SDPUtils.matchPrefix(mediaSection, 'a=rtpmap:' + pt + ' ')[0];
          if (rtpmapline) {
            var codec = SDPUtils.parseRtpMap(rtpmapline);
            var fmtps = SDPUtils.matchPrefix(mediaSection, 'a=fmtp:' + pt + ' ');
            // Only the first a=fmtp:<pt> is considered.
            codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
            codec.rtcpFeedback = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-fb:' + pt + ' ').map(SDPUtils.parseRtcpFb);
            description.codecs.push(codec);
            // parse FEC mechanisms from rtpmap lines.
            switch (codec.name.toUpperCase()) {
              case 'RED':
              case 'ULPFEC':
                description.fecMechanisms.push(codec.name.toUpperCase());
                break;
              default:
                // only RED and ULPFEC are recognized as FEC mechanisms.
                break;
            }
          }
        }
        SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function (line) {
          description.headerExtensions.push(SDPUtils.parseExtmap(line));
        });
        // FIXME: parse rtcp.
        return description;
      };

      // Generates parts of the SDP media section describing the capabilities /
      // parameters.
      SDPUtils.writeRtpDescription = function (kind, caps) {
        var sdp = '';

        // Build the mline.
        sdp += 'm=' + kind + ' ';
        sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.
        sdp += ' UDP/TLS/RTP/SAVPF ';
        sdp += caps.codecs.map(function (codec) {
          if (codec.preferredPayloadType !== undefined) {
            return codec.preferredPayloadType;
          }
          return codec.payloadType;
        }).join(' ') + '\r\n';

        sdp += 'c=IN IP4 0.0.0.0\r\n';
        sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';

        // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
        caps.codecs.forEach(function (codec) {
          sdp += SDPUtils.writeRtpMap(codec);
          sdp += SDPUtils.writeFmtp(codec);
          sdp += SDPUtils.writeRtcpFb(codec);
        });
        var maxptime = 0;
        caps.codecs.forEach(function (codec) {
          if (codec.maxptime > maxptime) {
            maxptime = codec.maxptime;
          }
        });
        if (maxptime > 0) {
          sdp += 'a=maxptime:' + maxptime + '\r\n';
        }
        sdp += 'a=rtcp-mux\r\n';

        if (caps.headerExtensions) {
          caps.headerExtensions.forEach(function (extension) {
            sdp += SDPUtils.writeExtmap(extension);
          });
        }
        // FIXME: write fecMechanisms.
        return sdp;
      };

      // Parses the SDP media section and returns an array of
      // RTCRtpEncodingParameters.
      SDPUtils.parseRtpEncodingParameters = function (mediaSection) {
        var encodingParameters = [];
        var description = SDPUtils.parseRtpParameters(mediaSection);
        var hasRed = description.fecMechanisms.indexOf('RED') !== -1;
        var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;

        // filter a=ssrc:... cname:, ignore PlanB-msid
        var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(function (line) {
          return SDPUtils.parseSsrcMedia(line);
        }).filter(function (parts) {
          return parts.attribute === 'cname';
        });
        var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
        var secondarySsrc;

        var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID').map(function (line) {
          var parts = line.substr(17).split(' ');
          return parts.map(function (part) {
            return parseInt(part, 10);
          });
        });
        if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
          secondarySsrc = flows[0][1];
        }

        description.codecs.forEach(function (codec) {
          if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
            var encParam = {
              ssrc: primarySsrc,
              codecPayloadType: parseInt(codec.parameters.apt, 10)
            };
            if (primarySsrc && secondarySsrc) {
              encParam.rtx = { ssrc: secondarySsrc };
            }
            encodingParameters.push(encParam);
            if (hasRed) {
              encParam = JSON.parse((0, _stringify2.default)(encParam));
              encParam.fec = {
                ssrc: primarySsrc,
                mechanism: hasUlpfec ? 'red+ulpfec' : 'red'
              };
              encodingParameters.push(encParam);
            }
          }
        });
        if (encodingParameters.length === 0 && primarySsrc) {
          encodingParameters.push({
            ssrc: primarySsrc
          });
        }

        // we support both b=AS and b=TIAS but interpret AS as TIAS.
        var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');
        if (bandwidth.length) {
          if (bandwidth[0].indexOf('b=TIAS:') === 0) {
            bandwidth = parseInt(bandwidth[0].substr(7), 10);
          } else if (bandwidth[0].indexOf('b=AS:') === 0) {
            // use formula from JSEP to convert b=AS to TIAS value.
            bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95 - 50 * 40 * 8;
          } else {
            bandwidth = undefined;
          }
          encodingParameters.forEach(function (params) {
            params.maxBitrate = bandwidth;
          });
        }
        return encodingParameters;
      };

      // parses http://draft.ortc.org/#rtcrtcpparameters*
      SDPUtils.parseRtcpParameters = function (mediaSection) {
        var rtcpParameters = {};

        // Gets the first SSRC. Note tha with RTX there might be multiple
        // SSRCs.
        var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(function (line) {
          return SDPUtils.parseSsrcMedia(line);
        }).filter(function (obj) {
          return obj.attribute === 'cname';
        })[0];
        if (remoteSsrc) {
          rtcpParameters.cname = remoteSsrc.value;
          rtcpParameters.ssrc = remoteSsrc.ssrc;
        }

        // Edge uses the compound attribute instead of reducedSize
        // compound is !reducedSize
        var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
        rtcpParameters.reducedSize = rsize.length > 0;
        rtcpParameters.compound = rsize.length === 0;

        // parses the rtcp-mux attrіbute.
        // Note that Edge does not support unmuxed RTCP.
        var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
        rtcpParameters.mux = mux.length > 0;

        return rtcpParameters;
      };

      // parses either a=msid: or a=ssrc:... msid lines and returns
      // the id of the MediaStream and MediaStreamTrack.
      SDPUtils.parseMsid = function (mediaSection) {
        var parts;
        var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');
        if (spec.length === 1) {
          parts = spec[0].substr(7).split(' ');
          return { stream: parts[0], track: parts[1] };
        }
        var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(function (line) {
          return SDPUtils.parseSsrcMedia(line);
        }).filter(function (msidParts) {
          return msidParts.attribute === 'msid';
        });
        if (planB.length > 0) {
          parts = planB[0].value.split(' ');
          return { stream: parts[0], track: parts[1] };
        }
      };

      // SCTP
      // parses draft-ietf-mmusic-sctp-sdp-26 first and falls back
      // to draft-ietf-mmusic-sctp-sdp-05
      SDPUtils.parseSctpDescription = function (mediaSection) {
        var mline = SDPUtils.parseMLine(mediaSection);
        var maxSizeLine = SDPUtils.matchPrefix(mediaSection, 'a=max-message-size:');
        var maxMessageSize;
        if (maxSizeLine.length > 0) {
          maxMessageSize = parseInt(maxSizeLine[0].substr(19), 10);
        }
        if (isNaN(maxMessageSize)) {
          maxMessageSize = 65536;
        }
        var sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');
        if (sctpPort.length > 0) {
          return {
            port: parseInt(sctpPort[0].substr(12), 10),
            protocol: mline.fmt,
            maxMessageSize: maxMessageSize
          };
        }
        var sctpMapLines = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:');
        if (sctpMapLines.length > 0) {
          var parts = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:')[0].substr(10).split(' ');
          return {
            port: parseInt(parts[0], 10),
            protocol: parts[1],
            maxMessageSize: maxMessageSize
          };
        }
      };

      // SCTP
      // outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers
      // support by now receiving in this format, unless we originally parsed
      // as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line
      // protocol of DTLS/SCTP -- without UDP/ or TCP/)
      SDPUtils.writeSctpDescription = function (media, sctp) {
        var output = [];
        if (media.protocol !== 'DTLS/SCTP') {
          output = ['m=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.protocol + '\r\n', 'c=IN IP4 0.0.0.0\r\n', 'a=sctp-port:' + sctp.port + '\r\n'];
        } else {
          output = ['m=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.port + '\r\n', 'c=IN IP4 0.0.0.0\r\n', 'a=sctpmap:' + sctp.port + ' ' + sctp.protocol + ' 65535\r\n'];
        }
        if (sctp.maxMessageSize !== undefined) {
          output.push('a=max-message-size:' + sctp.maxMessageSize + '\r\n');
        }
        return output.join('');
      };

      // Generate a session ID for SDP.
      // https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1
      // recommends using a cryptographically random +ve 64-bit value
      // but right now this should be acceptable and within the right range
      SDPUtils.generateSessionId = function () {
        return Math.random().toString().substr(2, 21);
      };

      // Write boilder plate for start of SDP
      // sessId argument is optional - if not supplied it will
      // be generated randomly
      // sessVersion is optional and defaults to 2
      // sessUser is optional and defaults to 'thisisadapterortc'
      SDPUtils.writeSessionBoilerplate = function (sessId, sessVer, sessUser) {
        var sessionId;
        var version = sessVer !== undefined ? sessVer : 2;
        if (sessId) {
          sessionId = sessId;
        } else {
          sessionId = SDPUtils.generateSessionId();
        }
        var user = sessUser || 'thisisadapterortc';
        // FIXME: sess-id should be an NTP timestamp.
        return 'v=0\r\n' + 'o=' + user + ' ' + sessionId + ' ' + version + ' IN IP4 127.0.0.1\r\n' + 's=-\r\n' + 't=0 0\r\n';
      };

      SDPUtils.writeMediaSection = function (transceiver, caps, type, stream) {
        var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

        // Map ICE parameters (ufrag, pwd) to SDP.
        sdp += SDPUtils.writeIceParameters(transceiver.iceGatherer.getLocalParameters());

        // Map DTLS parameters to SDP.
        sdp += SDPUtils.writeDtlsParameters(transceiver.dtlsTransport.getLocalParameters(), type === 'offer' ? 'actpass' : 'active');

        sdp += 'a=mid:' + transceiver.mid + '\r\n';

        if (transceiver.direction) {
          sdp += 'a=' + transceiver.direction + '\r\n';
        } else if (transceiver.rtpSender && transceiver.rtpReceiver) {
          sdp += 'a=sendrecv\r\n';
        } else if (transceiver.rtpSender) {
          sdp += 'a=sendonly\r\n';
        } else if (transceiver.rtpReceiver) {
          sdp += 'a=recvonly\r\n';
        } else {
          sdp += 'a=inactive\r\n';
        }

        if (transceiver.rtpSender) {
          // spec.
          var msid = 'msid:' + stream.id + ' ' + transceiver.rtpSender.track.id + '\r\n';
          sdp += 'a=' + msid;

          // for Chrome.
          sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc + ' ' + msid;
          if (transceiver.sendEncodingParameters[0].rtx) {
            sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc + ' ' + msid;
            sdp += 'a=ssrc-group:FID ' + transceiver.sendEncodingParameters[0].ssrc + ' ' + transceiver.sendEncodingParameters[0].rtx.ssrc + '\r\n';
          }
        }
        // FIXME: this should be written by writeRtpDescription.
        sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc + ' cname:' + SDPUtils.localCName + '\r\n';
        if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
          sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc + ' cname:' + SDPUtils.localCName + '\r\n';
        }
        return sdp;
      };

      // Gets the direction from the mediaSection or the sessionpart.
      SDPUtils.getDirection = function (mediaSection, sessionpart) {
        // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
        var lines = SDPUtils.splitLines(mediaSection);
        for (var i = 0; i < lines.length; i++) {
          switch (lines[i]) {
            case 'a=sendrecv':
            case 'a=sendonly':
            case 'a=recvonly':
            case 'a=inactive':
              return lines[i].substr(2);
            default:
            // FIXME: What should happen here?
          }
        }
        if (sessionpart) {
          return SDPUtils.getDirection(sessionpart);
        }
        return 'sendrecv';
      };

      SDPUtils.getKind = function (mediaSection) {
        var lines = SDPUtils.splitLines(mediaSection);
        var mline = lines[0].split(' ');
        return mline[0].substr(2);
      };

      SDPUtils.isRejected = function (mediaSection) {
        return mediaSection.split(' ', 2)[1] === '0';
      };

      SDPUtils.parseMLine = function (mediaSection) {
        var lines = SDPUtils.splitLines(mediaSection);
        var parts = lines[0].substr(2).split(' ');
        return {
          kind: parts[0],
          port: parseInt(parts[1], 10),
          protocol: parts[2],
          fmt: parts.slice(3).join(' ')
        };
      };

      SDPUtils.parseOLine = function (mediaSection) {
        var line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];
        var parts = line.substr(2).split(' ');
        return {
          username: parts[0],
          sessionId: parts[1],
          sessionVersion: parseInt(parts[2], 10),
          netType: parts[3],
          addressType: parts[4],
          address: parts[5]
        };
      };

      // a very naive interpretation of a valid SDP.
      SDPUtils.isValidSDP = function (blob) {
        if (typeof blob !== 'string' || blob.length === 0) {
          return false;
        }
        var lines = SDPUtils.splitLines(blob);
        for (var i = 0; i < lines.length; i++) {
          if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {
            return false;
          }
          // TODO: check the modifier a bit more.
        }
        return true;
      };

      // Expose public methods.
      if ((typeof module === "undefined" ? "undefined" : (0, _typeof4.default)(module)) === 'object') {
        module.exports = SDPUtils;
      }
    }, {}] }, {}, [1])(1);
});

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(150), __esModule: true };

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(151);
module.exports = __webpack_require__(84).Object.assign;


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(82);

$export($export.S + $export.F, 'Object', { assign: __webpack_require__(152) });


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var DESCRIPTORS = __webpack_require__(92);
var getKeys = __webpack_require__(103);
var gOPS = __webpack_require__(131);
var pIE = __webpack_require__(132);
var toObject = __webpack_require__(119);
var IObject = __webpack_require__(106);
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(93)(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
    }
  } return T;
} : $assign;


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(154), __esModule: true };

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(155);
var $Object = __webpack_require__(84).Object;
module.exports = function getOwnPropertyDescriptor(it, key) {
  return $Object.getOwnPropertyDescriptor(it, key);
};


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = __webpack_require__(105);
var $getOwnPropertyDescriptor = __webpack_require__(136).f;

__webpack_require__(143)('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(157), __esModule: true };

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(137);
__webpack_require__(76);
__webpack_require__(120);
__webpack_require__(158);
__webpack_require__(176);
__webpack_require__(177);
module.exports = __webpack_require__(84).Promise;


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(81);
var global = __webpack_require__(83);
var ctx = __webpack_require__(85);
var classof = __webpack_require__(159);
var $export = __webpack_require__(82);
var isObject = __webpack_require__(90);
var aFunction = __webpack_require__(86);
var anInstance = __webpack_require__(160);
var forOf = __webpack_require__(161);
var speciesConstructor = __webpack_require__(165);
var task = __webpack_require__(166).set;
var microtask = __webpack_require__(168)();
var newPromiseCapabilityModule = __webpack_require__(169);
var perform = __webpack_require__(170);
var userAgent = __webpack_require__(171);
var promiseResolve = __webpack_require__(172);
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[__webpack_require__(117)('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __webpack_require__(173)($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__webpack_require__(116)($Promise, PROMISE);
__webpack_require__(174)(PROMISE);
Wrapper = __webpack_require__(84)[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(175)(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(107);
var TAG = __webpack_require__(117)('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),
/* 160 */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(85);
var call = __webpack_require__(162);
var isArrayIter = __webpack_require__(163);
var anObject = __webpack_require__(89);
var toLength = __webpack_require__(109);
var getIterFn = __webpack_require__(164);
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(89);
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(99);
var ITERATOR = __webpack_require__(117)('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(159);
var ITERATOR = __webpack_require__(117)('iterator');
var Iterators = __webpack_require__(99);
module.exports = __webpack_require__(84).getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(89);
var aFunction = __webpack_require__(86);
var SPECIES = __webpack_require__(117)('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(85);
var invoke = __webpack_require__(167);
var html = __webpack_require__(115);
var cel = __webpack_require__(94);
var global = __webpack_require__(83);
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (__webpack_require__(107)(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};


/***/ }),
/* 167 */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(83);
var macrotask = __webpack_require__(166).set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(107)(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 25.4.1.5 NewPromiseCapability(C)
var aFunction = __webpack_require__(86);

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),
/* 170 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(83);
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(89);
var isObject = __webpack_require__(90);
var newPromiseCapability = __webpack_require__(169);

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

var hide = __webpack_require__(87);
module.exports = function (target, src, safe) {
  for (var key in src) {
    if (safe && target[key]) target[key] = src[key];
    else hide(target, key, src[key]);
  } return target;
};


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(83);
var core = __webpack_require__(84);
var dP = __webpack_require__(88);
var DESCRIPTORS = __webpack_require__(92);
var SPECIES = __webpack_require__(117)('species');

module.exports = function (KEY) {
  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(117)('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// https://github.com/tc39/proposal-promise-finally

var $export = __webpack_require__(82);
var core = __webpack_require__(84);
var global = __webpack_require__(83);
var speciesConstructor = __webpack_require__(165);
var promiseResolve = __webpack_require__(172);

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-promise-try
var $export = __webpack_require__(82);
var newPromiseCapability = __webpack_require__(169);
var perform = __webpack_require__(170);

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(179), __esModule: true };

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(180);
module.exports = __webpack_require__(84).Object.keys;


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(119);
var $keys = __webpack_require__(103);

__webpack_require__(143)('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(182), __esModule: true };

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(137);
__webpack_require__(76);
__webpack_require__(120);
__webpack_require__(183);
__webpack_require__(190);
__webpack_require__(193);
__webpack_require__(195);
module.exports = __webpack_require__(84).Map;


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(184);
var validate = __webpack_require__(185);
var MAP = 'Map';

// 23.1 Map Objects
module.exports = __webpack_require__(186)(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var dP = __webpack_require__(88).f;
var create = __webpack_require__(101);
var redefineAll = __webpack_require__(173);
var ctx = __webpack_require__(85);
var anInstance = __webpack_require__(160);
var forOf = __webpack_require__(161);
var $iterDefine = __webpack_require__(80);
var step = __webpack_require__(123);
var setSpecies = __webpack_require__(174);
var DESCRIPTORS = __webpack_require__(92);
var fastKey = __webpack_require__(128).fastKey;
var validate = __webpack_require__(185);
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(90);
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(83);
var $export = __webpack_require__(82);
var meta = __webpack_require__(128);
var fails = __webpack_require__(93);
var hide = __webpack_require__(87);
var redefineAll = __webpack_require__(173);
var forOf = __webpack_require__(161);
var anInstance = __webpack_require__(160);
var isObject = __webpack_require__(90);
var setToStringTag = __webpack_require__(116);
var dP = __webpack_require__(88).f;
var each = __webpack_require__(187)(0);
var DESCRIPTORS = __webpack_require__(92);

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  if (!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    C = wrapper(function (target, iterable) {
      anInstance(target, C, NAME, '_c');
      target._c = new Base();
      if (iterable != undefined) forOf(iterable, IS_MAP, target[ADDER], target);
    });
    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','), function (KEY) {
      var IS_ADDER = KEY == 'add' || KEY == 'set';
      if (KEY in proto && !(IS_WEAK && KEY == 'clear')) hide(C.prototype, KEY, function (a, b) {
        anInstance(this, C, KEY);
        if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false;
        var result = this._c[KEY](a === 0 ? 0 : a, b);
        return IS_ADDER ? this : result;
      });
    });
    IS_WEAK || dP(C.prototype, 'size', {
      get: function () {
        return this._c.size;
      }
    });
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F, O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__(85);
var IObject = __webpack_require__(106);
var toObject = __webpack_require__(119);
var toLength = __webpack_require__(109);
var asc = __webpack_require__(188);
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(189);

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(90);
var isArray = __webpack_require__(133);
var SPECIES = __webpack_require__(117)('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__(82);

$export($export.P + $export.R, 'Map', { toJSON: __webpack_require__(191)('Map') });


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = __webpack_require__(159);
var from = __webpack_require__(192);
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

var forOf = __webpack_require__(161);

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
__webpack_require__(194)('Map');


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(82);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = new Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
__webpack_require__(196)('Map');


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(82);
var aFunction = __webpack_require__(86);
var ctx = __webpack_require__(85);
var forOf = __webpack_require__(161);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(198), __esModule: true };

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(199);
var $Object = __webpack_require__(84).Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(82);
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(92), 'Object', { defineProperty: __webpack_require__(88).f });


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _keys = __webpack_require__(178);

var _keys2 = _interopRequireDefault(_keys);

var _regenerator = __webpack_require__(201);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _stringify = __webpack_require__(144);

var _stringify2 = _interopRequireDefault(_stringify);

var _asyncToGenerator2 = __webpack_require__(204);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _typeof2 = __webpack_require__(73);

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//Service 类，会创建session(me), 并且将current属性设置为 me; 以后方法需要此值


var _util = __webpack_require__(72);
var _ = __webpack_require__(205);

var _logger = _util.tagLogger("Service");

var Session = __webpack_require__(207);

var Attendee = __webpack_require__(211);

var __event = __webpack_require__(208);
var EventHandler = __webpack_require__(217);

var __Desktop = __webpack_require__(218);

var __desktop = new __Desktop({
    onExtLoaded: function onExtLoaded() {
        _logger.info("Share desktop ext. had loaded.");
    }
});

var __Stream = __webpack_require__(215);
var PCStats = __webpack_require__(219);

var DefaultMouseTrack = __webpack_require__(220);

/**
 * {
 *  newSession:
 *  onCalling:
 *  onRinging:
 *
 *
 * }
 *
 *
 *
 */
module.exports = _util.prototypeExtend({
    __init__: function __init__() {
        var self = this;

        _logger.warn("emedia version: ", window._emediaVersion || "unkown");
        _logger.warn("UserAgent: ", navigator.userAgent);

        var urlLogLevel = _util.parseURL("__log_level___");
        if (urlLogLevel) {
            emedia.LOG_LEVEL = parseInt(urlLogLevel);
        }

        // if(self.ticket && _util.isPlainObject(self.ticket)){
        //     self.setup(self.ticket);
        // }

        self.namespace = Math.uuidFast();
        emedia.useCurrentXService = self;

        if (self.useRTCCfg === undefined) {
            self.useRTCCfg = emedia.config.useRTCCfgIfServerReturn;
        }

        if (typeof self.useRTCCfg === "string") {
            self.useRTCCfg = JSON.parse(self.useRTCCfg);
        }

        self.inboundAudio = PCStats.inboundAudio.bind(self);
        self.inboundVideo = PCStats.inboundVideo.bind(self);
        self.outboundAudio = PCStats.outboundAudio.bind(self);
        self.outboundVideo = PCStats.outboundVideo.bind(self);

        // if(self.listeners){
        //     for(var funcName in self.listeners){
        //         var name = funcName;
        //         var func = self.listeners[name];
        //         if(typeof func === 'undefined'
        //             || name === 'onRecvRemoteMessage'
        //             || name === 'onSoundChanage'
        //             || name === 'onTalking'){
        //             continue;
        //         }
        //
        //         self.listeners["__user_" + name] = func;
        //         self.listeners[name] = (function(name, func) {
        //             return (function () {
        //                 _logger.info("sdk call user impl func. func=", name, self.current && self.current.getMemberId());
        //                 func.apply(this, arguments);
        //             })
        //         })(name, func);
        //     }
        // }

        // 接收到的session
        self._cache_receive_sessions = [];
    },

    AVPubstream: __Stream.extend({
        __init__: function __init__() {
            var self = this;

            self.type = 0;
            self._located = true;

            self.mutedMuted = true;

            if (self.constaints) {
                self.constaints.video || (self.voff = 1);
                self.constaints.audio || (self.aoff = 1);
            }
            //self.constaints || (self.constaints = {audio: !self.aoff, video: !self.voff});
            self.constaints || (self.constaints = { audio: true, video: true });

            emedia.config.maxVideoBitrate && (self.vbitrate = emedia.config.maxVideoBitrate);
            emedia.config.maxAudioBitrate && (self.abitrate = emedia.config.maxAudioBitrate);
        }
    }),

    AudioMixerPubstream: new __Stream.extend({
        __init__: function __init__() {
            var self = this;

            self.type = 2;
            self._located = true;

            self.mutedMuted = true;

            self.constaints || (self.constaints = { audio: true, video: false });
            if (self.constaints) {
                var audio = !!self.constaints.audio;
                //self.constaints.audio = true;
                self.constaints.video || (self.constaints.video = false);

                self.constaints.video || (self.voff = 1);
                self.constaints.audio || (self.aoff = 1);

                audio === false && (self.aoff = 1);
            }

            emedia.config.maxVideoBitrate && (self.vbitrate = emedia.config.maxVideoBitrate);
            emedia.config.maxAudioBitrate && (self.abitrate = emedia.config.maxAudioBitrate);
        },

        onGotRemoteMediaStream: function onGotRemoteMediaStream(remoteMediaStream) {
            var self = this;

            if (!self.remotePlayAudioObject) {
                var _audioId = "__o_remote_play_audio_" + self.id;
                var audioObject = document.querySelector("#" + _audioId);
                if (audioObject) {
                    //audioObject.remove();
                } else {
                    audioObject = document.createElement("audio");

                    audioObject.style.display = "none";
                    audioObject.id = "__o_remote_play_audio_" + self.id;
                    audioObject.autoplay = true;
                    audioObject.playsinline = true;

                    document.body.appendChild(audioObject);
                }

                //monitorEvents && monitorEvents(audioObject);

                self.remotePlayAudioObject = audioObject;
            }

            // self.remotePlayAudioObject.autoplay = true;
            // self.remotePlayAudioObject.playsinline = true;
            self.remotePlayAudioObject.srcObject = remoteMediaStream;

            //window.__$_remoteMediaStream = remoteMediaStream;
        }
    }),

    //screenOptions ['screen', 'window', 'tab']
    ShareDesktopPubstream: __Stream.extend({
        voff: 0,

        __init__: function __init__() {
            var self = this;

            self.type = 1;
            self._located = true;

            self.mutedMuted = true;
            self.constaints = { audio: !this.aoff, video: true };

            emedia.config.maxVideoBitrate && (self.vbitrate = emedia.config.maxVideoBitrate);
            emedia.config.maxAudioBitrate && (self.abitrate = emedia.config.maxAudioBitrate);
        }
    }),

    __assertCurrent: function __assertCurrent() {
        var self = this;
        if (!self.current) {
            _logger.error("Please call emedia.service.setup(ticket)");
            throw "Please call emedia.service.setup(ticket)";
        }
        if (self.current.closed) {
            _logger.error("current closed");
            throw "current closed";
        }
    },

    hasAudioMixers: function hasAudioMixers() {
        var self = this;

        self.__assertCurrent();

        for (var sid in self.current.audioMixers) {
            var stream = self.current.audioMixers[sid];
            if (stream && stream.located()) {
                return true;
            }
        }
    },

    getMediaDevices: function getMediaDevices(kind, devices, errorCallback) {
        if (typeof kind === 'function') {
            errorCallback = devices;
            devices = kind;
            kind = undefined;
        }

        function gotDevices(deviceInfos) {
            var resultDeviceInfos = [];

            for (var i = 0; i !== deviceInfos.length; ++i) {
                var deviceInfo = deviceInfos[i];
                //var deviceId = deviceInfo.deviceId;

                if (!kind) {
                    resultDeviceInfos.push(deviceInfo);
                } else if (kind === deviceInfo.kind) {
                    resultDeviceInfos.push(deviceInfo);
                } else if (deviceInfo.kind === 'audioinput') {} else if (deviceInfo.kind === 'audiooutput') {} else if (deviceInfo.kind === 'videoinput') {} else {
                    _logger.info('Some other kind of source/device: ', deviceInfo);
                }
            }

            devices && devices(resultDeviceInfos);
        }

        navigator.mediaDevices.enumerateDevices().then(gotDevices).catch(function handleError(error) {
            _logger.warn('navigator.getUserMedia error: ', error);
            errorCallback && errorCallback(error);
        });
    },

    //有些机器必须得getUserMedia后才能够产生正常得cands
    //比如 safair不调用getUserMedia，将不产生cands；window chrome75，则产生得cands中没有ip 而且 uuid.local
    // requireRights: function(success, errorCallback){
    //     function gotDevices(deviceInfos) {
    //         var resultDeviceInfos = [];
    //
    //         for (var i = 0; i !== deviceInfos.length; ++i) {
    //             var deviceInfo = deviceInfos[i];
    //             _logger.info('Got device: ', deviceInfo);
    //         }
    //
    //         success && success(resultDeviceInfos);
    //     }
    //     navigator.mediaDevices.enumerateDevices().then(gotDevices).catch(function handleError(error) {
    //         _logger.warn('navigator.getUserMedia error: ', error);
    //         errorCallback && errorCallback(error);
    //     });
    // },

    // Attach audio output device to video element using device/sink ID.
    // sinkId deviceInfo.deviceId;
    // attachSinkId(videoElement, deviceInfo.deviceId);
    attachSinkId: function attachSinkId(videoObj, sinkId) {
        if (typeof videoObj.sinkId !== 'undefined') {
            videoObj.setSinkId(sinkId).then(function () {
                _logger.info('Success, audio output device attached: ' + sinkId);
            }).catch(function (error) {
                var errorMessage = error;
                if (error.name === 'SecurityError') {
                    errorMessage = 'You need to use HTTPS for selecting audio output ' + 'device: ' + error;
                }
                _logger.warn(errorMessage);
            });
        } else {
            _logger.warn('Browser does not support output device selection.');
        }
    },

    _stopTracks: function _stopTracks(_stream) {
        emedia.stopTracks(_stream);
        _stream && _logger.warn("Stream tracks stop. it = ", _stream);
    },
    _enableVideoTracks: function _enableVideoTracks(_stream, enabled) {
        emedia.enableVideoTracks(_stream, enabled);
    },
    _enableAudioTracks: function _enableAudioTracks(_stream, enabled) {
        emedia.enableAudioTracks(_stream, enabled);
    },

    /**
     * 手机 前置
     * video:{ 'facingMode': "user" }//调用前置摄像头
     * video: { facingMode: { exact: "environment" } }//后置
     *
     * @param pubS
     * @returns {{then: then}}
     */
    openUserMedia: function openUserMedia(pubS) {
        _logger.debug("begin open user media", pubS);

        var self = this;

        //self.__assertCurrent();

        if (!pubS) {
            _logger.error("require pubS");
            throw "require pubS";
        }

        return {
            then: function then(_success, errCallback) {
                // stream.oninactive = self._onStreamInactive.bind(self, stream);
                // stream.onactive = self._onStreamActive.bind(self, stream);

                function success() {
                    _success.apply(null, arguments);

                    var mediaStream = pubS.localStream;
                    if (mediaStream) {
                        mediaStream.oninactive = self._onStreamInactive.bind(self, pubS, mediaStream);
                        mediaStream.onactive = self._onStreamActive.bind(self, pubS, mediaStream);
                    }
                }

                if (pubS instanceof self.AVPubstream) {
                    self._openCamera(pubS, success, errCallback);
                } else if (pubS instanceof self.ShareDesktopPubstream) {
                    self._openSharedDesktop(pubS, success, errCallback);
                } else if (pubS instanceof self.AudioMixerPubstream) {
                    self._openCamera(pubS, success, errCallback);
                } else {
                    _logger.error("Unspported pubS");
                    throw "Unspported pubS";
                }
            }
        };
    },

    _openSharedDesktop: function _openSharedDesktop(pubS, success, errCallback) {
        var self = this;

        //self.__assertCurrent();

        function getAudioStream(pubS) {
            var audioConstaints = { audio: true };
            if (pubS.constaints) {
                if ((0, _typeof3.default)(pubS.constaints.audio) === 'object' && pubS.constaints.audio) {} else if (!pubS.constaints.audio) {
                    audioConstaints.audio = false;
                }
            }
            self.__getUserMedia(audioConstaints, function (_user, stream) {
                var mediaStream = new MediaStream();
                mediaStream._located = true;

                stream && stream.getAudioTracks().forEach(function (track) {
                    mediaStream.addTrack(track);
                });

                pubS.localStream && pubS.localStream.getVideoTracks().forEach(function (track) {
                    mediaStream.addTrack(track);
                });

                pubS.localStream = mediaStream;

                success && success(self.current, mediaStream);
            }, errCallback);
        }

        var videoTracks;
        if (pubS._localMediaStream && (videoTracks = pubS._localMediaStream.getVideoTracks()) && videoTracks.length > 0) {
            pubS.localStream = pubS._localMediaStream;

            if (pubS.constaints.audio) {
                getAudioStream(pubS);
            } else {
                success && success(self.current, stream);
            }

            return;
        }

        //screenOptions ['screen', 'window', 'tab']
        __desktop.openDesktopMedia(pubS.screenOptions || ['screen', 'window', 'tab'], function (_event) {
            if (_event instanceof __event.OpenDesktopMedia) {
                var desktopStreamId = _event.desktopStreamId;
                _logger.warn("desktop streamId", desktopStreamId);

                var constraints = {
                    audio: false,
                    video: {
                        mandatory: _util.extend(pubS.mandatory || {}, {
                            chromeMediaSource: 'desktop',
                            chromeMediaSourceId: desktopStreamId
                            // maxWidth: window.screen.width > 1920 ? window.screen.width : 1920,
                            // maxHeight: window.screen.height > 1080 ? window.screen.height : 1080
                        }),
                        optional: []
                    }
                };

                //delete pubS.mandatory;

                self.__getUserMedia(constraints, function (_me, stream) {
                    pubS.localStream = stream;

                    if (pubS.constaints.audio) {
                        getAudioStream(pubS);
                    } else {
                        success && success(self.current, stream);
                    }
                }, errCallback);
            } else {
                self.current && self.current.onEvent(new __event.ShareDesktopExtensionNotFound({ member: self.current }));
                errCallback && errCallback(_event);
            }
        });
    },

    _openCamera: function _openCamera(pubS, success, errCallback) {
        var self = this;
        //self.__assertCurrent();

        //var constaints = pubS.constaints || {audio: !pubS.aoff, video: !pubS.voff};
        var constaints = pubS.constaints || { audio: true, video: true };

        function successCallback(_me, stream) {
            self.__controlStream(pubS, stream);

            pubS.localStream = stream;
            success && success(self.current, stream);
        }
        self.__getUserMedia(constaints, successCallback.bind(constaints), errCallback);
    },

    __controlStream: function __controlStream(pubS, stream) {
        emedia.enableVideoTracks(stream, !pubS.voff);
        emedia.enableAudioTracks(stream, !pubS.aoff);
    },

    __getUserMedia: function __getUserMedia(constaints, success, errCallback) {
        _logger.debug('get user media. using constaints', constaints);

        var self = this;

        constaints = _util.extend({}, constaints);
        // if(typeof constaints.audio === 'object' && constaints.audio){
        //     constaints.audio = true;
        // }

        var _openstream;

        function onFail(e) {
            _logger.debug('[WebRTC-API] getUserMedia() error: ', e);

            emedia.stopTracks(_openstream);

            self.current && self.current.onEvent(new __event.OpenMediaError({ member: self.current, event: e }));
            errCallback && errCallback(new __event.OpenMediaError({ member: self.current, event: e }));
        }

        function onSuccess(stream) {
            if (self.current && !self.current.closed) {
                //push stream时，由于异步，在未返回成功后，退出会议，摄像头不会被关闭问题
                //将stream 与 Attendee绑定
                self.current._openedRtcMediaStreams[stream.id] = stream;
                stream._bindAttendee = self.current;
                stream._bindAttendeeId = self.current.getMemberId();
                _logger.info("stream bind attendee.", stream.id, self.current.ticket && self.current.ticket.id, self.current.getMemberId(), self.current.memName);
            }

            emedia._yetGetUserMedia = true;

            _openstream = stream;

            var videoTracks = stream.getVideoTracks();
            var audioTracks = stream.getAudioTracks();

            if (videoTracks.length > 0) {
                var videoTrack = videoTracks[0];
                _logger.debug(stream.id, 'using video device: ', videoTrack.id, videoTrack.label, videoTrack.kind, videoTrack.enabled);
            }
            if (audioTracks.length > 0) {
                var audioTrack = audioTracks[0];
                _logger.debug(stream.id, 'using audio device: ', audioTrack.id, audioTrack.label, audioTrack.kind, audioTrack.enabled);
            }

            stream._located = true;

            //window electron 69-73, 当摄像头被占用后，不会抛出任何异常，但是stream active == false
            if (typeof stream.active === "boolean" && !stream.active) {
                _logger.error("media stream not active. it is", stream.id);
                onFail({ constraint: constaints, name: "NotAllowedStreamNonactive", message: "stream non-active" });
                return;
            }

            // stream.oninactive = self._onStreamInactive.bind(self, stream);
            // stream.onactive = self._onStreamActive.bind(self, stream);

            success && success(self.current, stream);
        }

        self.__sysGetUserMedia(constaints, onSuccess, onFail);
    },

    _onStreamInactive: function _onStreamInactive(pubS, mediaStream, event) {

        var self = this;
        _logger.warn("media stream inactive. it =", mediaStream.id);

        pubS.onMediaInactive && self.current && _util.forEach(self.current._cacheStreams, function (_sid, _stream) {
            if (_stream.located() && _stream.localStream && _stream.localStream.id === mediaStream.id) {
                if (!_stream._webrtc || !_stream._webrtc.closed) {
                    pubS.onMediaInactive.call(_stream, mediaStream, event, self);
                }
            }
        });
    },
    _onStreamActive: function _onStreamActive(pubS, mediaStream, event) {
        var self = this;
        _logger.warn("media stream active. it =", mediaStream.id);

        pubS.onMediaActive && self.current && _util.forEach(self.current._cacheStreams, function (_sid, _stream) {
            if (_stream.located() && _stream.localStream && _stream.localStream.id === mediaStream.id) {
                pubS.onMediaActive.call(_stream, mediaStream, event, self);
            }
        });
    },

    __sysGetUserMedia: function __sysGetUserMedia(constaints, onSuccess, onFail) {
        var getUserMedia = function () {
            var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(constaints, onSuccess, onFail) {
                var mediaStream, audioStream, videoStream;
                return _regenerator2.default.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                if ((0, _typeof3.default)(emedia.config.globalConstraints) === 'object') {
                                    if ((0, _typeof3.default)(emedia.config.globalConstraints.audio) === 'object' && constaints.audio) {
                                        if (typeof constaints.audio === 'boolean') {
                                            constaints.audio = _util.extend({}, emedia.config.globalConstraints.audio);
                                        } else {
                                            constaints.audio = _util.extend({}, emedia.config.globalConstraints.audio, constaints.audio);
                                        }
                                    }
                                    if ((0, _typeof3.default)(emedia.config.globalConstraints.video) === 'object' && constaints.video) {
                                        if (typeof constaints.video === 'boolean') {
                                            constaints.video = _util.extend({}, emedia.config.globalConstraints.video);
                                        } else {
                                            constaints.video = _util.extend({}, emedia.config.globalConstraints.video, constaints.video);
                                        }
                                    }
                                }

                                _logger.info("navigator.mediaDevices.getUserMedia constaints = ", (0, _stringify2.default)(constaints));

                                // audio video 分别获取
                                mediaStream = new MediaStream();
                                audioStream = void 0, videoStream = void 0;

                                if (!constaints.audio) {
                                    _context.next = 14;
                                    break;
                                }

                                _context.prev = 5;
                                _context.next = 8;
                                return navigator.mediaDevices.getUserMedia({ audio: true });

                            case 8:
                                audioStream = _context.sent;
                                _context.next = 14;
                                break;

                            case 11:
                                _context.prev = 11;
                                _context.t0 = _context['catch'](5);

                                console.error('getUserMedia audio error', _context.t0);

                            case 14:
                                if (!constaints.video) {
                                    _context.next = 24;
                                    break;
                                }

                                _context.prev = 15;
                                _context.next = 18;
                                return navigator.mediaDevices.getUserMedia({ video: constaints.video });

                            case 18:
                                videoStream = _context.sent;
                                _context.next = 24;
                                break;

                            case 21:
                                _context.prev = 21;
                                _context.t1 = _context['catch'](15);

                                console.error('getUserMedia video error', _context.t1);

                            case 24:

                                if (audioStream) {
                                    audioStream.getAudioTracks().forEach(function (track) {
                                        mediaStream.addTrack(track);
                                    });
                                }
                                if (videoStream) {
                                    videoStream.getVideoTracks().forEach(function (track) {
                                        mediaStream.addTrack(track);
                                    });
                                }

                                if (!audioStream && !videoStream) {
                                    onFail({ message: 'getUserMedia error: not have input device' });
                                } else {
                                    onSuccess(mediaStream);
                                }

                            case 27:
                            case 'end':
                                return _context.stop();
                        }
                    }
                }, _callee, this, [[5, 11], [15, 21]]);
            }));

            return function getUserMedia(_x, _x2, _x3) {
                return _ref.apply(this, arguments);
            };
        }();

        getUserMedia(constaints, onSuccess, onFail);
    },

    attachMediaStream: window.attachMediaStream.bind({ logger: _logger }),

    setup: function setup(ticket, ext) {
        var self = this;

        _logger.count();
        _logger.debug("recv ticket", ticket, ext);
        _logger.debug("use sdk version", window._emediaVersion);
        _logger.debug(navigator.userAgent);

        ext = ext || {};

        var extObj = ext;
        if (_util.isPlainObject(ext)) {
            //ext 是对象， extObj 也是对象
            ext = (0, _stringify2.default)(ext);
        } else {
            //ext 是字符串， extObj 尽量转换为 对象
            try {
                extObj = JSON.parse(ext);
            } catch (e) {}
        }

        if (typeof ticket === "string") {
            ticket = JSON.parse(ticket);
        }

        var sysUserId, memName;
        sysUserId = memName = ticket.memName;
        emedia._lastSetupConfr = ticket.confrId;
        emedia._lastSetupMemName = memName;
        emedia._lastSetupDate = new Date();
        emedia._lastSetupTktId = ticket.tktId;

        if (self.current && !self.current.closed) {
            var __eventCalling = new __event.CurrentCalling();
            self.current.onEvent(__eventCalling);

            _logger.error("confr not close. calling...");
            throw __eventCalling;
            //return;

            //self.current.exit(0);
        }

        var TargetAttendee = self.Attendee || Attendee;
        var _Attendee = TargetAttendee.extend(EventHandler);

        var attendee = self.current = new _Attendee({
            _service: self,
            service: self,
            autoSub: emedia.config.autoSub,
            getCopyIntervalMillis: emedia.config.getCopyIntervalMillis,
            sysUserId: sysUserId,
            memName: memName,
            resource: self.resource,
            nickName: self.nickName,
            ticket: ticket,
            ext: ext,
            extObj: extObj,

            sessionFactory: function sessionFactory() {
                return self.newSession(this, ticket);
            }
        }, self.listeners || {});

        return attendee;
    },

    getStreamById: function getStreamById(streamId) {
        var stream = this.current && this.current._cacheStreams[streamId];
        return stream && _util.extend(false, {}, stream);
    },

    getStreamsByRtcId: function getStreamsByRtcId(rtcId) {
        if (!this.current || !this.current._cacheStreams) {
            return;
        }

        var streams = [];
        _util.forEach(this.current._cacheStreams, function (sid, _stream) {
            if (_stream.rtcId === rtcId) {
                streams.push(_stream);
            }
        });
        return streams;
    },

    getMemberById: function getMemberById(memId) {
        var member = this.current && this.current._cacheMembers[memId];
        return member && _util.extend(false, {}, member);
    },

    exit: function exit(closeMyConfrIfICrtConfr) {
        _logger.warn("User click exit ", closeMyConfrIfICrtConfr);
        this.current && this.current.exit(closeMyConfrIfICrtConfr);
    },

    join: function join(joined, joinError) {
        _logger.debug("begin join ...");

        var self = this;

        self.__assertCurrent();
        if (self.current._memberId) {
            //已经加入会议
            _logger.warn("Had joined. igrone it");
            joined && joined(self.memId);
            return;
        } else {
            self.current._session._sessionId = undefined;
        }

        self.current.join(joined, joinError);
    },

    withpublish: function withpublish(pubS) {
        var self = this;

        if (!pubS || !pubS.localStream) {
            _logger.error("pubS null or stream not open");
            throw "pubS null or stream not open";
        }

        self.__assertCurrent();
        if (self.current._memberId) {
            //已经加入会议
            _logger.warn("Had joined. igrone it");
        } else {
            self.current._session._sessionId = undefined;
        }

        return self.current.withpublish(pubS);
    },

    push: function push(pubS, pushed, onPushError) {
        _logger.debug("begin push ...");

        var self = this;

        if (arguments.length === 2) {
            onPushError = pushed;
            pushed = undefined;
        }

        if (!pubS || !pubS.localStream) {
            _logger.error("pubS or stream open");
            throw "pubS or stream open";
        }

        self.__assertCurrent();
        self.current.push(pubS, pushed, onPushError, false);
    },

    subscribe: function subscribe(streamId, onSub, subfail, subArgs) {
        var self = this;

        _logger.info("begin subscribe ", streamId, subArgs);

        if (onSub && _util.isPlainObject(onSub)) {
            subArgs = onSub;
            onSub = subfail = undefined;
        }
        if (subfail && _util.isPlainObject(subfail)) {
            subArgs = subfail;
            subfail = onSub;
            onSub = undefined;
        }

        if (emedia.isSafari) {
            var _onSub = function _onSub() {
                try {
                    var shiftsub = subs.shift();
                    shiftsub && shiftsub.onSub && shiftsub.onSub.apply(shiftsub, arguments);
                } finally {
                    next();
                }
            };

            var _subfail = function _subfail() {
                try {
                    var shiftsub = subs.shift();
                    shiftsub && shiftsub.subfail && shiftsub.subfail.apply(shiftsub, arguments);
                } finally {
                    next();
                }
            };

            var next = function next() {
                if (subs.length > 0) {
                    self.__subscribe(subs[0].streamId, _onSub, _subfail, subs[0].subArgs);
                }
            };

            // safari 两个流同时订阅可能会出现无声音 等一等
            var sub = {
                streamId: streamId,
                onSub: onSub,
                subfail: subfail,
                subArgs: subArgs
            };

            var subs = self.__safari_subs || (self.__safari_subs = []);
            subs.push(sub);

            if (subs.length === 1) {
                next();
            }
        } else {
            self.__subscribe(streamId, onSub, subfail, subArgs);
        }
    },
    __subscribe: function __subscribe(streamId, onSub, subfail, subArgs) {
        var self = this;

        self.__assertCurrent();

        if (arguments.length == 2) {
            subfail = onSub;
            onSub = undefined;
        }

        if (onSub && _util.isPlainObject(onSub)) {
            subArgs = onSub;
            onSub = undefined;
        }
        if (subfail && _util.isPlainObject(subfail)) {
            subArgs = subfail;
            subfail = undefined;
        }

        subArgs || (subArgs = { subSVideo: true, subSAudio: true });

        var subStream = self.current._cacheStreams[streamId];
        // if(subStream && subStream.type === 2 && subArgs.subSAudio !== undefined && !subArgs.subSAudio){
        //     subfail && subfail(new __event.AudioMixerStreamNotAllowOnlySubVideo({stream: subStream}));
        //     self.current.onEvent(new __event.AudioMixerStreamNotAllowOnlySubVideo({stream: subStream}));
        //     return;
        // }

        var webrtc = self.current._getWebrtc(streamId);

        var usePreRTCPeer = webrtc && webrtc.isConnected();

        var remoteStream = usePreRTCPeer && webrtc.getRemoteStream();
        if (remoteStream && (usePreRTCPeer = remoteStream.active)) {
            var hasAudioTracks = remoteStream.getAudioTracks().length;
            var hasVideoTracks = remoteStream.getVideoTracks().length;

            if (!hasAudioTracks && subArgs.subSAudio === true) {
                usePreRTCPeer = false;
            } else if (!hasVideoTracks && subArgs.subSVideo === true) {
                usePreRTCPeer = false;
            }
        }

        _logger.info("sub stream", streamId, ", use prertcpeer =", usePreRTCPeer);

        if (usePreRTCPeer) {
            self.current.subscribeStream(webrtc._rtcId, streamId, subfail, subArgs, onSub);
            onSub && onSub();
            return;
        }

        webrtc && !webrtc.closed && self.current.closeWebrtc(webrtc.getRtcId(), true, false);

        self.current.createWebrtcAndSubscribeStream(streamId, {
            onGotRemote: function onGotRemote(stream) {
                onSub && onSub(stream);
            },
            onEvent: function onEvent(_evt) {
                subfail && subfail(_evt);
            }
        }, undefined, subArgs);
    },

    closePubstream: function closePubstream(stream) {
        if (stream.located()) {
            emedia.stopTracks(stream._localMediaStream);
            emedia.stopTracks(stream.localStream);
        }
    },

    hungup: function hungup(streamId) {
        var stream = this.getStreamById(streamId);

        try {
            this._hungup(streamId);
        } finally {
            this.onHungup && stream && this.onHungup(stream);
        }
    },
    _hungup: function _hungup(streamId) {
        var self = this;

        self.__assertCurrent();

        var attendee = self.current;

        var stream = attendee._cacheStreams[streamId];
        stream && !stream.closeReason && stream.updateAttributes({
            closeReason: 'UserHangup'
        });

        var rtcId = stream && stream.rtcId;
        if (rtcId) {
            attendee.closeWebrtc(rtcId);

            if (stream.located()) {
                stream.type !== 1 && stream._localMediaStream && emedia.stopTracks(stream._localMediaStream);

                if (stream.remotePlayAudioObject) {
                    document.body.removeChild(stream.remotePlayAudioObject);
                }

                attendee._cacheStreams[streamId] && attendee.onRemoveStream(stream);

                _util.removeAttribute(attendee._cacheStreams, streamId);
                self._streamAutomators && _util.removeAttribute(self._streamAutomators, streamId);
            }
        }

        if (stream && !stream.located()) {
            attendee._linkedStreams[stream.id] && _util.removeAttribute(attendee._linkedStreams, stream.id);
            _logger.warn("Hangeup remove from _linkedStreams. stream = ", stream.id);

            stream = attendee._cacheStreams[streamId];
            if (!stream) {
                return;
            }

            stream.updateAttributes({
                rtcId: undefined,
                _webrtc: undefined,
                mediaStream: undefined
            });

            var _stream = new __Stream(stream);
            attendee.onUpdateStream(_stream, new _stream.Update(_stream));
        }
    },

    postMessage: function postMessage(memberIdOrStreamId, message, fail, onRsp) {
        var self = this;

        var theMessage = message;
        if (typeof message !== 'string') {
            message = (0, _stringify2.default)(message);
        }

        self.__assertCurrent();
        var attendee = self.current;

        var memberId;

        var linkedStream = attendee._linkedStreams[memberIdOrStreamId];
        if (linkedStream && linkedStream.owner) {
            memberId = linkedStream.owner.id;
        } else {
            memberId = memberIdOrStreamId;
        }

        var message = attendee.newMessage({
            op: 1003,
            memId: memberId,
            arg: message
        });

        attendee.postMessage(message, (fail || onRsp) && function (rsp) {
            onRsp && onRsp(rsp, theMessage);

            if (rsp.result != 0) {
                var _evt = new __event.RemoteControlFail({ memId: memberId, failed: rsp.result, cause: rsp.msg, type: "postMessage", postMessage: message });
                attendee.onEvent(_evt);

                fail && fail(_evt, theMessage);

                return;
            }
        });
    },

    torchRemote: function torchRemote(streamId, torch, success, fail) {
        var self = this;

        if (typeof torch === 'function') {
            fail = success;
            success = torch;
            torch = undefined;
        }

        if (torch !== undefined) {
            torch = torch ? 1 : 0;
        }

        self.__assertCurrent();
        var attendee = self.current;

        var linkedStream = attendee._linkedStreams[streamId];
        if (!linkedStream || linkedStream.located()) {
            _logger.error("not exsits or locate, not connect", streamId);
            throw streamId + " not exsits or locate, not connect";
        }

        var lastTorch = linkedStream.torch;
        var torch = torch === undefined ? !linkedStream.torch ? 1 : 0 : torch;

        var arg = {
            op2: 20,
            streamId: streamId,
            tor: torch
        };

        var message = attendee.newMessage({
            op: 1002,
            memId: linkedStream.owner.id,
            arg: (0, _stringify2.default)(arg),
            _reqOps: [100206]
        });

        linkedStream.updateAttributes({ torch: torch });

        attendee.postMessage(message, function (rsp) {
            if (rsp.result != 0) {
                var _evt = new __event.RemoteControlFail({ stream: linkedStream, failed: rsp.result, cause: rsp.msg, type: "torch_control" });
                attendee.onEvent(_evt);

                linkedStream.updateAttributes({ torch: lastTorch });

                fail && fail(_evt, linkedStream.torch);

                return;
            } else {
                success && success(linkedStream.torch);
            }
        });
    },

    freezeFrameRemote: function freezeFrameRemote(streamId, success, fail) {
        var self = this;

        self.__assertCurrent();
        var attendee = self.current;

        var linkedStream = attendee._linkedStreams[streamId];
        if (!linkedStream || linkedStream.located()) {
            _logger.error("not exsits or locate, not connect", streamId);
            throw streamId + " not exsits or locate, not connect";
        }

        var freezeFrame = !linkedStream.freezeFrame;

        var arg = {
            op2: 20,
            streamId: streamId,
            frz: freezeFrame ? 1 : 0
        };

        var message = attendee.newMessage({
            op: 1002,
            memId: linkedStream.owner.id,
            arg: (0, _stringify2.default)(arg),
            _reqOps: [100204]
        });

        linkedStream.updateAttributes({ freezeFrame: freezeFrame });

        attendee.postMessage(message, function (rsp) {
            if (rsp.result != 0) {
                var _evt = new __event.RemoteControlFail({ stream: linkedStream, failed: rsp.result, cause: rsp.msg, type: "freeze_control" });
                attendee.onEvent(_evt);

                linkedStream.updateAttributes({ freezeFrame: !linkedStream.freezeFrame });

                fail && fail(_evt, linkedStream.freezeFrame);

                return;
            } else {
                success && success(linkedStream.freezeFrame);
            }
        });
    },

    base64Img2Blob: function base64Img2Blob(code) {
        var parts = code.split(';base64,');
        var contentType = parts[0].split(':')[1];
        var raw = window.atob(parts[1]);
        var rawLength = raw.length;

        var uInt8Array = new Uint8Array(rawLength);

        for (var i = 0; i < rawLength; ++i) {
            uInt8Array[i] = raw.charCodeAt(i);
        }

        // if(emedia.isSafari){
        //     return new Blob([uInt8Array], {type:"application/octet-stream"});
        // }

        return new Blob([uInt8Array], { type: contentType });
    },

    blob2URL: function blob2URL(blob) {
        return URL.createObjectURL(blob);
    },

    imagesPngContext2URL: function imagesPngContext2URL(code) {
        var self = this;
        return self.blob2URL(self.blob2URL(code));
    },

    downloadFile: function downloadFile(fileName, content, blobs) {
        var self = this;

        var aLink = document.createElement('a');
        aLink.style.display = 'none';
        var blob = content ? self.base64Img2Blob(content) : blobs; //new Blob([content]);

        // if(typeof FileReader === 'object'){
        //     var reader = new FileReader();
        //
        //     reader.onloadend = function () {
        //         var url = reader.result;
        //         url = url.replace(/^data:[^;]*;/, 'data:attachment/file;');
        //         window.location.href = url;
        //     };
        //
        //     reader.readAsDataURL(blob);
        //     return;
        // }

        var blobUrl;
        aLink.download = fileName;
        aLink.href = blobUrl = self.blob2URL(blob);
        aLink.rel = 'noopener';

        var evt = document.createEvent("HTMLEvents");
        evt.initEvent("click", false, false); //initEvent 不加后两个参数在FF下会报错
        aLink.dispatchEvent(evt);

        document.body.appendChild(aLink);
        aLink.click();
        aLink.parentNode.removeChild(aLink);

        setTimeout(function () {
            URL.revokeObjectURL && URL.revokeObjectURL(blobUrl);
        }, 40000);
    },

    videoCaptureBase64Context2URL: function videoCaptureBase64Context2URL(videoObj) {
        var self = this;
        return self.imagesPngContext2URL(self.getCaptureBase64Context(videoObj));
    },

    getCaptureBase64Context: function getCaptureBase64Context(videoObj) {
        var canvas = document.createElement("canvas");
        var id = canvas.id = "__capture_video_" + new Date().getTime();

        canvas.width = videoObj.videoWidth;
        canvas.height = videoObj.videoHeight;

        var canvas2dContext = canvas.getContext('2d');
        canvas2dContext.drawImage(videoObj, 0, 0, canvas.width, canvas.height);

        var base64 = canvas.toDataURL('images/png');
        //console.log(base64);

        return base64;
    },

    captureVideo: function captureVideo(videoObj, storeLocal, filename) {
        var self = this;

        var base64 = self.getCaptureBase64Context(videoObj);

        if (storeLocal) {
            filename = filename || "capture_" + new Date().getTime();
            self.downloadFile(filename, base64);
            //window.location.href = base64;

            // var iframe = document.createElement("iframe");
            // iframe.id = "__capture_video_pic_dl_iframe_" + (new Date().getTime());
            // iframe.style.display = "none";
            //
            // //document.body.appendChild(iframe);
            //
            // iframe.src = base64;
            // //iframe.contentWindow.location.href = URL.createObjectURL(base64);
            //
            // setTimeout(function () {
            //     //document.body.removeChild(iframe);
            // }, 50);
        }

        return base64;
    },

    capturePictureRemote: function capturePictureRemote(streamId, rspBase64Pic, success, fail) {
        var self = this;

        self.__assertCurrent();
        var attendee = self.current;

        var linkedStream = attendee._linkedStreams[streamId];
        if (!linkedStream || linkedStream.located()) {
            _logger.error("not exsits or locate, not connect", streamId);
            throw streamId + " not exsits or locate, not connect";
        }

        var arg = {
            op2: 20,
            streamId: streamId,
            pic: 1,
            rspBase64Pic: rspBase64Pic === true
        };

        var message = attendee.newMessage({
            op: 1002,
            memId: linkedStream.owner.id,
            arg: (0, _stringify2.default)(arg),
            _reqOps: [100205]
        });

        attendee.postMessage(message, function (rsp) {
            if (rsp.result != 0) {
                var _evt = new __event.RemoteControlFail({ stream: linkedStream, failed: rsp.result, cause: rsp.msg, type: "capture_control" });
                attendee.onEvent(_evt);
                fail && fail(_evt);

                return;
            } else {
                if (!rspBase64Pic) {
                    success && success();
                    return;
                }

                if (!rsp.arg) {
                    fail && fail(new __event.RemoteControlFail({ stream: linkedStream, failed: rsp.result, cause: "Not found base64 pic" }));
                    return;
                }

                var arg = JSON.parse(rsp.arg);
                success && success(arg.pic);
            }
        });
    },

    zoomRemote: function zoomRemote(streamId, multiples, fail, success) {
        var self = this;

        self.__assertCurrent();
        var attendee = self.current;

        var linkedStream = attendee._linkedStreams[streamId];
        if (!linkedStream || linkedStream.located()) {
            _logger.error("not exsits or locate, not connect", streamId);
            throw streamId + " not exsits or locate, not connect";
        }

        linkedStream._zoom || linkedStream.updateAttributes({ _zoom: 1 });

        var _zoom = linkedStream._zoom * multiples;
        if (_zoom < 1) {
            return;
        }

        linkedStream.updateAttributes({ _zoom: _zoom });

        var arg = {
            op2: 20,
            streamId: streamId,
            zoom: Math.round(_zoom * 10000)
        };

        var message = attendee.newMessage({
            op: 1002,
            memId: linkedStream.owner.id,
            arg: (0, _stringify2.default)(arg),
            _reqOps: [100201]
        });

        attendee.postMessage(message, function (rsp) {
            if (rsp.result != 0) {
                var _evt = new __event.RemoteControlFail({ stream: linkedStream, failed: rsp.result, cause: rsp.msg, type: "zoom_control" });
                attendee.onEvent(_evt);
                fail && fail(_evt);

                return;
            }

            success && success();
        });
    },

    _getPosition: function getPosition(obj) {
        var topValue = 0,
            leftValue = 0;
        while (obj) {
            leftValue += obj.offsetLeft;
            topValue += obj.offsetTop;
            obj = obj.offsetParent;
        }

        return { clientX: leftValue, clientY: topValue };
    },

    eventXYAtMedia: function eventXYAtMedia(eventXY, videoTag) {
        var videoXY = _util.getDomPageRect(videoTag);

        var videoWidth = videoXY.width,
            videoHeight = videoXY.height;
        var mediaWidth = videoTag.videoWidth,
            mediaHeight = videoTag.videoHeight;

        if (mediaHeight / mediaWidth > videoHeight / videoWidth) {
            var t = mediaWidth / mediaHeight;
            mediaHeight = videoHeight;
            mediaWidth = mediaHeight * t;
        } else {
            var t = mediaHeight / mediaWidth;
            mediaWidth = videoWidth;
            mediaHeight = mediaWidth * t;
        }

        var clickXY = eventXY;

        var isRadioX, isRadioY;
        if (isRadioX = _util.isFloat(clickXY.x)) {
            //比率
            clickXY.x = clickXY.x * videoWidth;
        }
        if (isRadioY = _util.isFloat(clickXY.y)) {
            //比率
            clickXY.y = clickXY.y * videoHeight;
        }

        if (Math.abs(clickXY.x) < (videoWidth - mediaWidth) / 2 || videoWidth - Math.abs(clickXY.x) < (videoWidth - mediaWidth) / 2) {
            return;
        }
        if (Math.abs(clickXY.y) < (videoHeight - mediaHeight) / 2 || videoHeight - Math.abs(clickXY.y) < (videoHeight - mediaHeight) / 2) {
            return;
        }

        clickXY.x = clickXY.x < 0 ? Math.floor(clickXY.x + (videoWidth - mediaWidth) / 2) : Math.floor(clickXY.x - (videoWidth - mediaWidth) / 2);
        clickXY.y = clickXY.y < 0 ? Math.floor(clickXY.y + (videoHeight - mediaHeight) / 2) : Math.floor(clickXY.y - (videoHeight - mediaHeight) / 2);

        if (isRadioX) {
            clickXY.x = clickXY.x / mediaWidth;
        }
        if (isRadioY) {
            clickXY.y = clickXY.y / mediaHeight;
        }

        return { x: clickXY.x, y: clickXY.y, width: mediaWidth, height: mediaHeight };
    },

    eventXYAtVideo: function eventXYAtVideo(mediaXY, videoTag) {
        var videoXY = _util.getDomPageRect(videoTag);

        var videoWidth = videoXY.width,
            videoHeight = videoXY.height;
        var mediaWidth = videoTag.videoWidth,
            mediaHeight = videoTag.videoHeight;

        if (mediaHeight / mediaWidth > videoHeight / videoWidth) {
            var t = mediaWidth / mediaHeight;
            mediaHeight = videoHeight;
            mediaWidth = mediaHeight * t;
        } else {
            var t = mediaHeight / mediaWidth;
            mediaWidth = videoWidth;
            mediaHeight = mediaWidth * t;
        }

        var isRadioX, isRadioY;
        if (isRadioX = _util.isFloat(mediaXY.x)) {
            //比率
            mediaXY.x = mediaXY.x * mediaWidth;
        }
        if (isRadioY = _util.isFloat(mediaXY.y)) {
            //比率
            mediaXY.y = mediaXY.y * mediaHeight;
        }

        mediaXY.x = mediaXY.x < 0 ? Math.floor(mediaXY.x - (videoWidth - mediaWidth) / 2) : Math.floor(mediaXY.x + (videoWidth - mediaWidth) / 2);
        mediaXY.y = mediaXY.y < 0 ? Math.floor(mediaXY.y - (videoHeight - mediaHeight) / 2) : Math.floor(mediaXY.y + (videoHeight - mediaHeight) / 2);

        if (isRadioX) {
            mediaXY.x = mediaXY.x / videoWidth;
        }
        if (isRadioY) {
            mediaXY.y = mediaXY.y / videoHeight;
        }

        return mediaXY;
    },

    getClickXY: function getClickXY(videoTag, clickEvent) {
        var self = this;

        var e = clickEvent || window.event;
        var scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
        var scrollY = document.documentElement.scrollTop || document.body.scrollTop;
        var x = e.pageX || e.clientX + scrollX;
        var y = e.pageY || e.clientY + scrollY;

        var xy = self._getPosition(videoTag);

        _logger.info("Video tag position ", xy.clientX, ":", xy.clientY);

        var mediaWidth = videoTag.videoWidth;
        var mediaHeight = videoTag.videoHeight;

        if (mediaHeight / mediaWidth > videoTag.offsetHeight / videoTag.offsetWidth) {
            var t = mediaWidth / mediaHeight;
            mediaHeight = videoTag.offsetHeight;
            mediaWidth = mediaHeight * t;

            xy.clientX += (videoTag.offsetWidth - mediaWidth) / 2;
        } else {
            var t = mediaHeight / mediaWidth;
            mediaWidth = videoTag.offsetWidth;
            mediaHeight = mediaWidth * t;

            xy.clientY += (videoTag.offsetHeight - mediaHeight) / 2;
        }
        _logger.info("Media position ", xy.clientX, ":", xy.clientY);
        _logger.info("Media xy ", mediaWidth, ":", mediaHeight);
        _logger.info("Click position ", x, ":", y);

        return {
            mediaWidth: mediaWidth,
            mediaHeight: mediaHeight,
            x: x - xy.clientX,
            y: y - xy.clientY
        };
    },

    focusExpoRemote: function focusExpoRemote(streamId, videoTag, clickEvent, fail, success) {
        var self = this;

        var e = clickEvent || window.event;
        var scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
        var scrollY = document.documentElement.scrollTop || document.body.scrollTop;
        var x = e.pageX || e.clientX + scrollX;
        var y = e.pageY || e.clientY + scrollY;

        var xy = self._getPosition(videoTag);

        _logger.info("Video tag position ", xy.clientX, ":", xy.clientY);

        var mediaWidth = videoTag.videoWidth;
        var mediaHeight = videoTag.videoHeight;

        if (mediaHeight / mediaWidth > videoTag.offsetHeight / videoTag.offsetWidth) {
            var t = mediaWidth / mediaHeight;
            mediaHeight = videoTag.offsetHeight;
            mediaWidth = mediaHeight * t;

            xy.clientX += (videoTag.offsetWidth - mediaWidth) / 2;
        } else {
            var t = mediaHeight / mediaWidth;
            mediaWidth = videoTag.offsetWidth;
            mediaHeight = mediaWidth * t;

            xy.clientY += (videoTag.offsetHeight - mediaHeight) / 2;
        }
        _logger.info("Media position ", xy.clientX, ":", xy.clientY);
        _logger.info("Media xy ", mediaWidth, ":", mediaHeight);
        _logger.info("Click position ", x, ":", y);

        self._focusExpo(streamId, mediaWidth, mediaHeight, x - xy.clientX, y - xy.clientY, fail, success);
    },

    _focusExpo: function _focusExpo(streamId, width, height, x, y, fail, success) {
        var self = this;

        if (x <= 0 || x > width) {
            return;
        }
        if (y <= 0 || y > height) {
            return;
        }

        self.__assertCurrent();
        var attendee = self.current;

        var linkedStream = attendee._linkedStreams[streamId];
        if (!linkedStream || linkedStream.located()) {
            _logger.error("not exsits or locate, not connect", streamId);
            throw streamId + " not exsits or locate, not connect";
        }

        var arg = {
            op2: 20,
            streamId: streamId,
            focus: 1,
            expo: 1,
            x: width === 0 ? 0 : Math.round(x * 10000 / width),
            y: height === 0 ? 0 : Math.round(y * 10000 / height)
        };

        var message = attendee.newMessage({
            op: 1002,
            memId: linkedStream.owner.id,
            arg: (0, _stringify2.default)(arg),
            _reqOps: [100202, 100203]
        });

        attendee.postMessage(message, function (rsp) {
            if (rsp.result != 0) {
                var _evt = new __event.RemoteControlFail({ stream: linkedStream, failed: rsp.result, cause: rsp.msg, type: "focus_expo_control" });
                attendee.onEvent(_evt);
                fail && fail(_evt);

                return;
            } else {
                success && success();
            }
        });
    },

    _republish: function _republish(pubS, success, error) {
        _logger.info("Republish stream. it = ", pubS.id);

        var self = this;

        var webrtc;
        if (pubS.id) {
            var rtcId = self.current.__getWebrtcFor(pubS.id);
            rtcId && self.current.closeWebrtc(rtcId, true);

            webrtc = self.current._getWebrtc(pubS.id);
        }

        var _pubS;

        // if(emedia.isSafari){
        //     emedia.enableAudioTracks(false);
        //     emedia.enableVideoTracks(false);
        // }

        switch (pubS.type) {
            case 0:
                //emedia.isSafari || emedia.stopTracks(pubS._localMediaStream);
                emedia.stopTracks(pubS._localMediaStream);
                _pubS = new self.AVPubstream(pubS);

                break;
            case 1:
                //emedia.isSafari || emedia.stopAndRemoveAudioTracks(pubS._localMediaStream);
                emedia.stopAndRemoveAudioTracks(pubS._localMediaStream);
                _pubS = new self.ShareDesktopPubstream(pubS);

                break;
            case 2:
                //emedia.isSafari || emedia.stopTracks(pubS._localMediaStream);
                emedia.stopTracks(pubS._localMediaStream);
                _pubS = new self.AudioMixerPubstream(pubS);

                break;
        }

        setTimeout(function () {
            self.openUserMedia(_pubS).then(function () {
                pubS.localStream = _pubS.localStream;

                pubS.isRepublished = true;

                pubS.optimalVideoCodecs = pubS.optimalVideoCodecs || webrtc && webrtc.optimalVideoCodecs;
                self.push(pubS, success, error);
            }, error);
        }, 100);

        // if(emedia.isSafari){
        //     setTimeout(function () {
        //         switch(pubS.type) {
        //             case 0:
        //                 emedia.stopTracks(pubS._localMediaStream);
        //                 break;
        //             case 1:
        //                 emedia.stopAndRemoveAudioTracks(pubS._localMediaStream);
        //                 break;
        //             case 2:
        //                 emedia.stopTracks(pubS._localMediaStream);
        //                 break;
        //         }
        //     }, 1400);
        // }
    },

    switchMobileCamera: function switchMobileCamera(pubS, error, success) {
        var self = this;

        if (typeof pubS === 'string') {
            //id
            pubS = self.current._cacheStreams[pubS];
        } else if (pubS.id) {
            pubS = self.current._cacheStreams[pubS.id];
        }

        if (pubS.voff) {
            _logger.warn("Stream id = ", pubS.id, " voff, do not chanage camera.");
            return;
        }

        pubS.constaints || (pubS.constaints = {});
        var preConstaints = _util.extend({}, pubS.constaints);
        pubS._lastConstaints = preConstaints;

        //video: {'facingMode': "user"}, // 前置
        //video: { facingMode: { exact: "environment" } } //后置
        pubS.constaints.video = (0, _typeof3.default)(pubS.constaints.video) === "object" ? pubS.constaints.video : {};
        if (pubS.constaints.video.facingMode === "user" || !pubS.constaints.video.facingMode) {
            //facingMode不存在或指定了user当前置
            pubS.constaints.video.facingMode = { exact: "environment" };
        } else {
            //pubS.constaints.video.facingMode
            pubS.constaints.video.facingMode = "user";
        }

        self._republish(pubS, function (mediaStream) {
            success && success(mediaStream);
        }, function (_evt) {
            if (_evt instanceof emedia.event.OpenMediaError) {
                //设备可能不支持，比如 没有摄像头，或 被禁止访问摄像头
                pubS.constaints = preConstaints;
            }

            error && error(_evt);
        });
    },

    chanageCamera: function chanageCamera(pubS, error, success) {
        var self = this;

        if (typeof pubS === 'string') {
            //id
            pubS = self.current._cacheStreams[pubS];
        } else if (pubS.id) {
            pubS = self.current._cacheStreams[pubS.id];
        }

        if (pubS.voff) {
            _logger.warn("Stream id = ", pubS.id, " voff, do not chanage camera.");
            return;
        }

        self.getMediaDevices("videoinput", function (devices) {
            if (devices.length <= 1) {
                _logger.warn("Only video input. not chanage");
                return;
            }

            var cameraIndex = pubS._cameraIndex;

            if (pubS._cameraIndex === null || pubS._cameraIndex === undefined) {
                var localStream = pubS.getLocalMediaStream();
                var videoTracks = localStream && localStream.getVideoTracks();
                var track = videoTracks && videoTracks.length && videoTracks[0];

                if (track && track.getCapabilities && typeof track.getCapabilities === 'function') {
                    var videoCapabilities = track.getCapabilities();
                    var deviceId = videoCapabilities && videoCapabilities.deviceId;

                    for (var index in devices) {
                        var device = devices[index];
                        if (device.deviceId === deviceId || device.label == track.label) {
                            cameraIndex = parseInt(index);
                            break;
                        }
                    }
                } else {
                    for (var index in devices) {
                        var device = devices[index];
                        if (device.label == track.label) {
                            cameraIndex = parseInt(index);
                            break;
                        }
                    }
                }
            }

            while (cameraIndex < devices.length) {
                var lastDevice = devices[cameraIndex];
                cameraIndex = (cameraIndex + 1) % devices.length;

                var device = devices[cameraIndex];

                var videoTracks = pubS.getLocalMediaStream().getVideoTracks();
                if (!videoTracks || videoTracks.length === 0 || device.label != videoTracks[0].label) {
                    break;
                }
            }

            var device = devices[cameraIndex];
            var deviceInfoLabel = device.label;

            _logger.warn("Stream ", pubS.id, lastDevice.label, ">>", deviceInfoLabel);

            pubS._cameraIndex = cameraIndex;

            pubS.constaints || (pubS.constaints = {});
            var preConstaints = _util.extend({}, pubS.constaints);
            pubS._lastConstaints = preConstaints;

            pubS.constaints.video = (0, _typeof3.default)(pubS.constaints.video) === "object" ? pubS.constaints.video : {};
            pubS.constaints.video.deviceId = { exact: device.deviceId };

            self._republish(pubS, function (mediaStream) {
                success && success(mediaStream);
            }, function (_evt) {
                if (_evt instanceof emedia.event.OpenMediaError) {
                    //设备可能不支持，比如 没有摄像头，或 被禁止访问摄像头
                    pubS.constaints = preConstaints;
                }

                error && error(_evt);
            });
        }, error);
    },

    chanageConstraints: function chanageConstraints(pubS, constraints, error, success) {
        var self = this;

        if (typeof pubS === 'string') {
            //id
            pubS = self.current._cacheStreams[pubS];
        } else if (pubS.id) {
            pubS = self.current._cacheStreams[pubS.id];
        }

        if (!pubS) {
            _logger.warn("Not found pubS");
            return;
        }
        _logger.info("chanage pubstream constraints. it", pubS.id, constraints);

        function updateAndDisabled() {
            var mediaStream = pubS.getMediaStream();
            emedia.enableVideoTracks(mediaStream, !pubS.voff);
            emedia.enableAudioTracks(mediaStream, !pubS.aoff);
        }

        if (_.isObject(constraints) && !_.isEqual(pubS.constaints, constraints)) {
            var preConstraints = pubS.constaints || {};
            var preVoff = pubS.voff;
            var preAoff = pubS.aoff;

            pubS._lastConstaints = preConstraints;
            pubS.constaints = _util.extend(true, {}, preConstraints, constraints);

            pubS.aoff = pubS.constaints.audio ? 0 : 1;
            pubS.voff = pubS.constaints.video ? 0 : 1;

            self._republish(pubS, function (mediaStream) {
                updateAndDisabled();
                success && success(mediaStream);
            }, function (_evt) {
                if (_evt instanceof emedia.event.OpenMediaError) {
                    //设备可能不支持，比如 没有摄像头，或 被禁止访问摄像头
                    pubS.constaints = preConstraints;
                    pubS.aoff = preAoff;
                    pubS.voff = preVoff;
                }

                error && error(_evt);
            });

            return;
        }

        updateAndDisabled();
        success && success(pubS.getMediaStream());
    },

    voff: function voff(pubS, _voff, error, success) {
        var self = this;

        if (typeof pubS === 'string') {
            //id
            pubS = self.current._cacheStreams[pubS];
        }

        var oldVoff = pubS.voff;
        _voff = _voff ? 1 : 0;
        pubS.voff = _voff;

        function updateAndDisabled() {
            if (_voff == oldVoff) {
                _logger.info("pubstream voff not chanage.");
                return;
            }
            emedia.enableVideoTracks(pubS.getMediaStream(), !_voff);
            self.current && self.current.voff(pubS, _voff);
        }

        if (!_voff && pubS.constaints && !pubS.constaints.video) {
            //error && error("When pub. only audio, voff invalidate");
            //throw "When pub. only audio, voff invalidate";

            var preVideo = pubS.constaints.video;

            pubS.constaints.video = true;
            self._republish(pubS, function (mediaStream) {
                updateAndDisabled();
                success && success(mediaStream);
            }, function (_evt) {
                if (_evt instanceof emedia.event.OpenMediaError) {
                    //设备可能不支持，比如 没有摄像头，或 被禁止访问摄像头
                    pubS.constaints.video = preVideo;
                    pubS.voff = oldVoff;
                }

                error && error(_evt);
            });

            return;
        }

        updateAndDisabled();
        success && success(pubS.getMediaStream());
    },

    aoff: function aoff(pubS, _aoff, error, success) {
        var self = this;

        if (typeof pubS === 'string') {
            //id
            pubS = self.current._cacheStreams[pubS];
        }

        var oldAoff = pubS.aoff;
        _aoff = _aoff ? 1 : 0;
        pubS.aoff = _aoff;

        function updateAndDisabled() {
            if (_aoff == oldAoff) {
                _logger.info("pubstream aoff not chanage.");
                return;
            }

            emedia.enableAudioTracks(pubS.getMediaStream(), !_aoff);
            self.current && self.current.aoff(pubS, _aoff);
        }

        if (!_aoff && pubS.constaints && !pubS.constaints.audio) {
            // error && error("When pub. only video, aoff invalidate");
            // throw "When pub. only video, aoff invalidate";

            var preAudio = pubS.constaints.audio;

            pubS.constaints.audio = true;
            self._republish(pubS, function (mediaStream) {
                updateAndDisabled();
                success && success(mediaStream);
            }, function (_evt) {
                if (_evt instanceof emedia.event.OpenMediaError) {
                    //设备可能不支持，比如 没有摄像头，或 被禁止访问摄像头
                    pubS.constaints.audio = preAudio;
                    pubS.aoff = oldAoff;
                }

                error && error(_evt);
            });

            return;
        }

        updateAndDisabled();
        success && success(pubS.getMediaStream());
    },

    iceing: function iceing(streamId) {
        var self = this;

        return _util.isPlainObject(self.current._linkedStreams[streamId]);
    },

    recording: function recording(streamId) {
        var self = this;

        return _util.isPlainObject(self.current._records[streamId]);
    },

    startRecord: function startRecord(streamId, callback) {
        var self = this;

        var _stream = self.current._linkedStreams[streamId];
        if (!_stream) {
            _logger.error("not at linked streams", streamId);
            throw streamId + " not at linked streams";
        }
        if (!_stream._webrtc) {
            callback && callback(false);
        }

        self.current.startRecord(_stream, callback);
    },

    stopRecord: function stopRecord(streamId, callback) {
        var self = this;

        var _stream = self.current._records[streamId];
        if (!_stream) {
            _logger.error("not at recording streams", streamId);
            throw streamId + " not at recording streams";
        }

        self.current.stopRecord(_stream, callback);
    },

    getCurrentMembers: function getCurrentMembers() {
        var self = this;
        return self.current.getCurrentMembers();
    },

    _onCapturePicture: function _onCapturePicture(evt) {
        var self = this;

        var rspBase64Pic = evt.arg.rspBase64Pic;
        var streamId = evt.arg.streamId;
        var stream = self.current._cacheStreams[streamId];

        var base64;
        if (rspBase64Pic) {
            var htmlVideo;
            if (typeof self.getHTMLVideo !== "function" || !(htmlVideo = self.getHTMLVideo(streamId))) {
                _logger.warn("Not support capture picture. caused by htmlVideo not found");
                return;
            }

            base64 = self.getCaptureBase64Context(htmlVideo);
        } else {
            if (typeof self.onCapturePicture !== "function") {
                _logger.warn("Not support capture picture. caused by onCapturePicture not found");
                return;
            }
            self.onCapturePicture(stream);
        }

        var message = self.current.newMessage({
            op: 1001,
            tsxId: evt.tsxId,
            memId: evt.memId,
            arg: (0, _stringify2.default)(base64 ? { pic: base64 } : {}),
            result: 0
        });

        self.current.postMessage(message, function (rsp) {
            _logger.warn("Send remote control onCapturePicture response. the result = ", rsp.result, rsp.msg || "");
        });

        return true;
    },

    // _onRemotePannelControl: function (evt) {
    //
    // },

    newSession: function newSession(attendee, ticket) {
        var self = this;

        var ExtendSession = self.Session || Session;
        var session = new ExtendSession({
            ticket: ticket,
            owner: attendee,

            onTcklC: function onTcklC(evt) {
                attendee.onTcklC(evt.rtcId, evt.cands);
            },
            onAcptC: function onAcptC(evt) {
                attendee.onAcptC(evt.rtcId, evt.sdp, evt.cands);
            },
            onAnsC: function onAnsC(evt) {
                attendee.onAnsC(evt.rtcId, evt.sdp, evt.cands);
            },
            onTermC: function onTermC(evt) {
                //self.onTermC(me, evt);
                _logger.info("Server termc rtc: ", evt.rtcId, evt.message || evt.msg);

                var endReason = evt.endReason;

                if (endReason === 21 || endReason === 22) {
                    _util.forEach(attendee._cacheStreams, function (sid, _stream) {
                        if (_stream.rtcId === evt.rtcId) {
                            var _event;
                            if (endReason === 21) {
                                // 建议更换编码方式
                                _event = new emedia.event.SwitchVCodes({ stream: _stream, useVCodes: evt.useVCodes });
                            } else {
                                _event = new emedia.event.SubFailNotSupportVCodes({ stream: _stream });
                            }

                            attendee.onEvent(_event);
                        }
                    });
                } else if (endReason == 23) {
                    //达到最大视频数
                    var onCallBack = self.listeners.mgr.onPubVideoTooMuch;
                    if (!onCallBack || typeof onCallBack != 'function') {
                        return;
                    }

                    onCallBack();
                } else if (endReason == 24) {
                    //达到最大共享桌面数
                    var _onCallBack = self.listeners.mgr.onPubDesktopTooMuch;
                    if (!_onCallBack || typeof _onCallBack != 'function') {
                        return;
                    }

                    _onCallBack();
                } else {
                    attendee.closeWebrtc(evt.rtcId, false, true);
                }
            },
            onEnter: function onEnter(evt) {
                attendee.onEnter(evt.cver, evt.mem);
            },
            onExit: function onExit(evt) {
                attendee.onExit(evt.cver, evt.memId, evt.reason || 0);
            },
            onPub: function onPub(evt) {
                attendee.onPub(evt.cver, evt.memId, evt.pubS);
            },
            onUnpub: function onUnpub(evt) {
                attendee.onUnpub(evt.cver, evt.memId, evt.pubSId);
            },
            onMems: function onMems(evt) {},
            onClose: function onClose(evt) {
                attendee.onClose(evt.cver, evt.confrId);
            },
            onEvent: function onEvent(evt) {
                attendee.onEvent(evt);
            },
            onStreamControl: function onStreamControl(evt) {
                attendee.onStreamControl(evt.cver, evt.streamId, evt.voff, evt.aoff, evt.sver);
            },
            onRoleUpdate: function onRoleUpdate(evt) {
                attendee._onRoleUpdate(evt.role, evt.roleToken);
            },
            onRemoteControl: function onRemoteControl(evt) {
                if (typeof evt.arg === 'string') {
                    evt.arg = JSON.parse(evt.arg);
                }
                if (evt.arg.op2 === 20 && evt.arg.pic && self._onCapturePicture.call(self, evt)) {
                    return;
                }
                if (evt.arg.op2 === 30 && self._onRemotePannelControl) {
                    try {
                        self._onRemotePannelControl.call(self, evt);
                        return;
                    } catch (e) {
                        _logger.warn(e);
                    }
                }

                // 上麦申请
                if (evt.arg.op2 === 21) {
                    var _evt$arg = evt.arg,
                        applicat_memId = _evt$arg.memId,
                        nickName = _evt$arg.nickName;


                    if (!applicat_memId) {
                        //申请者 memId
                        console.warn('onRequestToTalker not have memberId');
                        return;
                    }

                    self._cache_receive_sessions.push(evt); //将接收到的session 存储

                    var onRequestToTalker = self.listeners.mgr.onRequestToTalker;


                    var applicat = { memberId: applicat_memId, nickName: nickName };
                    if (onRequestToTalker && typeof onRequestToTalker == 'function') {
                        onRequestToTalker(applicat, function (memberId, talker_is_full_callback) {
                            return self.agreeRequestToTalker(memberId, talker_is_full_callback);
                        }, function (memberId) {
                            return self.refuseRequestToTalker(memberId);
                        });
                    }
                    return;
                }

                // 主持人申请回调给管理员
                if (evt.arg.op2 === 22) {
                    var _evt$arg2 = evt.arg,
                        _applicat_memId = _evt$arg2.memId,
                        _nickName = _evt$arg2.nickName;


                    if (!_applicat_memId) {
                        //申请者 memId
                        console.warn('onRequestToAdmin not have memberId');
                        return;
                    }

                    self._cache_receive_sessions.push(evt); //将接收到的session 存储

                    var onRequestToAdmin = self.listeners.mgr.onRequestToAdmin;

                    var _applicat = { memberId: _applicat_memId, nickName: _nickName };
                    if (onRequestToAdmin && typeof onRequestToAdmin == 'function') {
                        onRequestToAdmin(_applicat, function (memberId) {
                            return self.agreeRequestToAdmin(memberId);
                        }, function (memberId) {
                            return self.refuseRequestToAdmin(memberId);
                        });
                    }
                    return;
                }

                // 静音或取消静音 接收消息
                if (evt.arg.op2 === 23) {
                    var callBack = self.listeners.mgr.onMuted;
                    if (callBack && typeof callBack == 'function') {
                        callBack();
                        return;
                    }
                }
                if (evt.arg.op2 === 24) {
                    var _callBack = self.listeners.mgr.onUnmuted;
                    if (_callBack && typeof _callBack == 'function') {
                        _callBack();
                        return;
                    }
                }

                _logger.warn("Not support remote control");

                var message = attendee.newMessage({
                    op: 1001,
                    tsxId: evt.tsxId,
                    memId: evt.memId,
                    arg: (0, _stringify2.default)(evt.arg),
                    result: evt && evt.arg && evt.arg.op2 === 30 ? -405 : -507,
                    msg: "Not support the remote control."
                });

                attendee.postMessage(message, function (rsp) {
                    _logger.warn("Send remote control response. the result = ", rsp.result, rsp.msg || "");
                });
            },
            onRecvRemoteMessage: function onRecvRemoteMessage(evt) {
                attendee._onRecvRemoteMessage && attendee._onRecvRemoteMessage(evt.memId, evt.arg, evt);
            },

            // 402 session的回调 会议属性 和会议状态
            onConfrAttrsUpdated: function onConfrAttrsUpdated(session) {
                // 会议属性 cattrs 处理函数
                var cattrs_updated = function cattrs_updated(evt) {

                    if (!self.listeners.mgr) {
                        return;
                    }
                    var cattrs = self.listeners.mgr.cattrs || []; //内存中的 会议属性

                    function object_to_array(obj) {
                        var array = [];

                        for (var key in obj) {
                            var _item = {};
                            _item.key = key;
                            _item.val = obj[key];
                            _item.op = '';
                            array.push(_item);
                        }

                        return array;
                    };

                    function set_attrs(target_array, array) {
                        if (array.length == 0) {
                            return target_array;
                        }

                        array.forEach(function (item) {
                            //有相同key的对象替换，没有则添加
                            var is_have = false;
                            target_array.forEach(function (target_item, index) {
                                if (target_item.key == item.key) {
                                    target_array.splice(index, 1, item); //替换item
                                    is_have = true;
                                    return;
                                }
                            });

                            if (!is_have) {
                                target_array.push(item);
                            }
                        });

                        return target_array;
                    }

                    // 返回的结构不同，处理
                    // 示例
                    /**
                     * 1. cattrs = {type:"MIXER"};
                     * 2. cattrs = [{key:'type',val:'MIXER',op:'UPDATE}]
                     * 3. 统一成 array 回调给前面
                     * */

                    if (evt.cattrs instanceof Array == true) {
                        cattrs = set_attrs(cattrs, evt.cattrs);
                    } else {
                        cattrs = object_to_array(evt.cattrs);
                    }

                    self.listeners.mgr.cattrs = cattrs; //将处理后的会议属性保存到内存

                    // 以下为回调
                    var onCallBack = self.listeners.mgr.onConfrAttrsUpdated;

                    if (onCallBack && typeof onCallBack == 'function') {
                        onCallBack = onCallBack.bind(self.listeners.mgr);
                        onCallBack(cattrs);
                    }
                };

                // 会议属性 cstate 处理函数
                var cstate_updated = function cstate_updated(evt) {
                    if ( //会议状态为空 或者空对象
                    !evt.cstate || (0, _keys2.default)(evt.cstate).length == 0) {
                        return;
                    }

                    var onCallBack = self.listeners.mgr.onConfrStateUpdated;
                    if (onCallBack && typeof onCallBack == 'function') {
                        onCallBack = onCallBack.bind(self.listeners.mgr);
                        onCallBack(evt.cstate);
                    }
                };

                // 收到回调判断是否有 某一个 cattrs 或者 cstate
                // 会议属性有两种结构
                // 对象或数组 不是空对象 或 空数组 才可以
                if (session.cattrs instanceof Array == true && session.cattrs.length > 0) {
                    // 非空数组
                    cattrs_updated(session);
                }
                if (session.cattrs.constructor == Object && (0, _keys2.default)(session.cattrs).length > 0) {
                    // 非空对象
                    cattrs_updated(session);
                }

                if (session.cstate) {
                    cstate_updated(session);
                }
            },

            onAdminChanged: function onAdminChanged(evt) {

                var onCallBack = self.listeners.mgr.onAdminChanged;
                if (!onCallBack || typeof onCallBack != 'function') {
                    return;
                }

                onCallBack(evt);
            },

            // 上麦申请的回复
            onRequestToTalkerReply: function onRequestToTalkerReply(result) {
                var callback = self.listeners.mgr.onRequestToTalkerReply;

                if (callback && typeof callback == 'function') {
                    callback(result);
                }
            },

            // 主持人申请的回复
            onRequestToAdminReply: function onRequestToAdminReply(result) {
                var callback = self.listeners.mgr.onRequestToAdminReply;

                if (callback && typeof callback == 'function') {
                    callback(result);
                }
            },

            // 存储 liveCfgs
            onLivecfgsChanged: function onLivecfgsChanged(evt) {
                if (evt.liveCfgs) {
                    emedia.config({
                        liveCfgs: evt.liveCfgs
                    });
                }
            }

        });

        return session;
    },

    _judgeTalking: function _judgeTalking(meter) {
        if (!meter) {
            return false;
        }

        return meter.instant >= emedia.config.judgeTalkingByInstantGE;
    },

    graffitiVideo: function graffitiVideo(streamId, videoTag, canvasTag) {
        var self = this;

        var hxStream = self.getStreamById(streamId);

        var mediaStream = new MediaStream();
        mediaStream._located = true;

        hxStream._localMediaStream.getAudioTracks().forEach(function (track) {
            mediaStream.addTrack(track);
        });

        var drawStream = canvasTag.captureStream(25);
        drawStream.getVideoTracks().forEach(function (track) {
            mediaStream.addTrack(track);
        });

        videoTag.srcObject = mediaStream;

        hxStream.updateAttributes({
            localStream: mediaStream,
            isRepublished: true,
            optimalVideoCodecs: hxStream.optimalVideoCodecs
        });
        self.push(hxStream);
    },

    resetCanvas: function resetCanvas(canvasTag) {
        var set;
        if (arguments.length > 1) {
            for (var i = 0; i < arguments.length; i++) {
                set = arguments[i];

                typeof set === "function" && set(canvasTag);
                typeof set !== "function" && _util.isPlainObject(set) && _util.forEach(set, function (key, value) {
                    _logger.debug("Canvas set ", key, " = ", value);
                    canvasTag.setAttribute(key, value);
                });
            }
        }
    },

    _random: function _random(c) {
        return Math.floor(Math.random() * c);
    },
    requestFrame: function requestFrame(stream, millis) {
        var self = this;

        var _cacheStream;
        if (typeof stream === "string") {
            _cacheStream = this.current._cacheStreams[stream];
        } else if (stream.id) {
            _cacheStream = this.current._cacheStreams[stream.id];
        } else {
            return;
        }

        if (!_cacheStream) {
            return;
        }

        function _requestFrame() {
            _cacheStream.requestFrame();

            if (_cacheStream.canvas) {
                var redraw = DefaultMouseTrack.prototype.redraw.bind({ _canvasContext: _cacheStream.canvas.getContext("2d") });
                //_logger.debug(self._random(255));
                redraw(3, 3);
            }
        }

        if (!millis) {
            _requestFrame();
            return;
        }

        setTimeout(function () {
            _requestFrame();
            self.requestFrame(_cacheStream, millis);
        }, millis);
    },

    graffitiCanvas: function graffitiCanvas(withVoice, canvasTag) {
        if (_util.targetDOM(withVoice)) {
            canvasTag = withVoice;
            withVoice = false;
        }

        var self = this;

        var pubS = new self.ShareDesktopPubstream({
            voff: 0,
            aoff: withVoice ? 0 : 1
        });

        canvasTag || (canvasTag = document.createElement("canvas"));

        //canvasTag.getContext("2d", {willReadFrequently: true}); //Fixed: Firefox captureStream  NS_ERROR_NOT_INITIALIZED
        canvasTag.getContext("2d");
        pubS.canvas = canvasTag;

        var diy = function diy() {};
        diy.prototype.setCanvas = function (set) {
            this.canvasTag = canvasTag;
            self.resetCanvas(canvasTag, set);

            return this;
        };

        diy.prototype.push = function (frameRate, _onpushed) {
            var diy = this;
            diy._push(frameRate, _onpushed);
        };
        diy.prototype._push = function (frameRate, _onpushed) {
            if (typeof frameRate === "function") {
                _onpushed = frameRate;
                frameRate = undefined;
            }

            canvasTag.captureStream && (canvasTag.captureStream.enabled = true);
            var drawStream = canvasTag.captureStream(frameRate || 25);

            function pushed(stream) {
                stream.canvas = canvasTag;
                _onpushed && _onpushed(stream, canvasTag, drawStream);

                if (withVoice) {
                    //发送一帧视频
                    stream.requestFrame();
                }
            }

            function pub(pubS, pushed) {
                var mediaStream = new MediaStream();
                mediaStream._located = true;

                pubS._localMediaStream && pubS._localMediaStream.getAudioTracks().forEach(function (track) {
                    mediaStream.addTrack(track);
                });

                drawStream.getVideoTracks().forEach(function (track) {
                    mediaStream.addTrack(track);
                });

                pubS._localMediaStream = mediaStream;
                pubS.localStream = mediaStream;
                self.push(pubS, pushed);
            }

            if (withVoice) {
                self.__getUserMedia({ audio: true }, function success(_user, stream) {
                    pubS._localMediaStream = stream;
                    pub(pubS, pushed);
                });
            } else {
                pub(pubS, pushed);
            }

            return this;
        };

        return new diy();
    },

    blobRecorder: function blobRecorder(mediaStream, options, handleDataAvailable, handleStop) {
        var self = this;

        if (_util.targetDOM(mediaStream)) {
            mediaStream = mediaStream.srcObject;
        }

        options || (options = { mimeType: 'video/webm;codecs=vp9' });
        if (!MediaRecorder.isTypeSupported(options.mimeType)) {
            _logger.info(options.mimeType, ' is not Supported');
            options = { mimeType: 'video/webm;codecs=vp8' };
            if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                _logger.info(options.mimeType, ' is not Supported');
                options = { mimeType: 'video/webm' };
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    _logger.info(options.mimeType, ' is not Supported');
                    options = { mimeType: '' };
                }
            }
        }

        try {
            var mediaRecorder = new MediaRecorder(mediaStream, options);
        } catch (e) {
            _logger.error('Exception while creating MediaRecorder: ', e);
            //alert('Exception while creating MediaRecorder: ' + e + '. mimeType: ' + options.mimeType);
            return;
        }
        var recordedBlobs = [];
        mediaRecorder.onstop = handleStop || function handleStop(event) {
            _logger.info('Recorder stopped: ', event);
        };
        mediaRecorder.ondataavailable = handleDataAvailable || function (event) {
            if (event.data && event.data.size > 0) {
                recordedBlobs.push(event.data);
            }
        };
        // mediaRecorder.start(10); // collect 10ms of data
        // _logger.error('MediaRecorder started', mediaRecorder);

        function BlobRecorder() {
            this.blobs = recordedBlobs;
        }
        BlobRecorder.prototype.start = function (secornds) {
            mediaRecorder.start(secornds);
        };
        BlobRecorder.prototype.stop = function () {
            mediaRecorder.stop();
        };
        BlobRecorder.prototype.playurl = function (options) {
            var superBuffer = new Blob(this.blobs, options || { type: 'video/webm' });
            return window.URL.createObjectURL(superBuffer);
        };
        BlobRecorder.prototype.download = function (filename, options) {
            var blobs = new Blob(this.blobs, options || { type: 'video/webm' });
            self.downloadFile(filename, undefined, blobs);
        };

        return new BlobRecorder();
    },

    // 申请上麦
    requestToTalker: function requestToTalker() {
        this.current.requestToTalker();
    },
    // 读取 _cache_session
    _get_session_by_memberId_and_op_type: function _get_session_by_memberId_and_op_type(memberId, op_type) {
        if (!memberId || !op_type) {
            return undefined;
        }

        var session = undefined;
        this._cache_receive_sessions.map(function (item) {
            var arg = item.arg;

            if (arg && arg instanceof Object && (0, _keys2.default)(arg).length > 0) {
                var applicant_memberId = arg.memId,
                    op = arg.op2;


                if ( // 比较 memberId 和 op 都相等返回 session
                applicant_memberId == memberId && op == op_type) {
                    session = item;
                }
            }
        });

        return session;
    },
    // 删除 _cache_session
    _delete_session_by_memberId_and_op_type: function _delete_session_by_memberId_and_op_type(memberId, op_type) {
        if (!memberId || !op_type) {
            return;
        }

        var _this = this;
        this._cache_receive_sessions.map(function (item, index) {
            var arg = item.arg;

            if (arg && arg instanceof Object && (0, _keys2.default)(arg).length > 0) {
                var applicant_memberId = arg.memId,
                    op = arg.op2;


                if ( // 比较 memberId 和 op 都相等 删除这一项
                applicant_memberId == memberId && op == op_type) {
                    _this._cache_receive_sessions.splice(index, 1);
                }
            }
        });
    },
    // 同意上麦
    agreeRequestToTalker: function () {
        var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(memberId, talker_is_full_callback) {
            var session, memName, confrId;
            return _regenerator2.default.wrap(function _callee2$(_context2) {
                while (1) {
                    switch (_context2.prev = _context2.next) {
                        case 0:
                            session = this._get_session_by_memberId_and_op_type(memberId, 21);

                            if (session) {
                                _context2.next = 3;
                                break;
                            }

                            return _context2.abrupt('return');

                        case 3:
                            memName = session.arg.memName;
                            confrId = this.listeners.confrId;
                            _context2.prev = 5;
                            _context2.next = 8;
                            return this.listeners.mgr.chanageRoles(3, [memName], confrId);

                        case 8:
                            _context2.next = 16;
                            break;

                        case 10:
                            _context2.prev = 10;
                            _context2.t0 = _context2['catch'](5);

                            if (!(_context2.t0.error == -523)) {
                                _context2.next = 16;
                                break;
                            }

                            if (!(talker_is_full_callback && typeof talker_is_full_callback == 'function')) {
                                _context2.next = 16;
                                break;
                            }

                            //回调给使用者
                            talker_is_full_callback();
                            return _context2.abrupt('return');

                        case 16:

                            this._delete_session_by_memberId_and_op_type(memberId, 21);

                        case 17:
                        case 'end':
                            return _context2.stop();
                    }
                }
            }, _callee2, this, [[5, 10]]);
        }));

        function agreeRequestToTalker(_x4, _x5) {
            return _ref2.apply(this, arguments);
        }

        return agreeRequestToTalker;
    }(),
    // 拒绝上麦
    refuseRequestToTalker: function refuseRequestToTalker(memberId) {
        if (!memberId) {
            console.warn('refuseRequestToTalker memberId is required');
            return;
        }

        var session = this._get_session_by_memberId_and_op_type(memberId, 21);

        if (!session) {
            return;
        }

        this.current.refuseRequestToTalker(session);

        this._delete_session_by_memberId_and_op_type(memberId, 21);
    },
    // 申请主持人
    requestToAdmin: function requestToAdmin() {
        this.current.requestToAdmin();
    },
    // 同意成为主持人
    agreeRequestToAdmin: function agreeRequestToAdmin(memberId) {
        var session = this._get_session_by_memberId_and_op_type(memberId, 22);

        if (!session) {
            return;
        }

        var memName = session.arg.memName;
        var confrId = this.listeners.confrId;

        this.listeners.mgr.chanageRoles(7, [memName], confrId);

        this._delete_session_by_memberId_and_op_type(memberId, 22);
    },
    // 拒绝成为主持人
    refuseRequestToAdmin: function refuseRequestToAdmin(memberId) {
        if (!memberId) {
            console.warn('refuseRequestToAdmin memberId is required');
            return;
        }

        var session = this._get_session_by_memberId_and_op_type(memberId, 22);

        if (!session) {
            return;
        }

        this.current.refuseRequestToAdmin(session);

        this._delete_session_by_memberId_and_op_type(memberId, 22);
    },
    // 指定静音
    muteBymemberId: function muteBymemberId(memberId) {

        if (!this.current) {
            return;
        }

        if (this.current.role != 7) {
            return;
        }

        this.current.muteBymemberId(memberId);
    },

    // 指定取消静音
    unmuteBymemberId: function unmuteBymemberId(memberId) {
        if (!this.current) {
            return;
        }

        if (this.current.role != 7) {
            return;
        }

        this.current.unmuteBymemberId(memberId);
    }

});

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(202);


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() { return this })() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = __webpack_require__(203);

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}


/***/ }),
/* 203 */
/***/ (function(module, exports) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() { return this })() || Function("return this")()
);


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _promise = __webpack_require__(156);

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (fn) {
  return function () {
    var gen = fn.apply(this, arguments);
    return new _promise2.default(function (resolve, reject) {
      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }

        if (info.done) {
          resolve(value);
        } else {
          return _promise2.default.resolve(value).then(function (value) {
            step("next", value);
          }, function (err) {
            step("throw", err);
          });
        }
      }

      return step("next");
    });
  };
};

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.9.1
//     http://underscorejs.org
//     (c) 2009-2018 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` (`self`) in the browser, `global`
  // on the server, or `this` in some virtual machines. We use `self`
  // instead of `window` for `WebWorker` support.
  var root = typeof self == 'object' && self.self === self && self ||
            typeof global == 'object' && global.global === global && global ||
            this ||
            {};

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype;
  var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

  // Create quick reference variables for speed access to core prototypes.
  var push = ArrayProto.push,
      slice = ArrayProto.slice,
      toString = ObjProto.toString,
      hasOwnProperty = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var nativeIsArray = Array.isArray,
      nativeKeys = Object.keys,
      nativeCreate = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for their old module API. If we're in
  // the browser, add `_` as a global object.
  // (`nodeType` is checked to ensure that `module`
  // and `exports` are not HTML elements.)
  if ( true && !exports.nodeType) {
    if ( true && !module.nodeType && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.9.1';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      // The 2-argument case is omitted because we’re not using it.
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  var builtinIteratee;

  // An internal function to generate callbacks that can be applied to each
  // element in a collection, returning the desired result — either `identity`,
  // an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value) && !_.isArray(value)) return _.matcher(value);
    return _.property(value);
  };

  // External wrapper for our callback generator. Users may customize
  // `_.iteratee` if they want additional predicate/iteratee shorthand styles.
  // This abstraction hides the internal-only argCount argument.
  _.iteratee = builtinIteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // Some functions take a variable number of arguments, or a few expected
  // arguments at the beginning and then a variable number of values to operate
  // on. This helper accumulates all remaining arguments past the function’s
  // argument length (or an explicit `startIndex`), into an array that becomes
  // the last argument. Similar to ES6’s "rest parameter".
  var restArguments = function(func, startIndex) {
    startIndex = startIndex == null ? func.length - 1 : +startIndex;
    return function() {
      var length = Math.max(arguments.length - startIndex, 0),
          rest = Array(length),
          index = 0;
      for (; index < length; index++) {
        rest[index] = arguments[index + startIndex];
      }
      switch (startIndex) {
        case 0: return func.call(this, rest);
        case 1: return func.call(this, arguments[0], rest);
        case 2: return func.call(this, arguments[0], arguments[1], rest);
      }
      var args = Array(startIndex + 1);
      for (index = 0; index < startIndex; index++) {
        args[index] = arguments[index];
      }
      args[startIndex] = rest;
      return func.apply(this, args);
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var shallowProperty = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  var has = function(obj, path) {
    return obj != null && hasOwnProperty.call(obj, path);
  }

  var deepGet = function(obj, path) {
    var length = path.length;
    for (var i = 0; i < length; i++) {
      if (obj == null) return void 0;
      obj = obj[path[i]];
    }
    return length ? obj : void 0;
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object.
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = shallowProperty('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  var createReduce = function(dir) {
    // Wrap code that reassigns argument variables in a separate function than
    // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
    var reducer = function(obj, iteratee, memo, initial) {
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      if (!initial) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    };

    return function(obj, iteratee, memo, context) {
      var initial = arguments.length >= 3;
      return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
    };
  };

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey;
    var key = keyFinder(obj, predicate, context);
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = restArguments(function(obj, path, args) {
    var contextPath, func;
    if (_.isFunction(path)) {
      func = path;
    } else if (_.isArray(path)) {
      contextPath = path.slice(0, -1);
      path = path[path.length - 1];
    }
    return _.map(obj, function(context) {
      var method = func;
      if (!method) {
        if (contextPath && contextPath.length) {
          context = deepGet(context, contextPath);
        }
        if (context == null) return void 0;
        method = context[path];
      }
      return method == null ? method : method.apply(context, args);
    });
  });

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value != null && value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(v, index, list) {
        computed = iteratee(v, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = v;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value != null && value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(v, index, list) {
        computed = iteratee(v, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = v;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection.
  _.shuffle = function(obj) {
    return _.sample(obj, Infinity);
  };

  // Sample **n** random values from a collection using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);
    var length = getLength(sample);
    n = Math.max(Math.min(n, length), 0);
    var last = length - 1;
    for (var index = 0; index < n; index++) {
      var rand = _.random(index, last);
      var temp = sample[index];
      sample[index] = sample[rand];
      sample[rand] = temp;
    }
    return sample.slice(0, n);
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    var index = 0;
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, key, list) {
      return {
        value: value,
        index: index++,
        criteria: iteratee(value, key, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior, partition) {
    return function(obj, iteratee, context) {
      var result = partition ? [[], []] : {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (has(result, key)) result[key]++; else result[key] = 1;
  });

  var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (_.isString(obj)) {
      // Keep surrogate pair characters together
      return obj.match(reStrSymbol);
    }
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = group(function(result, value, pass) {
    result[pass ? 0 : 1].push(value);
  }, true);

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null || array.length < 1) return n == null ? void 0 : [];
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null || array.length < 1) return n == null ? void 0 : [];
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, Boolean);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, output) {
    output = output || [];
    var idx = output.length;
    for (var i = 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        // Flatten current level of array or arguments object.
        if (shallow) {
          var j = 0, len = value.length;
          while (j < len) output[idx++] = value[j++];
        } else {
          flatten(value, shallow, strict, output);
          idx = output.length;
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = restArguments(function(array, otherArrays) {
    return _.difference(array, otherArrays);
  });

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // The faster algorithm will not work with an iteratee if the iteratee
  // is not a one-to-one function, so providing an iteratee will disable
  // the faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted && !iteratee) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = restArguments(function(arrays) {
    return _.uniq(flatten(arrays, true, true));
  });

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      var j;
      for (j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = restArguments(function(array, rest) {
    rest = flatten(rest, true, true);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  });

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices.
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = restArguments(_.unzip);

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values. Passing by pairs is the reverse of _.pairs.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions.
  var createPredicateIndexFinder = function(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  };

  // Returns the first index on an array-like that passes a predicate test.
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions.
  var createIndexFinder = function(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
          i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  };

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    if (!step) {
      step = stop < start ? -1 : 1;
    }

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Chunk a single array into multiple arrays, each containing `count` or fewer
  // items.
  _.chunk = function(array, count) {
    if (count == null || count < 1) return [];
    var result = [];
    var i = 0, length = array.length;
    while (i < length) {
      result.push(slice.call(array, i, i += count));
    }
    return result;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments.
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = restArguments(function(func, context, args) {
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var bound = restArguments(function(callArgs) {
      return executeBound(func, bound, context, this, args.concat(callArgs));
    });
    return bound;
  });

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder by default, allowing any combination of arguments to be
  // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.
  _.partial = restArguments(function(func, boundArgs) {
    var placeholder = _.partial.placeholder;
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  });

  _.partial.placeholder = _;

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = restArguments(function(obj, keys) {
    keys = flatten(keys, false, false);
    var index = keys.length;
    if (index < 1) throw new Error('bindAll must be passed function names');
    while (index--) {
      var key = keys[index];
      obj[key] = _.bind(obj[key], obj);
    }
  });

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = restArguments(function(func, wait, args) {
    return setTimeout(function() {
      return func.apply(null, args);
    }, wait);
  });

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var timeout, context, args, result;
    var previous = 0;
    if (!options) options = {};

    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };

    var throttled = function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };

    throttled.cancel = function() {
      clearTimeout(timeout);
      previous = 0;
      timeout = context = args = null;
    };

    return throttled;
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, result;

    var later = function(context, args) {
      timeout = null;
      if (args) result = func.apply(context, args);
    };

    var debounced = restArguments(function(args) {
      if (timeout) clearTimeout(timeout);
      if (immediate) {
        var callNow = !timeout;
        timeout = setTimeout(later, wait);
        if (callNow) result = func.apply(this, args);
      } else {
        timeout = _.delay(later, wait, this, args);
      }

      return result;
    });

    debounced.cancel = function() {
      clearTimeout(timeout);
      timeout = null;
    };

    return debounced;
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  _.restArguments = restArguments;

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
    'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  var collectNonEnumProps = function(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  };

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`.
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object.
  // In contrast to _.map it returns an object.
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = _.keys(obj),
        length = keys.length,
        results = {};
    for (var index = 0; index < length; index++) {
      var currentKey = keys[index];
      results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  // The opposite of _.object.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`.
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, defaults) {
    return function(obj) {
      var length = arguments.length;
      if (defaults) obj = Object(obj);
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!defaults || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s).
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test.
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Internal pick helper function to determine if `obj` has key `key`.
  var keyInObj = function(value, key, obj) {
    return key in obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = restArguments(function(obj, keys) {
    var result = {}, iteratee = keys[0];
    if (obj == null) return result;
    if (_.isFunction(iteratee)) {
      if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);
      keys = _.allKeys(obj);
    } else {
      iteratee = keyInObj;
      keys = flatten(keys, false, false);
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  });

  // Return a copy of the object without the blacklisted properties.
  _.omit = restArguments(function(obj, keys) {
    var iteratee = keys[0], context;
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
      if (keys.length > 1) context = keys[1];
    } else {
      keys = _.map(flatten(keys, false, false), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  });

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq, deepEq;
  eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // `null` or `undefined` only equal to itself (strict comparison).
    if (a == null || b == null) return false;
    // `NaN`s are equivalent, but non-reflexive.
    if (a !== a) return b !== b;
    // Exhaust primitive checks
    var type = typeof a;
    if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
    return deepEq(a, b, aStack, bStack);
  };

  // Internal recursive comparison function for `isEqual`.
  deepEq = function(a, b, aStack, bStack) {
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN.
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
      case '[object Symbol]':
        return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError, isMap, isWeakMap, isSet, isWeakSet.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
  var nodelist = root.document && root.document.childNodes;
  if ( true && typeof Int8Array != 'object' && typeof nodelist != 'function') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return !_.isSymbol(obj) && isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`?
  _.isNaN = function(obj) {
    return _.isNumber(obj) && isNaN(obj);
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, path) {
    if (!_.isArray(path)) {
      return has(obj, path);
    }
    var length = path.length;
    for (var i = 0; i < length; i++) {
      var key = path[i];
      if (obj == null || !hasOwnProperty.call(obj, key)) {
        return false;
      }
      obj = obj[key];
    }
    return !!length;
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  // Creates a function that, when passed an object, will traverse that object’s
  // properties down the given `path`, specified as an array of keys or indexes.
  _.property = function(path) {
    if (!_.isArray(path)) {
      return shallowProperty(path);
    }
    return function(obj) {
      return deepGet(obj, path);
    };
  };

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    if (obj == null) {
      return function(){};
    }
    return function(path) {
      return !_.isArray(path) ? obj[path] : deepGet(obj, path);
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

  // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped.
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // Traverses the children of `obj` along `path`. If a child is a function, it
  // is invoked with its parent as context. Returns the value of the final
  // child, or `fallback` if any child is undefined.
  _.result = function(obj, path, fallback) {
    if (!_.isArray(path)) path = [path];
    var length = path.length;
    if (!length) {
      return _.isFunction(fallback) ? fallback.call(obj) : fallback;
    }
    for (var i = 0; i < length; i++) {
      var prop = obj == null ? void 0 : obj[path[i]];
      if (prop === void 0) {
        prop = fallback;
        i = length; // Ensure we don't continue iterating.
      }
      obj = _.isFunction(prop) ? prop.call(obj) : prop;
    }
    return obj;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate: /<%([\s\S]+?)%>/g,
    interpolate: /<%=([\s\S]+?)%>/g,
    escape: /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'": "'",
    '\\': '\\',
    '\r': 'r',
    '\n': 'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offset.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    var render;
    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var chainResult = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return chainResult(this, func.apply(_, args));
      };
    });
    return _;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return chainResult(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return chainResult(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return String(this._wrapped);
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
      return _;
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
}());

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(206), __webpack_require__(2)(module)))

/***/ }),
/* 206 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof2 = __webpack_require__(73);

var _typeof3 = _interopRequireDefault(_typeof2);

var _stringify = __webpack_require__(144);

var _stringify2 = _interopRequireDefault(_stringify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _util = __webpack_require__(72);
var _logger = _util.tagLogger("Sess");

var __event = __webpack_require__(208);

var __url_seqno = 0;
var DeployMore = __webpack_require__(209).default; // 多集群

var Message = _util.prototypeExtend({
    setSessId: function setSessId(sessId) {
        sessId && (this.sessId = sessId);
        return this;
    },
    setOp: function setOp(op) {
        op && (this.op = op);

        if (op === 200) {
            this.res = {
                type: emedia.config.clientType,
                ver: window._emediaVersion || emedia.config.version,
                agent: emedia.config.userAgent,
                ops: emedia.config.acptOps
            };

            //this.res = JSON.stringify(this.res);
        }

        return this;
    },
    setTsxId: function setTsxId(tsxId) {
        tsxId && (this.tsxId = tsxId);
        return this;
    },
    setTicket: function setTicket(tkt) {
        tkt && (this.tkt = tkt);
        return this;
    },
    setSdp: function setSdp(sdp) {
        sdp && (this.sdp = sdp);
        return this;
    },
    setCands: function setCands(cands) {
        cands && (this.cands = cands);
        return this;
    },
    setSubSId: function setSubSId(subSId) {
        subSId && (this.subSId = subSId);
        return this;
    },
    setMemId: function setMemId(memId) {
        memId && (this.memId = memId);
        return this;
    },
    setPubS: function setPubS(pubS) {
        pubS && (this.pubS = _util.extend(false, {}, pubS));

        var thisPubS = this.pubS;
        if (thisPubS.ext && _util.isPlainObject(thisPubS.ext)) {
            thisPubS.ext = (0, _stringify2.default)(thisPubS.ext);
        }

        thisPubS && _util.forEach(thisPubS, function (key, value) {
            if (_util.isPlainObject(value) || typeof value === 'function') {
                if (key != 'resolution') {
                    //不能 删除分辨率参数
                    _util.removeAttribute(thisPubS, key);
                }
            }
        });

        thisPubS && _util.removeAttribute(thisPubS, "localStream");
        thisPubS && _util.removeAttribute(thisPubS, "_localMediaStream");
        thisPubS && _util.removeAttribute(thisPubS, "_webrtc");

        return this;
    },
    setRtcId: function setRtcId(rtcId) {
        rtcId && (this.rtcId = rtcId);
        return this;
    },
    setCver: function setCver(cver) {
        cver && (this.cver = cver);
        return this;
    },
    setEndReason: function setEndReason(endReason) {
        endReason && (this.endReason = endReason);
        return this;
    },
    setNickName: function setNickName(nickName) {
        nickName && (this.nickName = nickName);
        return this;
    },
    setResource: function setResource(resource) {
        resource && (this.resource = resource);
        return this;
    },
    setReason: function setReason(reason) {
        reason && (this.reason = reason);
        return this;
    },
    setConfrId: function setConfrId(confrId) {
        confrId && (this.confrId = confrId);
        return this;
    },
    setVoff: function setVoff(voff) {
        typeof voff === "undefined" || (this.voff = voff ? 1 : 0);
        return this;
    },
    setAoff: function setAoff(aoff) {
        typeof aoff === "undefined" || (this.aoff = aoff ? 1 : 0);
        return this;
    },
    setFlag: function setFlag(flag) {
        flag === 0 && (this.flag = 0);
        flag === 1 && (this.flag = 1);

        return this;
    },
    setExt: function setExt(ext) {
        if (ext && _util.isPlainObject(ext)) {
            ext = (0, _stringify2.default)(ext);
        }
        ext && (this.ext = ext);
        return this;
    }
});

/**
 * {
 *   websocket:
 *   onMessage:
 *   _postMessage(Message):
 *   onError:
 * }
 *
 * reconnectCount > 0 时不上报错误（调用onWebsocketEvent）。
 * 不存在或==0 调用调用onWebsocketEvent
 * 调用onWebsocketEvent WSClose时 将会关闭
 *
 * @returns {*}
 *
 */

var __session_globalCount = emedia.__session_globalCount = 0;

function _connect(onConnected, onConnectFail, retry) {
    var self = this;

    function connectFail(cause, _evt) {
        try {
            self.onWebsocketEvent(new __event.WSClose({ url: self.thisWsUri, retry: retry, online: self.online, cause: cause, event: _evt, session: self }));
        } finally {
            onConnectFail && onConnectFail(new __event.WSClose({ url: self.thisWsUri, retry: retry, online: self.online, cause: cause, event: _evt, session: self }));
        }
    }

    function post(message) {
        if (!self.connected(self.thisWsUri)) {
            _logger.debug("current dont connect. the message = ", message);
            return;
        }

        if (_util.isPlainObject(message) && !(message instanceof Message)) {
            _logger.error("message not a Messages");
            throw "message not a Messages";
        }

        if (self.sessId && message.sessId != self.sessId) {
            _logger.warn("self.sessId && message.sessId != self.sessId", message);
            return;
        }

        var wsMsg = (0, _stringify2.default)(message);

        self.thisWsUri === self._websocket.url && self._websocket.send(wsMsg);
        self.thisWsUri === self._websocket.url && _logger.debug("Done send req:", wsMsg, self._websocket.url);
        self.thisWsUri === self._websocket.url || _logger.debug("Donot send(url not equal): req:", wsMsg, self._websocket.url);
    }

    function notifyNewMessage() {

        if (self.connected(self.thisWsUri)) {
            if (self._bufferedMessages.length === 0) {
                return;
            }

            var __array = [];

            var bufferedMessage;
            while (bufferedMessage = self._bufferedMessages.shift()) {
                if (!bufferedMessage.sessId && !self.sessId && bufferedMessage.op != 200) {
                    //等待Enter
                    __array.push(bufferedMessage);
                    _logger.warn("tmp store message, util enter success!", bufferedMessage);
                    continue;
                }

                if (bufferedMessage.op === 200) {
                    //200单独发送，有可能会修改session值
                    post(bufferedMessage);
                    break;
                }

                if (self.sessId && !bufferedMessage.sessId) {
                    bufferedMessage.sessId = self.sessId;
                }

                var _bufferedMessage = post(bufferedMessage);
                _bufferedMessage && __array.push(_bufferedMessage);
            }

            if (__array.length > 0) {
                Array.prototype.push.apply(self._bufferedMessages, __array);
            }
            //} else if(!retry || !self.online){
        } else if (retry === 0 || !self.online) {
            var _messageMap = _util.extend(false, {}, self._callbacks);

            var tmp = [];
            for (var tsxId in _messageMap) {
                var msg = _messageMap[tsxId];
                //if(retry > 0 && !self.online && (msg.op === 107 || msg.op === 201 || msg.op === 204 || msg.op === 206 || msg.op === 400 || msg.op === 500)) {
                if (retry > 0 && !self.online) {
                    //缓存所有消息
                    tmp.push(msg);
                    continue;
                }
                self.onMessage({ op: 1001, tsxId: tsxId, result: -9527, msg: "sdk rsp fail. retry fail or online = " + self.online });
            }

            self._bufferedMessages = self._bufferedMessages || [];

            tmp.length > 0 && Array.prototype.push.apply(self._bufferedMessages, tmp);
        } else if (!self.connected()) {
            // var _messageMap = _util.extend(false, {}, self._callbacks);
            //
            // for(var tsxId in _messageMap){
            //     var msg = _messageMap[tsxId];
            //     if(msg.op !== 102 && msg.op !== 105 && msg.op !== 1000) {
            //         continue;
            //     }
            //     self.onMessage({op: 1001, tsxId: tsxId, result: -9527, msg: "websocket disconnect", retrying: true});
            // }
        }
    }

    if (self.connected(self.thisWsUri)) {
        onConnected && onConnected(self);
        _logger.info("Session connected. dont continue connect");
        self.notifyNewMessage && self.notifyNewMessage();

        return;
    }

    if (!self.online) {
        connectFail();
        return;
    }

    self.notifyNewMessage = notifyNewMessage;

    _logger.info("Session begin connect.");

    var _websocket = self._websocket;
    if (_websocket) {
        _logger.warn("will close. websocket state", _websocket.readyState, _websocket.url, self.thisWsUri);
        _websocket.close(1000);
    }

    try {
        _logger.info("Connecting", self.thisWsUri, retry);
        _websocket = self._websocket = new WebSocket(self.thisWsUri);
    } catch (e) {
        _logger.warn(e);
        connectFail(e);

        return;
    }

    _websocket.onopen = function (evt) {
        var _url = this.url;
        if (_url !== self.thisWsUri) {
            _logger.warn("ignore the onopen. caused by websocket url not ", self.thisWsUri, _url);
            return;
        }

        try {
            _logger.info("websocket connected:", _url);
            onConnectFail && (onConnectFail = null);
            onConnected && onConnected(self);
            self.onWebsocketEvent(new __event.WSConnected({ event: evt, session: self }));
        } finally {
            //self.notifyNewMessage();
        }
    };

    _websocket.onmessage = function (evt) {

        var _url = this.url;
        if (_url !== self.thisWsUri) {
            _logger.warn("ignore recv data. caused by websocket url not ", self.thisWsUri, _url, evt.data);
            return;
        }

        _logger.debug("recv data", evt.data);

        var data = JSON.parse(evt.data);
        data && data.op == 1001 && _logger.debug("recv message: rsp:", data);
        data && data.op != 1001 && _logger.debug("recv message: evt:", data);

        self.onMessage(data);
    };

    _websocket.onclose = function (evt) {
        var _url = this.url;
        _logger.info("Disconnected:", _url, self.thisWsUri, evt);
        if (_url !== self.thisWsUri) {
            _logger.warn("ignore onclose. caused by websocket url not ", self.thisWsUri, _url);
            return;
        }

        self.notifyNewMessage();

        if (evt.code !== 1000) {
            //手动断开
            connectFail(undefined, evt);
        }
    };

    _websocket.onerror = function (evt) {
        _logger.info("On error:", evt);

        self.onWebsocketEvent(new __event.WSError({ event: evt, online: self.online, session: self, url: this.url }));
    };
}

/**
 * {
 *   ticket:
 *   reconnectCount:
 *   onError:
 *
 *   onEnter:
 *   onExit:
 *   onPub:
 *   onUnpub:
 *   onMems:
 *   onClose:
 *
 *   onInitC:
 *   onTcklC:
 *
 *
 *   newMessage:
 *   postMessage:
 * }
 *
 *
 * @private
 */
module.exports = _util.prototypeExtend({
    _events: {
        '0': 'onReqP2P',
        '1': 'onNewCfr',
        '2': 'onDelCfr',
        '3': 'onReqTkt',

        '100': 'onPing',
        '101': 'onPong',
        '102': 'onInitC',
        '103': 'onReqC',
        '104': 'onAcptC',
        '105': 'onTcklC',
        '106': 'onAnsC',
        '107': 'onTermC',

        '300': 'onEnter',
        '301': 'onExit',
        '302': 'onPub',
        '303': 'onUnpub',
        '304': 'onMems',
        '204': 'onClose',
        '400': 'onStreamControl',
        '401': 'onJoin',
        '412': 'onRoleUpdate',
        '1002': 'onRemoteControl',
        '1003': 'onRecvRemoteMessage',

        //'onServerError': 'onServerError'
        '402': 'onConfrAttrsUpdated',
        '413': 'onAdminChanged',
        '452': 'onLivecfgsChanged'
    },

    __init__: function __init__() {
        var self = this;

        //self.owner = null;

        self._bufferedMessages = [];
        self._callbacks = {};

        function nowline() {
            if (navigator.onLine) {
                self.online = true;
            } else {
                self.online = false;
            }
        }

        nowline();

        // window.__hx_checkLineIntervalId_ && clearInterval(window.__hx_checkLineIntervalId_);
        // window.__hx_checkLineIntervalId_ = setInterval(function () {
        //     var lastOnline = self.online;
        //     nowline();
        //     if(!lastOnline && self.online){
        //         online();
        //     }
        //     if(lastOnline && !self.online){
        //         offline();
        //     }
        // }, 500);


        function online(e) {
            self.online = true;
            _logger.warn("online online online");

            if (!self.closed) {
                self._reconnect(emedia.config.reconnect);
            }
        }

        function offline(e) {
            self.online = false;
            _logger.warn("offline offline offline");

            self.__checkConnectIntervalId && clearTimeout(self.__checkConnectIntervalId);

            self.__retryConnectIntervalId && clearTimeout(self.__retryConnectIntervalId);
            self.__retryConnectIntervalId && delete self.__retryConnectIntervalId;

            self._websocket && self._websocket.close(1000);
        }

        window.addEventListener("online", online, true);

        window.addEventListener("offline", offline, true);

        _logger.info("online status = ", self.online);
    },

    _nextWsUri: function _nextWsUri() {
        var self = this;

        var url = self.ticket.url;

        // var hostname = window.location.hostname;
        // if(hostname.endsWith("paic.com.cn")){ //pingan.com.cn -> paic.com.cn
        //     url = url.replace("pingan.com.cn", "paic.com.cn");
        // }else if(hostname.endsWith("pingan.com.cn")){ // paic.com.cn -> pingan.com.cn
        //     url = url.replace("paic.com.cn", "pingan.com.cn");
        // }
        // _logger.warn("ticket url modifiy. ", hostname, url);

        // 如果使用多集群 加入之前 拿rtcconfig.json 重置 ws
        if (emedia.config.useDeployMore) {
            emedia.mgr.rtc_url_config = null;
            emedia.mgr.rtc_url_config = new DeployMore(emedia.config.rtcConfigUrl || '');
            url = emedia.mgr.rtc_url_config.replace_ws(url);
        }

        var replaceFunc = emedia.config && emedia.config.convertWebsocketURLOfTicket || emedia.convertWebsocketURLOfTicket;
        if (typeof replaceFunc === "function") {
            var oldUrl = url;
            url = replaceFunc(url);
            _logger.warn(oldUrl, "-->", url);
        }

        if (url.startsWith('/')) {
            //通过地址栏 补齐url
            if (emedia.config.wsorigin) {
                url = emedia.config.wsorigin + url;
            } else {
                var href = window.location.href;
                var proto = href.startsWith("https") ? "wss://" : "ws://";

                var startIndex = href.indexOf("://") + 3;
                var endIndex = href.indexOf("/", startIndex);
                var wsorigin = href.substring(startIndex, endIndex);

                url = proto + wsorigin + url;
            }

            _logger.warn("websocket url. update. {} -> {}", self.ticket.url, url);
        } else if (emedia.config.wsorigin) {
            _logger.warn("emedia.config.wsorigin invalidate. causeby server url {}", url);
        }

        if (url.indexOf("?") >= 0) {
            url += "&" + __url_seqno++;
        } else {
            url += "?" + __url_seqno++;
        }

        // if(self.ticket.confrId){
        //     url += "&" + encodeURIComponent(self.ticket.confrId);
        // }
        return url;
    },

    _reconnect: function _reconnect(retry) {
        var self = this;

        function connected() {
            _logger.warn("Reconnected. at ", retry, self._websocket.url);
            self.__retryConnectIntervalId && clearTimeout(self.__retryConnectIntervalId);
            self.__retryConnectIntervalId && delete self.__retryConnectIntervalId;

            var enter = self.newMessage().setOp(200).setSessId(self._sessionId).setTicket(self.ticket).setNickName(self.nickName || self.ticket.memName).setResource(self.resource).setExt(self.owner.ext);
            self.postMessage(enter, function (rsp) {
                if (rsp.result != 0) {
                    try {
                        self.onEvent(new __event.EnterFail({
                            me: self.owner,
                            cause: new __event.RspFail({ request: enter, response: rsp }) }));
                    } finally {
                        if (rsp.result !== -9527) {
                            //-9527 客户端 自己返回，网络未通， 其他值服务端返回
                            self.onEvent(new __event.ServerRefuseEnter({ failed: rsp.result, msg: rsp.msg }));
                        }
                    }

                    return;
                }
                // 重新连接 webrtc start 兼容bug android-wechat [ISSUE-1262]
                var owner = self.owner;
                _util.forEach(owner._cacheStreams, function (_sid, stream) {
                    if (!owner._maybeNotExistStreams[_sid]) {
                        //_maybeNotExistStreams 中的stream 将在 Enter success后，重建，所以在_maybeNotExistStreams中，不需要rebuild
                        if (stream._webrtc) {
                            var _webrtc = stream._webrtc;
                            if (!_webrtc.closed) {
                                _logger.warn("network chanage. webrtc will rebuild.", _webrtc._rtcId, _webrtc.__id);
                                owner.onICEClosed(_webrtc);
                            }
                        }
                    }
                });
                // 重连 webrtc end
                self.onEvent(new __event.EnterSuccess({ ip: self.owner.ip }));

                self.owner.onMembers(rsp.cver, rsp.mems);
                self.owner.onStreams(rsp.cver, rsp.streams);

                self.notifyNewMessage();
            });
        }

        function failed(evt) {
            if (retry <= 0) {
                _logger.warn("Reconnect end. but fail.", evt.url, retry);
                self.__retryConnectIntervalId && delete self.__retryConnectIntervalId;

                return;
            }
            retry && (self.__retryConnectIntervalId = setTimeout(function () {
                self.connect(connected, failed, --retry);
            }, emedia.config.reconnectDelay));
        }

        self.connect(connected, failed, --retry);
    },

    __checkConnect: function __checkConnect() {
        var self = this;

        self.__checkConnectIntervalId && clearTimeout(self.__checkConnectIntervalId);

        emedia.config.checkConnectIntervalMillis && (self.__checkConnectIntervalId = setTimeout(function () {
            //_logger.trace("Check connect..");

            try {
                if (self.online && !self.connected()) {
                    self.__retryConnectIntervalId && _logger.debug("online, reconnecting...");
                    self.__retryConnectIntervalId || _logger.debug("online, but disconnect. will reconnect");
                    self.__retryConnectIntervalId || self._reconnect(emedia.config.reconnect);
                } else {
                    //self.notifyNewMessage && self.notifyNewMessage();
                }
            } finally {
                self.__checkConnect();
            }
        }, emedia.config.checkConnectIntervalMillis));
    },

    connect: function connect(onConnected, onConnectFail, retry) {
        var self = this;

        var nextUrl = self.thisWsUri = self._nextWsUri();

        typeof retry !== "undefined" && _logger.warn("begin connect... at retry = ", retry, nextUrl);

        function connected() {
            try {
                onConnected.apply(self, arguments);
            } finally {
                self.__checkConnect();
            }
        }

        function failed(evt) {
            try {
                onConnectFail.apply(self, arguments);
            } finally {
                retry || evt.url !== nextUrl || self.onEvent(new __event.ServerRefuseEnter({
                    failed: -95270, msg: "sdk reconnect fail. " + nextUrl + "|" + evt.url }));
            }
        }
        _connect.call(self, connected, failed, retry);
    },

    connected: function connected(wsUri) {
        var self = this;
        var result = self.online && self._websocket && (!wsUri || wsUri === self._websocket.url) && self._websocket.readyState == WebSocket.OPEN;
        //_logger.trace("Connected?", result, self.online, wsUri, self._websocket && self._websocket.url, self._websocket && self._websocket.readyState);

        return result;
    },

    onWebsocketEvent: function onWebsocketEvent(evt) {
        var self = this;
        self.onEvent(evt);
    },

    register: function register(listeners) {

        if ((typeof listeners === 'undefined' ? 'undefined' : (0, _typeof3.default)(listeners)) === "object") {
            for (var event in listeners) {
                this.bind(event, listeners[event]);
            }
        }
    },

    bind: function bind(event, func) {
        var self = this;
        var onFunc;
        if (onFunc = self._events[event]) {
            self[onFunc] = func;
        } else {
            _logger.error("Not supported event = ", event);
            throw "Not supported event = " + event;
        }
    },

    getSessionId: function getSessionId() {
        return this._sessionId;
    },

    newMessage: function newMessage(cfg) {
        return new Message(cfg);
    },

    __modifyMessage: function __modifyMessage(message) {
        if (message && message.sdp) {
            if (typeof message.sdp === 'string') {
                message.sdp = _util.parseJSON(message.sdp);
            }
            message.sdp.type && (message.sdp.type = message.sdp.type.toLowerCase());
            message.cctx && (message.sdp.cctx = message.cctx);
        }
        if (message && message.cands) {
            if (typeof message.cands === 'string') {
                message.cands = _util.parseJSON(message.cands);
            }

            for (var i = 0; i < message.cands.length; i++) {
                typeof message.cands[i] === 'string' && (message.cands[i] = _util.parseJSON(message.cands[i]));

                message.cands[i].sdpMLineIndex = message.cands[i].mlineindex;
                message.cands[i].sdpMid = message.cands[i].mid;

                delete message.cands[i].mlineindex;
                delete message.cands[i].mid;

                message.cctx && (message.cands[i].cctx = message.cctx);
            }
        }

        if (message && message.mems) {
            if (!_util.isArray(message.mems)) {
                return;
            }

            var _mems = message.mems;
            message.mems = {};

            _util.forEach(_mems, function (index, _mem) {
                _mem.name && (_mem.memName = _mem.name);
                message.mems[_mem.id] = _mem;

                var acptOps = _mem.acptOps = {};
                _util.forEach(emedia.config.baseAcptOps, function (_index, _oper) {
                    acptOps[_oper] = true;
                });
                if (_mem.res) {
                    _util.forEach(_mem.res.ops, function (_index, _oper) {
                        acptOps[_oper] = true;
                    });
                }

                if (_mem && _mem.ext) {
                    try {
                        message.mems[_mem.id].ext = JSON.parse(_mem.ext);
                    } catch (e) {
                        _logger.debug(e);
                    }
                }
            });
        }

        if (message && message.mem) {
            message.mem.name && (message.mem.memName = message.mem.name);

            var acptOps = message.mem.acptOps = {};
            _util.forEach(emedia.config.baseAcptOps, function (_index, _oper) {
                acptOps[_oper] = true;
            });
            if (message.mem.res) {
                _util.forEach(message.mem.res.ops, function (_index, _oper) {
                    acptOps[_oper] = true;
                });
            }

            if (message.mem && message.mem.ext) {
                try {
                    message.mem.ext = JSON.parse(message.mem.ext);
                } catch (e) {
                    _logger.debug(e);
                }
            }
        }

        if (message && message.streams) {
            if (!_util.isArray(message.streams)) {
                return;
            }

            var _streams = message.streams;
            message.streams = {};

            _util.forEach(_streams, function (index, _stream) {
                message.streams[_stream.id] = _stream;

                if (_stream && _stream.ext) {
                    try {
                        message.streams[_stream.id].ext = JSON.parse(_stream.ext);
                    } catch (e) {
                        _logger.debug(e);
                    }
                }
            });
        }

        if (message && message.pubS) {
            if (message.pubS && message.pubS.ext) {
                try {
                    message.pubS.ext = JSON.parse(message.pubS.ext);
                } catch (e) {
                    _logger.debug(e);
                }
            }
        }

        if (message && message.ext) {
            try {
                message.ext = JSON.parse(message.ext);
            } catch (e) {
                _logger.debug(e);
            }
        }

        return message;
    },

    onMessage: function onMessage(servMessage) {

        var self = this;

        function onFunc(servMessage) {

            var fun_name = self._events[servMessage.op];

            var onFunCallback = self[fun_name];

            if (onFunCallback) {

                onFunCallback.call(self, servMessage);
            } else {
                //throw "Not supported event = " + servMessage;
                _logger.warn("Not supported event = ", servMessage);
                return;
            }
        }

        if (servMessage.op != 1001 && !servMessage.sessId) {
            _logger.error("message sessId error. server evt data error");
            throw "message sessId error. server evt data error";
        }

        if (servMessage.op != 1001 && self._sessionId && self._sessionId != servMessage.sessId) {
            _logger.error("message sessId error. server and local not equal");
            throw "message sessId error. server and local not equal";
        }

        if (servMessage.op === 1004) {
            onFunc(servMessage);
            return;
        }

        // 上麦申请 和主持人申请的回复
        if (servMessage.op == 1001 && servMessage.arg) {
            var _JSON$parse = JSON.parse(servMessage.arg),
                op2 = _JSON$parse.op2;

            if (op2 == 21) {
                //上麦申请 code
                var _servMessage = servMessage,
                    result = _servMessage.result;

                self.onRequestToTalkerReply(result);
                return;
            } else if (op2 == 22) {
                // 主持人申请 code
                var _servMessage2 = servMessage,
                    _result = _servMessage2.result;

                self.onRequestToAdminReply(_result);
                return;
            }
        }

        servMessage = self.__modifyMessage(servMessage);

        var preIp;
        var reqMessage = _util.removeAttribute(self._callbacks, servMessage.tsxId);
        if (reqMessage && reqMessage.op === 200) {
            self._sessionId = servMessage.sessId;
            var nowIp = typeof servMessage.yourIp === "string" ? servMessage.yourIp : undefined;

            if (typeof self._session_ip === "string" && nowIp != self._session_ip) {
                preIp = self._session_ip;
            }

            _logger.info(self._sessionId, "ip is", nowIp, preIp);
            self._session_ip = nowIp;
            self.owner.ip = nowIp;

            if (servMessage.result === 0) {
                //enter 成功

                for (var index in self._bufferedMessages) {
                    var message = self._bufferedMessages[index];

                    if (!message.sessId && message.op !== 200) {
                        message.sessId = servMessage.sessId;
                    }
                }

                setTimeout(function () {
                    self.notifyNewMessage();
                }, 100);

                //用来回调会议属性监听函数
                // 只在加入后（200） 和 有修改时（402）回调上去
                if (servMessage.op == 1001 && (servMessage.cattrs || servMessage.cstate)) {
                    self.onConfrAttrsUpdated(servMessage);
                }
            } else {
                var bufferedMessage;
                while (bufferedMessage = self._bufferedMessages.shift()) {
                    if (bufferedMessage.op === 200) {
                        continue;
                    }

                    self.onMessage({ op: 1001, tsxId: bufferedMessage.tsxId, result: -9527, msg: "sdk enter fail. sdk callback. enter result = " + servMessage.result });
                }
            }
        }

        if (self.owner && self.owner.closed) {
            _logger.warn("self closed. me is " + self.owner.getMemberId() + ", session_id = " + self.getSessionId() + ". drop message", servMessage);
            return;
        }

        self.onEvent(new __event.RecvResponse({ request: reqMessage, response: servMessage }));

        if (reqMessage && reqMessage.__callback__ && servMessage.op !== 1004) {
            reqMessage.__callback__(servMessage);
            preIp && self.onWebsocketEvent(new __event.NetworkChanaged({ preIp: preIp, nowIp: self._session_ip }));
            return;
        }

        if (!servMessage.op || servMessage.op == 1001) {
            _logger.debug("Igron message. caused by op not found.", servMessage);
            return;
        }

        onFunc(servMessage);
        preIp && self.onWebsocketEvent(new __event.NetworkChanaged({ preIp: preIp, nowIp: self._session_ip }));
    },

    __modifyMessageForPost: function __modifyMessageForPost(message) {
        if (message.cands) {
            var _cands = [];

            var cands = message.cands;
            for (var i = 0; i < cands.length; i++) {
                var _cand;

                if (i == 0) {
                    cands[i].cctx && (message.cctx = cands[i].cctx);
                }

                if (typeof cands[i] === "string") {
                    _cand = {
                        type: "candidate",
                        candidate: cands[i],
                        mlineindex: 0,
                        mid: "audio"
                        // seq: i
                    };
                } else {
                    // if (cands[i].type && cands[i].type == "candidate") {
                    //     _cands.push(cands[i]);
                    //     continue;
                    // }

                    _cand = {
                        type: "candidate",
                        candidate: cands[i].candidate,
                        mlineindex: cands[i].sdpMLineIndex,
                        mid: cands[i].sdpMid
                        // seq: i
                    };
                }

                _cands.push((0, _stringify2.default)(_cand));
            }

            message.cands = _cands;
        }

        if (message.sdp && typeof message.sdp !== "string") {
            var _sdp = {
                type: message.sdp.type,
                sdp: message.sdp.sdp
            };

            message.sdp.cctx && (message.cctx = message.sdp.cctx);

            message.sdp = _sdp;

            message.sdp.type = message.sdp.type.toUpperCase();
            message.sdp = _util.stringifyJSON(message.sdp);
        }

        // if(message.ext && _util.isPlainObject(message.ext)){
        //     message.ext = JSON.stringify(message.ext);
        // }

        message.pubS && _util.removeAttribute(message.pubS, "_located");
        message.pubS && _util.removeAttribute(message.pubS, "mutedMuted");
        message.pubS && _util.removeAttribute(message.pubS, "mediaStream");
        message.pubS && _util.removeAttribute(message.pubS, "isRepublished");
        message.pubS && _util.removeAttribute(message.pubS, "optimalVideoCodecs");

        typeof message.post === "function" && _util.removeAttribute(message, "post");

        return message;
    },

    postMessage: function postMessage(message, callback, timeoutMillis) {

        if (message.op == 1002) {
            console.log('postMessage 1002', (0, _stringify2.default)(message));
        }
        var self = this;

        if (!message.tsxId) {
            message.tsxId = "MSG" + Date.now() + "-" + __session_globalCount++;
        }

        if (message.memId) {
            var _mem = self.owner._cacheMembers[message.memId];

            // 动作消息、不执行 _cacheMembers内查找
            var _message = message,
                arg = _message.arg;

            var is_action_message = false;
            if (arg) {
                arg = JSON.parse(arg);
                if (arg.op2 == 21 || arg.op2 == 22 || arg.op2 == 23 || arg.op2 == 24) {
                    is_action_message = true;
                }
            }

            if (!_mem && !is_action_message) {
                _logger.warn("Member not found at local. memberId = " + message.memId, message);
                callback && callback({ op: 1001, tsxId: message.tsxId, result: -507, msg: " member not found at local. memberId = " + message.memId });
                return;
            }

            var reqOps = message._reqOps;
            if (!reqOps) {
                reqOps = [];
                reqOps.push(message.op);
            }

            if (!is_action_message) {
                //动作消息 不走这里 
                for (var index in reqOps) {
                    var _reqOp = reqOps[index];

                    if (!_mem.acptOps[_reqOp]) {
                        _logger.warn("Member not accept op " + _reqOp + ", " + message.memId, message);
                        callback && callback({ op: 1001, tsxId: message.tsxId, result: -507, msg: " member not accept op " + _reqOp + ", " + message.memId });
                        return;
                    }
                }
            }
        }
        _util.removeAttribute(message, '_reqOps');

        if (self._sessionId && self._sessionId != message.sessId) {
            _logger.warn("sessionId not excepted. self._sessionId = " + self._sessionId, message);
            callback && callback({ op: 1001, tsxId: message.tsxId, result: -9527, msg: "sessionId not excepted." });
            return;
        }
        if (self.closed) {
            _logger.warn("session closed.", message);
            callback && callback({ op: 1001, tsxId: message.tsxId, result: -9527, msg: "session closed" });
            return;
        }

        var oldMessage = _util.extend({}, message);
        message = self.__modifyMessageForPost(message);
        if (!message) {
            _logger.warn("Message drop. callback success.", message);
            callback && callback({ op: 1001, tsxId: oldMessage.tsxId, result: 0, msg: "Message drop. callback success." });
            return;
        }

        if (message.op === 200) {
            // enter 放在首位
            self._bufferedMessages.unshift(message);

            if (callback) {
                setTimeout(function () {
                    if (!self._callbacks[message.tsxId]) {
                        return;
                    }

                    _logger.error("Enter timeout. fail.");
                    self.onMessage({ op: 1001, tsxId: message.tsxId, result: -9527, msg: "enter timeout. millis = " + emedia.config.enterTimeout });
                }, emedia.config.enterTimeout);
            }
        } else {
            self._bufferedMessages.push(message);
        }

        callback && (self._callbacks[message.tsxId] = _util.extend(message, {
            __callback__: callback.bind(self.owner)
        }));

        self.notifyNewMessage && self.notifyNewMessage();

        if (timeoutMillis && callback) {
            setTimeout(function () {
                var message = self._callbacks[message.tsxId];

                if (message && message.__callback__) {
                    message.__callback__({ op: 1001, tsxId: oldMessage.tsxId, result: -408, msg: "Message request timeout." });
                }

                _util.removeAttribute(self._callbacks, message.tsxId);
            }, timeoutMillis);
        }
    },

    close: function close(reason) {
        _logger.warn("sessiong closing, reason = ", reason);

        var self = this;

        self.notifyNewMessage && self.notifyNewMessage();

        self.closed = true;

        self.seqno = 0;

        self._websocket && (reason == 0 || reason == 100 ? self._websocket.close(1000) : self._websocket.close());

        self.__retryConnectIntervalId && clearTimeout(self.__retryConnectIntervalId);
        self.__retryConnectIntervalId && delete self.__retryConnectIntervalId;

        self.__checkConnectIntervalId && clearTimeout(self.__checkConnectIntervalId);
        self.__checkConnectIntervalId && delete self.__checkConnectIntervalId;

        self.owner = null;
        //self._sessionId = null;

        self._bufferedMessages = [];
        self._callbacks = {};

        _logger.warn("session closed");
    }
});

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _util = __webpack_require__(72);
var _logger = _util.logger;

/**
 * Error({
 *   hidden:
 * })
 *
 *
 *
 *
 */
var Error = _util.prototypeExtend({
    msg: "",
    __init__: function __init__() {
        this.day = new Date();
    },

    execTime: function execTime() {
        var hour = this.day.getHours();
        if (hour < 10) {
            hour = "0" + hour;
        }
        var minute = this.day.getMinutes();
        if (minute < 10) {
            minute = "0" + minute;
        }
        var second = this.day.getSeconds();
        if (second < 10) {
            second = "0" + second;
        }

        return hour + ":" + minute + ":" + second;
    }
});

var __ICEEvent = Error.extend({
    _webrtcDesc: function _webrtcDesc() {
        var webrtc = this.webrtc;

        var message = this.webrtc.getRtcId();

        return message;
    }
});

module.exports = {
    Exception: Error.extend(),

    NetworkChanaged: Error.extend({ message: function message() {
            var message = this.execTime() + " : Network chanage (" + this.preIp + " -> " + this.nowIp + ").";

            return message;
        } }),

    /**
     * {retry: retry, online: self.online, event: evt, cause: e, session: self}
     */
    WSClose: Error.extend({ message: function message() {
            var message = this.execTime() + " WSClose: Websocket close (" + (this.retry || 0) + ").";

            this.online || (message += " offline.");
            this.event && (message += " wscode: " + this.event.code);
            this.cause && (message += " cause: " + this.cause.message);

            this.url && (message += " url: " + this.url);

            message += " retry: " + (this.retry || 0);

            this.session && this.session.getSessionId() && (message = message + ", sess = " + this.session.getSessionId());

            return message;
        } }),

    /**
     * {event: evt, online: self.online, session: self}
     */
    WSError: Error.extend({ message: function message() {
            var message = this.execTime() + " WSError: Websocket error. ready state:" + (this.event.srcElement && this.event.srcElement.readyState || this.event.currentTarget.readyState) + ". online = " + this.online;
            this.session && this.session.getSessionId() && (message = message + ", sess = " + this.session.getSessionId());

            this.url && (message += " url: " + this.url);

            return message;
        } }),

    /**
     * {event: evt, session: self}
     */
    WSConnected: Error.extend({ message: function message() {
            var message = this.execTime() + " WSConnected: Websocket success. ready state:" + (this.event.srcElement && this.event.srcElement.readyState || this.event.currentTarget.readyState);
            this.session && this.session.getSessionId() && (message = message + ", sess = " + this.session.getSessionId());

            return message;
        } }),

    /**
     * {webrtc: webrtc, event: webrtcEvent, state: webrtcEvent.target.iceConnectionState}
     */
    ICEChanage: __ICEEvent.extend({ message: function message() {
            return this.execTime() + " ICEChanage: " + this._webrtcDesc() + " state: " + this.state;
        } }),

    /**
     * {webrtc: webrtc, event: err}
     */
    AddIceCandError: __ICEEvent.extend({ message: function message() {
            return this.execTime() + " AddIceCandError: " + this._webrtcDesc() + ", add cand error";
        } }),

    /**
     * {webrtc: webrtc, event: event}
     */
    ICEConnectFail: __ICEEvent.extend({ message: function message() {
            return this.execTime() + " ICEConnectFail: " + this._webrtcDesc() + " failed";
        } }),

    /**
     * {webrtc: webrtc, event: event}
     */
    ICEConnected: __ICEEvent.extend({ message: function message() {
            return this.execTime() + " ICEConnected: " + this._webrtcDesc() + " connected";
        } }),

    /**
     * {webrtc: webrtc, event: event}
     */
    ICEDisconnected: __ICEEvent.extend({ message: function message() {
            return this.execTime() + " ICEDisconnected: " + this._webrtcDesc() + " disconnected";
        } }),

    /**
     * {webrtc: webrtc}
     */
    ICEClosed: __ICEEvent.extend({ message: function message() {
            return this.execTime() + " ICEClosed: " + this._webrtcDesc() + " closed";
        } }),

    /**
     * {webrtc: webrtc}
     */
    ICERemoteMediaStream: __ICEEvent.extend({ message: function message() {
            return this.execTime() + " ICERemoteMediaStream: " + this._webrtcDesc() + " got remote stream";
        } }),

    /**
     * {stream: stream, state:, msg: }
     */
    StreamState: Error.extend({ message: function message() {
            return this.execTime() + " StreamState: " + " stream " + this.stream.id + " state: " + this.state + " " + this.msg;
        },
        iceFail: function iceFail() {
            this.state = 1;
            this.msg = "network anomaly. media lost";
        }
    }),

    /**
     * {member: self.current, event: e}
     */
    OpenMediaError: Error.extend({ message: function message() {
            return this.execTime() + " OpenMediaError: " + " open media error. caused by " + (this.event.name ? this.event.name : this.event.message ? this.event.message : this.event.toString());
        } }),

    /**
     * {reason: reason, parnter: {id: self._memberId}}
     */
    Hangup: Error.extend({ message: function message() {
            if (this.self) {
                return "hangup id = " + (this.self.id || "--") + " reason：" + (this.reason || 0);
            } else {
                return this.execTime() + " Hangup: " + (this.parnter && (this.parnter.name || this.parnter.id || " ") || "") + " hangup, reason：" + (this.reason || 0);
            }
        } }),

    /**
     * {failed: rsp.result, msg: rsp.msg}
     */
    ServerRefuseEnter: Error.extend({ message: function message() {
            return this.execTime() + " ServerRefuseEnter: " + "server refuse, cause：" + this.failed + ", msg:" + (this.msg || "");
        } }),

    /**
     * {request: req, response: rsp}
     */
    RspFail: Error.extend({
        __init__: function __init__() {
            this.day = new Date();
            this.failed = this.response.result;
            this.msg = this.response.msg || this.response.message || "--";
        },
        message: function message() {
            return this.execTime() + " RspFail: " + this.request.tsxId + ", " + (this.response.sessId || "--") + " op: " + this.request.op + ", cause: " + this.failed + " " + this.msg;
        }
    }),

    RecvResponse: Error.extend({
        __init__: function __init__() {
            this.day = new Date();
            this.failed = this.response.result;
            this.msg = this.response.msg;
            //this.request = this.response.result;
            //this.response = this.response.msg;
        },
        message: function message() {
            if (this.request) {
                return this.execTime() + " RecvResponse: " + (this.request && this.request.tsxId) + ", " + (this.response.sessId || "--") + " op: " + (this.request && this.request.op) + ", cause: " + this.failed + " " + this.msg;
            } else {
                return this.execTime() + " RecvMessage: " + (this.response && this.response.tsxId) + ", " + (this.response.sessId || "--") + " op: " + (this.response && this.response.op) + " " + this.msg;
            }
        }
    }),

    /**
     * {me: me, cause: _event_}
     */
    EnterFail: Error.extend({ message: function message() {
            return this.execTime() + " EnterFail: " + "enter fail：" + (this.cause ? this.cause.message() : "unkown");
        } }),

    EnterSuccess: Error.extend({ message: function message() {
            return this.execTime() + " EnterSuccess: " + "enter success " + (this.ip ? ", ip = " + this.ip : "");
            // + (", wifi: " + emedia.isWifi());
        } }),

    /**
     * {streamId: rsp.streamId}
     */
    PushSuccess: Error.extend({ message: function message() {
            return this.execTime() + " PushSuccess: " + "push success, streamId = " + this.stream.id + ", " + this.stream.optimalVideoCodecs + ", webrtc = " + this.stream.rtcId;
        } }),

    /**
     * {webrtc: webrtc, pubS: pubS, me: me, cause: _event_}
     */
    PushFail: Error.extend({ message: function message() {
            return this.execTime() + " PushFail: " + "push fail, streamId = " + this.stream.id + ", " + this.stream.optimalVideoCodecs + ", webrtc = " + this.stream.rtcId + " cause：" + (this.cause ? this.cause.message ? this.cause.message() : this.cause : "unkown");
        } }),

    /**
     * {stream: stream, failed: failed, me: me, cause: cause}
     */
    RemoteControlFail: Error.extend({ message: function message() {
            return this.execTime() + " RemoteControlFail: " + (this.type || "remote control") + " fail, " + (this.stream ? this.stream.id : "") + " failed = " + this.failed + " cause：" + (this.cause ? this.cause.message ? this.cause.message() : this.cause : "unkown");
        } }),

    /**
     * {stream: stream, cause: }
     */
    SubSuccess: Error.extend({ message: function message() {
            return this.execTime() + " SubSuccess: " + "sub success, streamId = " + this.stream.id + ", " + this.stream.vcodes + ", webrtc = " + this.stream.rtcId;
        } }),

    /**
     * {stream: stream, cause: }
     */
    SubFail: Error.extend({ message: function message() {
            return this.execTime() + " SubFail: " + "sub fail, streamId = " + this.stream.id + ", " + this.stream.vcodes + ", webrtc = " + this.stream.rtcId + " cause：" + (this.cause ? this.cause.message ? this.cause.message() : this.cause : "unkown");
        } }),

    /**
     * {stream: stream, cause: }
     */
    SubFailNotSupportVCodes: Error.extend({ message: function message() {
            return this.execTime() + " SubFailNotSupportVCodes: " + "sub fail, streamId = " + this.stream.id + " cause：" + (this.cause ? this.cause.message ? this.cause.message() : this.cause : "unkown");
        } }),

    /**
     * {stream: stream, cause: }
     */
    SubFailSafariNotAllowSubBeforePub: Error.extend({ message: function message() {
            return this.execTime() + " SubFailSafariNotAllowSubBeforePub: " + "sub fail, streamId = " + this.stream.id + " cause：Safari without access to capture devices, " + "WebKit only exposes Server Reflexive and TURN ICE candidates, " + "which expose IPs that could already be gathered by websites.";
        } }),

    /**
     * {stream: stream, useVCodes: []}
     */
    SwitchVCodes: Error.extend({ message: function message() {
            return this.execTime() + " SwitchVCodes: " + "pub streamId = " + this.stream.id;
        } }),

    CurrentCalling: Error.extend({ message: function message() {
            return this.execTime() + " CurrentCalling: " + "warn! current calling...";
        } }),

    /**
     * {desktopStreamId: m.streamId}
     */
    OpenDesktopMedia: Error.extend({ message: function message() {
            return this.execTime() + " OpenDesktopMedia: " + "shared desktop, desktopStreamId = " + desktopStreamId;
        } }),

    OpenDesktopMediaAccessDenied: Error.extend({ message: function message() {
            return this.execTime() + " OpenDesktopMediaAccessDenied: " + "shared desktop not allow";
        } }),

    ShareDesktopExtensionNotFound: Error.extend({ message: function message() {
            return this.execTime() + " ShareDesktopExtensionNotFound: " + "shared desktop plugin required";
        } }),

    OtherDeviceAnswer: Error.extend({ message: function message() {
            return this.execTime() + " other device answer, webrtc = " + this.rtcId;
        } }),

    AudioMixerStreamNotAllowSub: Error.extend({ message: function message() {
            return this.execTime() + " audio mixer stream not allow sub, webrtc = " + this.rtcId + ", streamId = " + this.stream.id;
        } }),
    AudioMixerStreamNotAllowOnlySubVideo: Error.extend({ message: function message() {
            return this.execTime() + " audio mixer stream not allow only sub video, webrtc = " + this.rtcId + ", streamId = " + this.stream.id;
        } }),
    AudioMixerStreamRepeatPublish: Error.extend({ message: function message() {
            return this.execTime() + " audio mixer stream repeat publish";
        } })
};

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _keys = __webpack_require__(178);

var _keys2 = _interopRequireDefault(_keys);

var _extends2 = __webpack_require__(210);

var _extends3 = _interopRequireDefault(_extends2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function DeployMore(rtcConfigUrl) {
    this.rtcconfig = undefined;
    this.rtcConfigUrl = rtcConfigUrl;
    this.get_rtcconfig();
}

DeployMore.prototype = {
    get_rtcconfig: function get_rtcconfig() {

        var option = {
            url: 'https://rs.easemob.com/easemob/rtcconfig.json',
            async: false
        };
        if (this.rtcConfigUrl) {
            option.url = this.rtcConfigUrl;
        }
        var _this = this;

        var rtcconfig = undefined;

        try {
            $.ajax((0, _extends3.default)({}, option, {
                success: function success(data) {
                    console.log('get_rtcconfig success');

                    if (data && (0, _keys2.default)(data).length > 0) {
                        _this.rtcconfig = data;
                        rtcconfig = data;
                    }
                },

                error: function error(_error) {
                    console.error('DeployMore get error', _error);
                    return _error;
                }
            }));
        } catch (error) {
            return;
        }

        return rtcconfig;
    },
    replace_ws: function replace_ws(url) {
        if (this.rtcconfig && this.rtcconfig.ws) {
            var new_url = 'wss://' + this.rtcconfig.ws + '/';
            var _RegExp = /wss.*com\//;

            return url.replace(_RegExp, new_url);
        }

        return url;
    },
    _get_info_from_candifate: function _get_info_from_candifate(candidate) {
        //在candidate 中获取 ip port
        if (!candidate) {
            return {};
        }

        var info = {};
        candidate = candidate.split(' ');
        info.ip = candidate[4];
        info.port = candidate[5];

        // candidate.replace(/(candidate:\d+\s+\d+\s+UDP\s+\d+\s+)([\d\.]+)\s+(\d+)(\s+.*)/g, 
        //                 function (all, $pre, $ip, $port, $after) {
        //                     // console.log(all);
        //                     // console.log(pre, ip, port, after);
        //                     // return $pre + ip + " " + port + $after;
        //                     info.ip = $ip;
        //                     info.port = $port;
        //                 }
        // );

        return info;
    },

    // 判断是否可替换 
    // dst_obj: rtcconfig 中的每一candidate 项，
    // ip：待替换candidate ip
    // port：待替换candidate port
    _can_replace: function _can_replace(dst_obj, ip, port) {
        if (!dst_obj || !ip || !port) {
            return false;
        }

        if (!dst_obj.src.ip) {
            return false;
        }

        if (dst_obj.src.ip != ip) {
            return false;
        }

        if (dst_obj.src.min_port > port || dst_obj.src.max_port < port) {
            return false;
        }

        return true;
    },
    _replace_candidate: function _replace_candidate(candidate) {

        /*
            * "candidate_map": [
            *   {
            *       "dst": {
            *           "ip": "10.66.204.222",
            *           "min_port": "32355",
            *           "max_port": "65535"
            *       },
            *       "src": {
            *           "ip": "39.107.157.65",
            *           "min_port": "32355",
            *           "max_port": "65535"
            *       }
            *   },
            * ]
            * 
            * candidate:3 1 UDP 2013266431 116.62.36.187 31574 typ host
            * 匹配到 src 就会 替换成映射的 dst
        */
        var ip_and_port = this._get_info_from_candifate(candidate);
        var ip = ip_and_port.ip,
            port = ip_and_port.port;


        var _this = this;
        this.rtcconfig.rtc.candidate_map.map(function (item) {
            // 在 map 中查找 相同的ip 和 范围区间内的 port; 两者必须同时满足
            // 将 src 映射到 dst

            if (_this._can_replace(item, ip, port)) {
                var new_ip = item.dst.ip;

                // 替换 port
                var port_difference_value = Number(port) - Number(item.src.min_port); // 即将被替换的 candidate 的port 在最大和最小的port的范围
                var new_port = Number(item.dst.min_port) + Number(port_difference_value);

                var cands_arr = candidate.split(' ');
                cands_arr[4] = new_ip;
                cands_arr[5] = new_port;

                candidate = cands_arr.join(' ');
                // candidate = candidate.replace(/(candidate:\d+\s+\d+\s+UDP\s+\d+\s+)([\d\.]+)\s+(\d+)(\s+.*)/g, 
                // function (all, $pre, $ip, $port, $after) {
                //     // console.log(all);
                //     // console.log(pre, ip, port, after);
                //     return ($pre + new_ip + " " + new_port + $after);
                // });
            }
        });

        return candidate;
    },
    replace_candidates: function replace_candidates(candidates) {

        if (!this.rtcconfig) {
            return candidates;
        }

        var _this = this;

        // 循环 candidates 数组 去替换
        candidates = candidates.map(function (item) {

            if (item && item.candidate) {
                item.candidate = _this._replace_candidate(item.candidate);
                return item;
            }

            return item;
        });

        return candidates;
    },


    // 1v1 替换 turn 地址
    replace_trun_url: function replace_trun_url(rtcCfg) {

        // 解析替换
        if (this.rtcconfig && this.rtcconfig.turn) {
            var iceServers = rtcCfg.iceServers;

            if (!iceServers) {
                return rtcCfg;
            }

            if (iceServers instanceof Array == false) {
                return rtcCfg;
            }

            var new_turn = this.rtcconfig.turn;
            iceServers = iceServers.map(function (item) {
                if (item.url) {
                    item.url = 'turn:' + new_turn;
                }
            });
            return rtcCfg;
        }

        return rtcCfg; //如果没有不替换
    }
};
exports.default = DeployMore;

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _assign = __webpack_require__(149);

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _assign2.default || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _stringify = __webpack_require__(144);

var _stringify2 = _interopRequireDefault(_stringify);

var _assign = __webpack_require__(149);

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _util = __webpack_require__(72);
var _logger = _util.tagLogger("Me");

var Member = __webpack_require__(212);

var __event = __webpack_require__(208);

var Stream = __webpack_require__(215);

/**
 * 未体现 member 使用了 session。
 * 请 这样创建
 * Member({_session: sess})
 *
 *
 * close:
 * 1.服务端 踢掉
 * 2.手动点击 挂断
 * 3.enter失败！
 *
 * websocket 断开连接后，并不会 去close。因为发送消息可以实现重连，重新enter
 *
 *
 */
var Attendee = Member.extend({
    __init__: function __init__() {
        var self = this;

        self._session || self.sessionFactory && (self._session = self.sessionFactory());

        if (!self._session) {
            _logger.error("Require session");
            throw "Require session";
        }

        self._cver = 0;

        self._cacheMembers = {};
        self._cacheStreams = {};
        self._streamAutomators = {};
        self._mediaMeters = {};
        self._openedRtcMediaStreams = {};

        self._linkedStreams = {};
        self._maybeNotExistStreams = {}; //与self._streams结构相同，用 存储 断网时，ice fail的stream对象。这个对象可能不存在了

        self._records = {};

        self._ices = {};
        self.audioMixers = {};

        self.closed = false;

        self._nextStreamSeqno = 0;

        self.getMediaMeterIntervalMillis = self.getMediaMeterIntervalMillis || emedia.config.getMediaMeterIntervalMillis;
    },

    getCurrentMembers: function getCurrentMembers() {
        var self = this;

        var members = [];
        _util.forEach(self._cacheMembers, function (_memId, _cacheMember) {
            var member = _util.extend(true, {}, _cacheMember);
            members.push(member);
        });

        return members;
    },

    newStream: function newStream(cfg) {
        var attendee = this;

        return new Stream(cfg, {
            __init__: function __init__() {
                var self = this;

                self.rtcId || self._webrtc && (self.rtcId = self._webrtc.getRtcId());
                self._webrtc || self.rtcId && (self._webrtc = attendee._ices[self.rtcId]);

                self.__create_id = attendee._nextStreamSeqno++;

                if (self.memId && !self.owner) {
                    self.owner = _util.extend({}, attendee._cacheMembers[self.memId]);
                    if (!self.owner && !self.located()) {
                        _logger.error("Remote stream, not owner. it = ", self.id);
                        throw "Remote stream, not owner. it = " + self.id;
                    }
                }
            }
        });
    },

    getConfrId: function getConfrId() {
        return this.ticket.confrId;
    },
    isCaller: function isCaller() {
        var self = this;
        return self.isP2P() && self.ticket.caller == self.ticket.memName;
    },
    isCallee: function isCallee() {
        var self = this;
        return self.isP2P() && self.ticket.callee == self.ticket.memName;
    },
    isP2P: function isP2P() {
        var self = this;
        return self.ticket && (self.ticket.type == "P2P" || self.ticket.type == "p2p");
    },
    isConfr: function isConfr() {
        var self = this;
        return self.ticket && (self.ticket.type == "CONFR" || self.ticket.type == "confr");
    },

    onEvent: function onEvent(evt) {},

    join: function join(joined, joinError) {
        var self = this;

        if (!emedia.requireTrustBeforeJoin()) {
            self._join(joined, joinError);
            return;
        }

        self.someBrowsersRequireGetUserMedia(function () {
            self._join(joined, joinError);
        }, joinError);
    },
    _join: function _join(joined, joinError) {
        _logger.debug("begin join ...");

        var self = this;
        console.log('Attendee self', self);

        var enter;

        if (self._memberId) {
            _logger.warn("Had joined. igrone it");
            joined && joined(self.memId);
            return;
        }

        function onJoinError(_event_) {
            try {
                if (_event_ instanceof __event.WSClose && _event_.retry) {
                    return;
                }

                if (!(_event_ instanceof __event.EnterFail)) {
                    _event_ = new __event.EnterFail({ //可能是 websocket 链接未成功
                        attendee: self,
                        cause: _event_
                    });
                }

                self.onEvent(_event_);
                joinError && joinError(_event_);
            } finally {}
        }

        function enterRsp(rsp) {
            if (rsp.result != 0) {
                try {
                    onJoinError(new __event.RspFail({ request: enter, response: rsp }));
                } finally {
                    if (rsp.result !== -9527) {
                        //-9527 客户端 自己返回，网络未通， 其他值服务端返回
                        self.onEvent(new __event.ServerRefuseEnter({ failed: rsp.result, msg: rsp.msg }));
                    }
                }

                return;
            }

            self.reflushSupportVCodes(rsp.vcodes);

            self.setMemberId(rsp.memId);
            self.role = rsp.role;

            self.onEvent(new __event.EnterSuccess({ ip: self.ip }));

            joined && joined(rsp.memId);

            try {
                self.__rtc_cfg = rsp.rtcCfg;
                if (typeof rsp.rtcCfg === 'string') {
                    self.__rtc_cfg = JSON.parse(rsp.rtcCfg);
                }
            } finally {
                self.onMembers(rsp.cver, rsp.mems);
                self.onStreams(rsp.cver, rsp.streams);
            }
        }

        function onConnected() {
            enter = self.newMessage().setOp(200).setTicket(self.ticket).setNickName(self.nickName || self.ticket.memName).setResource(self.resource).setExt(self.ext);
            self.postMessage(enter, enterRsp);
        }

        self.connect(onConnected, onJoinError);
        _logger.debug("join", self.ticket.url);
    },

    withpublish: function withpublish(pubS) {
        var self = this;

        if (!pubS || !pubS.localStream) {
            _logger.error("pubS null or stream not open");
            throw "pubS null or stream not open";
        }

        var enter;

        var openedStream = pubS && pubS.localStream;

        var webrtc;

        function then(joined, joinError) {
            if (arguments.length === 1) {
                joinError = joined;
                joined = undefined;
            }

            if (self._memberId) {
                _logger.warn("Had joined. igrone it");
                joined && joined(self.memId);
                return;
            }

            function onJoinError(_event_) {
                try {
                    if (_event_ instanceof __event.WSClose && _event_.retry) {
                        return;
                    }

                    if (!(_event_ instanceof __event.EnterFail)) {
                        _event_ = new __event.EnterFail({ //可能是 websocket 链接未成功
                            attendee: self,
                            cause: _event_
                        });
                    }

                    self.onEvent(_event_);
                    joinError && joinError(_event_);
                } finally {
                    emedia.stopTracks(openedStream);

                    webrtc && self.closeWebrtc(webrtc.getRtcId());
                }
            }

            var optimalVideoCodecs = self.getOptimalVideoCodecs();

            function enterRsp(rsp) {
                if (rsp.result != 0) {
                    try {
                        onJoinError(new __event.RspFail({ request: enter, response: rsp }));
                    } finally {
                        if (rsp.result !== -9527) {
                            //-9527 客户端 自己返回，网络未通， 其他值服务端返回
                            self.onEvent(new __event.ServerRefuseEnter({ failed: rsp.result, msg: rsp.msg }));
                        }
                    }

                    return;
                }

                self.reflushSupportVCodes(rsp.vcodes);

                self.setMemberId(rsp.memId);
                self.role = rsp.role;

                self.onEvent(new __event.EnterSuccess({ ip: self.ip }));

                var stream = self.newStream(pubS);
                stream.updateAttributes({
                    _localMediaStream: pubS.localStream,
                    rtcId: webrtc.getRtcId(),
                    _webrtc: webrtc,
                    id: rsp.streamId,
                    csrc: rsp.csrc,
                    owner: { id: rsp.memId, nickName: self.nickName, name: self.sysUserId, ext: self.extObj },
                    optimalVideoCodecs: optimalVideoCodecs
                });

                joined && joined(rsp.memId, stream);
                webrtc.useIp = self.ip;
                self.onEvent(new __event.PushSuccess({ stream: stream, hidden: true })); //ice重连成功后 会 再次 onEvent PushSuccess

                rsp.sdp && self.ansC(webrtc.getRtcId(), rsp.sdp);
                rsp.cands && self.tcklC(webrtc.getRtcId(), rsp.cands);

                try {
                    self.__rtc_cfg = rsp.rtcCfg;
                    if (typeof rsp.rtcCfg === 'string') {
                        self.__rtc_cfg = JSON.parse(rsp.rtcCfg);
                    }
                    if (self.__rtc_cfg && self.__rtc_cfg.iceServers && self.__rtc_cfg.iceServers.length > 0) {
                        _logger.warn("Server rsp one rtc cfg. publish will republish");

                        self._service && setTimeout(function () {
                            self._service._republish(stream);
                        }, 200);
                    }
                } finally {
                    self.onMembers(rsp.cver, rsp.mems);
                    self.onStreams(rsp.cver, rsp.streams);
                }
            }

            function onConnected() {
                _logger.debug("enter and pubs");

                var stream = pubS.localStream;

                var offerOptions, subArgs;
                if (pubS.type === 2) {
                    offerOptions = {
                        offerToReceiveAudio: true,
                        offerToReceiveVideo: false
                    };
                    subArgs = {
                        subSVideo: false,
                        subSAudio: true
                    };
                }

                webrtc = self.createWebrtc({
                    _rtcId: pubS.rtcId,
                    optimalVideoCodecs: optimalVideoCodecs,
                    offerOptions: offerOptions,
                    subArgs: subArgs,
                    vbitrate: pubS.vbitrate || pubS.constaints && pubS.constaints.video && pubS.constaints.video.bitrate,
                    abitrate: pubS.abitrate || pubS.constaints && pubS.constaints.audio && pubS.constaints.audio.bitrate
                }, pubS.iceRebuildCount);
                self.setLocalStream(stream, webrtc.getRtcId());

                self.doOffer(webrtc.getRtcId(), function (sdp) {
                    enter = self.newMessage().setOp(200).setTicket(self.ticket).setNickName(self.nickName || self.ticket.memName).setResource(self.resource).setSdp(sdp).setRtcId(webrtc.getRtcId()).setPubS(pubS).setExt(self.ext);
                    self.postMessage(enter, enterRsp);
                });
            }

            self.connect(onConnected, onJoinError);
            _logger.debug("join", self.ticket.url);
        }

        return {
            join: then
        };
    },

    push: function push(pubS, pushed, onPushError, autoPush) {
        _logger.debug("begin push ...");

        var self = this;

        if (arguments.length === 2) {
            onPushError = pushed;
            pushed = undefined;
        }

        if (!pubS || !pubS.localStream) {
            _logger.error("pubS or stream open");
            throw "pubS or stream open";
        }

        var initC;

        var openedStream = pubS.localStream;

        var webrtc;

        function _onPushError(_event_) {
            try {
                var stream = self.newStream(pubS);
                stream.updateAttributes({
                    _localMediaStream: pubS.localStream,
                    _webrtc: webrtc,
                    rtcId: webrtc && webrtc.getRtcId(),
                    owner: { id: self.getMemberId(), nickName: self.nickName, name: self.sysUserId, ext: self.extObj }
                });

                var _event_ = new __event.PushFail({
                    stream: stream,
                    cause: _event_,
                    hidden: autoPush && _event_.hidden === true
                });

                self.onEvent(_event_);
                _event_.hidden || onPushError && onPushError(_event_);
            } finally {
                if (openedStream && _event_.hidden !== true) {
                    emedia.stopTracks(openedStream);
                }

                webrtc && self.closeWebrtc(webrtc.getRtcId(), _event_.hidden === true);
            }
        }

        if (!pubS.rtcId && pubS.type === 2 && !emedia.config.allowRepeatAudioMixerPublish && self._service.hasAudioMixers()) {
            _onPushError(new __event.AudioMixerStreamRepeatPublish());
            return;
        }

        var optimalVideoCodecs = pubS.optimalVideoCodecs || self.getOptimalVideoCodecs();

        function pushRsp(webrtc, rsp) {
            if (rsp.result != 0) {
                _onPushError(new __event.RspFail({ request: initC, response: rsp, hidden: rsp.retrying === true }));

                return;
            }

            var stream = self.newStream(pubS);

            stream.updateAttributes({
                _localMediaStream: pubS.localStream,
                _webrtc: webrtc,
                rtcId: webrtc.getRtcId(),
                id: rsp.streamId,
                csrc: rsp.csrc,
                owner: { id: self.getMemberId(), nickName: self.nickName, name: self.sysUserId, ext: self.extObj },
                optimalVideoCodecs: optimalVideoCodecs
            });

            stream.id && stream.type === 2 && (self.audioMixers[stream.id] = stream);

            try {
                self.onEvent(new __event.PushSuccess({ stream: stream, hidden: true })); //ice重连成功后 会 再次 onEvent PushSuccess
            } finally {
                rsp.sdp && self.ansC(webrtc.getRtcId(), rsp.sdp);
                rsp.cands && self.tcklC(webrtc.getRtcId(), rsp.cands);

                pushed && pushed(stream);
            }
        }

        function pub(pubS) {
            _logger.debug("pubs");

            var stream = pubS.localStream;

            var offerOptions, subArgs;
            if (pubS.type === 2) {
                offerOptions = {
                    offerToReceiveAudio: true,
                    offerToReceiveVideo: false
                };
                subArgs = {
                    subSVideo: false,
                    subSAudio: true
                };
            }

            webrtc = self.createWebrtc({
                _rtcId: pubS.rtcId,
                optimalVideoCodecs: optimalVideoCodecs,
                offerOptions: offerOptions,
                subArgs: subArgs,
                vbitrate: pubS.vbitrate || pubS.constaints && pubS.constaints.video && pubS.constaints.video.bitrate,
                abitrate: pubS.abitrate || pubS.constaints && pubS.constaints.audio && pubS.constaints.audio.bitrate
            }, pubS.iceRebuildCount);

            self.setLocalStream(stream, webrtc.getRtcId());

            // 推流时增加分辨率参数 如果有
            if (pubS.constaints && pubS.constaints.video) {
                // video = {
                //     width: {
                //         exact: 1280
                //     },
                //     height: {
                //         exact: 720
                //     }
                // }
                var _pubS$constaints$vide = pubS.constaints.video,
                    width = _pubS$constaints$vide.width,
                    height = _pubS$constaints$vide.height;

                if (width && height) {
                    var width_resolution = width.exact || width.min;
                    var height_resolution = height.exact || height.min;

                    var resolution = {
                        w: width_resolution,
                        h: height_resolution
                    };
                    pubS.resolution = resolution;
                }
            }

            self.doOffer(webrtc.getRtcId(), function (sdp) {
                initC = self.newMessage().setOp(102).setRtcId(webrtc.getRtcId()).setSdp(sdp).setPubS(pubS);

                self.postMessage(initC, function (rsp) {
                    pushRsp(webrtc, rsp);
                });
            });
        }

        pub(pubS);
        _logger.debug("push", self.ticket.url);
    },

    isSafari: function isSafari() {
        //return /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent);
        return emedia.isSafari;
    },

    //有些机器必须得getUserMedia后才能够产生正常得cands
    //比如 safair不调用getUserMedia，将不产生cands；window chrome75，则产生得cands中没有ip 而且 uuid.local
    someBrowsersRequireGetUserMedia: function someBrowsersRequireGetUserMedia(successOpenMedia, failOpenMedia) {
        var self = this;

        if (emedia.youInSomeBrowsers() && !emedia._yetGetUserMedia) {
            if (self.__tryingOpenMedia === true) {
                self.__tryingOpenMediaWaitSuceess = self.__tryingOpenMediaWaitSuceess || [];
                self.__tryingOpenMediaWaitFail = self.__tryingOpenMediaWaitFail || [];

                if (typeof successOpenMedia === "function") {
                    self.__tryingOpenMediaWaitSuceess.push(successOpenMedia);
                }
                if (typeof failOpenMedia === "function") {
                    self.__tryingOpenMediaWaitFail.push(failOpenMedia);
                }
            } else {
                var success = function success(_user, mediaStream) {
                    emedia._yetGetUserMedia = true;
                    // setTimeout(function () {
                    //     emedia.stopAudioTracks(mediaStream);
                    // }, 700);
                    emedia.stopTracks(mediaStream);

                    setTimeout(function () {
                        self.__tryingOpenMedia = false;
                        successOpenMedia && successOpenMedia.apply(self);
                        self.__tryingOpenMediaWaitSuceess && _util.forEach(self.__tryingOpenMediaWaitSuceess, function (index, func) {
                            func.apply(self);
                        });
                        self.__tryingOpenMediaWaitSuceess = [];
                        self.__tryingOpenMediaWaitFail = [];
                    }, 300);
                };

                var error = function error(event) {
                    self.__tryingOpenMedia = false;
                    _logger.error("Some browsers must getUserMedia, gather cands. now try get audio. fail. subfail");

                    failOpenMedia && failOpenMedia.call(self, event);
                    self.__tryingOpenMediaWaitFail && _util.forEach(self.__tryingOpenMediaWaitFail, function (index, func) {
                        func.call(self, event);
                    });
                    self.__tryingOpenMediaWaitSuceess = [];
                    self.__tryingOpenMediaWaitFail = [];
                };

                self.__tryingOpenMedia = true;

                self._service.__getUserMedia({ audio: true }, success, function (event) {
                    self._service.__getUserMedia({ video: true }, success, error);
                });
            }
            return true;
        }

        return false;
    },

    createWebrtcAndSubscribeStream: function createWebrtcAndSubscribeStream(streamId, callbacks, iceServerConfig, subArgs) {
        var self = this;

        callbacks || (callbacks = {});

        var subStream = self._cacheStreams[streamId];
        var subMember = self._cacheMembers[subStream.memId];

        //var stream = self.newStream(subStream);
        var stream = subStream;
        subArgs = subArgs || stream.subArgs || { subSVideo: true, subSAudio: subStream.type !== 2 }; //混音自动订阅不要订阅音频

        function _onSubFail(evt) {
            _logger.warn("sub stream error", streamId, evt);

            preSubArgs && stream._webrtc && stream._webrtc.setSubArgs(preSubArgs);
            preSubArgs && stream.updateAttributes({ subArgs: preSubArgs });

            evt = new __event.SubFail({
                stream: stream,
                hidden: evt.hidden === true,
                cause: evt
            });

            callbacks && callbacks.onEvent && callbacks.onEvent(evt);
            self.onEvent && self.onEvent(evt);
        }
        function _onSubSuccess() {
            stream.updateAttributes(stream.subArgs);
        }

        var pubStreamVCodes = subStream.vcodes || [];
        var pubMemberSupportVCodes = subMember && subMember.vcodes || [];
        var selfSupportVCodes = self.supportVCodes;

        var optimalVideoCodecs = self._getOptimalVideoCodecsSubset(pubStreamVCodes, pubMemberSupportVCodes, selfSupportVCodes);

        // if(!stream.voff && subArgs.subSVideo && optimalVideoCodecs.length == 0){ // 订阅视频 但是 没有相同的 视频编码格式。失败
        //     _onSubFail(_util.extend(new __event.SubFail(), new __event.SubFailNotSupportVCodes({
        //         stream: stream
        //     })));
        //     return;
        // }

        subArgs = subArgs || stream.subArgs;

        var preSubArgs = stream.subArgs;

        var withoutVideo = !(stream.vcodes && stream.vcodes.length > 0);
        emedia.isSafari && (withoutVideo = withoutVideo || !!stream.voff);

        var offerOptions = {
            offerToReceiveAudio: true,
            offerToReceiveVideo: subArgs.subSVideo && !withoutVideo
        };

        if (!offerOptions.offerToReceiveAudio && !offerOptions.offerToReceiveVideo) {
            _logger.warn("offerToReceiveAudio == false and offerToReceiveVideo == false");
        }

        function createWebrtcAndInit() {
            var webrtc = self.createWebrtc({
                iceServerConfig: iceServerConfig,
                optimalVideoCodecs: optimalVideoCodecs,
                offerOptions: offerOptions,

                onGotMediaStream: function onGotMediaStream(remoteMediaStream) {
                    callbacks.onGotRemote && callbacks.onGotRemote(stream);
                    // self.onEvent && self.onEvent(new __event.SubSuccess({
                    //     stream: stream,
                    //     hidden: true
                    // }));
                }
            }, stream.iceRebuildCount);
            var rtcId = webrtc.getRtcId();

            _logger.warn(rtcId, " sub stream ", streamId, optimalVideoCodecs);

            stream.updateAttributes({
                _webrtc: webrtc,
                rtcId: rtcId,
                owner: _util.extend({}, subMember)
            });

            subArgs && stream._webrtc && stream._webrtc.setSubArgs(subArgs);
            subArgs && stream.updateAttributes({ subArgs: subArgs });
        }

        if (self.someBrowsersRequireGetUserMedia(function success() {
            createWebrtcAndInit();
            self.offerCall(stream.rtcId, null, streamId, _onSubFail, _onSubSuccess);
        }, function (event) {
            _logger.error("Some browsers must getUserMedia, gather cands. now try get audio. fail. subfail", streamId);
            _onSubFail(event);
        })) {// safari 如果没有getUserMedia时，是不会生成cands的
        } else {
            createWebrtcAndInit();
            self.offerCall(stream.rtcId, null, streamId, _onSubFail, _onSubSuccess);
        }
    },

    _getOptimalVideoCodecsSubset: function _getOptimalVideoCodecsSubset(pubStreamVCodes, pubMemberSupportVCodes, selfSupportVCodes) {
        var self = this;

        var optimalVideoCodecs = [];

        if (pubStreamVCodes && pubStreamVCodes.length > 0 && selfSupportVCodes[pubStreamVCodes[0]]) {
            optimalVideoCodecs.push(pubStreamVCodes[0]);
        }
        if (optimalVideoCodecs.length == 0) {
            for (var i = 0; i < self._orderVCodes.length; i++) {
                _util.forEach(pubMemberSupportVCodes, function (index, sVCode) {
                    if (sVCode == self._orderVCodes[i]) {
                        optimalVideoCodecs.push(sVCode);
                    }
                });
            }
        }

        return optimalVideoCodecs;
    },

    subscribeStream: function subscribeStream(rtcId, streamId, rspFail, subArgs, onSub) {
        var self = this;

        var webrtc = self._ices[rtcId];

        var subStream = self._cacheStreams[streamId];
        var subMember = self._cacheMembers[subStream.memId];

        //var stream = self.newStream(subStream);
        var stream = subStream;
        stream.updateAttributes({
            _webrtc: webrtc,
            rtcId: rtcId,
            owner: _util.extend({}, subMember)
        });

        var preSubArgs = stream.subArgs;

        subArgs = subArgs || { subSVideo: true, subSAudio: true };
        stream.updateAttributes({ subArgs: stream.subArgs || { subSVideo: true, subSAudio: true } });
        stream._webrtc && stream._webrtc.setSubArgs(stream._webrtc.subArgs || { subSVideo: true, subSAudio: true });

        if (!stream.subArgs.subSVideo && subArgs.subSVideo && !stream.voff) {
            var pubStreamVCodes = subStream.vcodes;
            var pubMemberSupportVCodes = subMember.vcodes;
            var selfSupportVCodes = self.supportVCodes;

            var optimalVideoCodecs = self._getOptimalVideoCodecsSubset(pubStreamVCodes, pubMemberSupportVCodes, selfSupportVCodes);

            // if(optimalVideoCodecs.length == 0){ // 订阅视频 但是 没有相同的 视频编码格式。失败
            //     preSubArgs && stream._webrtc && stream._webrtc.setSubArgs(preSubArgs);
            //     preSubArgs && (stream.subArgs = preSubArgs);
            //
            //     var evt = _util.extend(new __event.SubFail(), new __event.SubFailNotSupportVCodes({
            //         stream: stream
            //     }));
            //
            //     rspFail && rspFail(evt);
            //     self.onEvent(evt);
            //
            //     return;
            // }
        }

        subArgs && stream._webrtc && stream._webrtc.setSubArgs(subArgs);
        subArgs && stream.updateAttributes({ subArgs: subArgs });

        var subMessage = self.newMessage().setOp(205).setRtcId(rtcId).setSubSId(streamId);

        subArgs && _util.extend(subMessage, subArgs);

        self.postMessage(subMessage, function (rsp) {
            if (rsp.result != 0) {
                preSubArgs && stream._webrtc && stream._webrtc.setSubArgs(preSubArgs);
                preSubArgs && stream.updateAttributes({ subArgs: preSubArgs });

                var evt = new __event.SubFail({
                    stream: stream,
                    cause: new __event.RspFail({ request: subMessage, response: rsp })
                });

                rspFail && rspFail(evt);
                self.onEvent(evt);

                return;
            }

            stream.updateAttributes(stream.subArgs);

            var evt = new __event.SubSuccess({
                stream: stream,
                hidden: true
            });
            self._updateRemoteStream(stream, stream._webrtc.getRemoteStream());
            self.onEvent(evt);

            typeof onSub === 'function' && onSub();
        });
    },

    unsubscribeStream: function unsubscribeStream(streamId) {
        var self = this;

        var stream = self._cacheStreams[streamId];
        var rtcId = stream._webrtc && stream._webrtc.getRtcId();
        if (!rtcId) {
            return;
        }

        try {
            var unsubMessage = self.newMessage().setOp(206).setRtcId(rtcId).setSubSId(streamId);

            self.postMessage(unsubMessage);
        } finally {
            self.closeWebrtc(rtcId);
        }

        return rtcId;
    },

    onEnter: function onEnter(cver, mem) {
        var self = this;

        cver && (self._cver = cver);

        if (!mem) return;
        if (self._cacheMembers[mem.id]) {
            return;
        }

        self._cacheMembers[mem.id] = mem;

        var _tmpMap = {};
        if (mem.res && mem.res.vcodes && mem.res.vcodes.length > 0) {
            _util.forEach(mem.res.vcodes, function (index, vcode) {
                if (_tmpMap[vcode]) {} else {
                    _tmpMap[vcode] = true;
                    self.supportVCodes[vcode] && self.supportVCodes[vcode]++;
                }
            });
        }

        // var hasOtherDevices;
        // _util.forEach(self._cacheMembers, function (_memId, _member) {
        //     if(!hasOtherDevices && _memId != mem.id && mem.memName === _member.memName){
        //         hasOtherDevices = true;
        //     }
        // });
        //
        // if(hasOtherDevices){
        //     return;
        // }

        self.onAddMember(_util.extend({}, mem));
    },

    _onFinally: function _onFinally() {
        var self = this;

        self._cacheMembers = {}; // id, name, nickName, resource
        self._cacheStreams = {}; // id, memId, name, voff, aoff, type
        self._linkedStreams = {};
        self._ices = {};
        self._maybeNotExistStreams = {};

        //self._session._sessionId = undefined;
        //self._session = undefined;


        //push stream时，由于异步，在未返回成功后，退出会议，摄像头不会被关闭问题
        var openedMediaStreams = [];
        _util.forEach(self._openedRtcMediaStreams, function (streamId, mediaStream) {
            if (mediaStream.active !== false) {
                //还没有关闭的流
                openedMediaStreams.push(mediaStream);
            }
        });
        if (openedMediaStreams.length > 0) {
            for (var i = 0; i < openedMediaStreams.length; i++) {
                try {
                    var _openStream = openedMediaStreams[i];
                    _logger.info("exit, close stream = ", _openStream.id);
                    emedia.stopTracks(_openStream);
                } catch (e) {
                    _logger.error(e);
                }
            }
        }

        _logger.warn("finally. all clean.");
    },

    _onRoleUpdate: function _onRoleUpdate(role, roleToken) {
        var self = this;

        _logger.info("Role ", role, " <-", self.role);
        _logger.info(roleToken);
        self.role = role;
        self.roleToken = roleToken;

        self.onRoleUpdate && self.onRoleUpdate(role, roleToken);
    },

    onExit: function onExit(cver, memId, reason) {
        var self = this;

        cver && (self._cver = cver);

        if (memId == self.getMemberId()) {
            //被服务器 强制 exit
            _logger.warn("Me exit. ", reason, memId);

            try {
                self.closed || self.close(reason);
            } catch (e) {
                self.onEvent(new __event.Hangup({ reason: reason, self: { id: self._memberId } }));
                self.onMeExit && self.onMeExit(reason);

                _logger.warn(e);
            }

            return;
        }

        var rmMember = self._cacheMembers[memId];
        if (rmMember) {
            if (rmMember.res && rmMember.res.vcodes && rmMember.res.vcodes.length > 0) {
                _util.forEach(rmMember.res.vcodes, function (index, vcode) {
                    self.supportVCodes[vcode]--;
                });
            }

            self._onRemoveMember(rmMember, reason);
            self.onEvent(new __event.Hangup({ reason: reason, parnter: rmMember }));
        }
    },

    onPub: function onPub(cver, memId, pubS) {
        var self = this;

        if (!self._cacheMembers[memId]) {
            _logger.error("No found member. when pub");
            throw "No found member. when pub";
        }

        // if(pubS.type === 2){ //强制 aoff = 1
        //     pubS._1_aoff = pubS.aoff;
        //     pubS.aoff = self._service.hasAudioMixers() ? 0 : 1;
        // }

        var newStream = self.newStream(pubS);
        var _stream = self._cacheStreams[pubS.id];

        cver && (self._cver = cver);

        if (_stream && newStream.sver !== _stream.sver) {
            _logger.info("Onpub. the steam ", _stream.id, " republish. sver ", _stream.sver, newStream.sver);

            if (newStream && (newStream.aoff !== _stream.aoff || newStream.voff != _stream.voff)) {
                self.onStreamControl(undefined, pubS.id, newStream.voff, newStream.aoff);
            }

            _util.extend(_stream, newStream);
            self._onRepublishStream(_stream);

            return;
        }

        var stream = newStream;

        stream.updateAttributes({ owner: self._cacheMembers[memId] });
        self._cacheStreams[pubS.id] = stream;

        self._onAddStream(self.newStream(stream));

        if (self.autoSub) {
            self.createWebrtcAndSubscribeStream(pubS.id, {
                onGotRemote: function onGotRemote(stream) {}
            }); //, undefined, subArgs
        }

        return stream;
    },

    onUnpub: function onUnpub(cver, memId, sId) {
        var self = this;

        var rmStream = self._cacheStreams[sId];
        self._onRemovePubstream(self._cacheMembers[memId], rmStream);

        cver && (self._cver = cver);
    },

    onClose: function onClose(cver, confrId, reason) {
        var self = this;

        try {
            self.close(reason || 0);
        } finally {
            self.onConfrClose && self.onConfrClose(confrId, reason);
        }
    },

    __getWebrtcFor: function __getWebrtcFor(pubStreamId) {
        var self = this;

        var webrtc = self._cacheStreams[pubStreamId] && self._cacheStreams[pubStreamId]._webrtc;
        return webrtc && webrtc.getRtcId();
    },
    _getWebrtc: function _getWebrtc(pubStreamId) {
        var self = this;

        var webrtc = self._cacheStreams[pubStreamId] && self._cacheStreams[pubStreamId]._webrtc;
        return webrtc;
    },

    _updateRemoteStream: function _updateRemoteStream(stream, remoteMediaStream) {
        if (stream.located() && stream.type === 2) {
            emedia.enableAudioTracks(remoteMediaStream, true);
        } else {
            emedia.enableAudioTracks(remoteMediaStream, !stream.aoff && !(stream.subArgs && stream.subArgs.subSAudio === false));
        }

        emedia.enableVideoTracks(remoteMediaStream, !stream.voff && !(stream.subArgs && stream.subArgs.subSVideo === false));
    },

    onStreamControl: function onStreamControl(cver, streamId, voff, aoff, sver) {
        var self = this;

        var stream = self._cacheStreams[streamId];

        stream.updateAttributes({
            voff: voff,
            aoff: aoff
        });

        var webrtc = stream._webrtc;
        webrtc && webrtc._remoteStream && self._updateRemoteStream(stream, webrtc._remoteStream);

        var _stream = self.newStream(stream);
        self.onUpdateStream && self.onUpdateStream(_stream, new _stream.Update({ voff: voff, aoff: aoff }));

        cver && (self._cver = cver);
        sver && stream.updateAttributes({ sver: sver });

        //Safari12/13 先订阅一个 没有视频的流后，这个流重新打开视频，无法显示视频。
        if (emedia.isSafari && !voff && webrtc && !webrtc.closed && webrtc.offerOptions && !webrtc.offerOptions.offerToReceiveVideo) {
            _logger.warn("stream video turn on. but sub not video, will close it, repsub stream", webrtc.getRtcId(), webrtc.__id, streamId);

            self.closeWebrtc(webrtc.getRtcId(), true, false);

            self.createWebrtcAndSubscribeStream(streamId, {
                onGotRemote: function onGotRemote(stream) {

                    var subs = (0, _assign2.default)(self._service.__safari_subs, {}); // 这里不会触发 subsuccess 清空一下 订阅过的流
                    if (subs && subs instanceof Array) {
                        subs.map(function (item, index) {
                            if (item.streamId == stream.id) subs.splice(index, 1);
                        });
                    }
                    self._service.__safari_subs = subs;
                },
                onEvent: function onEvent(evt) {
                    var subs = (0, _assign2.default)(self._service.__safari_subs, {}); // 这里不会触发 subsuccess 清空一下 订阅过的流
                    if (subs && subs instanceof Array) {
                        subs.map(function (item, index) {
                            if (item.streamId == stream.id) subs.splice(index, 1);
                        });
                    }
                    self._service.__safari_subs = subs;
                }
            }, undefined, stream.subArgs);
        }
    },

    aoff: function aoff(pubS, _aoff, callback) {
        var self = this;

        var rtcId = self.__getWebrtcFor(pubS.id);
        if (!rtcId) {
            _logger.error("pubS not publish", pubS.id);
            throw "pubS not publish" + pubS.id;
        }

        var linkedStream = self._linkedStreams[pubS.id];
        linkedStream.updateAttributes({ aoff: _aoff });
        pubS.updateAttributes({ aoff: _aoff });

        var streamControl = self.newMessage().setOp(400).setRtcId(rtcId).setVoff(pubS.voff).setAoff(_aoff);
        self.postMessage(streamControl, callback);
        self.onUpdateStream && self.onUpdateStream(pubS, new pubS.Update({ aoff: _aoff }));
    },

    voff: function voff(pubS, _voff, callback) {
        var self = this;

        var rtcId = self.__getWebrtcFor(pubS.id);
        if (!rtcId) {
            _logger.error("pubS not publish", pubS.id);
            throw "pubS not publish" + pubS.id;
        }

        var linkedStream = self._linkedStreams[pubS.id];
        linkedStream.updateAttributes({ voff: _voff });
        pubS.updateAttributes({ voff: _voff });

        var streamControl = self.newMessage().setOp(400).setRtcId(rtcId).setVoff(_voff).setAoff(pubS.aoff);
        self.postMessage(streamControl, callback);
        self.onUpdateStream && self.onUpdateStream(pubS, new pubS.Update({ voff: _voff }));
    },

    startRecord: function startRecord(_stream, success) {
        var self = this;

        var rtcId = _stream.rtcId;

        var startRecord = self.newMessage().setOp(500).setRtcId(rtcId).setFlag(1);
        self.postMessage(startRecord, function (rsp) {
            _logger.warn("record ", rtcId, rsp.result, rsp.msg);
            success && success(rsp.result === 0);
            if (rsp.result === 0) {
                self._records[_stream.id] = _util.extend(false, {}, _stream);
            }
        });
    },

    stopRecord: function stopRecord(_stream, success) {
        var self = this;

        var rtcId = _stream.rtcId;

        var stopRecord = self.newMessage().setOp(500).setRtcId(rtcId).setFlag(0);
        self.postMessage(stopRecord, function (rsp) {
            _logger.warn("stop record ", rtcId, rsp.result, rsp.msg);
            success && success(rsp.result === 0);
        });

        if (self._records[_stream.id]) {
            _util.removeAttribute(self._records, _stream.id);
        }
    },

    onMembers: function onMembers(cver, members) {
        var self = this;

        var removedMembers = [];
        _util.forEach(self._cacheMembers, function (_memberId, _member) {
            members[_memberId] || removedMembers.push(_member);
        });
        _util.forEach(removedMembers, function (_index, _member) {
            self.onExit(undefined, _member.id);
        });

        var addMembers = [];
        _util.forEach(members, function (_memberId, _member) {
            //if(_memberId != self.getMemberId()){
            if (_member.name && _member.name != self.memName || !_member.name && _memberId != self.getMemberId()) {
                self._cacheMembers[_memberId] || addMembers.push(_member);
                self._cacheMembers[_memberId] && _util.extend(self._cacheMembers[_memberId], _member);
            }
        });
        _util.forEach(addMembers, function (_index, _member) {
            self.onEnter(undefined, _member);
        });

        cver && (self._cver = cver);
    },

    onStreams: function onStreams(cver, streams) {
        var self = this;

        var removedStreams = [];
        _util.forEach(self._cacheStreams, function (_pubSId, _stream) {
            _stream.located() || streams[_pubSId] || removedStreams.push(_stream);
        });
        _util.forEach(removedStreams, function (_index, _stream) {
            self.onUnpub(undefined, _stream.memId, _stream.id);
        });

        var addStreams = [];
        _util.forEach(streams, function (_pubSId, stream) {
            // if(stream.type === 2){ //强制 aoff = 1
            //     stream._1_aoff = stream.aoff;
            //     stream.aoff = self._service.hasAudioMixers() ? 0 : 1;
            // }

            //if(stream.memId != self.getMemberId()){
            if (stream.memName && stream.memName != self.memName || !stream.memName && stream.memId != self.getMemberId()) {
                self._cacheStreams[_pubSId] || addStreams.push(stream);
                self._cacheStreams[_pubSId] && _util.extend(self._cacheStreams[_pubSId], stream);
            }
        });
        _util.forEach(addStreams, function (_index, _stream) {
            self.onPub(undefined, _stream.memId, _stream);
        });

        _util.forEach(self._cacheStreams, function (_pubSId, _stream) {
            var newStream;
            _stream.located() || (newStream = streams[_pubSId]);
            if (newStream && (newStream.aoff !== _stream.aoff || newStream.voff != _stream.voff)) {
                self.onStreamControl(undefined, _pubSId, newStream.voff, newStream.aoff);
            }

            if (newStream && newStream.sver !== _stream.sver) {
                _util.extend(_stream, newStream);
                self._onRepublishStream(_stream);
            }
        });

        cver && (self._cver = cver);
    },

    _onRemoveMember: function _onRemoveMember(member, reason) {
        var self = this;

        _logger.info("remove", member, reason);

        var unpubStreams = [];
        _util.forEach(self._cacheStreams, function (_pubSId, _stream) {
            if ((_stream.memId || _stream.owner && _stream.owner.id) === member.id) {
                unpubStreams.push(_stream);
            }
        });

        _util.forEach(unpubStreams, function (index, stream) {
            self._onRemovePubstream(stream.owner, stream, reason);
        });

        _util.removeAttribute(self._cacheMembers, member.id);

        // var hasOtherDevices;
        // _util.forEach(self._cacheMembers, function (_memId, _member) {
        //     if(!hasOtherDevices && _memId != member.id && member.memName === _member.memName){
        //         hasOtherDevices = true;
        //     }
        // });
        //
        // if(hasOtherDevices){
        //     return;
        // }

        self.onRemoveMember && self.onRemoveMember(member, reason);
    },

    _onAddStream: function _onAddStream(stream) {
        _logger.info("add stream ", stream.id);
        _logger.debug("add stream ", stream);

        var self = this;
        self.onAddStream(stream);
    },

    _onRemovePubstream: function _onRemovePubstream(member, stream, reason) {
        var self = this;

        if (!stream) {
            return;
        }
        if (stream.id == 0) {
            return;
        }

        function finallyDo(stream) {
            if (stream.type === 2) {
                _util.removeAttribute(self.audioMixers, stream.id);

                if (stream.remotePlayAudioObject) {
                    document.body.removeChild(stream.remotePlayAudioObject);
                }
            }

            if (!reason) {
                reason = 'Unpub';
            }

            stream && !stream.closeReason && stream.updateAttributes({
                closeReason: reason
            });

            var _rtcId = self.unsubscribeStream(stream.id);
            var rmStream = _util.removeAttribute(self._cacheStreams, stream.id);
            self._streamAutomators && _util.removeAttribute(self._streamAutomators, stream.id);
            self._monitSoundChanagedStreams && _util.removeAttribute(self._monitSoundChanagedStreams, stream.id);

            if (self.onRemoveStream) {
                var stream = self.newStream(stream);

                self.onRemoveStream(stream);
            }
        }

        try {
            var soundMeter = _util.removeAttribute(self._mediaMeters, stream.id);
            soundMeter && soundMeter._finally();
        } finally {
            finallyDo(stream);
        }
    },

    _onRepublishStream: function _onRepublishStream(_stream) {
        var self = this;

        if ((self._ices[_stream.rtcId] || emedia.subscribed(_stream)) && !self._maybeNotExistStreams[_stream.id]) {
            var _rtcId = self.unsubscribeStream(_stream.id);

            self.createWebrtcAndSubscribeStream(_stream.id, {
                onGotRemote: function onGotRemote(stream) {
                    //self.onUpdateStream(_stream);
                }
            });
        } else {
            self.onUpdateStream(_stream);
        }
    },

    _onRecvRemoteMessage: function _onRecvRemoteMessage(fromMemId, args, evt) {
        var self = this;

        _logger.debug("Recv remote message", fromMemId, args);

        var fromMember = self._cacheMembers[fromMemId];
        var argsObject;
        try {
            argsObject = JSON.parse(args);
        } catch (e) {}

        self.onRecvRemoteMessage && self.onRecvRemoteMessage(fromMember || fromMemId, argsObject || args, evt);
    },

    _onSoundChanage: function _onSoundChanage(member, stream, meterData) {
        if (emedia.config._printSoundData) {
            _logger.info("Stream id " + stream.id + ", meter " + (meterData && meterData.instant.toFixed(2) + " " + meterData.slow.toFixed(2) + " " + meterData.clip.toFixed(2) + " " + (meterData.trackAudioLevel || "--") + " " + (meterData.trackTotalAudioEnergy || "--")));
        }

        meterData || (meterData = {
            instant: 0,
            slow: 0,
            clip: 0
        });

        if (emedia.config.logVolumeWhenInstantGE && emedia.config.logVolumeWhenInstantGE > 0 && meterData.instant >= emedia.config.logVolumeWhenInstantGE && meterData.instant < emedia.config.logVolumeWhenInstantGE * 3 //为了应对 混音时，移动端sdk audioLevel 问题。
        ) {
                _logger.info("Stream id " + stream.id + ", webrtc = " + (stream._webrtc ? stream._webrtc.getRtcId() : "null") + ", media streamId = " + (stream.getMediaStream() ? stream.getMediaStream().id : "null") + ", instant >= " + emedia.config.logVolumeWhenInstantGE + ", meter instant=" + meterData.instant + ", slow=" + meterData.slow + ", clip=" + meterData.clip);
            }

        var self = this;

        if (meterData.instant === 0) {
            meterData.instant = meterData.trackAudioLevel || meterData.trackTotalAudioEnergy || 0;
        }

        self.onSoundChanage(member, stream, meterData);
        if (self._service._judgeTalking(meterData)) {
            self.onTalking(member, stream, meterData);
        }
    },

    onAddMember: function onAddMember(member) {},
    onRemoveMember: function onRemoveMember(member, reason) {},
    onAddStream: function onAddStream(stream) {//stream undefined 表明 autoSub属性 空或false. autoSub = true时，自动订阅

    },
    onRemoveStream: function onRemoveStream(stream) {},
    onUpdateStream: function onUpdateStream(stream, update) {},
    onRecvRemoteMessage: function onRecvRemoteMessage(fromMember, argsObject) {},

    onSoundChanage: function onSoundChanage(member, stream, meterData) {},
    onTalking: function onTalking(member, stream, meterData) {},

    // 以下为动作消息封装

    /* 申请上麦和申请主持人
    *  都向 websocket send message(结构相同)
    *  文档链接 http://c1.private.easemob.com/pages/viewpage.action?pageId=12159600
    *  type： 21 申请上麦、22 申请主持人
    */
    _sendRequestMessage: function _sendRequestMessage(type) {

        if (!type) {
            return;
        }

        var _this = this;
        var get_admin_memberId = function get_admin_memberId() {
            var admin_memberId = '';

            for (var key in _this._cacheMembers) {
                var item = _this._cacheMembers[key];

                if (item.role == emedia.mgr.Role.ADMIN) {
                    admin_memberId = item.id;
                    break;
                }
            }

            return admin_memberId;
        };

        var admin_memberId = get_admin_memberId();
        if (!admin_memberId) {
            console.warn('this confrence have not admin');
            return;
        }

        var my_memberId = this._memberId,
            memName = this.memName,
            nickName = this.nickName;


        var message = this.newMessage();
        var post_message = {
            op: 1002,
            memId: admin_memberId,
            arg: (0, _stringify2.default)({ op2: type, memId: my_memberId, memName: memName, nickName: nickName || memName }),
            tsxTime: new Date().getTime(),
            _reqOps: ['1002' + type] // entry.js --> emedia.config.baseAcptOps 配置相应的参数
        };

        (0, _assign2.default)(message, post_message);

        this.postMessage(message);
    },
    // 申请上麦
    requestToTalker: function requestToTalker() {
        this._sendRequestMessage(21);
    },
    // 同意上麦
    // agreeRequestToTalker: function(arg){

    //     console.log(' atten agreeRequestToTalker this', this);
    //     console.log(' atten agreeRequestToTalker arg', arg);
    //     console.log(' atten agreeRequestToTalker emedia', emedia);

    //     let { memName } = arg;
    //     if(!memName) {
    //         console.warn('agreeRequestToTalker memName is required')
    //         return
    //     }


    // },

    // 发送对上麦申请和主持人申请的处理 type:21、上麦申请 22、主持人申请  result: 0、同意 1、拒绝
    // session  请求上麦的session，给他回复
    _send_action_request_message: function _send_action_request_message(type, session, result) {

        if (!session || !type) {
            return;
        }

        if (result === undefined) {
            return;
        }

        var tsxId = session.tsxId,
            arg = session.arg;
        var applicant_memberId = arg.memId;


        var message = this.newMessage();
        var post_message = {
            op: 1001,
            arg: (0, _stringify2.default)({ op2: type, memId: applicant_memberId }),
            memId: applicant_memberId,
            result: result,
            tsxId: tsxId,
            _reqOps: ['1002' + type]
        };

        (0, _assign2.default)(message, post_message);
        this.postMessage(message);
    },

    // 拒绝上麦
    refuseRequestToTalker: function refuseRequestToTalker(session) {

        this._send_action_request_message(21, session, 1);
    },

    // 拒绝主持人申请
    refuseRequestToAdmin: function refuseRequestToAdmin(session) {

        this._send_action_request_message(22, session, 1);
    },

    // 申请主持人
    requestToAdmin: function requestToAdmin() {
        this._sendRequestMessage(22);
    },

    /*
    * 指定静音或取消指定静音，发送消息
    * type: 23 静音、24 指定静音
    * memberId: 被指定静音人的 memberId
    */
    _sendControlAudioMessage: function _sendControlAudioMessage(memberId, type) {
        if (!memberId || !type) {
            return;
        }

        var message = this.newMessage();
        var post_message = {
            op: 1002,
            memId: memberId,
            arg: (0, _stringify2.default)({ op2: type, memId: memberId }),
            tsxTime: new Date().getTime(),
            _reqOps: [100223, 100224]
        };

        (0, _assign2.default)(message, post_message);

        this.postMessage(message);
    },
    // 指定静音
    muteBymemberId: function muteBymemberId(memberId) {
        this._sendControlAudioMessage(memberId, 23);
    },
    // 指定取消静音
    unmuteBymemberId: function unmuteBymemberId(memberId) {
        this._sendControlAudioMessage(memberId, 24);
    }

    // 动作消息封装结束
});

module.exports = Attendee;

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _util = __webpack_require__(72);
var _logger = _util.tagLogger("Member");

var __event = __webpack_require__(208);

var WebRTC = __webpack_require__(213);

/**
 * 未体现 Member 使用了 session。
 * 请 这样创建
 * Member({_session: sess, _memberId: memberId})
 * this._session
 *
 * {
 *  _memberId:
 *  _ices[Map]:
 * }
 *
 *
 *
 */
module.exports = _util.prototypeExtend({
    __init__: function __init__() {
        var self = this;

        if (!self._session) {
            _logger.error("Require session");
            throw "Require session";
        }

        self.closed = false;
        self._ices = {};

        self.supportVCodes = {};

        self.audioMixers = {};
    },

    reflushSupportVCodes: function reflushSupportVCodes(vcodes) {
        var self = this;

        self.supportVCodes = {};

        self._orderVCodes = vcodes;

        if (!vcodes || vcodes.length == 0) {
            _logger.warn("Not config support vcodes");
            return;
        }

        _util.forEach(vcodes, function (index, vcode) {
            self.supportVCodes[vcode] = 1;
        });
    },

    getOptimalVideoCodecs: function getOptimalVideoCodecs() {
        var self = this;

        if (!self._orderVCodes || self._orderVCodes.length == 0) {
            if (/Chrome/.test(navigator.userAgent)) {
                return 'VP8';
            } else if (/Safari/.test(navigator.userAgent)) {
                if (/Version\/11/.test(navigator.userAgent)) {
                    return "H264";
                }
                return 'VP8';
            }

            return 'VP8';
        }

        var memberCount = 0;
        _util.forEach(self._cacheMembers, function () {
            memberCount++;
        });

        var maxSupportCount = 0;
        var optimalVCode;

        for (var i = 0; i < self._orderVCodes.length; i++) {
            var vcode = self._orderVCodes[i];

            if (maxSupportCount == 0) {
                maxSupportCount = self.supportVCodes[vcode];
            }

            if (self.supportVCodes[vcode] > memberCount) {
                return vcode;
            }

            if (self.supportVCodes[vcode] > maxSupportCount) {
                maxSupportCount = self.supportVCodes[vcode];
                optimalVCode = vcode;
            }
        }

        return optimalVCode || self._orderVCodes && self._orderVCodes.length > 0 && self._orderVCodes[0];
    },

    setMemberId: function setMemberId(memberId) {
        this._memberId = memberId;
    },

    getMemberId: function getMemberId() {
        return this._memberId || this.id;
    },

    /**
     * createWebrtc({
     *  _rtcId:
     *  iceServerConfig:
     *  onGotMediaStream:
      * onEvent:
     * })
     *
     * @param iceServerConfig
     */
    createWebrtc: function createWebrtc(webrtcCfg, rebuildCount) {
        var self = this;

        webrtcCfg || (webrtcCfg = {});

        _util.extend(webrtcCfg, { _rebuildCount: rebuildCount || 0 });

        if (self._service.useRTCCfg === true && self.__rtc_cfg) {
            //优先使用 __rtc_cfg
            webrtcCfg.iceServerConfig = _util.extend(true, {}, self.__rtc_cfg);
        } else if (_util.isPlainObject(self._service.useRTCCfg)) {
            webrtcCfg.iceServerConfig = _util.extend(true, {}, self._service.useRTCCfg);
        }

        var webrtc = new WebRTC({
            //iceServerConfig: iceServerConfig,
            confrAttendee: self,
            useIp: self.ip,
            onIceStateChange: function onIceStateChange(iceState) {
                var state = iceState;

                _logger.debug("evt.target ice state", state);
                try {
                    if (state == 'failed') {
                        self.onEvent(new __event.ICEConnectFail({ webrtc: webrtc }));
                        webrtc.onEvent && webrtc.onEvent(new __event.ICEConnectFail({ webrtc: webrtc }));

                        return;
                    }
                    if (state == 'connected') {
                        self.onEvent(new __event.ICEConnected({ webrtc: webrtc }));
                        webrtc.onEvent = null;

                        return;
                    }
                    if (state == 'closed') {
                        self.onEvent(new __event.ICEClosed({ webrtc: webrtc }));
                        webrtc.onEvent && webrtc.onEvent(new __event.ICEClosed({ webrtc: webrtc }));

                        return;
                    }
                    if (state == 'disconnected') {
                        self.onEvent(new __event.ICEDisconnected({ webrtc: webrtc }));
                        webrtc.onEvent && webrtc.onEvent(new __event.ICEDisconnected({ webrtc: webrtc }));

                        return;
                    }
                } finally {
                    self._onIceStateChange && self._onIceStateChange(webrtc, iceState);
                }
            },

            onIceCandidate: function onIceCandidate(candidate) {
                //event.candidate
                self._onIceCandidate && candidate && self._onIceCandidate(webrtc, candidate);
            },

            onGotRemoteStream: function onGotRemoteStream(remoteStream) {
                _logger.info("got stream.", webrtc._rtcId, webrtc.__id, remoteStream);

                webrtc.onGotMediaStream && webrtc.onGotMediaStream(remoteStream);

                self.onEvent(new __event.ICERemoteMediaStream({ webrtc: webrtc }));
            },
            onAddIceCandidateError: function onAddIceCandidateError(err) {
                self.onEvent(new __event.AddIceCandError({ webrtc: webrtc, event: err }));
            },
            onSetSessionDescriptionError: function onSetSessionDescriptionError(error) {
                _logger.warn('onSetSessionDescriptionError : Failed to set session description: ' + error.toString());
                self.onEvent && self.onEvent(new __event.ICEConnectFail({ webrtc: webrtc, event: error }));
            },
            onCreateSessionDescriptionError: function onCreateSessionDescriptionError(error) {
                _logger.warn('Failed to create session description: ' + error.toString());
                self.onEvent && self.onEvent(new __event.ICEConnectFail({ webrtc: webrtc, event: error }));
            }
            // onSetLocalSessionDescriptionSuccess: function (error) {
            //     _logger.debug('onSetLocalSessionDescriptionSuccess : setLocalDescription complete: ' + error.toString());
            //     self.onEvent && self.onEvent(new __event.ICEConnectFail({webrtc: webrtc, event: error}));
            // },
        }, webrtcCfg);

        self._ices || (self._ices = {});
        if (self._ices[webrtc.getRtcId()]) {
            self._howDoWebrtcWhenCrtExsitsWebrtc(webrtc);
        }
        self._ices[webrtc.getRtcId()] = webrtc;
        self._ices[webrtc.__id] = webrtc;

        self._iceCreateRtcPeerConnection(webrtc.getRtcId());
        _logger.debug("create rtc ", webrtc);

        return webrtc;
    },

    _howDoWebrtcWhenCrtExsitsWebrtc: function _howDoWebrtcWhenCrtExsitsWebrtc(webrtc) {
        var self = this;

        //throw "Webrtc id exsits at ices. it is " + webrtc.getRtcId();
        self.closeWebrtc(webrtc.getRtcId(), true, false);
    },

    connect: function connect(suceess, fail) {
        var self = this;

        self._session.connect(suceess, fail);
    },

    connected: function connected() {
        var self = this;

        return self._session.connected();
    },

    newMessage: function message(cfg) {
        var self = this;

        var message = self._session.newMessage(cfg);
        message.post = function (callback, timeoutMillis) {
            self.postMessage(this, callback, timeoutMillis);
        };

        return message;
    },

    message: function message(cfg) {
        var self = this;

        var message = self._session.newMessage(cfg);
        message.post = function (callback, timeoutMillis) {
            self.postMessage(this, callback, timeoutMillis);
        };

        return message;
    },

    postMessage: function postMessage(message, callback, timeoutMillis) {
        var self = this;

        try {
            message.sessId || (message.sessId = self._session._sessionId);
            self._session.postMessage(message, callback, timeoutMillis);
        } catch (e) {
            callback && callback({ op: 1001, tsxId: message.tsxId, result: -9527, msg: "post message. exception" });
            _logger.warn(e);
        }
    },

    onEvent: function onEvent(error) {},

    _onIceStateChange: function _onIceStateChange(webrtc, rtcState) {
        var self = this;

        _logger.info(webrtc.getRtcId(), rtcState);
        self.onEvent(new __event.ICEChanage({ webrtc: webrtc, state: rtcState }));
    },

    _onIceCandidate: function _onIceCandidate(webrtc, cand) {
        //event.candidate
        var self = this;

        var cands;
        if (_util.isArray(cand)) {
            cands = cand;
        } else {
            cands = [];
            cands.push(cand);
        }

        var tcklC = self.newMessage().setOp(105).setRtcId(webrtc.getRtcId()).setCands(cands);

        self.postMessage(tcklC, function (rsp) {
            if (rsp.result != 0) {
                self.onEvent(new __event.RspFail({ request: tcklC, response: rsp }));

                return;
            }
        });
    },

    _initC: function _initC(webrtc, stream, sdp, subSId, rspFail, rspSuccess) {
        var self = this;

        if (stream && stream.rtcId !== webrtc.getRtcId()) {
            _logger.error("stream and webrtc rtcId not equal.");
            throw "stream and webrtc rtcId not equal.";
        }

        var initC = self.newMessage().setOp(102).setRtcId(webrtc.getRtcId()).setSdp(sdp).setSubSId(subSId);

        webrtc.subArgs && _util.extend(initC, webrtc.subArgs);

        if (stream && stream.located()) {
            initC.setPubS(stream);
        }

        self.postMessage(initC, function (rsp) {
            if (rsp.result != 0) {
                self.onEvent(new __event.RspFail({ request: initC, response: rsp }));
                rspFail && rspFail(new __event.RspFail({ request: initC, response: rsp, hidden: rsp.retrying === true }));

                return;
            }

            if (stream && !stream.id && rsp.streamId) {
                stream.updateAttributes({ id: rsp.streamId });
            }

            try {
                rspSuccess && rspSuccess();
            } catch (e) {
                _logger.warn(e);
            }

            rsp.sdp && self.ansC(webrtc.getRtcId(), rsp.sdp, rsp.cands);

            rsp.mems && self.onMembers && self.onMembers(rsp.cver, rsp.mems);
            rsp.streams && self.onStreams && self.onStreams(rsp.cver, rsp.streams);
        });
    },

    _acptC: function _acptC(webrtc, sdp, rspFail) {
        var self = this;

        var acptC = self.newMessage().setOp(104).setRtcId(webrtc.getRtcId()).setSdp(sdp);

        self.postMessage(acptC, function (rsp) {
            if (rsp.result != 0) {
                self.onEvent(new __event.RspFail({ request: acptC, response: rsp }));
                rspFail && rspFail(new __event.RspFail({ request: acptC, response: rsp }));

                return;
            }
        });
    },

    _ansCAndPubstream: function _ansCAndPubstream(webrtc, stream, sdp, rspFail, rspSuccess) {
        var self = this;

        var ansC = self.newMessage().setOp(106).setRtcId(webrtc.getRtcId()).setSdp(sdp);

        webrtc.subArgs && _util.extend(ansC, webrtc.subArgs);

        if (stream && stream.located()) {
            stream = _util.extend({}, stream);
            _util.removeAttribute(stream, "mutedMuted");
            _util.removeAttribute(stream, "_located");

            ansC.setPubS(stream);
        }

        self.postMessage(ansC, function (rsp) {
            if (rsp.result != 0) {
                self.onEvent(new __event.RspFail({ request: ansC, response: rsp }));
                rspFail && rspFail(new __event.RspFail({ request: ansC, response: rsp, hidden: rsp.retrying === true }));

                return;
            }

            if (stream && !stream.id && rsp.streamId) {
                stream.updateAttributes({ id: rsp.streamId });
            }

            try {
                rspSuccess && rspSuccess();
            } catch (e) {
                _logger.warn(e);
            }
        });
    },

    _ansC: function _ansC(webrtc, sdp, rspFail) {
        var self = this;

        var ansC = self.newMessage().setOp(106).setRtcId(webrtc.getRtcId()).setSdp(sdp);

        self.postMessage(ansC, function (rsp) {
            if (rsp.result != 0) {
                self.onEvent(new __event.RspFail({ request: ansC, response: rsp }));
                rspFail && rspFail(new __event.RspFail({ request: ansC, response: rsp }));

                return;
            }
        });
    },

    _termC: function _termC(webrtc, endReason, rspFail) {
        var self = this;

        var rtcId = typeof webrtc === "string" ? webrtc : webrtc.getRtcId();
        var termC = self.newMessage().setOp(107).setRtcId(rtcId).setEndReason(endReason);

        self.postMessage(termC, function (rsp) {
            if (rsp.result != 0) {
                self.onEvent(new __event.RspFail({ request: termC, response: rsp }));
                rspFail && rspFail(new __event.RspFail({ request: termC, response: rsp }));

                return;
            }
        });
    },

    _iceCreateRtcPeerConnection: function _iceCreateRtcPeerConnection(rtcId) {
        var self = this;

        self._ices[rtcId].createRtcPeerConnection();

        _logger.debug("create rtc peer connection", rtcId);
    },

    doOffer: function doOffer(rtcId, onGotOffer, onCreateOfferError) {
        var self = this;

        var webrtc = self._ices[rtcId];

        webrtc.createOffer(function (sdp) {
            onGotOffer(sdp);
        });
    },

    offerCall: function offerCall(rtcId, stream, subSId, rspFail, rspSuccess) {
        var self = this;

        var webrtc = self._ices[rtcId];

        webrtc.createOffer(function (sdp) {
            self._initC && self._initC(webrtc, stream, sdp, subSId, rspFail, rspSuccess);
        });
    },

    accept: function accept(rtcId, rspFail) {
        var self = this;

        var webrtc = self._ices[rtcId];
        webrtc.createPRAnswer(function (sdp) {
            self._acptC && self._acptC(webrtc, sdp, rspFail);
        });
    },

    answerCall: function answerCall(rtcId, stream, rspFail, rspSuccess) {
        var self = this;

        var webrtc = self._ices[rtcId];

        webrtc.createAnswer(function (sdp) {
            self._ansCAndPubstream && self._ansCAndPubstream(webrtc, stream, sdp, rspFail, rspSuccess);
        });
    },

    answer: function answer(rtcId, rspFail) {
        var self = this;

        var webrtc = self._ices[rtcId];
        webrtc.createAnswer(function (sdp) {
            self._ansC && self._ansC(webrtc, sdp, rspFail);
        });
    },

    onTcklC: function onTcklC(rtcId, cands) {
        var self = this;
        self._addIceCandidate(cands, rtcId);
    },

    onAcptC: function onAcptC(rtcId, sdp, cands) {
        var self = this;
        self._iceSetRemoteSDP(sdp, rtcId);
        cands && self._addIceCandidate(cands, rtcId);
    },

    onAnsC: function onAnsC(rtcId, sdp, cands) {
        var self = this;
        // setTimeout(function () {
        //     self._iceSetRemoteSDP(sdp, rtcId);
        //     cands && self._addIceCandidate(cands, rtcId);
        // }, 2000);

        self._iceSetRemoteSDP(sdp, rtcId);
        cands && self._addIceCandidate(cands, rtcId);
    },

    _addIceCandidate: function _addIceCandidate(cands, rtcId) {
        var self = this;

        if (!cands || cands.length == 0) {
            _logger.warn("drop cands", cands);
            return;
        }

        var webrtc = self._ices[rtcId];
        webrtc && webrtc.addIceCandidate(cands);
    },

    closeWebrtc: function closeWebrtc(rtcId, remainLocalStream, serverClosed) {
        var self = this;
        var webrtc = self._ices[rtcId];

        _util.forEach(self._cacheStreams, function (sid, _stream) {
            if (_stream.rtcId === rtcId && !_stream.located()) {
                try {
                    var soundMeter = _util.removeAttribute(self._mediaMeters, sid);
                    soundMeter && soundMeter._finally();
                } catch (e) {
                    _logger.warn(e);
                }
            }

            if (_stream.rtcId === rtcId && _stream.type === 2) {
                _util.removeAttribute(self.audioMixers, _stream.id);
            }
        });

        if (!webrtc || webrtc.closed) {
            _logger.warn("Webrtc not exsits or closed", webrtc && webrtc.closed);

            if (serverClosed) {
                webrtc && _util.forEach(self._cacheStreams, function (sid, _stream) {
                    if (_stream.rtcId === rtcId) {
                        //delete self._linkedStreams[sid];
                        _util.removeAttribute(self._linkedStreams, sid);
                        _logger.warn("Webrtc close, remvoe from _linkedStreams", sid);
                    }
                });
            }

            serverClosed || self._termC(rtcId, 0);

            return;
        }

        if (self._records) {
            var _stopRecord = function _stopRecord(_stream) {
                try {
                    self.stopRecord(_stream);
                } catch (e) {
                    _logger.warn(e);
                } finally {
                    _util.removeAttribute(self._records, _stream.id);
                }
            };

            _util.forEach(self._records, function (sid, _stream) {
                _stream.rtcId === rtcId && _stopRecord(_stream);
            });
        }

        try {
            serverClosed || webrtc && self._termC(webrtc, remainLocalStream && webrtc._localStream ? -10 : 0);
        } finally {
            //webrtc && _util.removeAttribute(self._ices, rtcId);

            webrtc && webrtc.close(remainLocalStream); //
            webrtc && self.onWebrtcTermC && self.onWebrtcTermC(webrtc);

            if (remainLocalStream) {} else {
                webrtc && _util.forEach(self._cacheStreams, function (sid, _stream) {
                    if (_stream.rtcId === rtcId) {
                        if (_stream.located()) {
                            emedia.stopTracks(_stream._localMediaStream);

                            _stream && !_stream.closeReason && _stream.updateAttributes({
                                closeReason: "WebrtcClose"
                            });

                            self._cacheStreams[sid] && self._linkedStreams[sid] && self.onRemoveStream(_stream);

                            _util.removeAttribute(self._cacheStreams, sid);
                            self._streamAutomators && _util.removeAttribute(self._streamAutomators, sid);
                            self._monitSoundChanagedStreams && _util.removeAttribute(self._monitSoundChanagedStreams, sid);
                            _logger.info("Webrtc close. Remove stream", sid, ". from cache");
                        }

                        if (serverClosed) {
                            //delete self._linkedStreams[sid];
                            _util.removeAttribute(self._linkedStreams, sid);
                            _logger.info("Webrtc close. Remove stream", sid, ". from _linkedStreams");
                        }
                    }
                });
            }
        }

        return webrtc;
    },

    __close: function __close(reason) {
        _logger.warn("closing, reason = ", reason);

        var self = this;
        if (self.closed) {
            return;
        }

        self.closed = true;

        if (self.__getCopyInterval) {
            clearInterval(self.__getCopyInterval);
            _logger.warn("Stop interval get copy");
        }

        if (self._ices) {
            for (var _rtcId in self._ices) {
                self.closeWebrtc(_rtcId, false);
            }
        }

        var exit = self.newMessage().setOp(201).setReason(reason || 0);
        self.postMessage(exit);
    },

    exit: function exit(closeMyConfrIfICrtConfr) {
        var self = this;

        if (!closeMyConfrIfICrtConfr) {
            self.close(0); // 正常挂断
            return;
        }

        if (closeMyConfrIfICrtConfr) {
            self._closeMyConfr(11);
            //return;
        }
        setTimeout(function () {
            self.close(0); // 正常挂断
        }, 100);
    },

    _closeMyConfr: function _closeMyConfr(reason) {
        var self = this;

        var closeConfr = self.newMessage().setOp(204).setReason(reason || 0);
        self.postMessage(closeConfr, function (rsp) {
            _logger.warn("Close confr ", rsp.result, rsp.msg);
        });
    },

    /**
     * 1.服务端 踢掉
     * 2.手动点击 挂断
     * 3.enter失败！
     *
     * @param reason
     */
    close: function close(reason, failed) {
        var self = this;
        if (self.closed) {
            return;
        }

        try {
            _util.forEach(self._cacheStreams || {}, function (sid, _stream) {
                if (_stream.located() && _stream._localMediaStream) {
                    emedia.stopTracks(_stream._localMediaStream);
                }
            });

            self.__close(reason);

            _util.forEach(self._cacheStreams, function (sid, _stream) {
                self.onRemoveStream(_stream);
            });
            _util.forEach(self._cacheMembers, function (_id, _member) {
                // self.onRemoveMember(_member);
            });
        } finally {
            try {
                setTimeout(function () {
                    self._session && self._session.close(reason);
                }, 500);

                self.onEvent(new __event.Hangup({ reason: reason, failed: failed, self: { id: self._memberId } }));
                self.onMeExit && self.onMeExit(reason, failed);
            } catch (e) {
                _logger.error(e);
            } finally {
                self._onFinally && self._onFinally();
            }
        }
    },

    webrtcState: function webrtcState(rtcId) {
        var self = this;

        var webrtc = self._ices[rtcId];
        return webrtc.iceConnectionState();
    },

    _iceSetRemoteSDP: function _iceSetRemoteSDP(sdp, rtcId) {
        var self = this;

        var webrtc = self._ices[rtcId];
        webrtc && webrtc.setRemoteDescription(sdp);
    },

    setLocalStream: function setLocalStream(stream, rtcId) {
        var self = this;

        var webrtc = self._ices[rtcId];
        webrtc.setLocalStream(stream);
    },

    onWebrtcTermC: function onWebrtcTermC(_webrtc) {}
});

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _stringify = __webpack_require__(144);

var _stringify2 = _interopRequireDefault(_stringify);

var _keys = __webpack_require__(178);

var _keys2 = _interopRequireDefault(_keys);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * WebRTC
 *
 *                              A                   |                                       B
 *                                                  |
 *   1.createMedia:got streamA                      | 1.createMedia:got streamB
 *   2.new RTCPeerConnection: APeerConnection       | 2.new RTCPeerConnection: BPeerConnection
 *   3.APeerConnection.createOffer:got offerA       |
 *      APeerConnection.setLocalDescription(offerA) |
 *      send offerA ---> ---> ---> --->        ---> |
 *                                                  | ---> 3.got offerA | offerA = new RTCSessionDescription(offerA);
 *                                                  | BPeerConnection.setRemoteDescription(offerA)
 *                                                  |
 *                                                  |
 *                                                  | 4.BPeerConnection.createAnswer: got answerB
 *                                                  | BPeerConnection.setLocalDescription(answerB)
 *                                                  | <---- send answerB
 *                                                  | 5.got answerB <--- <--- <--- <---
 *                                                  | answerB = new RTCSessionDescription(answerB)
 *                                                  |
 * APeerConnection.setRemoteDescription(answerB)    |
 *                                                  |
 * 6.got candidateA ---> --->  ---> --->            | ---> got candidateA
 *                                                  | BPeerConnection.addIceCandidate(new RTCIceCandidate(candidateA))
 *                                                  |
 *                                                  |
 *                                                  | got candidateB <--- <--- <--- <---
 *                                                  | <--- 6.got candidateB APeerConnection.addIceCandidate(candidateB)
 *                                                  |
 *                                                  |
 *                                                  | 7. APeerConnection.addStream(streamA)
 *                                                  | 7. BPeerConnection.addStream(streamB)
 *                                                  |
 *                              streamA >>>>>>>>>>> |  <<<<< see A
 *                              seeB <<<<<<<<<<<    | <<<<< streamB
 *                                                  |
 *
 */

var _util = __webpack_require__(72);
var _logger = _util.tagLogger("Webrtc");

var SDPUtils = __webpack_require__(214); //希望使用 SDPUtils 取代 SDPSection

var DeployMore = __webpack_require__(209).default; //多集群部署 配置文件

var _SDPSection = {
    headerSection: null,

    audioSection: null,
    videoSection: null,

    _parseHeaderSection: function _parseHeaderSection(sdp, audioIndex, videoIndex) {
        var index = audioIndex;

        if (videoIndex === -1) {//保持不变
        } else if (audioIndex === -1) {
            index = videoIndex;
        } else {
            index = Math.min(audioIndex, videoIndex);
        }

        if (index >= 0) {
            return sdp.slice(0, index);
        }
        return sdp;
    },

    _parseAudioSection: function _parseAudioSection(sdp, audioIndex, videoIndex) {
        var index = audioIndex;
        if (index >= 0) {
            return sdp.slice(index, videoIndex < index ? sdp.length : videoIndex);
        }
    },

    _parseVideoSection: function _parseVideoSection(sdp, audioIndex, videoIndex) {
        var index = videoIndex;
        if (index >= 0) {
            return sdp.slice(index, audioIndex < index ? sdp.length : audioIndex);
        }
    },

    spiltSection: function spiltSection(sdp) {
        var self = this;

        self._preSDP = sdp;

        var audioIndex = self._preAudioIndex = sdp.indexOf('m=audio');
        var videoIndex = self._preVideoIndex = sdp.indexOf('m=video');

        self.headerSection = self._parseHeaderSection(sdp, audioIndex, videoIndex);
        self.audioSection = self._parseAudioSection(sdp, audioIndex, videoIndex);
        self.videoSection = self._parseVideoSection(sdp, audioIndex, videoIndex);
    },

    setVideoBitrate: function setVideoBitrate(vbitrate) {
        if (!vbitrate || !this.videoSection) {
            return;
        }

        this.videoSection = this.setBitrate(this.videoSection, vbitrate);
    },

    // setVideoMinBitrate: function (vminBitrate) {
    //     if(!vminBitrate || !this.videoSection){
    //         return;
    //     }
    //     //x-google-min-bitrate
    //     this.videoSection = this.videoSection.replace(/(a=fmtp\:\d+\sx-google-min-bitrate=)\d+/g, "$1" + vminBitrate);
    // },
    setVideoMinBitrate: function setVideoMinBitrate(minBitrate) {
        this.setAllFmtpBitrate({ "x-google-min-bitrate": minBitrate });
        // this.setAllFmtpBitrate({
        //     "x-google-min-bitrate": minBitrate,
        //     "x-google-start-bitrate": minBitrate + 100,
        //     "x-google-max-bitrate": minBitrate + 100000,
        // });
    },
    setVideoMaxBitrate: function setVideoMaxBitrate(maxBitrate) {
        this.setAllFmtpBitrate({ "x-google-max-bitrate": maxBitrate });
    },
    setVideoStartBitrate: function setVideoStartBitrate(startBitrate) {
        this.setAllFmtpBitrate({ "x-google-start-bitrate": startBitrate });
    },
    setAllFmtpBitrate: function setFmtpBitrate(map) {
        if (!this.videoSection) {
            return;
        }

        // var vp8H264H265=[];
        // this.videoSection.replace(/a=rtpmap\:(\d+)\s+(VP8|H264|H265)[^\r\n]+([\r\n]+)/g, function (all, code, name) {
        //     //console.log(code, name);
        //     vp8H264H265.push(code);
        // });

        var fields = {};
        (0, _keys2.default)(map).forEach(function (fmtpName) {
            var bitrate = map[fmtpName];
            var field = fmtpName + "=" + bitrate;
            var regex = new RegExp('(a=fmtp\\:\\d+\\s\\S*;?)(' + fmtpName + '=\\d+)(;?\\S*)', 'g');

            fields[fmtpName] = { field: field, regex: regex };
        });

        //(?:' + vp8H264H265.join('|') + '
        ///(a=fmtp\:\d+)[^\r\n]+)([\r\n]+)/g
        //new RegExp('(a=fmtp\\:(?:' + vp8H264H265.join('|') + ')[^\\r\\n]+)([\\r\\n]+)', 'g')

        this.videoSection = this.videoSection.replace(/(a=fmtp\:\d+[^\r\n]+)([\r\n]+)/g, function (all, fmtp, enter) {
            if (fmtp.indexOf("apt=") >= 0) {
                return all;
            }

            (0, _keys2.default)(fields).forEach(function (fmtpName) {
                var fieldAndRegex = fields[fmtpName];

                var regex = fieldAndRegex.regex;
                var field = fieldAndRegex.field;
                var replacedFmtp = fmtp.replace(regex, function ($$, $1, $2, $3) {
                    return $1 + field + $3;
                });

                if (replacedFmtp.indexOf(fmtpName) < 0) {
                    //没有包含
                    if (!replacedFmtp.endsWith(';')) {
                        replacedFmtp += ";";
                    }
                    fmtp = replacedFmtp + field;
                } else {
                    fmtp = replacedFmtp;
                }
            });

            return fmtp + enter;
        });
    },
    setFmtpBitrate: function setFmtpBitrate(fmtpName, bitrate) {
        if (!bitrate || !this.videoSection) {
            return;
        }

        var field = fmtpName + "=" + bitrate;
        var regex = new RegExp('(a=fmtp\\:\\d+\\s\\S*;?)(' + fmtpName + '=\\d+)(;?\\S*)', 'g');
        this.videoSection = this.videoSection.replace(/(a=fmtp\:\d+[^\r\n]+)([\r\n]+)/g, function (all, fmtp, enter) {
            var replacedFmtp = fmtp.replace(regex, function ($$, $1, $2, $3) {
                return $1 + field + $3;
            });

            if (replacedFmtp.indexOf(fmtpName) < 0) {
                //没有包含
                if (!replacedFmtp.endsWith(';')) {
                    replacedFmtp += ";";
                }
                replacedFmtp = replacedFmtp + field;
            }

            return replacedFmtp + enter;
        });
    },

    setAudioBitrate: function setAudioBitrate(abitrate) {
        if (!abitrate || !this.audioSection) {
            return;
        }

        this.audioSection = this.setBitrate(this.audioSection, abitrate);
    },

    setBitrate0: function setBitrate0(section, bitrate) {
        section = section.replace(/(b=)(?:AS|TIAS)(\:)\d+/g, "$1AS$2" + bitrate);
        if (section.indexOf('b=AS') < 0) {
            section = section.replace(/(m=(?:audio|video)[^\r\n]+)([\r\n]+)/g, "$1$2b=AS:" + bitrate + "$2");
        }
        return section;
    },

    setBitrate: function setBitrate(section, bandwidth) {
        var modifier = 'AS';
        if (emedia.isFirefox) {
            bandwidth = (bandwidth >>> 0) * 1000;
            modifier = 'TIAS';
        }
        section = section.replace(/(b=)(?:AS|TIAS)(\:)\d+/g, "$1" + modifier + "$2" + bandwidth);
        if (section.indexOf('b=' + modifier + ':') < 0) {
            //没有b行
            if (section.indexOf('c=IN ') < 0) {
                // 没有C行
                section = section.replace(/(m=(?:audio|video)[^\r\n]+)([\r\n]+)/g, "$1$2b=" + modifier + ":" + bandwidth + "$2");
            } else {
                // insert b= after c= line.
                section = section.replace(/c=IN ([^\r\n]+)([\r\n]+)/, 'c=IN $1$2b=' + modifier + ':' + bandwidth + '$2');
            }
        }
        return section;
    },

    updateVideoSection: function updateVideoSection(regx, oper) {
        var self = this;

        if (!self.videoSection) {
            return;
        }

        self.videoSection = self.videoSection.replace(regx, oper);
    },

    updateAudioSection: function updateAudioSection(regx, oper) {
        var self = this;

        if (!self.audioSection) {
            return;
        }

        self.audioSection = self.audioSection.replace(regx, oper);
    },

    updateVideoSendonly: function updateVideoSendonly() {
        var self = this;

        if (!self.videoSection) {
            return;
        }

        self.videoSection = self.videoSection.replace(/sendrecv/g, "sendonly");
    },

    updateVideoRecvonly: function updateVideoRecvonly() {
        var self = this;

        if (!self.videoSection) {
            return;
        }

        self.videoSection = self.videoSection.replace(/sendrecv/g, "recvonly");
    },

    updateAudioSendonly: function updateAudioSendonly() {
        var self = this;

        if (!self.audioSection) {
            return;
        }

        self.audioSection = self.audioSection.replace(/sendrecv/g, "sendonly");
    },

    updateAudioRecvonly: function updateAudioRecvonly() {
        var self = this;

        if (!self.audioSection) {
            return;
        }

        self.audioSection = self.audioSection.replace(/sendrecv/g, "recvonly");
    },

    updateACodes: function updateACodes(acodes) {
        var self = this;

        if (!acodes) {
            return;
        }
        if (!self.audioSection) {
            return;
        }

        if (typeof acodes === "string") {
            var arr = [];
            arr.push(acodes);
            acodes = arr;
        }

        var vcodeMap = {};
        var regexp = /a=rtpmap:(\d+) ([A-Za-z0-9]+)\/.*/ig;
        var arr = self._parseLine(self.audioSection, regexp);
        for (var i = 0; i < arr.length; i++) {
            var codeNum = arr[++i];
            var code = arr[++i];
            vcodeMap[code] = codeNum;
        }

        var numCodes = [];
        for (var i = 0; i < acodes.length; i++) {
            var supportVCode = vcodeMap[acodes[i]];
            supportVCode && numCodes.push(supportVCode);
        }
        if (numCodes.length == 0) {
            if (self._webrtc) {
                _logger.warn("Not found acodes map", acodes, self._webrtc._rtcId, self._webrtc.__id);
            } else {
                _logger.warn("Not found acodes map", acodes);
            }
        }

        var codeLineLastIndex = self.audioSection.indexOf('\r');
        var codeLine = self.audioSection.substring(0, codeLineLastIndex);

        var fields = codeLine.split(' ');

        Array.prototype.push.apply(numCodes, fields.slice(3));

        var newNumCodes = [];
        var _map = {};
        _util.forEach(numCodes, function (index, ele) {
            if (newNumCodes.length == 0) {
                newNumCodes.push(ele);
                _map[ele] = true;
            } else {
                if (!_map[ele]) {
                    newNumCodes.push(ele);
                    _map[ele] = true;
                }
            }
        });
        //alert(numCodes.join(' '));

        //fields.splice(3, 0, numCodes);
        fields.splice(3, fields.length - 3, newNumCodes.join(' '));

        codeLine = fields.join(' ');
        //_logger.info(codeLine);
        if (self._webrtc) {
            _logger.warn(codeLine, self._webrtc._rtcId, self._webrtc.__id);
        }

        self.audioSection = codeLine + self.audioSection.substring(codeLineLastIndex);
    },

    updateVCodes: function updateVCodes(vcodes) {
        var self = this;

        if (!vcodes) {
            return;
        }
        if (!self.videoSection) {
            return;
        }

        if (typeof vcodes === "string") {
            var arr = [];
            arr.push(vcodes);
            vcodes = arr;
        }

        var vcodeMap = {};
        var regexp = /a=rtpmap:(\d+) ([A-Za-z0-9]+)\/.*/ig;
        var arr = self._parseLine(self.videoSection, regexp);
        for (var i = 0; i < arr.length; i++) {
            var codeNum = arr[++i];
            var code = arr[++i];
            vcodeMap[code] = codeNum;
        }

        //H264
        //if(/Firefox/.test(navigator.userAgent) || /Chrome/.test(navigator.userAgent)){ //a=fmtp:126 profile-level-id=42e01f;level-asymmetry-allowed=1;packetization-mode=1
        var h264_regexp = /a=fmtp:(\d+) .*profile-level-id=42e01f;?.*/ig;
        var h264_arr = self._parseLine(self.videoSection, h264_regexp);

        if (h264_arr && h264_arr.length >= 2) {
            vcodeMap['H264'] = h264_arr[1];
        }
        //}

        var numCodes = [];
        for (var i = 0; i < vcodes.length; i++) {
            var supportVCode = vcodeMap[vcodes[i]];
            supportVCode && numCodes.push(supportVCode);
        }
        if (numCodes.length == 0) {
            if (self._webrtc) {
                _logger.warn("Not found vcodes map", vcodes, self._webrtc._rtcId, self._webrtc.__id);
            } else {
                _logger.warn("Not found vcodes map", vcodes);
            }
        }

        var codeLineLastIndex = self.videoSection.indexOf('\r');
        var codeLine = self.videoSection.substring(0, codeLineLastIndex);

        var fields = codeLine.split(' ');

        Array.prototype.push.apply(numCodes, fields.slice(3));

        var newNumCodes = [];
        var _map = {};
        _util.forEach(numCodes, function (index, ele) {
            if (newNumCodes.length == 0) {
                newNumCodes.push(ele);
                _map[ele] = true;
            } else {
                if (!_map[ele]) {
                    newNumCodes.push(ele);
                    _map[ele] = true;
                }
            }
        });
        //alert(numCodes.join(' '));

        //fields.splice(3, 0, numCodes);
        fields.splice(3, fields.length - 3, newNumCodes.join(' '));

        codeLine = fields.join(' ');
        //_logger.info(codeLine);
        if (self._webrtc) {
            _logger.warn(codeLine, self._webrtc._rtcId, self._webrtc.__id);
        }

        self.videoSection = codeLine + self.videoSection.substring(codeLineLastIndex);
    },

    removeSSRC: function removeSSRC(section) {
        var arr = [];

        var _arr = section.split(/a=ssrc:[^\n]+/g);
        for (var i = 0; i < _arr.length; i++) {
            _arr[i] != '\n' && arr.push(_arr[i]);
        }
        // arr.push('');

        return arr.join('\n');
    },

    removeField_msid: function removeField_msid(section) {
        var arr = [];

        var _arr = section.split(/a=msid:[^\n]+/g);
        for (var i = 0; i < _arr.length; i++) {
            _arr[i] != '\n' && arr.push(_arr[i]);
        }
        // arr.push('');

        section = arr.join('\n');
        arr = [];

        _arr = section.split(/[\n]+/g);
        for (var i = 0; i < _arr.length; i++) {
            _arr[i] != '\n' && arr.push(_arr[i]);
        }

        return arr.join('\n');
    },

    updateHeaderMsidSemantic: function updateHeaderMsidSemantic(wms) {

        var self = this;

        var line = "a=msid-semantic: WMS " + wms;

        var _arr = self.headerSection.split(/a=msid\-semantic: WMS.*/g);
        var arr = [];
        switch (_arr.length) {
            case 1:
                arr.push(_arr[0]);
                break;
            case 2:
                arr.push(_arr[0]);
                arr.push(line);
                arr.push('\n');
                break;
            case 3:
                arr.push(_arr[0]);
                arr.push(line);
                arr.push('\n');
                arr.push(_arr[2]);
                arr.push('\n');
                break;
        }

        return self.headerSection = arr.join('');
    },

    updateAudioSSRCSection: function updateAudioSSRCSection(ssrc, cname, msid, label) {
        var self = this;

        self.audioSection && (self.audioSection = self.removeSSRC(self.audioSection));
        self.audioSection && (self.audioSection = self.removeField_msid(self.audioSection));
        self.audioSection && (self.audioSection = self.audioSection + self.ssrcSection(ssrc, cname, msid, label));
    },

    updateVideoSSRCSection: function updateVideoSSRCSection(ssrc, cname, msid, label) {
        var self = this;

        self.videoSection && (self.videoSection = self.removeSSRC(self.videoSection));
        self.videoSection && (self.videoSection = self.removeField_msid(self.videoSection));
        self.videoSection && (self.videoSection = self.videoSection + self.ssrcSection(ssrc, cname, msid, label));
    },

    getUpdatedSDP: function getUpdatedSDP(audioVideo) {
        var self = this;

        // if(self._preAudioIndex < 0 || self._preVideoIndex < 0){
        //     return this._preSDP;
        // }
        //
        // audioVideo = (audioVideo === true || audioVideo === undefined);
        // var sdpAudioVideo = self._preAudioIndex < self._preVideoIndex;
        //
        // if(audioVideo == sdpAudioVideo){
        //     return this._preSDP;
        // }

        if (audioVideo === undefined || audioVideo == null) {
            audioVideo = self._preAudioIndex < self._preVideoIndex;
        }

        var videoMid;
        self.videoSection && self.videoSection.replace(/a=mid:([^\r\n]+)/, function (match, p1) {
            videoMid = p1;
            return match;
        });

        var audioMid;
        self.audioSection && self.audioSection.replace(/a=mid:([^\r\n]+)/, function (match, p1) {
            audioMid = p1;
            return match;
        });

        var sdp;
        if (audioVideo) {
            var bundleLine = ["a=group:BUNDLE"];
            self.audioSection && bundleLine.push(audioMid);
            self.videoSection && bundleLine.push(videoMid);

            sdp = self.headerSection.replace(/a=group:BUNDLE [^\r\n]+/, bundleLine.join(" "));

            self.audioSection && (sdp += self.audioSection);
            self.videoSection && (sdp += self.videoSection);
        } else {
            var bundleLine = ["a=group:BUNDLE"];
            self.videoSection && bundleLine.push(videoMid);
            self.audioSection && bundleLine.push(audioMid);

            sdp = self.headerSection.replace(/a=group:BUNDLE [^\r\n]+/, bundleLine.join(" "));

            self.videoSection && (sdp += self.videoSection);
            self.audioSection && (sdp += self.audioSection);
        }

        return sdp;
    },

    parseMsidSemantic: function parseMsidSemantic(header) {
        var self = this;

        var regexp = /a=msid\-semantic:\s*WMS (\S+)/ig;
        var arr = self._parseLine(header, regexp);

        arr && arr.length == 2 && (self.msidSemantic = {
            line: arr[0],
            WMS: arr[1]
        });

        return self.msidSemantic;
    },

    ssrcSection: function ssrcSection(ssrc, cname, msid, label) {
        var lines = ['a=ssrc:' + ssrc + ' cname:' + cname, 'a=ssrc:' + ssrc + ' msid:' + msid + ' ' + label, 'a=ssrc:' + ssrc + ' mslabel:' + msid, 'a=ssrc:' + ssrc + ' label:' + label, ''];

        return lines.join('\n');
    },

    parseSSRC: function parseSSRC(section) {
        var self = this;

        var regexp = new RegExp("a=(ssrc):(\\d+) (\\S+):(\\S+)", "ig");

        var arr = self._parseLine(section, regexp);
        if (arr) {
            var ssrc = {
                lines: [],
                updateSSRCSection: self.ssrcSection
            };

            for (var i = 0; i < arr.length; i++) {
                var e = arr[i];
                if (e.indexOf("a=ssrc") >= 0) {
                    ssrc.lines.push(e);
                } else {
                    switch (e) {
                        case 'ssrc':
                        case 'cname':
                        case 'msid':
                        case 'mslabel':
                        case 'label':
                            ssrc[e] = arr[++i];
                    }
                }
            }

            return ssrc;
        }
    },

    _parseLine: function _parseLine(str, regexp) {
        var arr = [];

        var _arr;
        while ((_arr = regexp.exec(str)) != null) {
            for (var i = 0; i < _arr.length; i++) {
                arr.push(_arr[i]);
            }
        }

        if (arr.length > 0) {
            return arr;
        }
    }
};

var SDPSection = function SDPSection(sdp, webrc) {
    _util.extend(this, _SDPSection);
    this._webrtc = webrc;
    this.spiltSection(sdp);
};

SDPSection.isAudioVideo = function (sdp) {
    var audioIndex = sdp.indexOf('m=audio');
    var videoIndex = sdp.indexOf('m=video');

    return audioIndex < videoIndex;
};

SDPSection.isVideoPreAudio = function (sdp) {
    var audioIndex = sdp.indexOf('m=audio');
    var videoIndex = sdp.indexOf('m=video');

    return audioIndex >= 0 && videoIndex >= 0 && videoIndex < audioIndex;
};

var __rtc_globalCount = emedia.__rtc_globalCount = 0;

/**
 * Abstract
 * {
 *   onIceStateChange:
 *   onIceCandidate:
 *   onGotRemoteStream:
 *
 *   createRtcPeerConnection:
 *   createOffer:
 *   createPRAnswer:
 *   createAnswer:
 *   addIceCandidate:
 *   close:
 *   iceState:
 *
 *   setLocalStream:
 *   getRtcId:
 * }
 *
 */
/**
 * ICE 通道失败：
 * 1.set sdp 失败
 * 2.set cands 失败
 * 但最终都是 ice fail
 *
 *
 * onSetSessionDescriptionError
 * onCreateSessionDescriptionError
 * onAddIceCandidateError
 *
 * onIceStateChange  ice fail
 *
 */
var _WebRTC = _util.prototypeExtend({
    closed: false,
    sdpConstraints: {
        'mandatory': {
            'OfferToReceiveAudio': true,
            'OfferToReceiveVideo': true
        }
    },

    /**
     * offerToReceiveAudio false sendonly, or sendrecv
     * offerToReceiveVideo false sendonly, or sendrecv
     *
     */
    offerOptions: {
        offerToReceiveAudio: true,
        offerToReceiveVideo: true
        //voiceActivityDetection: false
    },

    optimalVideoCodecs: null,
    optimalAudioCodecs: null,

    __init__: function __init__() {
        var self = this;

        self._rtcId || (self._rtcId = "RTC" + __rtc_globalCount++);
        self.__id = "_i_" + __rtc_globalCount++;

        self.__setRemoteSDP = false;
        self.__tmpRemoteCands = [];
        self.__tmpLocalCands = [];
        self._rtcPeerConnection = null;

        self.cctx = self.__id;

        emedia && emedia.config && emedia.config.forceUseVideoCodecs && emedia.config.forceUseVideoCodecs.length > 0 && (self.optimalVideoCodecs = emedia.config.forceUseVideoCodecs);
        emedia && emedia.config && emedia.config.forceUseAudioCodecs && emedia.config.forceUseAudioCodecs.length > 0 && (self.optimalAudioCodecs = emedia.config.forceUseAudioCodecs);
        emedia && emedia.config && typeof emedia.config.forceVideoBitrate === "number" && (self.vbitrate = emedia.config.forceVideoBitrate);
        emedia && emedia.config && typeof emedia.config.forceMinVideoBitrate === "number" && (self.vminBitrate = emedia.config.forceMinVideoBitrate);
        emedia && emedia.config && typeof emedia.config.forceAudioBitrate === "number" && (self.abitrate = emedia.config.forceAudioBitrate);

        _logger.info("Webrtc created. optimal video codecs:", self.optimalVideoCodecs, "audio codecs:", self.optimalAudioCodecs, "vbitrate:", self.vbitrate, "vminBitrate:", self.vminBitrate, "abitrate:", self.abitrate, self._rtcId, self.__id);
    },

    getRtcId: function getRtcId() {
        return this._rtcId;
    },

    iceState: function iceState() {
        var self = this;
        return self._rtcPeerConnection.iceConnectionState;
    },

    setSubArgs: function setSubArgs(subArgs) {
        var self = this;
        self.subArgs = subArgs;
    },

    getReceiversOfPeerConnection: function getReceiversOfPeerConnection() {
        var self = this;

        if (!self._rtcPeerConnection) {
            return;
        }

        if (self._rtcPeerConnection.iceConnectionState == 'closed') {
            return;
        }

        return self._rtcPeerConnection.getReceivers();
    },

    updateRemoteBySubArgs: function updateRemoteBySubArgs() {
        var self = this;

        if (!self.subArgs) {
            return;
        }
        if (!self._remoteStream) {
            return;
        }

        emedia.enableVideoTracks(self._remoteStream, !(self.subArgs && self.subArgs.subSVideo === false));
        emedia.enableAudioTracks(self._remoteStream, !(self.subArgs && self.subArgs.subSAudio === false));

        _logger.info("enable tracks remote stream", self._remoteStream, self.subArgs, self._rtcId, self.__id, self.closed);
    },

    createRtcPeerConnection: function createRtcPeerConnection(iceServerConfig) {
        var self = this;
        _logger.debug('begin create peer connection ......', self._rtcId, self.__id, self.closed);

        iceServerConfig || (iceServerConfig = self.iceServerConfig);

        if (iceServerConfig || emedia.isEdge) {
            //reduce icecandidate number:add default value
            iceServerConfig || (iceServerConfig = {});
            !iceServerConfig.iceServers && (iceServerConfig.iceServers = []);

            iceServerConfig.rtcpMuxPolicy = "require";
            iceServerConfig.bundlePolicy = "max-bundle";

            // iceServerConfig.iceTransportPolicy = 'relay';
            if (iceServerConfig.relayOnly) {
                iceServerConfig.iceTransportPolicy = 'relay';
            }
        } else {
            iceServerConfig = null;
        }

        // iceServerConfig = {
        //     capAudio: true,
        //     capVideo: true,
        //     iceServers:[{
        //         credential: "+F34cGoWeMmwa+XtvibM7dr4Ccc=",
        //         url: "turn:101.200.76.93:3478",
        //         username: "hx-demo#chatdemoui_yss000@hx.com/webim_device_uuid%179310420104847360:1506431735"
        //     }],
        //     recvAudio: true,
        //     recvVideo: true,
        //     relayOnly: false,
        // };

        if (emedia && emedia.config && typeof emedia.config.reconfigRTCConfiguration === 'function') {
            iceServerConfig = emedia.config.reconfigRTCConfiguration(iceServerConfig);
        }

        if (emedia.config.useDeployMore) {
            // 读取rtcconfig 替换trun url 如果开启了使用多集群
            if (!emedia.mgr.rtc_url_config) {
                // 1v1 第一次呼叫可能还没请求 config.json
                emedia.mgr.rtc_url_config = new DeployMore(emedia.config.rtcConfigUrl || '');
            }
            if (iceServerConfig && iceServerConfig.iceServers) {
                // 多人时 iceServerConfig 为 null
                iceServerConfig = emedia.mgr.rtc_url_config.replace_trun_url(iceServerConfig);
            }
        }

        _logger.info('create pc, set config:', iceServerConfig, self._rtcId, self.__id, self.closed);

        var rtcPeerConnection = self._rtcPeerConnection = new RTCPeerConnection(iceServerConfig);
        rtcPeerConnection.__peerId = self._rtcId;
        _logger.debug('created local peer connection object', rtcPeerConnection, self._rtcId);

        rtcPeerConnection.onicecandidate = function (event) {
            var candidate = event.candidate;

            //reduce icecandidate number: don't deal with tcp, udp only
            if (event.type == "icecandidate" && (!candidate || typeof candidate.protocol === 'string' && candidate.protocol.toLowerCase() === 'tcp' || / TCP /.test(candidate.candidate))) {
                _logger.debug("On ICE candidate: drop", candidate, self._rtcId, self.__id, self.closed);
                return;
            }

            if (!candidate.candidate) {
                _logger.error("Not found candidate. candidate is error");
                throw "Not found candidate. candidate is error,";
            }

            candidate.cctx = self.cctx;
            if (!self.__setRemoteSDP) {
                (self.__tmpLocalCands || (self.__tmpLocalCands = {})).push(candidate);
                _logger.debug('On ICE candidate ok: but tmp buffer caused by not set remote sdp: ', candidate, self._rtcId, self.__id, self.closed);
                return;
            } else {
                _logger.debug('On ICE candidate ok: ', candidate, self._rtcId, self.__id, self.closed);
            }
            self._onIceCandidate(candidate);
        };

        self.lastIceConnectionState = '';
        function stateChange(event) {
            _logger.info("states: connectionState", rtcPeerConnection.connectionState, ", iceConnectionState", rtcPeerConnection.iceConnectionState, "@", self._rtcId, self.__id, self.closed);
            try {
                //var theState = rtcPeerConnection.connectionState || rtcPeerConnection.iceConnectionState;
                var theState = rtcPeerConnection.iceConnectionState || rtcPeerConnection.connectionState;
                if ('failed' == rtcPeerConnection.connectionState || 'failed' == rtcPeerConnection.iceConnectionState || 'closed' == rtcPeerConnection.iceConnectionState || 'closed' == rtcPeerConnection.iceConnectionState // closed 安卓微信内核状态
                ) {
                        theState = "failed";
                        console.log('sqx state', theState);
                    }
                if (self.lastIceConnectionState !== theState) {
                    self.lastIceConnectionState = theState;
                    self.onIceStateChange(theState);
                }
            } finally {}
        }

        rtcPeerConnection.onconnectionstatechange = stateChange.bind(self);
        rtcPeerConnection.onicestatechange = stateChange.bind(self);
        rtcPeerConnection.oniceconnectionstatechange = stateChange.bind(self);
        rtcPeerConnection.onsignalingstatechange = function (event) {
            _logger.info("states: signaling", rtcPeerConnection.signalingState, "@", self._rtcId, self.__id, self.closed);
        };

        if (rtcPeerConnection.ontrack === null) {
            self._onTrack && (rtcPeerConnection.ontrack = function (event) {
                self._onTrack(event);
            });
        }

        rtcPeerConnection.onaddstream = function (event) {
            self._onGotRemoteStream(event);
        };
    },

    addTrack: function addTrack(tracks, stream) {
        var self = this;

        tracks.forEach(function (track) {
            self._rtcPeerConnection.addTrack(track, stream);
            _logger.debug('Added track(', track.id, track.kind, track.label, ') of stream(', stream.id, ') to RtcPeerConnection', self._rtcId, self.__id, self.closed);
        });
    },
    setLocalStream: function setLocalStream(localStream) {
        var self = this;

        self._localStream = localStream;

        if (self._rtcPeerConnection.addTrack) {
            localStream.getTracks().forEach(function (track) {
                self._rtcPeerConnection.addTrack(track, localStream);
                _logger.debug('Added track(', track.enabled, track.id, track.kind, track.label, ') of localStream(', localStream.id, ') to RtcPeerConnection', self._rtcId, self.__id, self.closed);
            });
        } else {
            self._rtcPeerConnection.addStream(localStream);

            var videoTracks = localStream.getVideoTracks();
            var audioTracks = localStream.getAudioTracks();

            if (videoTracks && videoTracks.length > 0) {
                _logger.debug('RtcPeerConnection video: ', videoTracks[0].enabled, videoTracks[0].id, videoTracks[0].kind, videoTracks[0].label, self._rtcId, self.__id, self.closed);
            }
            if (audioTracks && audioTracks.length > 0) {
                _logger.debug('RtcPeerConnection audio: ', audioTracks[0].enabled, audioTracks[0].id, audioTracks[0].kind, audioTracks[0].label, self._rtcId, self.__id, self.closed);
            }
        }
        _logger.debug('Added local stream to RtcPeerConnection', localStream.id, localStream.active, self._rtcId, self.__id, this.closed);
    },

    removeStream: function removeStream(mediaStream) {
        this._rtcPeerConnection.removeStream(mediaStream);
        _logger.debug('Remove stream from RtcPeerConnection', mediaStream, self._rtcId, self.__id, this.closed);
    },

    getLocalStream: function getLocalStream() {
        return this._localStream;
    },
    getRemoteStream: function getRemoteStream() {
        return this._remoteStream;
    },

    createOffer: function createOffer(onCreateOfferSuccess, onCreateOfferError) {
        //offerToReceiveAudio = false时，chrome没有video段；safari却这个块。需要将sendrecv改为sendonly
        //由于手机没有视频发布时，sdp中有video字段，而 web以offerToReceiveVideo = false去订阅时，导致订阅流中没有video块，会引发重协商。进而导致 始终无法看到对方视频
        //所以 订阅流时 无论offerToReceiveVideo = false，都生成offer sdp；其中都有video块。即 offerToReceiveVideo = true；但要将sdp修改为recvonly

        // if(self.subArgs){
        //     c_offerOptions = {
        //         offerToReceiveAudio: true,
        //         offerToReceiveVideo: true
        //     }
        // }

        _logger.info('start create offer... self.offerOption str', (0, _stringify2.default)(this.offerOptions));
        _logger.info('start create offer... self.offerOption', this.offerOptions);

        var self = this;

        var offerOptions_changeless = _util.extend({}, self.offerOptions); // 固定下来的 options， createoffer 异步后不固化，可能会变

        var offerOptions = self.subArgs ? { offerToReceiveAudio: true, offerToReceiveVideo: true } : JSON.parse((0, _stringify2.default)(self.offerOptions)); //  createoffer options

        return self._rtcPeerConnection.createOffer(offerOptions).then(function (desc) {

            _logger.info('original offer sdp', desc);

            self.offerDescription = desc;

            if (emedia.isEdge) {
                desc.sdp = desc.sdp.replace(/profile-level-id=[^;]+/, "profile-level-id=42e01f");
            }
            if (emedia.isFirefox) {
                //需要交换 cand answer
                self.fireFoxOfferVideoPreAudio = self.__offerVideoPreAudio = SDPSection.isVideoPreAudio(desc.sdp);
            } else {
                self.__offerVideoPreAudio = SDPSection.isVideoPreAudio(desc.sdp); // video在audio前时，xswitch的answer是 audio在前。set answer时需要 变换answer
            }

            desc.sdp = desc.sdp.replace(/m=video 0/g, "m=video 9");
            _logger.warn("setLocalDescription. modify offer. if 'm=video 0' -> 'm=video 9'; if H264, 'profile-level-id=42e01f'", self._rtcId, self.__id);

            if (self.optimalVideoCodecs && self.optimalVideoCodecs.length > 0 || //数组或字符串
            self.optimalAudioCodecs && self.optimalAudioCodecs.length > 0 //数组或字符串
            // || (self.offerOptions && (self.offerOptions.offerToReceiveVideo === false || self.offerOptions.offerToReceiveAudio === false))
            || offerOptions_changeless && (offerOptions_changeless.offerToReceiveVideo === false || offerOptions_changeless.offerToReceiveAudio === false)) {
                var sdpSection = new SDPSection(desc.sdp, self);
                self.optimalVideoCodecs && sdpSection.updateVCodes(self.optimalVideoCodecs);
                self.optimalAudioCodecs && sdpSection.updateACodes(self.optimalAudioCodecs);

                // self.offerOptions && self.offerOptions.offerToReceiveVideo === false
                //     && sdpSection.updateVideoSection(/a=sendrecv|a=recvonly/g, "a=sendonly");
                // self.offerOptions && self.offerOptions.offerToReceiveAudio === false
                //     && sdpSection.updateAudioSection(/a=sendrecv|a=recvonly/g, "a=sendonly");

                offerOptions && offerOptions_changeless.offerToReceiveVideo === false && sdpSection.updateVideoSection(/a=sendrecv|a=recvonly/g, "a=sendonly");
                offerOptions && offerOptions_changeless.offerToReceiveAudio === false && sdpSection.updateAudioSection(/a=sendrecv|a=recvonly/g, "a=sendonly");

                desc.sdp = sdpSection.getUpdatedSDP(); //保持顺序
            }

            _logger.debug('setLocalDescription start', self._rtcId, self.__id, self.closed, self.optimalVideoCodecs, self.optimalAudioCodecs);
            if (emedia.config.useDTX) {
                // 1. 先删除 带 CN/ 的行
                desc.sdp = desc.sdp.replace(/a=rtpmap:(.*)CN\/(.*)\r\n/g, '');
                // 2. 拿到 音频编码的 数字
                var num = desc.sdp.match(/a=rtpmap:(.*)\sopus/)[1];
                // 3. 在a=fmtp:${num} 结尾添加 ;usedtx=1
                desc.sdp = desc.sdp.replace(new RegExp('a=fmtp:' + num + '(.*)\\r\\n'), 'a=fmtp:' + num + '$1;usedtx=1\r\n');
            }
            self._rtcPeerConnection.setLocalDescription(desc).then(self._onSetLocalSessionDescriptionSuccess.bind(self), self._onSetSessionDescriptionError.bind(self, desc)).then(function () {
                desc.cctx = self.cctx;
                (onCreateOfferSuccess || self.onCreateOfferSuccess.bind(self))(desc);
            });
        }, onCreateOfferError || self._onCreateSessionDescriptionError.bind(self, offerOptions));
    },

    createPRAnswer: function createPRAnswer(onCreatePRAnswerSuccess, onCreatePRAnswerError) {
        var self = this;

        _logger.info(' createPRAnswer start', self.closed, self.sdpConstraints);
        // Since the 'remote' side has no media stream we need
        // to pass in the right constraints in order for it to
        // accept the incoming offer of audio and video.
        return self._rtcPeerConnection.createAnswer(self.sdpConstraints).then(function (desc) {
            _logger.debug('_____________PRAnswer ', desc.sdp, self._rtcId, self.__id, self.closed); //_logger.debug('from :\n' + desc.sdp);

            desc.type = "pranswer";
            desc.sdp = desc.sdp.replace(/a=recvonly/g, 'a=inactive');

            var sdpSection = new SDPSection(desc.sdp, self);
            self.optimalVideoCodecs && sdpSection.updateVCodes(self.optimalVideoCodecs);
            self.optimalAudioCodecs && sdpSection.updateACodes(self.optimalAudioCodecs);

            desc.sdp = sdpSection.getUpdatedSDP(); //保持顺序

            self.__prAnswerDescription = desc;

            _logger.debug('inactive PRAnswer ', desc.sdp, self._rtcId, self.__id, self.closed); //_logger.debug('from :\n' + desc.sdp);
            _logger.debug('setLocalDescription start', desc, self._rtcId, self.__id, self.closed);

            self._rtcPeerConnection.setLocalDescription(desc).then(self._onSetLocalSessionDescriptionSuccess.bind(self), self._onSetSessionDescriptionError.bind(self, desc)).then(function () {
                sdpSection.updateHeaderMsidSemantic("MS_0000");
                sdpSection.updateAudioSSRCSection(1000, "CHROME0000", "MS_0000", "LABEL_AUDIO_1000");
                sdpSection.updateVideoSSRCSection(2000, "CHROME0000", "MS_0000", "LABEL_VIDEO_2000");

                desc.sdp = sdpSection.getUpdatedSDP();

                _logger.debug('Send PRAnswer ', desc.sdp, self._rtcId, self.__id, self.closed); //_logger.debug('from :\n' + desc.sdp);

                self.cctx && (desc.cctx = self.cctx);
                (onCreatePRAnswerSuccess || self.onCreatePRAnswerSuccess.bind(self))(desc);
            });
        }, onCreatePRAnswerError || self._onCreateSessionDescriptionError.bind(self, self.sdpConstraints));
    },

    createAnswer: function createAnswer(onCreateAnswerSuccess, onCreateAnswerError) {
        var self = this;

        _logger.info('createAnswer start', self.closed, self.sdpConstraints);
        // Since the 'remote' side has no media stream we need
        // to pass in the right constraints in order for it to
        // accept the incoming offer of audio and video.
        return self._rtcPeerConnection.createAnswer(self.sdpConstraints).then(function (desc) {
            _logger.debug('_____________________Answer ', self._rtcId, self.__id, self.closed); //_logger.debug('from :\n' + desc.sdp);

            desc.type = 'answer';

            function updateSDP(sdpSection) {
                var ms = sdpSection.parseMsidSemantic(sdpSection.headerSection);
                if (!ms) {
                    return;
                }

                if (ms.WMS == '*') {
                    sdpSection.updateHeaderMsidSemantic(ms.WMS = "MS_0000");
                }
                var audioSSRC = sdpSection.parseSSRC(sdpSection.audioSection);
                var videoSSRC = sdpSection.parseSSRC(sdpSection.videoSection);

                audioSSRC && sdpSection.updateAudioSSRCSection(1000, "CHROME0000", ms.WMS, audioSSRC.label || "LABEL_AUDIO_1000");
                if (videoSSRC) {
                    sdpSection.updateVideoSSRCSection(2000, "CHROME0000", ms.WMS, videoSSRC.label || "LABEL_VIDEO_2000");
                }
                // mslabel cname

                desc.sdp = sdpSection.getUpdatedSDP();
            }

            var sdpSection = new SDPSection(desc.sdp, self);
            self.optimalVideoCodecs && sdpSection.updateVCodes(self.optimalVideoCodecs);
            self.optimalAudioCodecs && sdpSection.updateACodes(self.optimalAudioCodecs);

            if (emedia.supportPRAnswer) {
                updateSDP(sdpSection);
            } else {
                desc.sdp = sdpSection.getUpdatedSDP(); //保持顺序
            }

            self.__answerDescription = desc;

            _logger.debug('Answer ', self._rtcId, self.__id, self.closed); //_logger.debug('from :\n' + desc.sdp);
            _logger.debug('setLocalDescription start', desc, self._rtcId, self.__id, self.closed);

            self._rtcPeerConnection.setLocalDescription(desc).then(self._onSetLocalSessionDescriptionSuccess.bind(self), self._onSetSessionDescriptionError.bind(self, desc)).then(function () {
                if (emedia.supportPRAnswer) {
                    sdpSection.updateHeaderMsidSemantic("MS_0000");
                    sdpSection.updateAudioSSRCSection(1000, "CHROME0000", "MS_0000", "LABEL_AUDIO_1000");
                    sdpSection.updateVideoSSRCSection(2000, "CHROME0000", "MS_0000", "LABEL_VIDEO_2000");

                    desc.sdp = sdpSection.getUpdatedSDP();
                }

                _logger.debug('Send Answer ', self._rtcId, self.__id, self.closed); //_logger.debug('from :\n' + desc.sdp);

                self.cctx && (desc.cctx = self.cctx);
                (onCreateAnswerSuccess || self.onCreateAnswerSuccess.bind(self))(desc);
            });
        }, onCreateAnswerError || self._onCreateSessionDescriptionError.bind(self, self.sdpConstraints));
    },

    _printStats: function _printStats(mediaStream) {
        var self = this;
        if (!self.confrAttendee || !emedia.config.remainLastStatsCount) {
            return;
        }

        mediaStream && mediaStream.getTracks().forEach(function (track) {
            self._printTrackStats(track);
        });
    },

    _printTrackStats: function _printTrackStats(track) {
        var self = this;
        if (!self.confrAttendee || !emedia.config.remainLastStatsCount) {
            return;
        }

        var trackStats = self.confrAttendee._trackStats && self.confrAttendee._trackStats[track.id];
        if (!trackStats) {
            return;
        }

        for (var type in trackStats) {
            var typeStats = trackStats[type];

            for (var subType in typeStats) {
                var stats = typeStats[subType];

                if (!stats) {
                    continue;
                }

                var index = stats.curIndex;
                for (var i = 0; i < emedia.config.remainLastStatsCount; i++) {
                    index = (index - 1) % emedia.config.remainLastStatsCount;
                    var stat = stats[index];
                    if (!stat || stat.data === undefined) {
                        break;
                    }
                    _logger.info("[track]", self._rtcId, self.__id, track.kind, track.id, type, subType, stat.data, stat.timestamp.toLocaleString());
                }
            }
        }

        _util.removeAttribute(self.confrAttendee._trackStats, track.id);
    },

    close: function close(remainLocalStream, onlyPeerConnectionClosed, retryBuild) {
        var self = this;
        _logger.warn("webrtc closing", self._rtcId, self.__id, self.closed);

        self.__iceWaitIntervalId && clearTimeout(self.__iceWaitIntervalId);

        if (self.closed) {
            return;
        }

        onlyPeerConnectionClosed = onlyPeerConnectionClosed === true;

        self.closed = true;

        try {
            var closePC = function closePC() {
                self._rtcPeerConnection && self._rtcPeerConnection.close();
                _logger.info("peer connection close. it is", self._rtcPeerConnection && self._rtcPeerConnection.__peerId);

                if (!retryBuild && emedia.isSafari) {
                    //safari close peer connection, not notify state closed
                    var theState = self._rtcPeerConnection.iceConnectionState || self._rtcPeerConnection.connectionState;
                    setTimeout(function () {
                        var nowState = self._rtcPeerConnection.iceConnectionState || self._rtcPeerConnection.connectionState;
                        // if(nowState !== 'closed' && theState !== 'closed'){
                        //     self.onIceStateChange && self.onIceStateChange('closed');
                        // }
                        self.onIceStateChange && self.onIceStateChange('closed');
                    }, 200);
                }
            };

            //self._rtcPeerConnection && self._rtcPeerConnection.close();
            var localStream = self._localStream;
            var remoteStream = self._remoteStream;

            if (emedia.config.printStatsWhenPCClose) {
                self.getStats(function () {
                    closePC();

                    localStream && self._printStats(localStream);
                    remoteStream && self._printStats(remoteStream);
                });
            } else {
                closePC();
            }
        } catch (e) {
            _logger.warn(e);
        } finally {
            if (self._localStream && remainLocalStream === false) {
                //localstream存在，不保留localstream
                emedia.stopTracks(self._localStream);
            }

            if (self._remoteStream) {
                emedia.stopTracks(self._remoteStream);
            }
            self._remoteStream = null;

            if (!onlyPeerConnectionClosed) {
                self.onClose && self.onClose();
            }

            if (retryBuild === true) {
                _logger.info("Webrtc close. but retry build. will onIceStateChange(failed). eg. emedia.config iceWaitBuildMillis", self._rtcId, self.__id);
                self.onIceStateChange && self.onIceStateChange('failed');
            }

            _logger.warn("webrtc closed. closed:", self._rtcId, self.__id, self.closed);
        }
    },

    addIceCandidate: function addIceCandidate(candidate) {
        console.log('addIceCandidate candidate', (0, _stringify2.default)(candidate));

        var self = this;

        var _cands = _util.isArray(candidate) ? candidate : [candidate];

        if (emedia.mgr.rtc_url_config) {
            // 读取rtcconfig 替换cands 如果开启了使用多集群
            _cands = emedia.mgr.rtc_url_config.replace_candidates(_cands);
        }

        if (emedia && emedia.config && typeof emedia.config.reChanageCandidate === "function") {
            var candsChanaged = [];
            for (var i = 0; i < _cands.length; i++) {
                candidate = _cands[i];

                var newCandidates = emedia.config.reChanageCandidate(candidate);
                if (newCandidates) {
                    _logger.info("Candidate rechanage. addons. it =", candidate, "->", newCandidates);

                    if (_util.isArray(newCandidates)) {
                        Array.prototype.push.apply(candsChanaged, newCandidates);
                    } else {
                        candsChanaged.push(newCandidates);
                    }
                }
            }
            _cands = candsChanaged;
        }

        self._addIceCandidate(_cands);
    },

    _addIceCandidate: function _addIceCandidate(candidate) {
        var self = this;

        if (!self._rtcPeerConnection) {
            return;
        }

        _logger.debug('Add ICE candidate: ', candidate, self._rtcId, self.__id, self.closed);

        var _cands = _util.isArray(candidate) ? candidate : [candidate];
        //!_util.isArray(candidate) && _cands.push(candidate);

        if (!self.__setRemoteSDP) {
            Array.prototype.push.apply(self.__tmpRemoteCands || (self.__tmpRemoteCands = {}), _cands);

            _logger.debug('Add ICE candidate but tmp buffer caused by not set remote sdp: ', candidate, self._rtcId, self.__id, self.closed);
            return;
        }

        for (var i = 0; i < _cands.length; i++) {
            candidate = _cands[i];

            if (candidate.cctx && candidate.cctx != self.cctx) {
                _logger.warn('addIceCandidate fail drop. cctx not equal. ', candidate, self._rtcId, self.__id, self.closed);
                continue;
            }

            //candidate.candidate = candidate.candidate.replace("172.17.2.130", "10.121.63.1");
            if (self.fireFoxOfferVideoPreAudio === true) {
                //candidate.sdpMid = "sdparta_0";
                var oldLineIndex = candidate.sdpMLineIndex;
                candidate.sdpMLineIndex = parseInt(candidate.sdpMid.replace(/[^0-9]*/, ''));
                _logger.warn("Firefox sdp section video pre audio, sdp mline index update ", oldLineIndex, "->", candidate.sdpMLineIndex);
            }

            if (candidate.candidate && candidate.candidate !== "") {
                self._rtcPeerConnection.addIceCandidate(new RTCIceCandidate(candidate)).then(self.onAddIceCandidateSuccess.bind(self), self._onAddIceCandidateError.bind(self, candidate));
            } else {
                _logger.warn("Add ICE candidate fail. drop it ", candidate, self._rtcId, self.__id, self.closed);
            }
        }
    },

    setRemoteDescription: function setRemoteDescription(desc) {
        var self = this;
        //setTimeout(self._setRemoteDescription.bind(this, desc), 1000);
        return self._setRemoteDescription(desc);
    },

    _setRemoteDescription: function _setRemoteDescription(desc) {
        var self = this;

        if (self.__iceWaitIntervalId) {
            clearTimeout(self.__iceWaitIntervalId);
            self.__iceWaitIntervalId = null;
            _logger.info("emedia.config iceWaitBuildMillis, clear ice wait interval id", self._rtcId, self.__id);
        }

        _logger.debug('setRemoteDescription start. ', self._rtcId, self.__id, self.closed);

        // 生成offer的
        // 会议模式，也是设置的是 pranswer 和 answer 会有服务器传回。
        // p2p模式下的主叫。此时设置的是 pranswer 和 answer。这个应该有p2p模式下传回。因此，需要如果有的话，需要判断
        if (self.offerDescription) {
            if (desc.cctx && desc.cctx != self.cctx) {
                _logger.warn('setRemoteDescription fail drop. cctx not equal. ', desc, self._rtcId, self.__id, self.closed);
                return;
            }

            if (self.fireFoxOfferVideoPreAudio === true || self.__offerVideoPreAudio === true) {
                //_logger.debug("Remote sdp.1", desc.sdp);

                var sdpSection = new SDPSection(desc.sdp, self);
                desc.sdp = sdpSection.getUpdatedSDP(false);
                _logger.info("Remote sdp.2. switch audio video", desc.sdp);
            }
        } else {
            //被叫 p2p模式，覆盖
            desc.cctx && (self.cctx = desc.cctx);
        }

        desc.sdp = desc.sdp.replace(/UDP\/TLS\/RTP\/SAVPF/g, "RTP/SAVPF");
        _logger.warn('setRemoteDescription. UDP/TLS/RTP/SAVPF -> RTP/SAVPF; if firefox: switch audio video;', self._rtcId, self.__id);
        //_logger.debug('setRemoteDescription.', desc, self._rtcId, self.__id);

        // https://webrtchacks.com/limit-webrtc-bandwidth-sdp/
        // bitrate
        if (self.vbitrate || self.abitrate || self.vminBitrate) {
            var sdpSection = new SDPSection(desc.sdp, self);

            self.vbitrate && sdpSection.setVideoBitrate(self.vbitrate);
            self.vminBitrate && sdpSection.setVideoMinBitrate(self.vminBitrate);
            self.abitrate && sdpSection.setAudioBitrate(self.abitrate);

            _logger.warn("vbitrate = ", self.vbitrate, "vminBitrate = ", this.vminBitrate, ", abitrate = ", self.abitrate, self._rtcId, self.__id);
            desc.sdp = sdpSection.getUpdatedSDP(typeof self.__offerVideoPreAudio === 'undefined' || self.__offerVideoPreAudio === null ? undefined : !self.__offerVideoPreAudio);
        }

        _logger.debug("final remote sdp =", desc.sdp, self._rtcId, self.__id);

        desc = self.__remoteDescription = new RTCSessionDescription(desc);

        return self._rtcPeerConnection.setRemoteDescription(desc).then(function () {
            self.__setRemoteSDP = true;
            self._onSetRemoteSuccess.apply(self, arguments);

            if (self.__tmpLocalCands && self.__tmpLocalCands.length > 0) {
                _logger.debug('After setRemoteDescription. send cands', self._rtcId, self.__id, self.closed);
                self._onIceCandidate(self.__tmpLocalCands);

                self.__tmpLocalCands = [];
            }

            if (self.__tmpRemoteCands && self.__tmpRemoteCands.length > 0) {
                _logger.debug('After setRemoteDescription. add tmp cands', self._rtcId, self.__id, self.closed);
                self._addIceCandidate(self.__tmpRemoteCands);

                self.__tmpRemoteCands = [];
            }
        }, self._onSetSessionDescriptionError.bind(self, desc));
    },

    iceConnectionState: function iceConnectionState() {
        var self = this;

        return self._rtcPeerConnection.iceConnectionState;
    },

    isConnected: function isConnected() {
        var self = this;

        var state = self.lastIceConnectionState;

        return "connected" === state || "completed" === state;
    },

    _onGotRemoteStream: function _onGotRemoteStream(event) {
        var self = this;

        self._remoteStream = event.stream || event.streams[0];
        self._remoteStream._rtcId = self._rtcId;
        self._remoteStream.__rtc_c_id = self.__id;
        _logger.debug('On got remote stream', self._remoteStream ? self._remoteStream.id + "_" + self._remoteStream.active : "null", self._rtcId, self.__id);

        self._remoteStream && self._remoteStream.getTracks().forEach(function (track) {
            // if(typeof track.getSettings === 'function'){
            //     _logger.debug('remote stream', self._remoteStream.id,
            //         " track setting =", track.enabled, track.id, track.kind, track.label, track.getSettings(), self._rtcId, self.__id);
            // }else{
            _logger.debug('remote stream', self._remoteStream.id, " track =", track.enabled, track.id, track.kind, track.label, self._rtcId, self.__id);
            // }
        });

        self.updateRemoteBySubArgs();

        this.onGotRemoteStream(this._remoteStream, event);

        _logger.debug('received remote stream, you will see the other.', self._rtcId, self.__id, this.closed);
    },

    _onSetRemoteSuccess: function _onSetRemoteSuccess() {
        _logger.info('onSetRemoteSuccess success', this._rtcId, this.__id);
        this.onSetRemoteSuccess.apply(this, arguments);

        if (this.offerDescription && this.__remoteDescription && this.__remoteDescription.sdp) {
            this._onAnswerCodes(this.__remoteDescription.sdp);
        }
    },

    _onAnswerCodes: function _onAnswerCodes(sdp) {
        var self = this;
        var section = new SDPSection(sdp, this);
        if (section.videoSection) {
            var rtpParams = SDPUtils.parseRtpParameters(section.videoSection);

            if (!rtpParams.codecs || rtpParams.codecs.length === 0) {
                _logger.info("not found any video codes. @ ", self._rtcId, self.__id);
                return;
            }

            var vcodes = [];
            var flag = {};
            _util.forEach(rtpParams.codecs, function (_i, _param) {
                if (flag[_param.name] !== true) {
                    flag[_param.name] = true;
                    vcodes.push(_param.name);
                }
            });

            self.finalVCodeChoices = vcodes;

            self.onVCodeChoices && self.onVCodeChoices(vcodes);
        }
    },

    onSetRemoteSuccess: function onSetRemoteSuccess() {},

    onAddIceCandidateSuccess: function onAddIceCandidateSuccess() {
        _logger.debug('addIceCandidate success', this._rtcId, this.__id);
    },

    _onAddIceCandidateError: function _onAddIceCandidateError(candidate, error) {
        _logger.error('failed to add ICE Candidate: ' + error.toString(), ", error candidate:", candidate, this._rtcId, this.__id);
        this.onAddIceCandidateError(error);
    },
    onAddIceCandidateError: function onAddIceCandidateError(error) {},

    _onIceCandidate: function _onIceCandidate(candidate) {
        _logger.debug('onIceCandidate:', candidate, this._rtcId, this.__id);
        this.onIceCandidate(candidate);
    },
    onIceCandidate: function onIceCandidate(candidate) {},

    onIceStateChange: function onIceStateChange(state) {
        _logger.debug('onIceStateChange : ICE state ', state);
    },

    _onCreateSessionDescriptionError: function _onCreateSessionDescriptionError(offerOptionsOrSDPConstraints, error) {
        _logger.error('Failed to create session description: ' + error.toString(), " offerOptionsOrSDPConstraints:", offerOptionsOrSDPConstraints, this._rtcId, this.__id);
        this.onCreateSessionDescriptionError(error);
    },
    onCreateSessionDescriptionError: function onCreateSessionDescriptionError(error) {},

    onCreateOfferSuccess: function onCreateOfferSuccess(desc) {
        _logger.debug('create offer success', this._rtcId, this.__id);
    },

    onCreatePRAnswerSuccess: function onCreatePRAnswerSuccess(desc) {
        _logger.debug('create answer success', this._rtcId, this.__id);
    },

    onCreateAnswerSuccess: function onCreateAnswerSuccess(desc) {
        _logger.debug('create answer success', this._rtcId, this.__id);
    },

    _onSetSessionDescriptionError: function _onSetSessionDescriptionError(sdp, error) {
        _logger.error('onSetSessionDescriptionError : Failed to set session description: ', error.toString(), this._rtcId, this.__id);
        sdp && sdp.type && sdp.sdp && _logger.error('error sdp: type=', sdp.type, "sdp=", sdp.sdp, this._rtcId, this.__id);
        this.onSetSessionDescriptionError(error);
    },
    onSetSessionDescriptionError: function onSetSessionDescriptionError(error) {},
    _onSetLocalSessionDescriptionSuccess: function _onSetLocalSessionDescriptionSuccess() {
        var self = this;
        _logger.debug('onSetLocalSessionDescriptionSuccess : setLocalDescription complete', this._rtcId, this.__id);

        if (emedia.config.iceWaitBuildMillis) {
            this.__iceWaitIntervalId && clearTimeout(this.__iceWaitIntervalId);
            this.__iceWaitIntervalId = setTimeout(function () {
                _logger.info("emedia.config iceWaitBuildMillis, timeout, will close webrtc, will retry build by onIceStateChange(failed)", self._rtcId, self.__id);
                //self.close(true, true, true);
                self.onIceStateChange && self.onIceStateChange('failed');
            }, emedia.config.iceWaitBuildMillis);
            _logger.info("emedia.config iceWaitBuildMillis, start timeout", self._rtcId, self.__id);
        }

        this.onSetLocalSessionDescriptionSuccess();

        if (this.__answerDescription && this.__answerDescription.sdp) {
            this._onAnswerCodes(this.__answerDescription.sdp);
        }
    },
    onSetLocalSessionDescriptionSuccess: function onSetLocalSessionDescriptionSuccess() {},

    onGotRemoteStream: function onGotRemoteStream(remoteStream) {
        _logger.debug("Got remote stream. ", remoteStream, this._rtcId, this.__id);
    },

    getStats: function getStats(onCallback) {
        var self = this;

        if (!self._rtcPeerConnection) {
            _logger.warn("Get stats, but peer connection not exsits, ", this._rtcId, this.__id);
            onCallback && onCallback();
            return;
        }

        if (typeof emedia.config.rtcStatsTypeMath !== 'function') {
            _logger.warn("Get stats, but config rtcStatsTypeMather, ", this._rtcId, this.__id);
            onCallback && onCallback();
            return;
        }

        self._rtcPeerConnection.getStats(null).then(function (stats) {
            stats.forEach(function (_stat, name) {
                if (emedia.config.rtcStatsTypeMath(_stat, name)) {
                    _logger.info("Rtc stats", _stat, self._rtcId, self.__id);
                }
            });
            onCallback && onCallback(stats);
        });
    }
});

module.exports = _WebRTC;

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint-env node */


// SDP helpers.
var SDPUtils = {};

// Generate an alphanumeric identifier for cname or mids.
// TODO: use UUIDs instead? https://gist.github.com/jed/982883
SDPUtils.generateIdentifier = function() {
  return Math.random().toString(36).substr(2, 10);
};

// The RTCP CNAME used by all peerconnections from the same JS.
SDPUtils.localCName = SDPUtils.generateIdentifier();

// Splits SDP into lines, dealing with both CRLF and LF.
SDPUtils.splitLines = function(blob) {
  return blob.trim().split('\n').map(function(line) {
    return line.trim();
  });
};
// Splits SDP into sessionpart and mediasections. Ensures CRLF.
SDPUtils.splitSections = function(blob) {
  var parts = blob.split('\nm=');
  return parts.map(function(part, index) {
    return (index > 0 ? 'm=' + part : part).trim() + '\r\n';
  });
};

// returns the session description.
SDPUtils.getDescription = function(blob) {
  var sections = SDPUtils.splitSections(blob);
  return sections && sections[0];
};

// returns the individual media sections.
SDPUtils.getMediaSections = function(blob) {
  var sections = SDPUtils.splitSections(blob);
  sections.shift();
  return sections;
};

// Returns lines that start with a certain prefix.
SDPUtils.matchPrefix = function(blob, prefix) {
  return SDPUtils.splitLines(blob).filter(function(line) {
    return line.indexOf(prefix) === 0;
  });
};

// Parses an ICE candidate line. Sample input:
// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
// rport 55996"
SDPUtils.parseCandidate = function(line) {
  var parts;
  // Parse both variants.
  if (line.indexOf('a=candidate:') === 0) {
    parts = line.substring(12).split(' ');
  } else {
    parts = line.substring(10).split(' ');
  }

  var candidate = {
    foundation: parts[0],
    component: parseInt(parts[1], 10),
    protocol: parts[2].toLowerCase(),
    priority: parseInt(parts[3], 10),
    ip: parts[4],
    address: parts[4], // address is an alias for ip.
    port: parseInt(parts[5], 10),
    // skip parts[6] == 'typ'
    type: parts[7]
  };

  for (var i = 8; i < parts.length; i += 2) {
    switch (parts[i]) {
      case 'raddr':
        candidate.relatedAddress = parts[i + 1];
        break;
      case 'rport':
        candidate.relatedPort = parseInt(parts[i + 1], 10);
        break;
      case 'tcptype':
        candidate.tcpType = parts[i + 1];
        break;
      case 'ufrag':
        candidate.ufrag = parts[i + 1]; // for backward compability.
        candidate.usernameFragment = parts[i + 1];
        break;
      default: // extension handling, in particular ufrag
        candidate[parts[i]] = parts[i + 1];
        break;
    }
  }
  return candidate;
};

// Translates a candidate object into SDP candidate attribute.
SDPUtils.writeCandidate = function(candidate) {
  var sdp = [];
  sdp.push(candidate.foundation);
  sdp.push(candidate.component);
  sdp.push(candidate.protocol.toUpperCase());
  sdp.push(candidate.priority);
  sdp.push(candidate.address || candidate.ip);
  sdp.push(candidate.port);

  var type = candidate.type;
  sdp.push('typ');
  sdp.push(type);
  if (type !== 'host' && candidate.relatedAddress &&
      candidate.relatedPort) {
    sdp.push('raddr');
    sdp.push(candidate.relatedAddress);
    sdp.push('rport');
    sdp.push(candidate.relatedPort);
  }
  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
    sdp.push('tcptype');
    sdp.push(candidate.tcpType);
  }
  if (candidate.usernameFragment || candidate.ufrag) {
    sdp.push('ufrag');
    sdp.push(candidate.usernameFragment || candidate.ufrag);
  }
  return 'candidate:' + sdp.join(' ');
};

// Parses an ice-options line, returns an array of option tags.
// a=ice-options:foo bar
SDPUtils.parseIceOptions = function(line) {
  return line.substr(14).split(' ');
};

// Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:
// a=rtpmap:111 opus/48000/2
SDPUtils.parseRtpMap = function(line) {
  var parts = line.substr(9).split(' ');
  var parsed = {
    payloadType: parseInt(parts.shift(), 10) // was: id
  };

  parts = parts[0].split('/');

  parsed.name = parts[0];
  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
  parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
  // legacy alias, got renamed back to channels in ORTC.
  parsed.numChannels = parsed.channels;
  return parsed;
};

// Generate an a=rtpmap line from RTCRtpCodecCapability or
// RTCRtpCodecParameters.
SDPUtils.writeRtpMap = function(codec) {
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  var channels = codec.channels || codec.numChannels || 1;
  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +
      (channels !== 1 ? '/' + channels : '') + '\r\n';
};

// Parses an a=extmap line (headerextension from RFC 5285). Sample input:
// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset
SDPUtils.parseExtmap = function(line) {
  var parts = line.substr(9).split(' ');
  return {
    id: parseInt(parts[0], 10),
    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
    uri: parts[1]
  };
};

// Generates a=extmap line from RTCRtpHeaderExtensionParameters or
// RTCRtpHeaderExtension.
SDPUtils.writeExtmap = function(headerExtension) {
  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +
      (headerExtension.direction && headerExtension.direction !== 'sendrecv'
        ? '/' + headerExtension.direction
        : '') +
      ' ' + headerExtension.uri + '\r\n';
};

// Parses an ftmp line, returns dictionary. Sample input:
// a=fmtp:96 vbr=on;cng=on
// Also deals with vbr=on; cng=on
SDPUtils.parseFmtp = function(line) {
  var parsed = {};
  var kv;
  var parts = line.substr(line.indexOf(' ') + 1).split(';');
  for (var j = 0; j < parts.length; j++) {
    kv = parts[j].trim().split('=');
    parsed[kv[0].trim()] = kv[1];
  }
  return parsed;
};

// Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeFmtp = function(codec) {
  var line = '';
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.parameters && Object.keys(codec.parameters).length) {
    var params = [];
    Object.keys(codec.parameters).forEach(function(param) {
      if (codec.parameters[param]) {
        params.push(param + '=' + codec.parameters[param]);
      } else {
        params.push(param);
      }
    });
    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
  }
  return line;
};

// Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
// a=rtcp-fb:98 nack rpsi
SDPUtils.parseRtcpFb = function(line) {
  var parts = line.substr(line.indexOf(' ') + 1).split(' ');
  return {
    type: parts.shift(),
    parameter: parts.join(' ')
  };
};
// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeRtcpFb = function(codec) {
  var lines = '';
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
    // FIXME: special handling for trr-int?
    codec.rtcpFeedback.forEach(function(fb) {
      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +
      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +
          '\r\n';
    });
  }
  return lines;
};

// Parses an RFC 5576 ssrc media attribute. Sample input:
// a=ssrc:3735928559 cname:something
SDPUtils.parseSsrcMedia = function(line) {
  var sp = line.indexOf(' ');
  var parts = {
    ssrc: parseInt(line.substr(7, sp - 7), 10)
  };
  var colon = line.indexOf(':', sp);
  if (colon > -1) {
    parts.attribute = line.substr(sp + 1, colon - sp - 1);
    parts.value = line.substr(colon + 1);
  } else {
    parts.attribute = line.substr(sp + 1);
  }
  return parts;
};

SDPUtils.parseSsrcGroup = function(line) {
  var parts = line.substr(13).split(' ');
  return {
    semantics: parts.shift(),
    ssrcs: parts.map(function(ssrc) {
      return parseInt(ssrc, 10);
    })
  };
};

// Extracts the MID (RFC 5888) from a media section.
// returns the MID or undefined if no mid line was found.
SDPUtils.getMid = function(mediaSection) {
  var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];
  if (mid) {
    return mid.substr(6);
  }
};

SDPUtils.parseFingerprint = function(line) {
  var parts = line.substr(14).split(' ');
  return {
    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.
    value: parts[1]
  };
};

// Extracts DTLS parameters from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the fingerprint line as input. See also getIceParameters.
SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {
  var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
    'a=fingerprint:');
  // Note: a=setup line is ignored since we use the 'auto' role.
  // Note2: 'algorithm' is not case sensitive except in Edge.
  return {
    role: 'auto',
    fingerprints: lines.map(SDPUtils.parseFingerprint)
  };
};

// Serializes DTLS parameters to SDP.
SDPUtils.writeDtlsParameters = function(params, setupType) {
  var sdp = 'a=setup:' + setupType + '\r\n';
  params.fingerprints.forEach(function(fp) {
    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
  });
  return sdp;
};
// Parses ICE information from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the ice-ufrag and ice-pwd lines as input.
SDPUtils.getIceParameters = function(mediaSection, sessionpart) {
  var lines = SDPUtils.splitLines(mediaSection);
  // Search in session part, too.
  lines = lines.concat(SDPUtils.splitLines(sessionpart));
  var iceParameters = {
    usernameFragment: lines.filter(function(line) {
      return line.indexOf('a=ice-ufrag:') === 0;
    })[0].substr(12),
    password: lines.filter(function(line) {
      return line.indexOf('a=ice-pwd:') === 0;
    })[0].substr(10)
  };
  return iceParameters;
};

// Serializes ICE parameters to SDP.
SDPUtils.writeIceParameters = function(params) {
  return 'a=ice-ufrag:' + params.usernameFragment + '\r\n' +
      'a=ice-pwd:' + params.password + '\r\n';
};

// Parses the SDP media section and returns RTCRtpParameters.
SDPUtils.parseRtpParameters = function(mediaSection) {
  var description = {
    codecs: [],
    headerExtensions: [],
    fecMechanisms: [],
    rtcp: []
  };
  var lines = SDPUtils.splitLines(mediaSection);
  var mline = lines[0].split(' ');
  for (var i = 3; i < mline.length; i++) { // find all codecs from mline[3..]
    var pt = mline[i];
    var rtpmapline = SDPUtils.matchPrefix(
      mediaSection, 'a=rtpmap:' + pt + ' ')[0];
    if (rtpmapline) {
      var codec = SDPUtils.parseRtpMap(rtpmapline);
      var fmtps = SDPUtils.matchPrefix(
        mediaSection, 'a=fmtp:' + pt + ' ');
      // Only the first a=fmtp:<pt> is considered.
      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
      codec.rtcpFeedback = SDPUtils.matchPrefix(
        mediaSection, 'a=rtcp-fb:' + pt + ' ')
        .map(SDPUtils.parseRtcpFb);
      description.codecs.push(codec);
      // parse FEC mechanisms from rtpmap lines.
      switch (codec.name.toUpperCase()) {
        case 'RED':
        case 'ULPFEC':
          description.fecMechanisms.push(codec.name.toUpperCase());
          break;
        default: // only RED and ULPFEC are recognized as FEC mechanisms.
          break;
      }
    }
  }
  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function(line) {
    description.headerExtensions.push(SDPUtils.parseExtmap(line));
  });
  // FIXME: parse rtcp.
  return description;
};

// Generates parts of the SDP media section describing the capabilities /
// parameters.
SDPUtils.writeRtpDescription = function(kind, caps) {
  var sdp = '';

  // Build the mline.
  sdp += 'm=' + kind + ' ';
  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.
  sdp += ' UDP/TLS/RTP/SAVPF ';
  sdp += caps.codecs.map(function(codec) {
    if (codec.preferredPayloadType !== undefined) {
      return codec.preferredPayloadType;
    }
    return codec.payloadType;
  }).join(' ') + '\r\n';

  sdp += 'c=IN IP4 0.0.0.0\r\n';
  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';

  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
  caps.codecs.forEach(function(codec) {
    sdp += SDPUtils.writeRtpMap(codec);
    sdp += SDPUtils.writeFmtp(codec);
    sdp += SDPUtils.writeRtcpFb(codec);
  });
  var maxptime = 0;
  caps.codecs.forEach(function(codec) {
    if (codec.maxptime > maxptime) {
      maxptime = codec.maxptime;
    }
  });
  if (maxptime > 0) {
    sdp += 'a=maxptime:' + maxptime + '\r\n';
  }
  sdp += 'a=rtcp-mux\r\n';

  if (caps.headerExtensions) {
    caps.headerExtensions.forEach(function(extension) {
      sdp += SDPUtils.writeExtmap(extension);
    });
  }
  // FIXME: write fecMechanisms.
  return sdp;
};

// Parses the SDP media section and returns an array of
// RTCRtpEncodingParameters.
SDPUtils.parseRtpEncodingParameters = function(mediaSection) {
  var encodingParameters = [];
  var description = SDPUtils.parseRtpParameters(mediaSection);
  var hasRed = description.fecMechanisms.indexOf('RED') !== -1;
  var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;

  // filter a=ssrc:... cname:, ignore PlanB-msid
  var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
    .map(function(line) {
      return SDPUtils.parseSsrcMedia(line);
    })
    .filter(function(parts) {
      return parts.attribute === 'cname';
    });
  var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
  var secondarySsrc;

  var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')
    .map(function(line) {
      var parts = line.substr(17).split(' ');
      return parts.map(function(part) {
        return parseInt(part, 10);
      });
    });
  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
    secondarySsrc = flows[0][1];
  }

  description.codecs.forEach(function(codec) {
    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
      var encParam = {
        ssrc: primarySsrc,
        codecPayloadType: parseInt(codec.parameters.apt, 10)
      };
      if (primarySsrc && secondarySsrc) {
        encParam.rtx = {ssrc: secondarySsrc};
      }
      encodingParameters.push(encParam);
      if (hasRed) {
        encParam = JSON.parse(JSON.stringify(encParam));
        encParam.fec = {
          ssrc: primarySsrc,
          mechanism: hasUlpfec ? 'red+ulpfec' : 'red'
        };
        encodingParameters.push(encParam);
      }
    }
  });
  if (encodingParameters.length === 0 && primarySsrc) {
    encodingParameters.push({
      ssrc: primarySsrc
    });
  }

  // we support both b=AS and b=TIAS but interpret AS as TIAS.
  var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');
  if (bandwidth.length) {
    if (bandwidth[0].indexOf('b=TIAS:') === 0) {
      bandwidth = parseInt(bandwidth[0].substr(7), 10);
    } else if (bandwidth[0].indexOf('b=AS:') === 0) {
      // use formula from JSEP to convert b=AS to TIAS value.
      bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95
          - (50 * 40 * 8);
    } else {
      bandwidth = undefined;
    }
    encodingParameters.forEach(function(params) {
      params.maxBitrate = bandwidth;
    });
  }
  return encodingParameters;
};

// parses http://draft.ortc.org/#rtcrtcpparameters*
SDPUtils.parseRtcpParameters = function(mediaSection) {
  var rtcpParameters = {};

  // Gets the first SSRC. Note tha with RTX there might be multiple
  // SSRCs.
  var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
    .map(function(line) {
      return SDPUtils.parseSsrcMedia(line);
    })
    .filter(function(obj) {
      return obj.attribute === 'cname';
    })[0];
  if (remoteSsrc) {
    rtcpParameters.cname = remoteSsrc.value;
    rtcpParameters.ssrc = remoteSsrc.ssrc;
  }

  // Edge uses the compound attribute instead of reducedSize
  // compound is !reducedSize
  var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
  rtcpParameters.reducedSize = rsize.length > 0;
  rtcpParameters.compound = rsize.length === 0;

  // parses the rtcp-mux attrіbute.
  // Note that Edge does not support unmuxed RTCP.
  var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
  rtcpParameters.mux = mux.length > 0;

  return rtcpParameters;
};

// parses either a=msid: or a=ssrc:... msid lines and returns
// the id of the MediaStream and MediaStreamTrack.
SDPUtils.parseMsid = function(mediaSection) {
  var parts;
  var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');
  if (spec.length === 1) {
    parts = spec[0].substr(7).split(' ');
    return {stream: parts[0], track: parts[1]};
  }
  var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
    .map(function(line) {
      return SDPUtils.parseSsrcMedia(line);
    })
    .filter(function(msidParts) {
      return msidParts.attribute === 'msid';
    });
  if (planB.length > 0) {
    parts = planB[0].value.split(' ');
    return {stream: parts[0], track: parts[1]};
  }
};

// SCTP
// parses draft-ietf-mmusic-sctp-sdp-26 first and falls back
// to draft-ietf-mmusic-sctp-sdp-05
SDPUtils.parseSctpDescription = function(mediaSection) {
  var mline = SDPUtils.parseMLine(mediaSection);
  var maxSizeLine = SDPUtils.matchPrefix(mediaSection, 'a=max-message-size:');
  var maxMessageSize;
  if (maxSizeLine.length > 0) {
    maxMessageSize = parseInt(maxSizeLine[0].substr(19), 10);
  }
  if (isNaN(maxMessageSize)) {
    maxMessageSize = 65536;
  }
  var sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');
  if (sctpPort.length > 0) {
    return {
      port: parseInt(sctpPort[0].substr(12), 10),
      protocol: mline.fmt,
      maxMessageSize: maxMessageSize
    };
  }
  var sctpMapLines = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:');
  if (sctpMapLines.length > 0) {
    var parts = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:')[0]
      .substr(10)
      .split(' ');
    return {
      port: parseInt(parts[0], 10),
      protocol: parts[1],
      maxMessageSize: maxMessageSize
    };
  }
};

// SCTP
// outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers
// support by now receiving in this format, unless we originally parsed
// as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line
// protocol of DTLS/SCTP -- without UDP/ or TCP/)
SDPUtils.writeSctpDescription = function(media, sctp) {
  var output = [];
  if (media.protocol !== 'DTLS/SCTP') {
    output = [
      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.protocol + '\r\n',
      'c=IN IP4 0.0.0.0\r\n',
      'a=sctp-port:' + sctp.port + '\r\n'
    ];
  } else {
    output = [
      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.port + '\r\n',
      'c=IN IP4 0.0.0.0\r\n',
      'a=sctpmap:' + sctp.port + ' ' + sctp.protocol + ' 65535\r\n'
    ];
  }
  if (sctp.maxMessageSize !== undefined) {
    output.push('a=max-message-size:' + sctp.maxMessageSize + '\r\n');
  }
  return output.join('');
};

// Generate a session ID for SDP.
// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1
// recommends using a cryptographically random +ve 64-bit value
// but right now this should be acceptable and within the right range
SDPUtils.generateSessionId = function() {
  return Math.random().toString().substr(2, 21);
};

// Write boilder plate for start of SDP
// sessId argument is optional - if not supplied it will
// be generated randomly
// sessVersion is optional and defaults to 2
// sessUser is optional and defaults to 'thisisadapterortc'
SDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {
  var sessionId;
  var version = sessVer !== undefined ? sessVer : 2;
  if (sessId) {
    sessionId = sessId;
  } else {
    sessionId = SDPUtils.generateSessionId();
  }
  var user = sessUser || 'thisisadapterortc';
  // FIXME: sess-id should be an NTP timestamp.
  return 'v=0\r\n' +
      'o=' + user + ' ' + sessionId + ' ' + version +
        ' IN IP4 127.0.0.1\r\n' +
      's=-\r\n' +
      't=0 0\r\n';
};

SDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {
  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

  // Map ICE parameters (ufrag, pwd) to SDP.
  sdp += SDPUtils.writeIceParameters(
    transceiver.iceGatherer.getLocalParameters());

  // Map DTLS parameters to SDP.
  sdp += SDPUtils.writeDtlsParameters(
    transceiver.dtlsTransport.getLocalParameters(),
    type === 'offer' ? 'actpass' : 'active');

  sdp += 'a=mid:' + transceiver.mid + '\r\n';

  if (transceiver.direction) {
    sdp += 'a=' + transceiver.direction + '\r\n';
  } else if (transceiver.rtpSender && transceiver.rtpReceiver) {
    sdp += 'a=sendrecv\r\n';
  } else if (transceiver.rtpSender) {
    sdp += 'a=sendonly\r\n';
  } else if (transceiver.rtpReceiver) {
    sdp += 'a=recvonly\r\n';
  } else {
    sdp += 'a=inactive\r\n';
  }

  if (transceiver.rtpSender) {
    // spec.
    var msid = 'msid:' + stream.id + ' ' +
        transceiver.rtpSender.track.id + '\r\n';
    sdp += 'a=' + msid;

    // for Chrome.
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
        ' ' + msid;
    if (transceiver.sendEncodingParameters[0].rtx) {
      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
          ' ' + msid;
      sdp += 'a=ssrc-group:FID ' +
          transceiver.sendEncodingParameters[0].ssrc + ' ' +
          transceiver.sendEncodingParameters[0].rtx.ssrc +
          '\r\n';
    }
  }
  // FIXME: this should be written by writeRtpDescription.
  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
      ' cname:' + SDPUtils.localCName + '\r\n';
  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
        ' cname:' + SDPUtils.localCName + '\r\n';
  }
  return sdp;
};

// Gets the direction from the mediaSection or the sessionpart.
SDPUtils.getDirection = function(mediaSection, sessionpart) {
  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
  var lines = SDPUtils.splitLines(mediaSection);
  for (var i = 0; i < lines.length; i++) {
    switch (lines[i]) {
      case 'a=sendrecv':
      case 'a=sendonly':
      case 'a=recvonly':
      case 'a=inactive':
        return lines[i].substr(2);
      default:
        // FIXME: What should happen here?
    }
  }
  if (sessionpart) {
    return SDPUtils.getDirection(sessionpart);
  }
  return 'sendrecv';
};

SDPUtils.getKind = function(mediaSection) {
  var lines = SDPUtils.splitLines(mediaSection);
  var mline = lines[0].split(' ');
  return mline[0].substr(2);
};

SDPUtils.isRejected = function(mediaSection) {
  return mediaSection.split(' ', 2)[1] === '0';
};

SDPUtils.parseMLine = function(mediaSection) {
  var lines = SDPUtils.splitLines(mediaSection);
  var parts = lines[0].substr(2).split(' ');
  return {
    kind: parts[0],
    port: parseInt(parts[1], 10),
    protocol: parts[2],
    fmt: parts.slice(3).join(' ')
  };
};

SDPUtils.parseOLine = function(mediaSection) {
  var line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];
  var parts = line.substr(2).split(' ');
  return {
    username: parts[0],
    sessionId: parts[1],
    sessionVersion: parseInt(parts[2], 10),
    netType: parts[3],
    addressType: parts[4],
    address: parts[5]
  };
};

// a very naive interpretation of a valid SDP.
SDPUtils.isValidSDP = function(blob) {
  if (typeof blob !== 'string' || blob.length === 0) {
    return false;
  }
  var lines = SDPUtils.splitLines(blob);
  for (var i = 0; i < lines.length; i++) {
    if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {
      return false;
    }
    // TODO: check the modifier a bit more.
  }
  return true;
};

// Expose public methods.
if (true) {
  module.exports = SDPUtils;
}


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _util = __webpack_require__(72);

var SoundMeter = __webpack_require__(216);

/**
 * {
 *  _located:
 *  _webrtc:
 *
 *  id:
 *  memId:
 *  name:
 *  voff:
 *  aoff:
 *  type: 0 1
 *  ext:
 *  owner: {
 *    id:
 *    nickName:
 *    name:
 *    ext:
 *  }
 *
 *  _localMediaStream:
 * }
 *
 *
 *
 */

emedia.subscribed = function (stream) {
    if (stream._located) {
        return true;
    }

    if (stream.type === 2) {
        return !!(!stream._located && stream._webrtc);
    }

    return stream._webrtc !== undefined;
};

var MediaSoundMeter = _util.prototypeExtend({
    voff: 0,
    aoff: 0,

    __init__: function __init__() {
        var self = this;

        if (!self._mediaStream) {
            _logger.error("_mediaStream empty");
            throw "_mediaStream empty";
        }

        if (!self.hasEnabledTracks(self._mediaStream)) {
            return;
        }

        if (!self.__audioContext) {
            _logger.error("require audioContext");
            throw "require audioContext";
        }

        self.__soundMeter = new SoundMeter(self.__audioContext);

        self.__soundMeter.connectToSource(self._mediaStream, function (e) {
            if (e) {
                throw e;
            }
            self.__worked = self.__soundMeter.__worked = true;
        });
    },

    hasEnabledTracks: function hasEnabledTracks(mediaStream) {
        return emedia.hasEnabledTracks(mediaStream);
    },

    getSoundMeters: function getSoundMeters() {
        var self = this;

        if (!self.__soundMeter || !self.__worked) {
            return;
        }

        if (!self._mediaStream.active) {
            self.__worked && self._finally();
            return;
        }

        if (!self.hasEnabledTracks(self._mediaStream)) {
            return;
        }

        return {
            instant: self.__soundMeter.instant,
            slow: self.__soundMeter.slow,
            clip: self.__soundMeter.clip
        };
    },

    _finally: function _finally() {
        var self = this;

        if (self.__soundMeter) {
            self.__soundMeter.stop();
            self.__worked = self.__soundMeter.__worked = false;
        }
    }
});

module.exports = _util.prototypeExtend({ //type 0 AVpub 1 Desktop 2 Sub
    __undefinedEQDelete: true,

    Update: _util.prototypeExtend({

        ifAoff: function ifAoff(update) {
            this.if("aoff", update);
        },

        ifVoff: function ifVoff(update) {
            this.if("voff", update);
        },

        ifMediaStream: function ifMediaStream(update) {
            this.if("mediaStream", update);
        },

        if: function _if(key, update) {
            if (typeof this[key] === "undefined") {
                return;
            }

            update(this[key]);
        }
    }),

    located: function located() {
        return this._located || false;
    },

    webrtc: function webrtc(_webrtc) {
        _webrtc && (this._webrtc = _webrtc);
        return this;
    },

    getMediaStream: function getMediaStream() {
        if (typeof this.mediaStream !== "undefined") {
            return this.mediaStream;
        }

        // if(this.type === 2 && this._webrtc && this._webrtc.getRemoteStream()){
        //     return this._webrtc.getRemoteStream();
        // }

        if (this._located) {
            return this._localMediaStream;
        }

        return this._webrtc && (this._webrtc.getRemoteStream() || this._webrtc.getLocalStream());
    },

    requestFrame: function requestFrame() {
        this._localMediaStream && this._localMediaStream.getVideoTracks().forEach(function (track) {
            typeof track.requestFrame === "function" && track.requestFrame();
        });
    },

    getLocalMediaStream: function getLocalMediaStream() {
        return this._localMediaStream;
    },

    getRemoteMediaStream: function getRemoteMediaStream() {
        if (this._webrtc && typeof this._webrtc.getRemoteStream() !== "undefined") {
            return this._webrtc.getRemoteStream();
        }
    },

    mutedNeed: function mutedNeed() {
        return this.mutedMuted || false;
    },

    ifMediaStream: function ifMediaStream(update) {
        if (typeof this.mediaStream !== "undefined") {
            update(this.mediaStream);
            return;
        }

        // if(this.type === 2 && this._webrtc && this._webrtc.getRemoteStream() !== "undefined"){
        //     update(this._webrtc.getRemoteStream());
        //     return;
        // }

        if (this._located && typeof this._localMediaStream !== "undefined") {
            update(this._localMediaStream);
            return;
        }

        if (!this._located && this._webrtc && typeof this._webrtc.getRemoteStream() !== "undefined") {
            update(this._webrtc.getRemoteStream());
            return;
        }
    },

    subscribed: function subscribed() {
        return emedia.subscribed(this);
    },

    updateAttributes: function updateAttributes() {
        var self = this;
        for (var i = 0; i < arguments.length; i++) {
            var arg = arguments[i];
            if (_util.isPlainObject(arg)) {
                for (var _key in arg) {
                    var _value = arg[_key];

                    self[_key] = _value;
                }
            }
        }
    },

    getHtmlDOMID: function getHtmlDOMID() {
        return "_m_" + this.owner.id + "_s_" + this.id;
    },

    MediaSoundMeter: MediaSoundMeter,

    StreamSoundMeter: _util.prototypeExtend({
        __init__: function __init__() {
            var self = this;

            if (!self._stream || typeof self._stream.getMediaStream !== 'function') {
                _logger.error("_stream empty or not found method getMediaStream");
                throw "_stream empty or not found method getMediaStream";
            }

            self._streamId = self._stream.id;
            self._streamCreateId = self._stream.__create_id;
            self._mediaStream = self._mediaStream;

            if (self._stream.type === 2 && !self._stream.located() && !self._webrtc) {
                _logger.error("require webrtc. when type = 2 and not located");
                throw "require webrtc. when type = 2 and not located";
            }

            self.__mediaSoundMeter = self.__mediaSoundMeter || new MediaSoundMeter({
                __audioContext: self.__audioContext,
                _mediaStream: self._mediaStream
            });
            self.__mediaSoundMeter.useCount = (self.__mediaSoundMeter.useCount || 0) + 1;
        },

        onSoundMeters: function onSoundMeters(callback) {
            var self = this;

            var emptyResult = {
                instant: 0,
                slow: 0,
                clip: 0
            };

            if (self._stream.aoff) {
                self._finally();
                callback(emptyResult);
                return emptyResult;
            }

            if (self._stream.type !== 2 && self._stream.subArgs && self._stream.subArgs.subSAudio !== undefined && !self._stream.subArgs.subSAudio) {
                self._finally();
                callback(emptyResult);
                return emptyResult;
            }

            if (self._stream.id == 0 || self._stream.type === 2 && !self._stream.located() && (!self._stream.subArgs || !self._stream.subArgs.subSAudio)) {
                var receivers = self._webrtc.getReceiversOfPeerConnection();

                if (!receivers || receivers.length === 0) {
                    callback(emptyResult);
                    return emptyResult;
                }

                var audioReceiver;
                for (var i in receivers) {
                    if (receivers[i].track.kind === 'audio') {
                        audioReceiver = receivers[i];
                    }
                }

                if (!audioReceiver) {
                    callback(emptyResult);
                    return emptyResult;
                }

                if (typeof audioReceiver.getContributingSources === 'function') {
                    var rtpContributingSources = audioReceiver.getContributingSources();
                    if (emedia.config._printSoundData) {
                        _util.logger.debug(self._stream.id, self._stream.csrc, "rtpContributingSources ", rtpContributingSources);
                    }

                    if (!rtpContributingSources || rtpContributingSources.length === 0) {
                        callback(emptyResult);
                        return emptyResult;
                    }

                    var source;
                    for (var i in rtpContributingSources) {
                        if (rtpContributingSources[i].source == self._stream.csrc) {
                            source = self._stream.csrc;
                        }
                    }

                    if (emedia.config._printSoundData) {
                        _util.logger.debug(self._stream.id, self._stream.csrc, "source ", source);
                    }

                    if (source === undefined) {
                        callback(emptyResult);
                        return emptyResult;
                    }
                }
            }

            var _meter = self.__mediaSoundMeter.getSoundMeters() || emptyResult;

            var webrtc = self._stream.type === 2 ? self._webrtc : self._stream._webrtc;
            if ((emedia.meterWithTrackAudioLevel || _meter.instant === 0) && webrtc && !webrtc.closed && webrtc._rtcPeerConnection) {
                webrtc._rtcPeerConnection.getStats().then(function (stats) {
                    if (stats.size > 0) {
                        stats.forEach(function (res) {
                            if (res.type === "track" && (res.kind === "audio" || res.trackIdentifier === "audio")) {
                                _meter.trackAudioLevel = res.audioLevel;
                                //_meter.trackTotalAudioEnergy = 0;
                                _meter.trackTotalAudioEnergy = res.totalAudioEnergy;
                                callback(_meter);
                            }
                        });
                    }
                });
            }

            callback(_meter);
        },

        _finally: function _finally() {
            var self = this;

            if (self._stream.type === 2 && self._stream.located() && self._remoteMediaSoundMeters) {
                self._remoteMediaSoundMeters._finally();
            }

            self.__mediaSoundMeter.useCount--;

            if (self.__mediaSoundMeter.useCount === 0) {
                self.__mediaSoundMeter._finally();
            }
        }
    })
});

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 *  Copyright (c) 2015 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */



// Meter class that generates a number correlated to audio volume.
// The meter class itself displays nothing, but it makes the
// instantaneous and time-decaying volumes available for inspection.
// It also reports on the fraction of samples that were at or near
// the top of the measurement range.

function SoundMeter(context) {
  this.context = context;
  this.instant = 0.0;
  this.slow = 0.0;
  this.clip = 0.0;
  this.script = context.createScriptProcessor(2048, 1, 1);
  var that = this;
  this.script.onaudioprocess = function (event) {
    var input = event.inputBuffer.getChannelData(0);
    var i;
    var sum = 0.0;
    var clipcount = 0;
    for (i = 0; i < input.length; ++i) {
      sum += input[i] * input[i];
      if (Math.abs(input[i]) > 0.99) {
        clipcount += 1;
      }
    }
    that.instant = Math.sqrt(sum / input.length);
    that.slow = 0.95 * that.slow + 0.05 * that.instant;
    that.clip = clipcount / input.length;
  };
}

SoundMeter.prototype.connectToSource = function (stream, callback) {
  console.log('SoundMeter connecting');
  try {
    this.mic = this.context.createMediaStreamSource(stream);
    this.mic.connect(this.script);
    // necessary to make sample run, but should not be.
    this.script.connect(this.context.destination);
    if (typeof callback !== 'undefined') {
      callback(null);
    }
  } catch (e) {
    console.error(e);
    if (typeof callback !== 'undefined') {
      callback(e);
    }
  }
};
SoundMeter.prototype.stop = function () {
  this.mic.disconnect();
  this.script.disconnect();
};

module.exports = SoundMeter;

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _util = __webpack_require__(72);
var _logger = _util.tagLogger("Handler");

var __event = __webpack_require__(208);

/**
 * Error({
 *   code:
 *   targetObj:
 *   evtObj:
 * })
 *
 *
 *
 *
 */
var Handler = _util.prototypeExtend({
    onEvent: function onEvent(evt) {
        if (this.mgr.upload_stats) {
            // upload qoe
            this.mgr.upload_stats.upload_event(evt);
        }
        var self = this;

        evt && _logger.info("[EVT]", evt.message(), evt.hidden || "");

        if (evt instanceof __event.ServerRefuseEnter) {
            evt.failed && evt.failed === -95270 && (evt.failed = -9527);
        }

        function afterNotify() {
            try {
                self.handleEvent(evt);
            } catch (e) {
                _logger.warn(e);
            }
        }

        if (evt instanceof emedia.event.StreamState && evt.stream && evt.stream.located()) {
            afterNotify();
            return;
        }

        try {
            evt.hidden || self.onNotifyEvent && self.onNotifyEvent(evt);
        } finally {
            afterNotify();
        }
    },

    handleEvent: function handleEvent(evt) {
        var self = this;

        if (evt instanceof __event.RecvResponse) {
            self._onRecvResponse(evt);
        } else if (evt instanceof __event.ServerRefuseEnter) {
            _logger.warn("Server refuse, ", evt.failed, evt.msg);
            self.onServerRefuseEnter(evt);
        } else if (evt instanceof __event.NetworkChanaged) {
            _logger.warn("Network chanaged, ", evt.preIp, evt.nowIp);
            self.onNetworkChanaged(evt);
        } else if (evt instanceof __event.EnterFail) {
            _logger.warn("Enter fail, result = ", evt.failed);
            self.onEnterFail();
        } else if (evt instanceof __event.WSClose) {
            //_logger.warn("Websocket closed");
            self.onWSClose();
        } else if (evt instanceof __event.WSConnected) {
            _logger.warn("Websocket connected");
        } else if (evt instanceof __event.ICEConnected) {
            var webrtc = evt.webrtc;
            self.onICEConnected(webrtc);
        } else if (evt instanceof __event.ICEConnectFail) {
            var webrtc = evt.webrtc;
            self.onICEConnectFail(webrtc);
        } else if (evt instanceof __event.ICEDisconnected) {
            //只要ICE断开
            var webrtc = evt.webrtc;
            self.onICEDisconnected(webrtc);
        } else if (evt instanceof __event.ICEClosed) {
            //只要ICE断开
            var webrtc = evt.webrtc;
            self.onICEClosed(webrtc);
        } else if (evt instanceof __event.ICERemoteMediaStream) {
            self.onICERemoteMediaStream(evt.webrtc);
        } else if (evt instanceof __event.PushSuccess) {
            self._cacheStreams[evt.stream.id] = self._linkedStreams[evt.stream.id] = evt.stream;

            var _stream = self.newStream(evt.stream);

            if (evt.hidden && !self._maybeNotExistStreams[evt.stream.id] && !_stream.isRepublished) {
                self._onAddStream(_stream);
                return;
            }

            emedia._yetGetUserMedia = true;

            try {
                //_stream && (_stream.mediaStream = _stream.getMediaStream());
                evt.hidden !== true && _stream && self.onUpdateStream(_stream, new _stream.Update({ voff: _stream.voff, aoff: _stream.aoff, mediaStream: _stream.getMediaStream() }));

                // _util.forEach(self._cacheStreams, function (_pubSId, _stream) {
                //     if(_stream.type === 2){
                //         self.onStreamControl(undefined, _pubSId, _stream.voff, _stream._1_aoff);
                //     }
                // });
            } finally {
                if (emedia.isSafari) {
                    _util.forEach(self._cacheStreams, function (_sid, _stream) {
                        if (_stream._autoSubWhenPushStream === true) {
                            _util.removeAttribute(_stream, "_autoSubWhenPushStream");
                            self.createWebrtcAndSubscribeStream(_stream.id);
                        }
                    });
                }
            }
        } else if (evt instanceof __event.SubSuccess) {
            console.log('__event.SubSuccess', evt);
            self._linkedStreams[evt.stream.id] = evt.stream;
            evt.stream.updateAttributes({ _zoom: 1 });
        } else if (evt instanceof __event.PushFail) {
            if (evt.hidden !== true) {
                var _removeStream = _util.removeAttribute(self._linkedStreams, evt.stream.id);
                _logger.warn("PushFail remove from _linkedStreams", evt.stream.id, _removeStream);

                if (_removeStream) {
                    var _stream = self.newStream(evt.stream);
                    self.onRemoveStream(_stream);
                }
            }
        } else if (evt instanceof __event.SubFail) {
            if (evt.hidden !== true) {
                //delete self._linkedStreams[evt.stream.id];
                _util.removeAttribute(self._linkedStreams, evt.stream.id);
                _logger.warn("SubFail remove from _linkedStreams", evt.stream.id);

                var _stream = self.newStream(evt.stream);
                _stream.updateAttributes({
                    rtcId: undefined,
                    _webrtc: undefined,
                    mediaStream: undefined
                });

                self.onUpdateStream(_stream, new _stream.Update(_stream));
            }
        } else if (evt instanceof __event.SubFailNotSupportVCodes) {
            // Server发现 此订阅时 不支持视频视频编码。或者 推送流 打开视频时，并不是所有的订阅端 都支持此视频编码
            // Server保持这个channel，客户端自行处理

            var stream = evt.stream;

            _logger.warn("Rtc donot support pub VCodes. close. sub fail.", stream.rtcId, " -> ", stream.id);
            try {
                self.onNotSupportPublishVideoCodecs && self.onNotSupportPublishVideoCodecs(stream);
            } catch (e) {
                _logger.warn(e);
            }

            // var streamId = stream.id;
            //
            // var webrtc = self._getWebrtc(streamId);
            // if(webrtc && webrtc.isConnected()){
            //     self.subscribeStream(webrtc._rtcId, streamId, undefined, {subSVideo: false, subSAudio: true});
            //     return;
            // }
        } else if (evt instanceof __event.EnterSuccess) {
            console.log('__event.EnterSuccess', evt);
            self.onEnterSuccess();
        } else if (evt instanceof __event.SwitchVCodes) {
            var stream = evt.stream;
            var useVCodes = evt.useVCodes;

            var webrtc = stream._webrtc;
            _logger.warn("Rtc switch VCodes. ", stream.id, useVCodes);

            if (!useVCodes || useVCodes.length == 0) {
                _logger.warn("Rtc switch VCodes. error! useVCodes is empty ", stream.id, useVCodes);
            }

            var forceUseVideoCodecs;
            if (emedia.config && emedia.config.forceUseVideoCodecs && emedia.config.forceUseVideoCodecs.length > 0) {
                forceUseVideoCodecs = emedia.config.forceUseVideoCodecs;
                if (!_util.isArray(forceUseVideoCodecs)) {
                    forceUseVideoCodecs = [];
                    forceUseVideoCodecs.push(emedia.config.forceUseVideoCodecs);
                }
            }
            // if(forceUseVideoCodecs){
            //     //与 useVCodes 取 交集
            //     var newVCodes = [];
            //     for(var index in useVCodes){
            //         var vcode = useVCodes[index];
            //
            //         for(var ii in forceUseVideoCodecs){
            //             if(forceUseVideoCodecs[ii] === vcode){
            //                 newVCodes.push(vcode);
            //             }
            //         }
            //     }
            //     useVCodes = evt.useVCodes = newVCodes;
            //     _logger.warn("Rtc switch VCodes. subset! config forceUseVideoCodecs. new useVCodes", stream.id, useVCodes);
            // }
            // if (!useVCodes || useVCodes.length == 0) {
            //     _logger.warn("Rtc switch VCodes. error! useVCodes is empty ", stream.id, useVCodes);
            // }
            if (forceUseVideoCodecs) {
                if (typeof forceUseVideoCodecs === 'string' && forceUseVideoCodecs !== useVCodes[0]) {
                    _logger.warn("Rtc switch VCodes. igrone . useVCodes !== forceUseVideoCodecs ", stream.id, webrtc._rtcId, useVCodes, forceUseVideoCodecs);
                    return;
                }
                if (_util.isArray(forceUseVideoCodecs) && forceUseVideoCodecs[0] !== useVCodes[0]) {
                    _logger.warn("Rtc switch VCodes. igrone ddd . useVCodes == forceUseVideoCodecs ", stream.id, webrtc._rtcId, useVCodes, forceUseVideoCodecs);
                    return;
                }
            }

            if (webrtc && webrtc.optimalVideoCodecs) {
                if (typeof webrtc.optimalVideoCodecs === 'string' && webrtc.optimalVideoCodecs == useVCodes[0]) {
                    _logger.warn("Rtc switch VCodes. igrone . useVCodes == optimalVideoCodecs ", stream.id, webrtc._rtcId, useVCodes);
                    return;
                }
                if (_util.isArray(webrtc.optimalVideoCodecs) && webrtc.optimalVideoCodecs.length > 0 && webrtc.optimalVideoCodecs[0] == useVCodes[0]) {
                    _logger.warn("Rtc switch VCodes. igrone ddd . useVCodes == optimalVideoCodecs ", stream.id, webrtc._rtcId, useVCodes);
                    return;
                }
            }

            stream.updateAttributes({ optimalVideoCodecs: useVCodes });

            webrtc && self.closeWebrtc(webrtc.getRtcId(), true);
            setTimeout(function () {
                stream.updateAttributes({ iceRebuildCount: 1 });
                self.iceRebuild(stream);
                _logger.warn("Rtc switch VCodes. iceRebuild end.", stream.id, useVCodes);
            }, 300);
        }
    },

    _onRecvResponse: function _onRecvResponse(evt) {
        var self = this;

        var request = evt.request;
        var response = evt.response;

        if (request && response && request.op !== 200 && request.op !== 1002 && response.result !== 0) {

            _logger.warn("Server refuse. when request = ", request);

            var failed = evt.failed;
            switch (failed) {
                case -9527:
                case -95270:
                    //self.close(4, -9527);
                    break;
                case -500:
                case -502:
                case -504:
                case -508:
                case -510:
                    self.close(4, failed);
                    break;
                case -506:
                    self.close(11, failed);
                    break;

                case -501:
                    self.close(11, failed);
                default: // -501 异常引起 忽略
            }
        }
    },

    onServerRefuseEnter: function onServerRefuseEnter(evt) {
        var self = this;

        var failed = evt.failed;
        switch (failed) {
            case -9527:
            case -95270:
                self.close(4, -9527);
                break;
            case -500:
            case -502:
            case -504:
            case -508:
            case -510:
                self.close(4, failed);
                break;
            case -506:
                self.close(11, failed);
                break;
            default:
                self.close(2);
        }
    },

    onEnterFail: function onEnterFail() {
        var self = this;

        if (self.__getCopyInterval) {
            clearInterval(self.__getCopyInterval);
        }
    },

    //会在enter success后回调
    onNetworkChanaged: function onNetworkChanaged(evt) {
        var self = this;

        //var preIp = evt.preIp;
        var nowIp = evt.nowIp;

        if (emedia.config.rebuildPeerConnectionWhenNetworkChanaged) {
            setTimeout(function () {
                //ip地址改变，需要将 useIp == preIp 和 useIp == undefined webrtc，rebuild
                var tmp = {};
                _util.forEach(self._cacheStreams, function (_sid, stream) {
                    if (!self._maybeNotExistStreams[_sid]) {
                        //_maybeNotExistStreams 中的stream 将在 Enter success后，重建，所以在_maybeNotExistStreams中，不需要rebuild
                        if (stream._webrtc) {
                            var _webrtc = stream._webrtc;
                            if (tmp[stream.rtcId]) {} else {
                                if (!_webrtc.closed && typeof _webrtc.useIp === "string" && _webrtc.useIp !== nowIp) {
                                    _logger.warn("network chanage. webrtc will rebuild.", _webrtc._rtcId, _webrtc.__id);
                                    self.onICEClosed(_webrtc);
                                }
                                tmp[stream.rtcId] = true;
                            }
                        }
                    }
                });

                // _util.forEach(self._ices, function (_id, _webrtc){
                //     if(_id === _webrtc._rtcId && !_webrtc.closed && (typeof _webrtc.useIp === "string") && _webrtc.useIp !== nowIp){
                //         _logger.warn("network chanage. webrtc will rebuild.", _webrtc._rtcId, _webrtc.__id);
                //         self.onICEClosed(_webrtc);
                //     }
                // });
            }, 100);
        }
    },

    onEnterSuccess: function onEnterSuccess() {
        var self = this;

        setTimeout(function () {
            self._failIcesRebuild();
        }, 50);

        if (self.getCopyIntervalMillis && self.getCopyIntervalMillis > 0) {
            _logger.warn("Run interval get copy. interval = ", self.getCopyIntervalMillis);

            if (self.__getCopyInterval) {
                clearInterval(self.__getCopyInterval);
            }

            self.__getCopyInterval = setInterval(function () {
                if (self._session.connected()) {
                    self._sysCopy.apply(self);
                } else {
                    _logger.warn("Warn! cannot get copy. cause offline.");

                    self.__getCopyInterval && clearInterval(self.__getCopyInterval);
                }
            }, self.getCopyIntervalMillis);
        }

        if (self.getMediaMeterIntervalMillis && self.getMediaMeterIntervalMillis > 0) {
            self._intervalGetMediaMeters();
        }
    },

    _intervalGetMediaMeters: function _intervalGetMediaMeters() {
        var self = this;

        function _start() {
            self.__getMediaMetersIntervalFlag && emedia.cancelAnimationFrame(self.__getMediaMetersIntervalFlag);

            if (!self.getMediaMeterIntervalMillis) {
                _logger.warn("Ontalking closed. please use getMediaMeterIntervalMillis");
                return;
            }
            self.__getMediaMetersIntervalFlag = emedia.requestAnimationFrame(function (time) {
                if (typeof emedia.AudioContext === 'function') {
                    self._flushMediaMetersByAudioContext.apply(self);
                }

                !(self.closed !== false) && _start();
            }, self.getMediaMeterIntervalMillis);
        }
        _start();
    },

    _flushMediaMetersByAudioContext: function _flushMediaMetersByAudioContext() {
        var self = this;

        _util.forEach(self._cacheStreams, function (_sid, _stream) {
            if (!self._monitSoundChanagedStreams || self._monitSoundChanagedStreams[_sid]) {
                _stream.id != "0" && self._updateMetersOrNewOne.call(self, _sid, _stream);
            }
        });

        var delStreamSoundMeters = [];
        _util.forEach(self._mediaMeters, function (_sid, streamSoundMeter) {
            var _stream = self._cacheStreams[_sid];
            _stream && self._updateMetersOrNewOne.call(self, _sid, _stream);
            _stream || delStreamSoundMeters.push(_sid);
        });

        _util.forEach(delStreamSoundMeters, function (index, _sid) {
            _util.removeAttribute(self._mediaMeters, _sid);
        });
    },

    _updateMetersOrNewOne: function _updateMetersOrNewOne(_sid, _stream) {
        var self = this;

        var metersData;

        var streamSoundMeter = self._mediaMeters[_sid];

        if (_stream.type === 2 && !_stream.located() && (!_stream.subArgs || !_stream.subArgs.subSAudio)) {
            var pubAudioMixersStream = self._oneAudioMixers();
            if (!pubAudioMixersStream || streamSoundMeter && streamSoundMeter._webrtc && pubAudioMixersStream._webrtc.__id != streamSoundMeter._webrtc.__id) {
                streamSoundMeter && streamSoundMeter._finally();
                _util.removeAttribute(self._mediaMeters, _sid);
                self._onSoundChanage.call(self, _stream.owner, _stream);

                return;
            }
        }

        if (streamSoundMeter && streamSoundMeter._streamCreateId === _stream.__create_id && streamSoundMeter.__mediaSoundMeter.__worked) {

            streamSoundMeter.onSoundMeters(function (metersData) {
                self._onSoundChanage.call(self, _stream.owner, _stream, metersData);
            });

            return streamSoundMeter;
        }

        if (streamSoundMeter && (streamSoundMeter._streamCreateId !== _stream.__create_id || streamSoundMeter.__mediaSoundMeter.__worked)) {
            streamSoundMeter && streamSoundMeter._finally();
            _util.removeAttribute(self._mediaMeters, _sid);
            self._onSoundChanage.call(self, _stream.owner, _stream);
        }

        if (_stream.aoff) {
            return;
        }

        streamSoundMeter = self._newMediaMeters(_stream);
        if (streamSoundMeter) {
            self._mediaMeters[_sid] && self._mediaMeters[_sid]._finally();
            self._mediaMeters[_sid] = streamSoundMeter;
        }

        return streamSoundMeter;
    },

    _newAudioContext: function _newAudioContext() {
        var self = this;

        if (!emedia.__usingWebAudio) {
            return;
        }

        return emedia.__audioContext;
    },

    _newMediaMeters: function _newMediaMeters(_stream) {
        var self = this;

        var mediaStream;
        if (_stream.type === 2 && _stream.subArgs && _stream.subArgs.subSAudio && _stream._webrtc && _stream._webrtc.getRemoteStream()) {
            var soundMeter = new _stream.StreamSoundMeter({
                _stream: _stream,
                _mediaStream: _stream._webrtc.getRemoteStream(),
                _webrtc: _stream._webrtc,
                __audioContext: self._newAudioContext()
            });

            return soundMeter;
        }

        if (_stream.type === 2 && _stream.located()) {
            var soundMeter = new _stream.StreamSoundMeter({
                _stream: _stream,
                _mediaStream: _stream._localMediaStream,
                __audioContext: self._newAudioContext()
            });

            return soundMeter;
        }

        if (_stream.type === 2 && !_stream.located()) {
            var pubAudioMixersStream = self._oneAudioMixers();
            if (!pubAudioMixersStream || !pubAudioMixersStream._webrtc || pubAudioMixersStream._webrtc.closed) {
                return;
            }

            if (pubAudioMixersStream && (pubAudioMixersStream._remoteMediaSoundMeters === undefined || !pubAudioMixersStream._remoteMediaSoundMeters.__worked) && pubAudioMixersStream._webrtc && pubAudioMixersStream._webrtc.getRemoteStream()) {
                pubAudioMixersStream._remoteMediaSoundMeters = new pubAudioMixersStream.MediaSoundMeter({
                    _mediaStream: pubAudioMixersStream._webrtc.getRemoteStream(),
                    __audioContext: self._newAudioContext()
                });
            }

            if (!pubAudioMixersStream._remoteMediaSoundMeters) {
                return;
            }

            var soundMeter = new _stream.StreamSoundMeter({
                _stream: _stream,
                _webrtc: pubAudioMixersStream._webrtc,
                __mediaSoundMeter: pubAudioMixersStream._remoteMediaSoundMeters
            });

            return soundMeter;
        }

        if (!_stream.aoff && (mediaStream = _stream.getMediaStream())) {
            var soundMeter = new _stream.StreamSoundMeter({
                _stream: _stream,
                _mediaStream: mediaStream,
                __audioContext: self._newAudioContext()
            });

            return soundMeter;
        }
    },

    _oneAudioMixers: function _oneAudioMixers() {
        var self = this;

        var zeroStream = self._cacheStreams["0"];
        if (zeroStream && zeroStream._webrtc && !zeroStream._webrtc.closed) {
            return zeroStream;
        }

        for (var sid in self.audioMixers) {
            var stream = self.audioMixers[sid];
            if (stream.located()) {
                return stream;
            }
        }
    },

    onWSClose: function onWSClose() {
        var self = this;
        if (self.__getCopyInterval) {
            clearInterval(self.__getCopyInterval);
        }

        _logger.info("Websocket closed.");
    },

    onICEDisconnected: function onICEDisconnected(webrtc) {
        var self = this;

        self.__networkWeakInterval && clearTimeout(self.__networkWeakInterval);
        self.__networkWeakInterval = setTimeout(function () {
            self.onNetworkWeak && self.onNetworkWeak();
        }, 1000);

        _util.forEach(self._linkedStreams, function (sid, stream) {
            if (stream.rtcId == webrtc.getRtcId()) {
                var problemStream;
                if (!(problemStream = self._maybeNotExistStreams[sid])) {
                    problemStream = self._maybeNotExistStreams[sid] = _util.extend({}, stream);
                    problemStream.updateAttributes({ iceRebuildCount: 1 });
                }

                _logger.info("Stream maybe not exist. caused by disconnected", stream.id);
            }
        });
    },

    onICEConnectFail: function onICEConnectFail(webrtc) {
        var self = this;

        for (var sid in self._linkedStreams) {
            var stream = self._linkedStreams[sid];
            if (stream.rtcId == webrtc.getRtcId()) {
                if (stream._webrtc && stream._webrtc.__id !== webrtc.__id) {
                    _logger.warn("Stream use other webrtc rtcId = ", stream.rtcId, ", id: ", stream._webrtc.__id, webrtc.__id);
                    continue;
                }

                var problemStream;
                if (!(problemStream = self._maybeNotExistStreams[sid])) {
                    problemStream = self._maybeNotExistStreams[sid] = _util.extend({}, stream);
                    problemStream.updateAttributes({ iceRebuildCount: 1 });
                }

                if (problemStream) {
                    var _evt = new __event.StreamState({ stream: problemStream });
                    _evt.iceFail();

                    self.onEvent(_evt);
                }

                _logger.info("ice fail. webrtc = ", webrtc.getRtcId(), " problem stream is ", problemStream.iceRebuildCount, problemStream.id);

                if (problemStream.iceRebuildCount > emedia.config.iceRebuildCount) {
                    _logger.info("ice fail. webrtc = ", webrtc.getRtcId(), " rebuild fail. problem stream is ", problemStream.id);

                    if (problemStream.located()) {
                        self.onEvent(new __event.PushFail({
                            stream: stream,
                            cause: "pub ice rebuild failed."
                        }));
                    } else {
                        self.onEvent(new __event.SubFail({
                            stream: stream,
                            cause: "sub ice rebuild failed."
                        }));
                    }
                    self.closeWebrtc(webrtc.getRtcId(), false);
                } else {
                    var recording = self._records[problemStream.id];

                    if (problemStream._localMediaStream) {
                        _logger.info("ice fail. webrtc = ", webrtc.getRtcId(), " will rebuild. remain local stream. ", problemStream.id);
                    } else {
                        _logger.info("ice fail. webrtc = ", webrtc.getRtcId(), " will rebuild.", problemStream.id);
                    }

                    self.closeWebrtc(webrtc.getRtcId(), true);

                    if (recording) {
                        self._records[problemStream.id] = recording;
                    }

                    (function (problemStream) {
                        setTimeout(function () {
                            self.iceRebuild(problemStream);
                        }, emedia.config.iceRebuildIntervalMillis);
                    })(problemStream);

                    _logger.info("ice fail. webrtc = ", webrtc.getRtcId(), " will rebuilding. problem stream is ", problemStream.id);
                }

                if (stream.type === 2) {
                    _util.removeAttribute(self.audioMixers, stream.id);
                }
            }
        }
    },

    onICEClosed: function onICEClosed(webrtc) {
        var self = this;

        if (webrtc.closed) {
            _logger.warn("Webrtc will be removed. by __id = ", webrtc.__id, ", rtcId = ", webrtc.getRtcId());
            var removedWebrtc = _util.removeAttribute(self._ices, webrtc.__id);
            if (removedWebrtc) {
                _logger.warn("Webrtc removed. by id = ", removedWebrtc.__id, ", rtcId = ", removedWebrtc.getRtcId());
            } else {
                _logger.warn("Webrtc removed. by id = ", webrtc.__id, ", rtcId = ", webrtc.getRtcId());
            }

            var webrtc22 = self._ices[webrtc.getRtcId()];
            if (webrtc22 && webrtc22.__id === removedWebrtc.__id) {
                removedWebrtc = _util.removeAttribute(self._ices, webrtc.getRtcId());
                _logger.warn("Webrtc removed. by rtcId = ", removedWebrtc.getRtcId(), ", __id = ", removedWebrtc.__id);
            }
        } else {
            _logger.info("ICE self closed. not allow. will rebuild", webrtc.getRtcId());
            self.onICEConnectFail(webrtc);
        }
    },

    onICEConnected: function onICEConnected(webrtc) {
        var self = this;

        _util.forEach(self._cacheStreams, function (sid, stream) {
            if (stream.rtcId == webrtc.getRtcId()) {
                stream.updateAttributes({ finalVCodeChoices: webrtc.finalVCodeChoices });

                if (self._maybeNotExistStreams[sid]) {
                    _util.removeAttribute(self._maybeNotExistStreams, stream.id);
                    self._linkedStreams[sid] = stream;

                    _logger.info("ice reconnected. webrtc = ", webrtc.getRtcId(), "will update stream = ", stream.id);
                    //stream.located() && self.onUpdateStream(self._linkedStreams[stream.id]);
                    //self.onUpdateStream(self._linkedStreams[stream.id]);

                    var _recordStream = self._records[stream.id];
                    if (_recordStream && _recordStream.rtcId !== stream.rtcId) {
                        //在重连后，恢复录制
                        //self.stopRecord(_recordStream);
                        self.startRecord(stream);
                        _logger.warn("Re record. for ", stream.id, ", after rebuild ice.", _recordStream.rtcId, "->", stream.rtcId);
                    }
                } else {
                    _logger.info("ice connected. webrtc = ", webrtc.getRtcId(), stream.id);

                    stream.located() && self.onEvent(new __event.PushSuccess({ stream: stream }));
                    stream.located() || self.onEvent(new __event.SubSuccess({ stream: stream }));
                }

                if (stream.type === 2) {
                    self.audioMixers[stream.id] = stream;
                }
            }
        });
    },

    onICERemoteMediaStream: function onICERemoteMediaStream(webrtc) {
        var self = this;

        var streams = [];
        _util.forEach(self._cacheStreams, function (sid, _stream) {
            if (_stream.rtcId == webrtc.getRtcId() && (!_stream.located() || _stream.type === 2)) {
                var mediaStream = webrtc.getRemoteStream();
                self._updateRemoteStream(_stream, mediaStream);

                if (_stream.onGotRemoteMediaStream) {
                    _stream.onGotRemoteMediaStream.call(_stream, mediaStream);
                } else {
                    var _stream = self.newStream(_stream);
                    _stream.updateAttributes({ mediaStream: webrtc.getRemoteStream() });
                    self.onUpdateStream(_stream, new _stream.Update({ mediaStream: _stream.mediaStream }));
                }
            }
        });
    },

    _failIcesRebuild: function _failIcesRebuild() {
        var self = this;

        var count = 1;
        _util.forEach(self._maybeNotExistStreams, function (streamId, stream) {
            setTimeout(function () {
                self.iceRebuild(stream);
            }, count * 100);
        });
    },

    iceRebuild: function iceRebuild(stream) {
        var self = this;

        if (!self.connected()) {
            stream.updateAttributes({ iceRebuildCount: 1 });
            _logger.warn("Websocket disconnect. waiting. rebuild count reset", stream.iceRebuildCount, stream.id);
            return;
        }
        if (!self._linkedStreams[stream.id] || !self._cacheStreams[stream.id]) {
            _logger.info("ice rebuild fail. it yet closed. stream is ", stream.id, stream.rtcId);
            _util.removeAttribute(self._maybeNotExistStreams, stream.id);
            _util.removeAttribute(self._linkedStreams, stream.id);
            _logger.warn("iceRebuild, remvoe from _linkedStreams", stream.id);

            return;
        }

        if (stream.iceRebuildCount > emedia.config.iceRebuildCount) {
            _logger.info("ice rebuild fail. count too many. stream is ", stream.id);

            if (stream.located()) {
                self.onEvent(new __event.PushFail({
                    stream: stream,
                    cause: "pub ice rebuild failed."
                }));
            } else {
                self.onEvent(new __event.SubFail({
                    stream: stream,
                    cause: "sub ice rebuild failed."
                }));
            }
        } else if (self.connected()) {
            _logger.info("ice try rebuild. count", stream.iceRebuildCount, ". stream is ", stream.id);
            self.rebuildIce(stream);

            stream.iceRebuildCount++;
        } else {
            _logger.warn("ice rebuild. stop. cause by not websocket disconnect", stream.id);
        }
    },

    rebuildIce: function rebuildIce(stream) {
        var self = this;

        if (!self._cacheStreams[stream.id]) {
            _logger.warn("Begin rebuild ice. not found stream at local", stream.iceRebuildCount, stream.id);
            return;
        }
        _logger.warn("Begin rebuild ice ", stream.iceRebuildCount, stream.id);

        if (stream.located()) {
            stream.updateAttributes({ isRepublished: true });
            self.push(stream, undefined, undefined, true);
        } else {
            self.createWebrtcAndSubscribeStream(stream.id);
        }
        _logger.warn("Finish rebuild ice ", stream.iceRebuildCount, stream.id, self._cacheStreams[stream.id].rtcId);
    },

    _sysCopy: function _sysCopy() {
        var self = this;

        var copyMessage = self.newMessage().setOp(1000).setCver(self._cver || 0);

        self.postMessage(copyMessage, function (rsp) {
            if (rsp.result != 0) {
                _logger.warn("Get copy fail. result = ", rsp.result);

                return;
            }

            if ((self._cver || 0) < rsp.cver) {
                self._cver = rsp.cver;

                self.onMembers(rsp.cver, rsp.mems || {});
                self.onStreams(rsp.cver, rsp.streams || {});

                _logger.info("Got copy success.");
            }
        });
    }
});

module.exports = Handler;

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _util = __webpack_require__(72);
var _logger = _util.tagLogger("Desktop");

var __event = __webpack_require__(208);

window.__shareDesktopMessageCount__ = 0;

module.exports = _util.prototypeExtend({

    __RTC_PAGE_MSG_TYPE__: 'RTC-SD-PAGE',
    __RTC_EXT_MSG_TYPE__: 'RTC-SD-EXT',

    __init__: function __init__() {
        var self = this;

        self.__extLoaded = self.rsdExtLoaded();
        if (self.__extLoaded) {
            self.__onRsdExtLoad();
        }

        window.addEventListener("load", function (event) {
            if (self.__extLoaded) {
                return;
            }

            var exist = self.rsdExtLoaded();
            // console.log('exist=', exist, ', ev4detect=', ev4detect);

            self.__extLoaded = exist;
        });

        window.addEventListener('message', function (event) {
            if (!event.data) {
                return;
            }

            var msg = event.data;
            if (!msg.type || msg.type !== self.__RTC_EXT_MSG_TYPE__ || !msg.evname) {
                return;
            }
            _logger.info('got ext-msg: ', msg);

            if (msg.evname === 'extLoaded') {
                if (!self.__extLoaded) {
                    self.__extLoaded = true;

                    setTimeout(self.__onRsdExtLoad(), 50);
                }

                return;
            }

            self.__onMessage(msg);
        });
    },

    rsdExtLoaded: function rsdExtLoaded() {
        var existele = document.getElementById('RTC-Share-Deskto-installed-ele-rat1abrr');
        return emedia.isElectron || existele ? true : false;
    },

    __sendMessage: function __sendMessage(msg, callback) {
        var self = this;

        var tsxId = 'tsx_' + __shareDesktopMessageCount__++ + '_' + Math.random().toString(36).substr(2, 4);

        if (!self.__extLoaded) {
            _logger.error("Rtc share desktop not loaded");
            throw "Rtc share desktop not loaded";
        }

        msg.tsxId = tsxId;

        self["on_" + tsxId] = function () {
            callback && callback.apply(self, arguments);

            //delete self["on_" + tsxId];
            _util.removeAttribute(self, "on_" + tsxId);
        };

        window.postMessage && window.postMessage(msg, '*');
    },

    __onMessage: function __onMessage(msg) {
        var self = this;

        var tsxId = msg.tsxId;

        self["on_" + tsxId] && self["on_" + tsxId](msg);
        //self["on_" + tsxId] || _logger.info(msg);
    },

    __onRsdExtLoad: function __onRsdExtLoad() {
        var self = this;

        self.onExtLoaded && self.onExtLoaded();
    },

    openDesktopMedia: function openDesktopMedia(screenOptions, callback) {
        var self = this;

        if (emedia.isElectron) {
            self.openDesktopMediaInElectron(screenOptions, callback);
            return;
        }

        if (!self.__extLoaded || !self.rsdExtLoaded()) {
            callback(new __event.ShareDesktopExtensionNotFound());
            return;
        }

        var msg = { type: self.__RTC_PAGE_MSG_TYPE__, evname: 'chooseDesktopMedia', screenOptions: screenOptions };
        self.__sendMessage(msg, function (m) {
            if (m.evname === 'onAccessApproved' && m.streamId) {
                callback(new __event.OpenDesktopMedia({ desktopStreamId: m.streamId }));
            } else {
                callback(new __event.OpenDesktopMediaAccessDenied());
            }
        });
    },

    openDesktopMediaInElectron: function openDesktopMediaInElectron(screenOptions, callback) {
        var self = this;

        if (!screenOptions) {
            screenOptions = ['screen', 'window'];
        }

        var getSourcesOptions = {
            types: screenOptions,
            thumbnailSize: { width: 230, height: 230 }
        };
        emedia.electron.desktopCapturer.getSources(getSourcesOptions).then(function (sources) {

            if (typeof emedia.chooseElectronDesktopMedia !== 'function') {
                callback(new __event.OpenDesktopMedia({ desktopStreamId: sources[0].id }));
                return;
            }

            for (var i = 0; i < sources.length; i++) {
                // _logger.debug("desktop capturer. ", sources[i]);
                var source = sources[i];
                source.hxThumbDataURL = source.thumbnail.toDataURL();
            }

            emedia.chooseElectronDesktopMedia(sources, function accessApproved(desktopCapturerSource) {
                var sourceId;
                if (desktopCapturerSource && desktopCapturerSource.id) {
                    sourceId = desktopCapturerSource.id;
                } else {
                    sourceId = desktopCapturerSource;
                }

                callback(new __event.OpenDesktopMedia({ desktopStreamId: sourceId }));
            }, function accessDenied() {
                callback(new __event.OpenDesktopMediaAccessDenied({ message: function message() {
                        return "User denied access";
                    } }));
            });
        }).catch(function (error) {
            return callback(new __event.OpenDesktopMediaAccessDenied({ error: error }));
        });
    }
});

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _util = __webpack_require__(72);
var _logger = _util.tagLogger("PCStats");

/**
 * outbound-rtp
 *  bytesSent
 *  packetsSent
 *  qpSum
 *  pliCount
 * inbound-rtp
 *  bytesReceived
 *  framesDecoded
 *  packetsLost
 *  packetsReceived
 *  pliCount
 * track
 *  framesDecoded
 *  framesReceived
 *  framesDropped
 * transport
 *  bytesReceived
 *  bytesSent
 * candidate-pair
 *  bytesReceived
 *  bytesSent
 *  totalRoundTripTime
 *  requestsReceived
 *  responsesSent
 *  requestsSent
 *  responsesReceived
 * local-candidate
 *  networkType
 *  protocol
 *  port
 * remote-candidate
 *  ip
 * codec
 *  clockRate
 *  mimeType
 *
 *
 */

var PCStats;
module.exports = PCStats = _util.prototypeExtend({
    //_webrtc:
    //_stream:

    __init__: function __init__() {
        if (!this._webrtc) {
            this._stream && (this._webrtc = this._stream._webrtc);
        }

        this.samplesDatas = {};
        this.gatherResults = {};

        this._bysamples = {};
        if (this._inbound_ !== false) {
            this._bysamples["inbound-rtp"] = ["bytesRateReceived", "packageLossRate", "bytesReceived", "packetsLost", "packetsReceived", "pliCount", "framesDecoded"];
            //this._bysamples["inbound-rtp"] = ["bytesReceived", "packetsLost", "packetsReceived", "packageLossRate"];
        }
        if (this._outbound_ !== false) {
            this._bysamples["outbound-rtp"] = ["bytesRateSent", "bytesSent", "packetsSent", "qpSum", "pliCount"];
            //this._bysamples["outbound-rtp"] = ["bytesSent"];
        }
    },

    _onGatherResult: function _onGatherResult(trackId, type, subtype, data) {
        //_logger.info(trackId, type, subtype, data);
        //_logger.debug(trackId, type, subtype, data);

        var self = this;

        if (self._service && self._service.current && emedia.config.remainLastStatsCount) {
            var trackStats = self._service.current._trackStats;
            if (!trackStats) {
                trackStats = self._service.current._trackStats = {};
            }
            var typeStats = (trackStats[trackId] || (trackStats[trackId] = {}))[type];
            if (!typeStats) {
                typeStats = trackStats[trackId][type] = {};
            }

            var subTypeStats = typeStats[subtype];
            if (!subTypeStats) {
                subTypeStats = typeStats[subtype] = new Array(emedia.config.remainLastStatsCount);
            }

            subTypeStats.curIndex === undefined && (subTypeStats.curIndex = 0);
            subTypeStats[subTypeStats.curIndex] = {
                data: data,
                timestamp: new Date()
            };
            subTypeStats.curIndex = (subTypeStats.curIndex + 1) % emedia.config.remainLastStatsCount;
        }
        typeof this.onGatherResult === "function" && this.onGatherResult(trackId, type, subtype, data);
    },

    stats: function stats(selector) {
        if (!this._webrtc || !this._webrtc._rtcPeerConnection) {
            _logger.warn("not found webrtc or peer connection");
            return;
        }

        return this._webrtc._rtcPeerConnection.getStats(selector);
    },

    statsOfTrack: function statsOfTrack(selector) {
        if (!selector instanceof window.MediaStreamTrack) {
            _logger.error("selector not a MediaStreamTrack");
            throw "selector not a MediaStreamTrack";
        }

        return this.stats(selector);
    },

    audioTrack: function audioTrack(mediaStream) {
        var tracks = mediaStream && mediaStream.getAudioTracks();
        return tracks && tracks.length ? tracks[0] : undefined;
    },

    videoTrack: function videoTrack(mediaStream) {
        var tracks = mediaStream && mediaStream.getVideoTracks();
        return tracks && tracks.length ? tracks[0] : undefined;
    },

    // samplingTrack: function (track) {
    //     var self = this;
    //
    //     var trackId = track.id;
    //     this.statsOfTrack(track).then(function(_stats){
    //         self._trackSamples[trackId] || (self._trackSamples[trackId] = []);
    //
    //         var statsParms = self._trackSamples[trackId];
    //
    //         _stats.forEach(function(_stat, name){
    //             var samplings = _bysamples[_stat.type];
    //
    //             var tmp;
    //             if(samplings && samplings.length){
    //                 var statParms = (tmp || (tmp = {}))[_stat.type] = {type:_stat.type, timestamp: _stat.timestamp};
    //
    //                 samplings.forEach(function(_param){
    //                     statParms[_param] = _stat[_param];
    //                 });
    //             }
    //             tmp && statsParms.push(tmp);
    //         });
    //     });
    // },

    gatherTrack: function gatherTrack(track, mediaType) {
        var self = this;

        mediaType = track.kind || mediaType;
        mediaType = mediaType && mediaType.toLowerCase();

        var trackId = track.id;
        this.statsOfTrack(track).then(function (_stats) {
            self.samplesDatas[trackId] || (self.samplesDatas[trackId] = {});

            var statsParms = self.samplesDatas[trackId];

            _stats.forEach(function (_stat, name) {
                var samplings = self._bysamples[_stat.type];

                var statMediaType = _stat.mediaType || name.indexOf("ideo") >= 0 && "video" || name.indexOf("udio") >= 0 && "audio" || undefined;

                if (samplings && samplings.length) {
                    if (emedia.config._printDebugStats === true) {
                        _logger.debug(name, _stat, track, statMediaType, mediaType);
                    }

                    if (!statMediaType || statMediaType === mediaType) {
                        var tmp = statsParms[_stat.type] || (statsParms[_stat.type] = {});

                        samplings.forEach(function (_param) {
                            var items = tmp[_param] || (tmp[_param] = []);

                            var item = { timestamp: _stat.timestamp, kind: _stat.mediaType || track.kind || mediaType };
                            if ("packageLossRate" === _param) {
                                item[_param] = { packetsLost: _stat["packetsLost"], packetsReceived: _stat["packetsReceived"] };
                            } else if ("bytesRateReceived" === _param) {
                                item[_param] = _stat["bytesReceived"];
                            } else if ("bytesRateSent" === _param) {
                                item[_param] = _stat["bytesSent"];
                            } else {
                                item[_param] = _stat[_param];
                            }

                            items.push(item);
                        });
                    }
                }
            });
        });
    },

    gatherWebrtcMediaStream: function gatherWebrtcMediaStream(_mediaStream, type) {
        var self = this;

        if (!type) {
            _mediaStream.getTracks().forEach(function (track) {
                self.gatherTrack(track);
            });
            return;
        }

        if ("audio" === type.toLowerCase()) {
            _mediaStream.getAudioTracks().forEach(function (track) {
                self.gatherTrack(track, track.kind || type.toLowerCase());
            });
            return;
        }

        if ("video" === type.toLowerCase()) {
            _mediaStream.getVideoTracks().forEach(function (track) {
                self.gatherTrack(track, track.kind || type.toLowerCase());
            });
            return;
        }
    },

    gatherWebrtc: function gatherWebrtc() {
        this._webrtc._localStream && this.gatherWebrtcMediaStream(this._webrtc._localStream);
        this._webrtc._remoteStream && this.gatherWebrtcMediaStream(this._webrtc._remoteStream);
    },

    _gather_inbound_rtp_packageLossRate: function _gather_inbound_rtp_packageLossRate(dataArray) {
        if (!dataArray || dataArray.length === 0) {
            return 0;
        }

        var sum = 0;
        var count = 0;

        if (dataArray.length > 1) {
            for (var i = 1; i < dataArray.length; i++) {
                var data = dataArray[i];
                var predata = dataArray[i - 1];
                if (data.packageLossRate.packetsReceived == predata.packageLossRate.packetsReceived) {
                    sum = 0;
                    count = 0;
                    continue;
                }

                sum = sum + (data.packageLossRate.packetsLost - predata.packageLossRate.packetsLost) / (data.packageLossRate.packetsReceived - predata.packageLossRate.packetsReceived);
                count++;
            }
        }

        if (dataArray.length >= emedia.config.statsSeconds) {
            dataArray.shift();
        }

        return count == 0 ? 0 : sum / count;
    },

    _gatherBytesRate: function _gatherBytesRate(type, subtype, dataArray) {
        if (!dataArray || dataArray.length === 0) {
            return 0;
        }

        var data = dataArray[dataArray.length - 1][subtype] - dataArray[0][subtype]; //byte 字节，不是位
        var time = dataArray[dataArray.length - 1].timestamp - dataArray[0].timestamp;

        if (dataArray.length >= emedia.config.statsSeconds) {
            dataArray.shift();
        }

        return time === 0 ? 0 : parseFloat(data * 1000 / time).toFixed(2);
    },
    _gather: function _gather(type, subtype, dataArray) {
        type = type.replace(/[^\w]/g, "_");
        subtype = subtype.replace(/[^\w]/g, "_");

        var func = _util.list("_gather", type, subtype).join("_");
        if (typeof this[func] === "function") {
            return this[func](dataArray);
        }

        if (subtype.startsWith('bytesRate')) {
            return this._gatherBytesRate(type, subtype, dataArray);
        }

        var data = dataArray.shift();
        return data && data[subtype] || 0;
    },

    _statsCount: function _statsCount() {
        var self = this;

        function gatherByTrack() {
            _util.forEach(self.samplesDatas, function (trackId, _samples) {
                var trackGathers = self.gatherResults[trackId] = self.gatherResults[trackId] || {};
                gatherByType(trackId, trackGathers, _samples);
            });
        }

        function gatherByType(trackId, trackGathers, _trackSamples) {
            _util.forEach(_trackSamples, function (type, _data) {
                var typeGathers = trackGathers[type] || (trackGathers[type] = {});
                gatherBySubtype(trackId, typeGathers, type, _data);
            });
        }

        function gatherBySubtype(trackId, typeGathers, type, _data) {
            _util.forEach(_data, function (subtype, dataArray) {
                var result = typeGathers[subtype] = self._gather(type, subtype, dataArray);
                self._onGatherResult(trackId, type, subtype, result);
            });
        }

        gatherByTrack();
    },

    gather: function gather() {
        this.gatherWebrtc();
        this._statsCount();
    },

    intervalGather: function intervalGather(intervalMillis) {
        this._intervalId && clearInterval(this._intervalId);
        this._intervalId = setInterval(this.gather.bind(this), intervalMillis || 1000);
    },

    stopIntervalGather: function stopIntervalGather() {
        this._intervalId && clearInterval(this._intervalId);
    }
});

var statsMap = {};
var echo = PCStats.echo = function (hxStreams) {
    _util.forEach(hxStreams, function (_k, _stream) {
        if (!statsMap[_stream.id] && _stream._webrtc && !_stream._webrtc.closed && _stream.getMediaStream()) {

            var pcstats;
            statsMap[_stream.id] = pcstats = new PCStats({ _webrtc: _stream._webrtc });
            pcstats._mediaStream = _stream.getMediaStream();
        } else if (statsMap[_stream.id] && (!_stream._webrtc || _stream._webrtc.closed || !_stream.getMediaStream())) {
            _util.removeAttribute(statsMap, _stream.id);
        }
    });

    var clearStats = [];
    _util.forEach(statsMap, function (_sid, stats) {
        if (!hxStreams || !hxStreams[_sid]) {
            clearStats.push(_sid);
        } else {
            stats.gatherWebrtcMediaStream(stats._mediaStream);
            stats._statsCount();
        }
    });

    _util.forEach(clearStats, function (_index, _sid) {
        _util.removeAttribute(statsMap, _sid);
    });
};

PCStats.intervalEcho = function (hxStreams, intervalMillis) {
    return setInterval(function () {
        echo(hxStreams);
    }, intervalMillis);
};

_util.forEach(["inbound", "outbound"], function (_typeIndex, gatherType) {
    _util.forEach(["Audio", "Video"], function (_trackTypeIndex, trackType) {
        (function gather(gatherType, trackType) {
            var _gatherTrack;
            PCStats[gatherType + trackType] = _gatherTrack = function gatherTrack(hxStream, onNotify, intervalMillis) {
                _gatherTrack.__intervalIds || (_gatherTrack.__intervalIds = {});

                var service;
                if (this instanceof emedia.XService) {
                    service = this;
                } else {
                    service = emedia.useCurrentXService;
                }

                var index = hxStream.id + "___" + service.namespace;

                var intervalId = _gatherTrack.__intervalIds && _gatherTrack.__intervalIds[index];
                intervalId && clearInterval(intervalId);

                intervalId = setInterval(function () {
                    var pcstats = _gatherTrack[index];
                    if (!pcstats && hxStream && hxStream._webrtc && !hxStream._webrtc.closed && hxStream.getMediaStream()) {

                        _gatherTrack[index] = pcstats = new PCStats({
                            _webrtc: hxStream._webrtc,
                            _inbound_: gatherType === "inbound",
                            _outbound_: gatherType === "outbound"
                        });
                        pcstats._service = service;
                        onNotify && (pcstats.onGatherResult = onNotify);
                        pcstats._mediaStream = hxStream.getMediaStream();
                    } else if (pcstats && (!hxStream || !hxStream._webrtc || hxStream._webrtc.closed || hxStream._webrtc.__id !== pcstats._webrtc.__id || !hxStream.getMediaStream() || !pcstats._mediaStream || pcstats._mediaStream.id !== hxStream.getMediaStream().id)) {
                        _util.removeAttribute(_gatherTrack, index);
                        pcstats = null;
                    }

                    if (!pcstats) {
                        var cacheStream;
                        if (hxStream && service && (cacheStream = service.getStreamById(hxStream.id))) {
                            hxStream = cacheStream;
                        } else {
                            intervalId && clearInterval(intervalId);
                        }

                        return;
                    }

                    pcstats.gatherWebrtcMediaStream(pcstats._mediaStream, trackType);
                    pcstats._statsCount();
                }, intervalMillis);

                _gatherTrack.__intervalIds[index] = intervalId;

                return intervalId;
            };
        })(gatherType, trackType);
    });
});

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _util = __webpack_require__(72);
var _logger = _util.tagLogger("DefaultTrack");

var MouseTrack = __webpack_require__(221);

function zoomCanvas(canvas, width, height) {
    var canvasContext = canvas.getContext("2d");

    var _width = canvas.width,
        _height = canvas.height;

    canvasContext.scale(_width / width, _height / height);
    _logger.warn("Canvas scale", _width / width, _height / height, width, height);
    var imageData = canvasContext.getImageData(0, 0, _width, _height);

    canvas.width = width;
    canvas.height = height;

    canvasContext.putImageData(imageData, 0, 0);
}

function initCanvas(_target) {
    var _canvas;
    _canvas = document.createElement("canvas");
    _target.appendChild(_canvas);

    _canvas.style.cssText = "position: absolute; background: transparent; width: 100%; height: 100%";

    _canvas.width = _target.offsetWidth;
    _canvas.height = _target.offsetHeight;
    _logger.warn("Canvas", _canvas.width, _canvas.height);

    // if(initCanvas.timeoutId === undefined){
    //     var targetElement = _target.onresize ? _target : window;
    //     _util.addEvent(targetElement, "resize", function () {
    //         if(initCanvas.timeoutId){
    //             clearTimeout(initCanvas.timeoutId);
    //         }
    //
    //         initCanvas.timeoutId = setTimeout(function () {
    //             initCanvas();
    //             initCanvas.timeoutId = null;
    //         }, 500);
    //     });
    // }

    return _canvas;
}

var DefaultMouseTrack;
module.exports = DefaultMouseTrack = MouseTrack.extend({
    __init__: function __init__() {
        this._canvas || (this._canvas = initCanvas(this._target));
        this._canvasContext || (this._canvasContext = this._canvas.getContext("2d"));
    },

    resizeCanvas: function resizeCanvas() {},

    _calPosition: function _calPosition() {
        var xy = MouseTrack.prototype._calPosition.apply(this, arguments);
        xy.x = Math.floor(xy.x * this._canvas.width / xy.width);
        xy.y = Math.floor(xy.y * this._canvas.height / xy.height);

        return xy;
    },

    _draw: function _draw(position, pixelCount, r, g, b, alpha) {
        var self = this;
        //_logger.warn(self._canvas.width, self._canvas.height);

        var canvasContext = self._canvasContext;

        if (!pixelCount || pixelCount <= 1) {
            pixelCount = 2;
        }

        var pixel = canvasContext.getImageData(position.x - pixelCount / 2, position.y - pixelCount / 2, pixelCount, pixelCount);
        var color = function color(imageData, r, g, b, alpha) {
            for (var i = 0, data = imageData.data; i < data.length; i += 4) {
                var rgb = {
                    r: r === undefined ? data[i] : r,
                    g: g === undefined ? data[i + 1] : g,
                    b: b === undefined ? data[i + 2] : b,
                    alpha: alpha === undefined ? data[i + 3] : alpha };

                data[i] = rgb.r; // red
                data[i + 1] = rgb.g; // green
                data[i + 2] = rgb.b; // blue
                data[i + 3] = rgb.alpha;

                //_logger.debug(rgb);
            }
        };
        pixel && color(pixel, r, g, b, alpha);

        canvasContext.putImageData(pixel, position.x, position.y);
    },

    redraw: function redraw(x, y, r, g, b, alpha) {
        var self = this;
        var draw = DefaultMouseTrack.prototype._draw.bind(self);
        draw({ x: x, y: y }, 2);
    },

    onMouseTrigger: function onMouseTrigger(trigger, _lastTrigger) {
        trigger.isLeftKey() && this._draw(trigger.xy, 8, 189, 56, 51, 255);
        trigger.isRightKey() && this._draw(trigger.xy, 8, 45, 23, 189, 255);
        trigger.isWheelKey() && this._draw(trigger.xy, 8, 58, 189, 76, 255);
    },

    onMouseTrack: function onMouseTrack(position, lastPosition, lastTrigger) {
        this._draw(position, 2, 227, 18, 247, 255);
    }

    // onMouseTrack2: function (position, lastPosition, lastTrigger) {
    //     var self = this;
    //     //_logger.warn(self._canvas.width, self._canvas.height);
    //
    //     self._canvasContext || (self._canvasContext = self._canvas.getContext("2d"));
    //
    //     var canvasContext = self._canvasContext;
    //
    //     var pixel = canvasContext.getImageData(position.x - 1, position.y - 1, 3, 3);
    //     var rgb;
    //     var color = function(imageData, r, g, b, alpha) {
    //         rgb = {r: r, g: g, b: b, alpha: alpha};
    //         for (var i = 0, data = imageData.data; i < data.length; i += 4) {
    //             data[i]     = r === undefined ? 0 : r; // red
    //             data[i + 1] = g === undefined ? 0 : g; // green
    //             data[i + 2] = b === undefined ? 0 : b; // blue
    //             data[i + 3] = alpha === undefined ? 255 : alpha;
    //         }
    //     };
    //     pixel && color(pixel, 189, 56, 51);
    //     lastTrigger.isRightKey() && pixel && color(pixel, 45, 23, 189);
    //     lastTrigger.isWheelKey() && pixel && color(pixel, 58, 189, 76);
    //
    //     if(!lastPosition){
    //         canvasContext.putImageData(pixel, position.x, position.y);
    //     }
    //
    //
    //     function line() {
    //         canvasContext.lineWidth = 2;
    //         canvasContext.beginPath();
    //         canvasContext.strokeStyle = _util.list('rgb(', rgb.r, ",", rgb.g, ",", rgb.b, ")").join("");
    //         canvasContext.moveTo(lastPosition ? lastPosition.x : position.x, lastPosition ? lastPosition.y : position.y);
    //         canvasContext.lineTo(position.x, position.y);
    //
    //         canvasContext.stroke();
    //         canvasContext.closePath();
    //     }
    //
    //     if(lastPosition){
    //         line();
    //     }
    // }
});

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _util = __webpack_require__(72);
var _logger = _util.tagLogger("MouseTrack");

var MouseTrigger = __webpack_require__(222);

module.exports = _util.prototypeExtend({
    _scale: 1,
    //_target
    //_referenceVideo

    __init__: function __init__() {
        var self = this;
    },

    getTargetPageXY: function getTargetPageXY() {
        var self = this;
        return self._target && _util.extend({}, _util.getDomPageRect(self._target));
    },

    onMouseTrack: function onMouseTrack(position, lastPosition, lastTrigger) {
        //_logger.warn(position.x, position.y);
    },

    onMouseTrigger: function onMouseTrigger(trigger, _lastTrigger) {},

    _onMouseTrack: function _onMouseTrack(position, lastPosition, _lastTrigger) {
        this.onMouseTrack && this.onMouseTrack(position, lastPosition, _lastTrigger);
    },

    _onMouseTrigger: function _onMouseTrigger(trigger, _lastTrigger) {
        this.onMouseTrigger && this.onMouseTrigger(trigger, _lastTrigger);
    },

    track: function track(pos) {
        var self = this;

        var pageXY = pos = _util.extend({}, pos);

        var _elementPageXY = self.getTargetPageXY();
        _elementPageXY && (pos = self._calPosition(pos), pageXY = {
            x: pos.x,
            y: pos.y,
            pageX: _elementPageXY.x + pos.x,
            pageY: _elementPageXY.y + pos.y
        });

        self._onMouseTrack(pageXY, self._lastPageXY, self._lastTrigger);
        self._lastPageXY = pageXY;
    },

    trigger: function trigger(_trigger) {
        var self = this;

        _trigger = new MouseTrigger(_trigger);

        var _elementPageXY = self.getTargetPageXY();

        var pos;
        _elementPageXY && (pos = self._calPosition(_trigger.xy), _trigger.xy = {
            x: pos.x,
            y: pos.y,
            pageX: _elementPageXY.x + pos.x,
            pageY: _elementPageXY.y + pos.y
        });
        _trigger._time || (_trigger._time = new Date().getTime());

        self._onMouseTrigger(_trigger, self._lastTrigger);
        self._lastTrigger = _trigger;
    },

    releaseTrigger: function releaseTrigger() {
        this._lastTrigger = undefined;
        this._lastPageXY = undefined;

        this.onReleaseTrigger && this.onReleaseTrigger(this._lastTrigger);
    },

    /**
     *
     *
     * @param mousePos
     * @private
     */
    _calPosition: function _calPosition(mousePos) {
        var self = this;

        if (self._referenceVideo) {
            mousePos = emedia.Service.prototype.eventXYAtVideo.call(null, mousePos, self._referenceVideo);
        }

        var _elementPageXY = self.getTargetPageXY();
        if (!_elementPageXY) {
            return mousePos;
        }

        if (_util.isFloat(mousePos.x) && mousePos.width !== undefined) {
            //比率
            mousePos.x = mousePos.x * mousePos.width * self._scale * (_elementPageXY.width / mousePos.width);
        }
        if (_util.isFloat(mousePos.y) && mousePos.height !== undefined) {
            //比率
            mousePos.y = mousePos.y * mousePos.height * self._scale * (_elementPageXY.height / mousePos.height);
        }

        if (_util.isFloat(mousePos.x) && mousePos.width === undefined) {
            //比率
            mousePos.x = mousePos.x * self._scale * _elementPageXY.width;
        }
        if (_util.isFloat(mousePos.y) && mousePos.height === undefined) {
            //比率
            mousePos.y = mousePos.y * self._scale * _elementPageXY.height;
        }

        if (_util.isInt(mousePos.x) && mousePos.width !== undefined) {
            mousePos.x = mousePos.x * self._scale * (_elementPageXY.width / mousePos.width);
        }
        if (_util.isInt(mousePos.y) && mousePos.height !== undefined) {
            mousePos.y = mousePos.y * self._scale * (_elementPageXY.height / mousePos.height);
        }

        if (_util.isInt(mousePos.x) && mousePos.width === undefined) {
            mousePos.x = mousePos.x * self._scale;
        }
        if (_util.isInt(mousePos.y) && mousePos.height === undefined) {
            mousePos.y = mousePos.y * self._scale;
        }

        var x = Math.floor(mousePos.x);
        var y = Math.floor(mousePos.y);

        if (x < 0) {
            x = _elementPageXY.width + x;
        }
        if (y < 0) {
            y = _elementPageXY.width + y;
        }

        return { x: x, y: y, width: _elementPageXY.width, height: _elementPageXY.height };
    }
});

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _util = __webpack_require__(72);
var _logger = _util.tagLogger("MouseTrigger");

var BTN = {
    LEFT: 1,
    WHEEL: 2,
    RIGHT: 4,

    WHEEL_ROLL_UP: 8,
    WHEEL_ROLL_DOWN: 16,

    KEY_UP: 0,
    KEY_DOWN: 1,
    MOVE: 2,

    KEYBOARD_DOWN: 3,
    KEYBOARD_UP: 4

    /**
     *
     * {
     *  xy: eventXY,
     *  oper: oper,
     *  btn: button,
     *  _time: _time
     * }
     *
     *
     */
};module.exports = _util.prototypeExtend({
    _timeoutMillis: 500,
    _time: new Date().getTime(),

    isKeyup: function isKeyup() {
        return BTN.KEY_UP == this.oper;
    },
    isKeydown: function isKeydown() {
        return BTN.KEY_DOWN == this.oper;
    },
    isWheelup: function isWheelup() {
        return BTN.WHEEL_ROLL_UP == this.btn;
    },
    isWheeldown: function isWheeldown() {
        return BTN.WHEEL_ROLL_DOWN == this.btn;
    },
    isLeftKey: function isLeftKey() {
        return BTN.LEFT == this.btn;
    },
    isRightKey: function isRightKey() {
        return BTN.RIGHT == this.btn;
    },
    isWheelKey: function isWheelKey() {
        return BTN.WHEEL == this.btn;
    },
    isWheelRoll: function isWheelRoll() {
        return this.isWheeldown() || this.isWheelup();
    },

    timeout: function timeout() {
        var cur = new Date().getTime();
        return cur - this._time >= this._timeoutMillis;
    },

    _toString: function _toString() {
        return _util.list("btn:", this.btn, ", oper:", this.oper, ", timeout:", this.timeout(), ", at (", this.xy.x, ", ", this.xy.y, ")").join("");
    }
});

module.exports.BTN = BTN;

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _stringify = __webpack_require__(144);

var _stringify2 = _interopRequireDefault(_stringify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _util = __webpack_require__(72);
var _logger = _util.tagLogger("AddonsP2P");

var __event = __webpack_require__(208);

/**
 *
 * 对于视频流，往往 会出现 多个流 共用一个webrtc情况
 *
 *
 * @type {{}}
 * @private
 */

var addonsSession = function addonsSession(Session) {
    var NewSession = Session.extend({

        postMessage: function postMessage(message, callback) {
            var self = this;

            var tsxId = message.tsxId;
            if (!message.tsxId) {
                tsxId = message.tsxId = "MSG" + Date.now() + "-" + emedia.__session_globalCount++;
            }

            Session.prototype.postMessage.call(self, message, callback);

            (function (tsxId) {
                var attendee = self.owner;
                if (attendee.isP2P() && self._callbacks[tsxId]) {
                    setTimeout(function () {
                        var _sentMessage = self._callbacks[tsxId];
                        if (_sentMessage && _sentMessage.op === 1004) {
                            var rsp = self.newMessage({
                                op: 1001,
                                tsxId: _sentMessage.tsxId,
                                memId: _sentMessage.memId,
                                result: 0,
                                msg: "3000ms not recv response. will success callback. " + _sentMessage.tsxId
                            });
                            self.onMessage(rsp);
                        }
                    }, 3000);
                }
            })(tsxId);
        },

        __modifyMessageForPost: function __modifyMessageForPost(message) {
            var self = this;

            message = Session.prototype.__modifyMessageForPost.call(self, message);

            var attendee = self.owner;
            if (attendee.isP2P()) {
                if (message.op === 102 || message.op === 105) {
                    //缓存  回调推流成功
                    var rsp = self.newMessage({
                        op: 1001,
                        tsxId: message.tsxId,
                        memId: message.memId,
                        result: 0,
                        streamId: message.rtcId + (attendee.isCaller() ? "__Caller" : "__Callee"),
                        sver: 1
                    });

                    setTimeout(function () {
                        self.onMessage(rsp);
                    }, 100);

                    if (!message._cached_) {
                        var cacheMessage = _util.extend({ _cached_: true }, message);
                        _util.removeAttribute(cacheMessage, "tsxId");
                        message.op === 102 && (attendee.__cache_[message.rtcId] = []).push(cacheMessage);
                        message.op === 105 && attendee.__cache_[message.rtcId] && attendee.__cache_[message.rtcId].push(cacheMessage);
                        attendee.__cache_[message.rtcId] && (attendee.__cache_[message.rtcId].selfId = attendee.getMemberId());
                    }
                }

                _util.removeAttribute(message, "_cached_");

                if (message.memId) {
                    var p2pMessage = self.newMessage({
                        op: 1004,
                        sessId: _util.removeAttribute(message, "sessId"),
                        memId: _util.removeAttribute(message, "memId"),
                        tsxId: _util.removeAttribute(message, "tsxId"),
                        arg: (0, _stringify2.default)(message)
                    });

                    message = p2pMessage;
                }

                switch (message.op) {
                    case 205:
                        var rsp = self.newMessage({
                            op: 1001,
                            tsxId: message.tsxId,
                            result: 0
                        });

                        setTimeout(function () {
                            self.onMessage(rsp);
                        }, 50);

                        return;
                    case 102:
                    case 104:
                    case 105:
                    case 106:
                    case 107:
                        if (message.endReason === -10) {
                            return;
                        }
                    case 1001:
                    case 400:
                        var p2pMessage = self.newMessage({
                            op: 1004,
                            sessId: _util.removeAttribute(message, "sessId"),
                            tsxId: _util.removeAttribute(message, "tsxId"),
                            arg: (0, _stringify2.default)(message)
                        });

                        message = p2pMessage;

                        break;

                    case 303:
                    case 206:
                        return;

                    default:
                }
            }

            return message;
        },

        onP2PMessage: function onP2PMessage(evt) {
            var self = this;
            var attendee = self.owner;

            if (self.owner.isConfr()) {
                _logger.warn("Recv p2p ctrl message. when CONFR. ignore");
                return;
            }

            var message = JSON.parse(evt.arg);
            message.memId = evt.memId;
            message.tsxId = evt.tsxId;
            message.sessId = evt.sessId;

            if (message.op === 400) {
                message.streamId = message.rtcId + (self.owner.isCaller() ? "__Callee" : "__Caller");
            }

            if (message.op !== 1001) {
                var rsp = self.newMessage({
                    op: 1001,
                    tsxId: evt.tsxId,
                    memId: evt.memId,
                    sessId: evt.sessId,
                    result: 0,
                    msg: "Web sdk success recv"
                });

                if (message.op === 102 || message.op === 105) {
                    _util.extend(rsp, {
                        streamId: message.rtcId + (attendee.isCaller() ? "__Callee" : "__Caller"),
                        sver: 1
                    });
                }

                self.postMessage(rsp);
            }

            (function (message) {
                setTimeout(function () {
                    self.onMessage(message);
                }, 10);
            })(message);
        }
    });

    _util.extend(NewSession.prototype._events, {
        '1004': 'onP2PMessage'
    });

    return NewSession;
};

var addonsAttendee = function addonsAttendee(Attendee) {
    var NewAttendee = Attendee.extend({
        __init__: function __init__() {
            var self = this;
            Attendee.prototype.__init__.call(self);

            self.__cache_ = {};

            var extIceRebuild = self.iceRebuild;
            self.iceRebuild = function (stream) {
                var self = this;

                if (!self.isP2P() || !stream.rtcId) {
                    extIceRebuild.call(self, stream);
                    return;
                }

                if (stream._webrtc && stream._webrtc.answerWebrtc === true) {
                    _logger.warn("Stream not auto iceRebuild. caused by answer webrtc. it = ", stream.id, stream);
                    return;
                }

                if (!stream.located()) {
                    //被叫 rtcId 不自动重建；所有的订阅流不自动重建；
                    _logger.warn("Stream not auto iceRebuild. caused by not located. it = ", stream.id, stream);
                    return;
                }

                // stream.isRepublished = true;
                // self.push(stream, undefined, undefined, true);
                extIceRebuild.call(self, stream);
            };
        },

        onEnter: function onEnter(cver, mem) {
            var self = this;
            try {
                Attendee.prototype.onEnter.call(self, cver, mem);
            } finally {
                if (!self.isP2P() || !(mem = self._cacheMembers[mem.id])) {
                    //不是p2p 或者 没有 member
                    return;
                }
                _util.forEach(self.__cache_, function (rtcId, cacheMessages) {
                    if (cacheMessages.answered !== true) {
                        _util.forEach(cacheMessages, function (index, cacheMessage) {
                            (function (cacheMessage) {
                                cacheMessage.memId = mem.id;
                                self.postMessage(cacheMessage);
                            })(cacheMessage);
                        });
                    }
                });
            }
        },

        rejectAnswer: function rejectAnswer(memId, rtcId, endReason, rspFail) {
            var self = this;

            var termC = self.newMessage().setOp(107).setRtcId(rtcId).setMemId(memId).setEndReason(endReason);

            self.postMessage(termC, function (rsp) {
                if (rsp.result != 0) {
                    self.onEvent(new __event.RspFail({ request: termC, response: rsp }));
                    rspFail && rspFail(new __event.RspFail({ request: termC, response: rsp }));

                    return;
                }
            });
        },

        closeWebrtc: function closeWebrtc(rtcId, remainLocalStream, serverClosed) {
            var self = this;

            var failed = false;

            if (self.isP2P()) {
                var _webrtc = self._ices[rtcId];
                if (_webrtc) {
                    var state = _webrtc.iceConnectionState();
                    failed = state === 'failed';
                    failed = failed && _webrtc._rebuildCount < emedia.config.iceRebuildCount;

                    _logger.warn("Webrtc state failed. it is ", rtcId, _webrtc._rebuildCount, emedia.config.iceRebuildCount, _webrtc.__id);
                }
            }

            //p2p failed认为服务端关闭，不发送 107.
            Attendee.prototype.closeWebrtc.call(self, rtcId, remainLocalStream, serverClosed || failed);

            if (self.isP2P()) if (!serverClosed && failed) {
                //p2p failed 需要重连 所以需要将 steam重新添加到_linkedStreams中
                //换句话说 需要重建RTC必须 _linkedStreams中有值
                _util.forEach(self._cacheStreams, function (sid, _stream) {
                    if (_stream.rtcId === rtcId) {
                        self._linkedStreams[sid] = _stream;
                        _logger.warn("Reput stream to _linkedStreams", sid);
                    }
                });
            }

            // p2p时 ice close 可以认为 流 已经关闭，移除流
            if (self.isP2P() && !remainLocalStream) {
                _util.removeAttribute(self.__cache_, rtcId);

                var _tmp = _util.extend({}, self._cacheStreams);

                _util.forEach(_tmp, function (streamId, stream) {
                    if (rtcId === stream.rtcId) {
                        _util.removeAttribute(self._linkedStreams, stream.id);
                        var rmStream = _util.removeAttribute(self._cacheStreams, stream.id);
                        self._streamAutomators && _util.removeAttribute(self._streamAutomators, stream.id);
                        _logger.warn("P2P close webrtc. remove stream from _cacheStreams. it = ", stream.id, stream);

                        if (rmStream._localMediaStream) {
                            self._service._stopTracks(rmStream._localMediaStream);
                        }

                        if (self.onRemoveStream) {
                            var stream = self.newStream(stream);

                            self.onRemoveStream(stream);
                        }
                    }
                });
            }
        },

        subscribeStream: function subscribeStream(rtcId, streamId, rspFail, subArgs) {
            var self = this;

            if (!self.isP2P()) {
                Attendee.prototype.subscribeStream.call(self, rtcId, streamId, rspFail, subArgs);
                return;
            }

            // throw "P2P not allow call subscribeStream";
            var webrtc = self._ices[rtcId];

            var subStream = self._cacheStreams[streamId];

            //var stream = self.newStream(subStream);
            var stream = subStream;
            stream.updateAttributes({
                _webrtc: webrtc,
                rtcId: rtcId
            });

            subArgs = subArgs || { subSVideo: true, subSAudio: true };
            stream.updateAttributes({
                subArgs: stream.subArgs || { subSVideo: true, subSAudio: true }
            });
            stream._webrtc && stream._webrtc.setSubArgs(stream._webrtc.subArgs || { subSVideo: true, subSAudio: true });

            if (!stream.subArgs.subSVideo && subArgs.subSVideo && stream.voff) {
                _logger.error("Sub not allow. stream voff");
                throw "Sub not allow. stream voff";
            }

            if (!stream.subArgs.subSAudio && subArgs.subSAudio && stream.aoff) {
                _logger.error("Sub not allow. stream aoff");
                throw "Sub not allow. stream aoff";
            }

            if (stream.subArgs.subSVideo && !subArgs.subSVideo && !stream.voff && emedia.isSafari) {
                _logger.error("Sub not allow. safari close sub video. will error");
                throw "Sub not allow. safari close sub video. will error";
            }

            subArgs && stream._webrtc && stream._webrtc.setSubArgs(subArgs);
            subArgs && stream.updateAttributes({ subArgs: subArgs });

            var evt = new __event.SubSuccess({
                stream: stream,
                hidden: true
            });
            self._updateRemoteStream(stream, stream._webrtc.getRemoteStream());
            self.onEvent(evt);
        },

        unsubscribeStream: function unsubscribeStream(streamId) {
            var self = this;

            if (!self.isP2P()) {
                Attendee.prototype.unsubscribeStream.call(self, streamId);
                return;
            }
        },

        onPub: function onPub(cver, memId, pubS) {
            var self = this;

            if (!self.isP2P()) {
                Attendee.prototype.onPub.call(self, cver, memId, pubS);
                return;
            }

            var stream = Attendee.prototype.onPub.call(self, cver, memId, pubS);

            return stream;
        },

        onStreams: function onStreams(cver, streams) {
            var self = this;

            if (!self.isP2P()) {
                Attendee.prototype.onStreams.call(self, cver, streams);
                return;
            }

            _logger.warn("P2P ingrone the onStreams");
        },

        _howDoWebrtcWhenCrtExsitsWebrtc: function _howDoWebrtcWhenCrtExsitsWebrtc(webrtc) {
            var self = this;

            if (!self.isP2P()) {
                Attendee.prototype._howDoWebrtcWhenCrtExsitsWebrtc.call(self, webrtc);
                return;
            }

            self.closeWebrtc(webrtc.getRtcId(), true, true);
        },

        createWebrtcAndSubscribeStream: function createWebrtcAndSubscribeStream(streamId, callbacks, iceServerConfig, subArgs) {
            var self = this;

            if (!self.isP2P()) {
                Attendee.prototype.createWebrtcAndSubscribeStream.call(self, streamId, callbacks, iceServerConfig, subArgs);
                return;
            }

            var self = this;

            callbacks || (callbacks = {});

            var subStream = self._cacheStreams[streamId];
            var subMember = self._cacheMembers[subStream.owner.id];

            //var stream = self.newStream(subStream);
            var stream = subStream;
            subArgs = subArgs || stream.subArgs || { subSVideo: true, subSAudio: true };

            function _onSubFail(evt) {
                _logger.warn("sub stream error", streamId, evt);

                preSubArgs && stream._webrtc && stream._webrtc.setSubArgs(preSubArgs);
                preSubArgs && stream.updateAttributes({ subArgs: preSubArgs });

                evt = new __event.SubFail({
                    stream: stream,
                    hidden: evt.hidden === true,
                    cause: evt
                });

                callbacks && callbacks.onEvent && callbacks.onEvent(evt);
                self.onEvent && self.onEvent(evt);
            }

            var pubStreamVCodes = subStream.vcodes;
            var pubMemberSupportVCodes = subMember.vcodes;
            var selfSupportVCodes = self.supportVCodes;

            var optimalVideoCodecs = self._getOptimalVideoCodecsSubset(pubStreamVCodes, pubMemberSupportVCodes, selfSupportVCodes);

            subArgs = subArgs || stream.subArgs;

            var preSubArgs = stream.subArgs;

            var withoutVideo = !(stream.vcodes && stream.vcodes.length > 0);
            var offerOptions = {
                offerToReceiveAudio: true,
                offerToReceiveVideo: subArgs.subSVideo && withoutVideo
            };

            if (!offerOptions.offerToReceiveAudio && !offerOptions.offerToReceiveVideo) {
                _logger.warn("offerToReceiveAudio == false and offerToReceiveVideo == false");
            }

            var webrtc = self.createWebrtc({
                _rtcId: stream.rtcId,

                iceServerConfig: iceServerConfig,
                optimalVideoCodecs: optimalVideoCodecs,
                offerOptions: offerOptions,

                onGotMediaStream: function onGotMediaStream(remoteMediaStream) {
                    var evt = new __event.SubSuccess({
                        stream: stream,
                        hidden: true
                    });

                    callbacks.onGotRemote && callbacks.onGotRemote(stream);
                    self.onEvent && self.onEvent(evt);
                }
            }, stream.iceRebuildCount);
            var rtcId = webrtc.getRtcId();

            _logger.warn(rtcId, " sub stream ", streamId, optimalVideoCodecs);

            var preWebrtc = stream._webrtc;

            stream.updateAttributes({
                _webrtc: webrtc,
                rtcId: rtcId,
                owner: _util.extend({}, subMember)
            });

            self._ices[rtcId] = webrtc;

            webrtc.answerWebrtc = true;

            subArgs && stream._webrtc && stream._webrtc.setSubArgs(subArgs);
            subArgs && stream.updateAttributes({ subArgs: subArgs });

            function channelSet(localStream) {
                localStream && webrtc.setLocalStream(localStream);
                webrtc.setRemoteDescription(stream.sdp);
                stream.cands && stream.cands.length > 0 && webrtc.addIceCandidate(stream.cands);
            }

            if (rtcId === "rtc-" + self.ticket.confrId) {
                var lastCalleePub = self.__lastCalleePub;

                var calleePub = self._cacheStreams[rtcId + (self.isCaller() ? "__Caller" : "__Callee")];
                var calleePub = new self._service.AVPubstream(calleePub || {
                    constaints: {
                        audio: !stream.aoff,
                        video: !stream.voff
                    }
                });

                preWebrtc && preWebrtc.getLocalStream() && self._service._stopTracks(preWebrtc.getLocalStream());

                self._service.openUserMedia(calleePub).then(function () {
                    var stream = self.newStream(calleePub);

                    stream.updateAttributes({
                        _localMediaStream: calleePub.localStream,
                        _webrtc: webrtc,
                        rtcId: webrtc.getRtcId(),
                        id: rtcId + (self.isCaller() ? "__Caller" : "__Callee"),
                        owner: { id: self.getMemberId(), nickName: self.nickName, name: self.sysUserId, ext: self.extObj }
                    });

                    self.onEvent(new __event.PushSuccess({ stream: stream, hidden: true }));

                    channelSet(calleePub.localStream);
                    self.answerCall(rtcId, calleePub, _onSubFail);
                }, _onSubFail);
            } else {
                channelSet();
                self.answer(rtcId, _onSubFail);
            }
        }
    });

    return NewAttendee;
};

var addonsService = function addonsService(Service, Session, Attendee) {
    var NewService = Service.extend({
        Session: Session,
        Attendee: Attendee,

        __init__: function __init__() {
            var self = this;
            Service.prototype.__init__.call(self);

            if (self.useRTCCfg === undefined || self.useRTCCfg === false || self.useRTCCfg === null) {
                self.useRTCCfg = emedia.config.forceUseRTCCfgIfServerReturnWhenP2P;
            }
        },

        push: function push(pubS, pushed, onPushError) {
            var self = this;

            if (self.current && self.current.isP2P()) {
                if (pubS.type === 2) {
                    _logger.error("P2P do not allow audio_mixer");
                    throw "P2P do not allow audio_mixer";
                }

                if (pubS instanceof self.AVPubstream && !pubS.rtcId) {
                    // 主叫 如果没有主RTC, 将创建
                    var p2pAV = self.current._cacheStreams["rtc-" + self.current.ticket.confrId + "__Caller"] || self.current._cacheStreams["rtc-" + self.current.ticket.confrId + "__Callee"];

                    if (!p2pAV) {
                        pubS.rtcId = "rtc-" + self.current.ticket.confrId;
                    }
                }
            }

            Service.prototype.push.call(self, pubS, pushed, onPushError);
        },

        newSession: function newSession(attendee, ticket) {
            var self = this;

            var session = Service.prototype.newSession.call(self, attendee, ticket);
            var preOnTermC = session.onTermC;
            var preOnAnsC = session.onAnsC;

            return _util.extend(session, {
                onInitC: function onInitC(message) {
                    if (!attendee.isP2P()) {
                        return;
                    }

                    if (message.rtcId === "rtc-" + attendee.ticket.confrId) {
                        //收到主呼叫
                        var streamId = message.rtcId + (attendee.isCaller() ? "__Callee" : "__Caller");
                        var _stream = attendee._cacheStreams[streamId];
                        if (_stream && _stream.owner && _stream.owner.id !== message.memId) {
                            attendee.rejectAnswer(message.memId, message.rtcId, 10);
                            attendee.postMessage(attendee.newMessage({
                                op: 1001,
                                memId: message.memId,
                                tsxId: message.tsxId,
                                result: -554,
                                msg: "Other device call it. you no."
                            }));

                            return;
                        }
                    }

                    //认为 只有一个音视频流，多个桌面共享的流  音视频流双向的。
                    message.pubS.sdp = message.sdp;
                    message.pubS.cands = message.cands;
                    message.pubS.id = message.rtcId + (attendee.isCaller() ? "__Callee" : "__Caller");
                    message.pubS._located = false;
                    message.pubS.memId = message.memId;
                    message.pubS.rtcId = message.rtcId;
                    message.pubS.sver = 0;

                    var _stream = attendee._cacheStreams[message.pubS.id];
                    if (_stream) {
                        message.pubS.sver = _stream.sver + 1;
                        _util.removeAttribute(attendee._maybeNotExistStreams, message.pubS.id);
                    }
                    attendee.onPub.call(attendee, ++attendee._cver, message.memId, message.pubS);
                },

                onTermC: function onTermC(evt) {
                    if (!attendee.isP2P()) {
                        preOnTermC.call(attendee, evt);
                        return;
                    }

                    if (evt.endReason === -20) {
                        var callerPub = attendee._cacheStreams[evt.rtcId + "__Caller"];

                        _logger.warn("Begin re-publish. 20", callerPub);
                        callerPub && self._republish(callerPub);

                        return;
                    }

                    // memId 不相等说明 来自 p2p的对方
                    // 意思是 evt.memId 关闭了一个 rtcId
                    if (evt.memId && evt.memId !== attendee.getMemberId()) {
                        // 由于流集合中，所有的发布流均有个特点，caller __Caller结尾，callee __Callee结尾
                        // 关闭流时，先关闭订阅流，在关闭发布流
                        // 所以做了下排序
                        var sortedStreams = [];
                        _util.forEach(attendee._cacheStreams, function (streamId, stream) {
                            sortedStreams.push(stream);
                        });
                        sortedStreams = sortedStreams.sort(function (a, b) {
                            var result = -1;
                            if (a.id > b.id) {
                                result = 1;
                            }

                            return attendee.isCallee() ? 0 - result : result;
                        });

                        _util.forEach(sortedStreams, function (_index, stream) {
                            // evt.memId 关闭的 evt.rtcId 所关联的流 要关闭
                            if (stream && stream.owner && stream.owner.id === evt.memId && evt.rtcId === stream.rtcId) {
                                evt.endReason !== -10 && preOnTermC.call(attendee, evt);

                                if (evt.rtcId === "rtc-" + attendee.ticket.confrId) {
                                    attendee.onUnpub(++attendee._cver, evt.memId, stream.id);
                                }

                                if (evt.endReason === 10) {
                                    attendee.onEvent(new __event.OtherDeviceAnswer({ rtcId: evt.rtcId, stream: stream }));
                                }
                            }

                            if (stream && stream.owner && stream.owner.id === attendee.getMemberId() && evt.rtcId === stream.rtcId) {
                                attendee.closeWebrtc(evt.rtcId);
                                attendee.onUnpub(++attendee._cver, stream.owner.id, stream.id);
                            }
                        });
                        return;
                    }

                    evt.endReason !== -10 && preOnTermC.call(attendee, evt);

                    if (evt.endReason === 10) {
                        attendee.onEvent(new __event.OtherDeviceAnswer({ rtcId: evt.rtcId }));
                    }
                },

                onAnsC: function onAnsC(evt) {
                    if (!attendee.isP2P()) {
                        preOnAnsC.call(attendee, evt);
                        return;
                    }

                    if (!attendee.__cache_[evt.rtcId]) {
                        _logger.warn("Webrtc ", evt.rtcId, "not created. drop the answer");

                        return;
                    }

                    if (attendee.__cache_[evt.rtcId].answered === true) {
                        _logger.warn("Webrtc ", evt.rtcId, "had been ansC");

                        attendee.rejectAnswer(evt.memId, evt.rtcId, 10);
                        attendee.postMessage(attendee.newMessage({
                            op: 1001,
                            memId: evt.memId,
                            tsxId: evt.tsxId,
                            result: -554,
                            msg: "Other device sub it. you no."
                        }));

                        return;
                    }

                    try {
                        if (evt.pubS) {
                            var stream = attendee.newStream(evt.pubS);

                            stream.updateAttributes({
                                _webrtc: attendee._ices[evt.rtcId],
                                rtcId: evt.rtcId,
                                id: evt.rtcId + (attendee.isCaller() ? "__Callee" : "__Caller"),
                                owner: attendee._cacheMembers[evt.memId]
                            });

                            if (!attendee._cacheStreams[stream.id]) {
                                attendee.onPub.call(attendee, ++attendee._cver, evt.memId, stream);
                            } else {
                                attendee._cacheStreams[stream.id] = stream;
                            }

                            attendee.onEvent(new __event.SubSuccess({ stream: stream, hidden: true }));
                        }

                        var ansCMember = attendee._cacheMembers[evt.memId];

                        preOnAnsC.call(attendee, evt);

                        _util.forEach(attendee._cacheMembers, function (_memberId, _member) {
                            if (_memberId !== evt.memId && ansCMember.memName === _member.memName) {
                                attendee.rejectAnswer(_memberId, evt.rtcId, 10);
                            }
                        });
                    } finally {
                        attendee.__cache_[evt.rtcId].answered = true;
                    }
                }
            });
        }
    });

    return NewService;
};

module.exports = function (Service) {
    var _Session = Service.prototype.Session || __webpack_require__(207);
    var Session = addonsSession(_Session.extend({}));

    var _Attendee = Service.prototype.Attendee || __webpack_require__(211);
    var Attendee = addonsAttendee(_Attendee.extend({}));

    return addonsService(Service, Session, Attendee);
};

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.outer = undefined;

var _regenerator = __webpack_require__(201);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _assign = __webpack_require__(149);

var _assign2 = _interopRequireDefault(_assign);

var _asyncToGenerator2 = __webpack_require__(204);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _keys = __webpack_require__(178);

var _keys2 = _interopRequireDefault(_keys);

var _extends2 = __webpack_require__(210);

var _extends3 = _interopRequireDefault(_extends2);

var _promise = __webpack_require__(156);

var _promise2 = _interopRequireDefault(_promise);

var _stringify = __webpack_require__(144);

var _stringify2 = _interopRequireDefault(_stringify);

var _Manager = __webpack_require__(225);

var _underscore = __webpack_require__(205);

var _underscore2 = _interopRequireDefault(_underscore);

var _zeptoWebpack = __webpack_require__(146);

var _zeptoWebpack2 = _interopRequireDefault(_zeptoWebpack);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _outer = {};

_Manager.single.onMemberJoin = function (member, confrId) {
    emedia.decodeMemeberName(member);
    this.onMemberJoined(member, _Manager.single._confr(confrId));
};
_Manager.single.onMemberLeave = function (member, reason, confrId) {
    emedia.decodeMemeberName(member);
    this.onMemberExited(member, reason, _Manager.single._confr(confrId));
};
_Manager.single._onRoleUpdated = function (role, confrId) {
    this.onRoleChanged(role, _Manager.single._confr(confrId));
};
_Manager.single._onAddMemberStream = function (stream, confrId) {
    stream && emedia.decodeMemeberName(stream.owner);
    this.onStreamAdded(stream.owner, stream, _Manager.single._confr(confrId));
};
_Manager.single._onRemoveMemberStream = function (stream, confrId) {
    stream && emedia.decodeMemeberName(stream.owner);
    this.onStreamRemoved(stream.owner, stream, _Manager.single._confr(confrId));
};
_Manager.single._onUpdateMemberStream = function (stream, constaints, confrId) {
    stream && emedia.decodeMemeberName(stream.owner);
    this.onStreamUpdated && this.onStreamUpdated(stream.owner, stream, constaints, _Manager.single._confr(confrId));
};
_Manager.single.onExit = function (reason, failed, confrId) {
    this.onConferenceExit(reason, failed, _Manager.single._confr(confrId));
};

/**
 * 有人加入会议的回调 返回member
 * @method onMemberJoined
 */
_outer.onMemberJoined = function (member) {};
/**
 * 有人退出的回调 返回member，reason
 * @method onMemberExited
 */
_outer.onMemberExited = function (member, reason) {};
/**
 * 改变角色的回调 返回role
 * @method onRoleChanged
 */
_outer.onRoleChanged = function (role) {};
/**
 * 有媒体流加入的回调 返回role
 * @method onStreamAdded
 */
_outer.onStreamAdded = function (member, stream) {};
/**
 * 有媒体流移除的回调 返回role
 * @method onStreamRemoved
 */
_outer.onStreamRemoved = function (member, stream) {};
/**
 * 退出会议的回调 返回role
 * @method onConferenceExit
 */
_outer.onConferenceExit = function (reason, error) {};

/**
 * 通过ticket加入会议
 * @method joinConferenceWithTicket
 * @param {String} confrId - 会议id
 * @param {String} ticket - 会议ticket
 * @param {String} ext - 扩展
 */
_outer.joinConferenceWithTicket = _Manager.single.joinUseTicket;

/**
 * 通过password加入会议
 * @method joinConference
 * @param {String} confrId - 会议id
 * @param {String} password - 会议密码
 * @param {String} ext - 扩展
 */
_outer.joinConference = _Manager.single.joinUsePassword;

/**
 * 获取会议ticket
 * @method getConferenceTkt
 * @param {String} confrId - 会议id
 * @param {String} password - 会议密码
 */
_outer.getConferenceTkt = _Manager.single.reqTkt;

/**
 * 发布媒体流
 * @method publish
 * @param {Object} constaints - 
 * @param {boolean} audio - 是否发布音频
 * @param {boolean} video - 是否发布视频
 * @param {Object} videoTag - video标签
 * @param {string} ext - 扩展
 */
_outer.publish = function (constaints, videoTag, ext) {
    return _Manager.single.shareVideoWithAudio(constaints.video, constaints.audio, videoTag, ext);
};

/**
 * 取消发布媒体流
 * @method unpublish
 * @param {Object} constaints - 
 * @param {boolean} audio - 是否发布音频
 * @param {boolean} video - 是否发布视频
 * @param {Object} videoTag - video标签
 * @param {string} ext - 扩展
 */
_outer.unpublish = function (stream) {
    return _Manager.single.hungup(stream);
};
//_outer.subscribe = inner.subscribe; //subscribe: function (member, stream, subSVideo, subSAudio, videoTag, confrId)

/**
 * 取消订阅媒体流
 * @method unsubscribe
 * @param {Object} stream - 媒体流
 */
_outer.unsubscribe = function (stream) {
    return _Manager.single.hungup(stream);
};

/**
 * 退出会议
 * @method exitConference
 * @param {boolean} closedSelfConfr - 是否关闭创建的会议，默认false
 */
_outer.exitConference = function (closedSelfConfr) {
    return _Manager.single.exit(closedSelfConfr || false);
};

/**
 * 获取会议信息
 * @method getConferenceInfo
 * @param {string} confrId - 会议id
 * @param {string} password - 会议密码
 */
_outer.getConferenceInfo = function (confrId, password) {
    return _Manager.single.selectConfr(confrId, password);
};

/**
 * 创建会议
 * @method createConference
 * @param {Number} confrType - 会议类型 COMMUNICATION: 10, COMMUNICATION_MIX: 11, LIVE: 12, P2P: 13, INTERCOMM: 14
 * @param {string} password - 会议密码
 * @param {boolean} rec - 是否录制
 * @param {boolean} recMerge - 是否合并
 * @param {boolean} supportWechatMiniProgram - 是否支持小程序
 * @example createConference(emedia.mgr.ConfrType.COMMUNICATION_MIX, pwd, rec, recMerge, suportMiniProgarm)
 */
_outer.createConference = _Manager.single.createConfrSptMnPrg;

/**
 * 改变角色
 * @method grantRole
 * @param {Object} confr - 会议对象
 * @param {Array} members - 会议成员
 * @param {string} role - 角色
 */
_outer.grantRole = function (confr, members, role) {
    // emedia.decodeMemeberName(members); 暂时注释，在 IM 一起的时候，appkey 会被删掉
    return _Manager.single.chanageRoles(role, members, confr.id);
};

/**
 * 降级角色 -- 只能降级
 * @method degradeRole
 * @param {string} confrId - 会议id
 * @param {Array} members - 会议成员
 * @param {string} role - 角色
 */
_outer.degradeRole = function (confrId, members, toRole) {
    if (!confrId) {
        return;
    }
    if (!members || members instanceof Array == false || members.length == 0) {
        console.warn('members is must Array also length > 0');
        return;
    }

    if (!toRole) {
        return;
    }

    var confr = this._confrs[confrId];

    if (!confr) {
        console.warn('confr is not exist');
        return;
    }
    var oldRole = confr.role,
        roleToken = confr.roleToken;


    if (Number(toRole) >= Number(oldRole)) {
        //只能降级操作
        console.warn('only degradeRole,oldRole: ' + oldRole + ' >>> toRole: ' + toRole);
        return;
    }

    var params = {
        type: 'POST',
        url: emedia.config.restPrefix + '/easemob/rtc/role/degrade',
        data: (0, _stringify2.default)({
            roleToken: roleToken,
            uids: members,
            role: toRole
        }),
        contentType: 'application/json'
    };
    return new _promise2.default(function (resolve, reject) {
        $.ajax((0, _extends3.default)({}, params, {
            success: function success(data) {
                if (data.error == 0) {
                    resolve(data);
                } else {
                    reject(data);
                }
            },
            error: function error(_error) {
                reject(_error);
            }
        }));
    });
};
/**
 * 通过id踢出成员
 * @method kickMembersById
 * @param {Object} confr - 会议对象
 * @param {Array} members - 会议成员
 */
_outer.kickMembersById = function (confr, members) {
    // emedia.decodeMemeberName(members); 暂时注释，在 IM 一起的时候，appkey 会被删掉
    return _Manager.single.kickMember(members, confr.id);
};

/**
 * 销毁会议
 * @method destroyConference
 * @param {Object} confr - 会议对象
 */
_outer.destroyConference = function (confr) {
    return _Manager.single.disbandConfr(confr, confr.roleToken);
};
// setConference and deleteConference
function _update_confr_attrs(options) {
    if (!options || (0, _keys2.default)(options).length == 0) {
        console.warn('options is not have');
        return;
    }
    if (!options.key) {
        console.warn('options.key is not have');
        return;
    }

    var key = options.key,
        val = options.val,
        _success = options.success,
        _error2 = options.error,
        type = options.type;


    if (!this.__current_confrId) {
        console.warn('please set_confr_attrs after joined');
        return;
    }
    var roleToken = this._confrs[this.__current_confrId].roleToken;


    if (!roleToken) {
        console.warn('roleToken is not have');
        return;
    }

    var data = {
        roleToken: roleToken,
        cattrs: [{
            key: key,
            val: val,
            op: type
        }]
    };

    $.ajax({
        type: 'POST',
        url: emedia.config.restPrefix + '/easemob/rtc/confr/attrs/update',
        data: (0, _stringify2.default)(data),
        contentType: 'application/json',
        success: function success(data) {
            if (_success && typeof _success == 'function') {
                _success(data);
            }
        },
        error: function error(err) {
            if (_error2 && typeof _error2 == 'function') {
                _error2(err);
            }
        }
    });
}

/**
 * 设置会议属性
 * @method setConferenceAttrs
 * @param {Object} option
 * @param {string} option.key - 自定义属性
 * @param {string} option.val - 自定义属性值
 * @param {function} option.success - 设置成功的回调
 * @param {function} option.error - 设置失败的回调
 */
_outer.setConferenceAttrs = function (options) {
    options.type = 'UPDATE';

    _update_confr_attrs.call(this, options);
};

/**
 * 删除会议属性
 * @method deleteConferenceAttrs
 * @param {Object} option
 * @param {string} option.key - 自定义属性
 * @param {string} option.val - 自定义属性值
 * @param {function} option.success - 删除成功的回调
 * @param {function} option.error - 删除失败的回调
 */
_outer.deleteConferenceAttrs = function (options) {
    options.type = 'DEL';

    _update_confr_attrs.call(this, options);
};
/**
 * 会议状态回调函数
 * @method onConfrStateUpdated
 * @param {Object} confr_state - 会议状态集合
 */
_outer.onConfrStateUpdated = function (confr_state) {

    // 全体静音、全体解除静音功能
    var _this = this;
    var mute_all_action = function mute_all_action() {
        var muteAll = confr_state.muteAll;


        if (muteAll === undefined) {
            return;
        }

        // 没有改变 return
        if (_this._temp_muteAll === undefined) {
            // 没执行过 赋值
            _this._temp_muteAll = muteAll;
        } else {

            if (muteAll === _this._temp_muteAll) {
                return;
            } else {
                _this._temp_muteAll = muteAll;
            }
        }

        if (muteAll) {
            if (_this.onMuteAll && typeof _this.onMuteAll == 'function') {
                _this.onMuteAll();
            }
        } else {
            if (_this.onUnMuteAll && typeof _this.onUnMuteAll == 'function') {
                _this.onUnMuteAll();
            }
        }
    };

    // 主持人不被执行 全体静音和非全体静音
    var confrId = this.__current_confrId;
    if (!confrId) {
        return;
    }

    var service = this._services[confrId];
    if (!service) {
        return;
    }

    var current = service.current;

    if (!current) {
        return;
    }

    if (current.role && current.role != this.Role.ADMIN) {
        //不是主持人 执行全体静音回调
        mute_all_action();
    }
};
/**
 * 创建房间并加入
 * step 1. 创建房间
 * step 2. 获取ticket
 * step 3. joinConfrence
 * */

/**
* 创建房间并加入
* @method joinRoom
* @param {Object} option
* @param {string} option.roomName - 房间名称
* @param {string} option.password - 房间密码
* @param {string} option.role - 进入房间时的角色
* @param {Object} option.config - 进入房间时的拓展配置 rec: 是否录制；recMerge:是否合并；supportWechatMiniProgram：是否支持小程序
*/
_outer.joinRoom = function () {
    var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(options) {
        var create, _this, get_ticket, roomName, password, role, config, memName, token, create_params, room, confrId, get_ticket_params, ticket_info, ticket, _ref2, nickName, ext, isCreator, user_room;

        return _regenerator2.default.wrap(function _callee$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:

                        // 请求 room 接口
                        create = function create(create_params) {
                            var _emedia$config = emedia.config,
                                restPrefix = _emedia$config.restPrefix,
                                appkey = _emedia$config.appkey;


                            if (!appkey) {
                                throw new Error('in joinRoom appkey is not defined');
                            }
                            var org_name = appkey.split('#')[0];
                            var app_name = appkey.split('#')[1];

                            var url = restPrefix + '/' + org_name + '/' + app_name + '/conferences/room';
                            return new _promise2.default(function (resolve, reject) {
                                var ajax_options = {
                                    url: url,
                                    data: (0, _stringify2.default)(create_params),
                                    type: 'POST',
                                    contentType: 'application/json',
                                    success: function success(result) {
                                        if (!result.error) {
                                            resolve(result);
                                        } else {
                                            reject(result);
                                        }
                                    },
                                    error: function error(_error3) {
                                        reject(_error3);
                                    }
                                };
                                $.ajax(ajax_options);
                            });
                        };

                        _this = this;
                        // get_ticket  加入会议之前获取 ticket

                        get_ticket = function get_ticket(get_ticket_params) {

                            var url = emedia.config.restPrefix + "/easemob/rtc/req/ticket" + "?_ct=" + new Date().getTime();
                            if (get_ticket_params.region) {
                                url += '&REGION=' + get_ticket_params.region;
                            }
                            if (get_ticket_params.confrId) {
                                url += '&CONFRID=' + get_ticket_params.confrId;
                            }

                            var params = {
                                type: 'POST',
                                url: url,
                                data: (0, _stringify2.default)(get_ticket_params),
                                contentType: 'application/json',
                                dataType: 'json'
                            };

                            return new _promise2.default(function (resolve, reject) {
                                $.ajax((0, _extends3.default)({}, params, {
                                    success: function success(data) {
                                        if (data.error == 0) {
                                            resolve(data);
                                        } else {
                                            reject(data);
                                        }
                                    },
                                    error: function error(_error4) {
                                        reject(_error4);
                                    }
                                }));
                            });
                        };

                        // 加入房间的参数


                        roomName = options.roomName, password = options.password, role = options.role, config = options.config;
                        memName = this.identityName, token = this.identityToken;

                        if (roomName) {
                            _context.next = 7;
                            break;
                        }

                        throw new Error('the roomName is required at joinRoom');

                    case 7:
                        if (password) {
                            _context.next = 9;
                            break;
                        }

                        throw new Error('the password is required at joinRoom');

                    case 9:
                        if (memName) {
                            _context.next = 11;
                            break;
                        }

                        throw new Error('the memName is required at joinRoom');

                    case 11:
                        if (token) {
                            _context.next = 13;
                            break;
                        }

                        throw new Error('the token is required at joinRoom');

                    case 13:
                        if (role) {
                            _context.next = 15;
                            break;
                        }

                        throw new Error('the role is required at joinRoom');

                    case 15:
                        create_params = (0, _extends3.default)({
                            roomName: roomName,
                            password: password,
                            memName: memName,
                            token: token
                        }, config);

                        if (config && config.supportWechatMiniProgram) {
                            create_params.useVCodes = ['H264', 'VP8'];
                        }

                        _context.next = 19;
                        return create(create_params);

                    case 19:
                        room = _context.sent;
                        // 加入房间

                        confrId = room.confrId;
                        get_ticket_params = {
                            uid: memName,
                            token: token,
                            confrId: confrId,
                            password: password,
                            role: role,
                            terminal: this._terminalInfo
                        };
                        _context.next = 24;
                        return get_ticket(get_ticket_params);

                    case 24:
                        ticket_info = _context.sent;
                        // 获取ticket


                        // 给会议添加 参数
                        ticket_info.mixed = ticket_info.type === 11 || ticket_info.type === 12;
                        ticket_info.id = ticket_info.serverConfrId = ticket_info.confrId = confrId;
                        this._confrs[confrId] = (0, _assign2.default)(this._confrs[confrId] || {}, ticket_info);

                        ticket = ticket_info.ticket;
                        _ref2 = config ? config : {}, nickName = _ref2.nickName, ext = _ref2.ext;
                        // join confrence 通过 ticket 接口

                        isCreator = room.isCreator;
                        _context.next = 33;
                        return _this.joinConferenceWithTicket(confrId, ticket, (0, _extends3.default)({ nickName: nickName }, ext));

                    case 33:
                        user_room = _context.sent;


                        if (isCreator) {
                            // 是否为创建者
                            user_room.isCreator = isCreator;
                        }

                        return _context.abrupt('return', user_room);

                    case 36:
                    case 'end':
                        return _context.stop();
                }
            }
        }, _callee, this);
    }));

    return function (_x) {
        return _ref.apply(this, arguments);
    };
}();

/**
 * 观众申请上麦
 */

_outer.requestToTalker = function (confrId) {

    if (!confrId) {
        console.warn('requestToTalker confrId is required');
        return;
    }

    var service = this._services[confrId];
    service.requestToTalker();
};

/**
 * 申请主持人
 */

_outer.requestToAdmin = function (confrId) {

    if (!confrId) {
        console.warn('requestToTalker confrId is required');
        return;
    }

    var service = this._services[confrId];
    service.requestToAdmin();
};

/**
 * 指定静音通过 memberId
 */
_outer.muteBymemberId = function (confrId, memberId) {
    if (!confrId || !memberId) {
        console.warn('muteBymemberId confrId and memberId is required');
        return;
    }

    var service = this._services[confrId];
    service.muteBymemberId(memberId);
};

/**
 * 指定取消静音通过 memberId
 */
_outer.unmuteBymemberId = function (confrId, memberId) {
    if (!confrId || !memberId) {
        console.warn('muteBymemberId confrId and memberId is required');
        return;
    }

    var service = this._services[confrId];
    service.unmuteBymemberId(memberId);
};
// 更新会议状态 接口
function _update_confr_state(roleToken, muteAll) {
    // muteAll: true 全体静音，false:取消全体静音
    var params = {
        type: 'POST',
        url: emedia.config.restPrefix + '/easemob/rtc/confr/attrs/update',
        data: (0, _stringify2.default)({
            roleToken: roleToken,
            cstate: {
                muteAll: muteAll
            }
        }),
        contentType: 'application/json'
    };

    return new _promise2.default(function (resolve, reject) {
        $.ajax((0, _extends3.default)({}, params, {
            success: function success(data) {
                if (data.error == 0) {
                    resolve(data);
                } else {
                    reject(data);
                }
            },
            error: function error(_error5) {
                reject(_error5);
            }
        }));
    });
}

// 全体静音
_outer.muteAll = function (confrId) {

    if (!confrId) {
        throw new Error('muteAll confrId is required');
    }

    var confr = this._confrs[confrId];

    if (!confr) {
        throw new Error('confr is not exist');
    }
    var role = confr.role,
        roleToken = confr.roleToken;


    if (role != 7) {
        //只有管理员能够操作
        throw new Error('only admin can action');
    }
    if (!roleToken) {
        throw new Error('roleToken is not exist');
    }

    var muteAll = true;
    return _update_confr_state.call(this, roleToken, muteAll);
};
// 取消全体静音
_outer.unmuteAll = function (confrId) {
    if (!confrId) {
        throw new Error('unmuteAll confrId is required');
    }

    var confr = this._confrs[confrId];

    if (!confr) {
        throw new Error('confr is not exist');
    }
    var role = confr.role,
        roleToken = confr.roleToken;


    if (role != 7) {
        //只有管理员能够操作
        throw new Error('only admin can action');
    }
    if (!roleToken) {
        throw new Error('roleToken is not exist');
    }

    var muteAll = false;
    return _update_confr_state.call(this, roleToken, muteAll);
};
// 多路推流 
_outer.addLive = function (confrId, liveCfg) {
    if (!confrId) {
        throw new Error('addLive confrId is required');
    }
    if (!liveCfg) {
        throw new Error('addLive liveCfg is required');
    }

    var confr = this._confrs[confrId];

    if (!confr) {
        throw new Error('confr is not exist');
    }
    var role = confr.role,
        roleToken = confr.roleToken;


    if (role != 7) {
        throw new Error('only admin can addLive');
    }
    if (!roleToken) {
        throw new Error('addLive roleToken is required');
    }

    var url = emedia.config.restPrefix + '/easemob/rtc/livecfg';
    var params = {
        confrId: confrId,
        roleToken: roleToken,
        liveCfg: liveCfg
    };

    return new _promise2.default(function (resolve, reject) {
        $.ajax({
            url: url,
            type: 'POST',
            data: (0, _stringify2.default)(params),
            contentType: 'application/json',
            dataType: 'json',
            success: function success(data) {
                if (data.error == 0) {
                    resolve(data);
                } else {
                    reject(data);
                }
            },
            error: function error(_error6) {
                reject(_error6);
            }
        });
    });
};
// 推流 CDN 更新布局
_outer.updateLiveLayout = function (confrId, liveId, regions) {
    if (!confrId) {
        throw new Error('updateLiveLayout confrId is required');
    }
    if (!liveId) {
        throw new Error('updateLiveLayout liveId is required');
    }

    if (!regions) {
        throw new Error('updateLiveLayout regions is required');
    }

    var confr = this._confrs[confrId];

    if (!confr) {
        throw new Error('confr is not exist');
    }
    var role = confr.role,
        roleToken = confr.roleToken;


    if (role != 7) {
        throw new Error('only admin can updateLiveLayout');
    }
    if (!roleToken) {
        throw new Error('updateLiveLayout roleToken is required');
    }

    var url = emedia.config.restPrefix + '/easemob/rtc/live/layout';

    var params = {
        confrId: confrId,
        liveId: liveId,
        regions: regions,
        roleToken: roleToken
    };

    return new _promise2.default(function (resolve, reject) {
        $.ajax({
            url: url,
            type: 'POST',
            data: (0, _stringify2.default)(params),
            contentType: 'application/json',
            dataType: 'json',
            success: function success(data) {
                if (data.error == 0) {
                    resolve(data);
                } else {
                    reject(data);
                }
            },
            error: function error(_error7) {
                reject(_error7);
            }
        });
    });
};

// 取消推流 CDN
_outer.deleteLive = function (confrId, liveId) {
    if (!confrId) {
        throw new Error('deleteLive confrId is required');
    }
    if (!liveId) {
        throw new Error('deleteLive liveId is required');
    }

    var confr = this._confrs[confrId];

    if (!confr) {
        throw new Error('confr is not exist');
    }
    var role = confr.role,
        roleToken = confr.roleToken;


    if (role != 7) {
        console.warn('only admin can deleteLive');
        return;
    }
    if (!roleToken) {
        console.error('updateLiveLayout roleToken is required');
        return;
    }

    var url = emedia.config.restPrefix + '/easemob/rtc/delete/live';
    var params = { confrId: confrId, liveId: liveId, roleToken: roleToken };

    return new _promise2.default(function (resolve, reject) {
        $.ajax({
            url: url,
            type: 'DELETE',
            data: (0, _stringify2.default)(params),
            contentType: 'application/json',
            dataType: 'json',
            success: function success(data) {
                if (data.error == 0) {
                    resolve(data);
                } else {
                    reject(data);
                }
            },
            error: function error(_error8) {
                reject(_error8);
            }
        });
    });
};

emedia.decodeMemeberName = function (member) {
    if (typeof emedia.decodeMemeberNameString !== "function") {
        return member;
    }

    if (typeof member === 'string') {
        return emedia.decodeMemeberNameString(member);
    }

    if (_underscore2.default.isArray(member)) {
        for (var i = 0; i < member.length; i++) {
            member[i] = emedia.decodeMemeberName(member[i]);
        }
        return member;
    }

    if (member.name) {
        member.globalName = member.name;
        member.memName = member.name = emedia.decodeMemeberName(member.name);
        return;
    }

    if (member.memName) {
        member.globalName = member.memName;
        member.memName = member.name = emedia.decodeMemeberName(member.memName);
        return;
    }
};

/**
 * 会议类型
 * @static
 */
emedia.ConfrType = _Manager.single.ConfrType;

/**
 * 角色
 * @static
 */
emedia.Role = _Manager.single.Role;

/**
 * 媒体流类型
 * @static
 */
emedia.StreamType = _Manager.single.StreamType;

(0, _zeptoWebpack2.default)(function () {
    var WebIM = window.WebIM;

    if (WebIM && WebIM.conn && typeof WebIM.conn.onOpened === "function") {
        // noinspection JSAnnotator
        var useIM = function useIM() {
            emedia.decodeMemeberNameString = function (member) {
                if (typeof member === 'string') {
                    if (member.indexOf(WebIM.conn.orgName) < 0) {
                        return member;
                    }

                    var _index = member.indexOf("_");
                    if (_index < 0) {
                        _index = 0;
                    } else {
                        _index++;
                    }

                    var endIndex = member.indexOf("@");
                    if (endIndex < 0) {
                        endIndex = member.length;
                    }

                    return member.substring(_index, endIndex);
                }

                return member;
            };

            _Manager.single.setIdentity(WebIM.conn.orgName + "#" + WebIM.conn.appName + "_" + WebIM.conn.user, WebIM.conn.token);
            emedia.config({
                appkey: WebIM.conn.appKey,
                restPrefix: WebIM.conn.apiUrl
            });
        };

        var _onOpened = WebIM.conn.onOpened;
        WebIM.conn.onOpened = function () {
            _onOpened.apply(WebIM.conn, arguments);
            useIM();
        };

        if (WebIM.conn.token) {
            useIM();
        };
    }
});

var outer = exports.outer = _underscore2.default.extend(_Manager.single, _outer);

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.single = undefined;

var _regenerator = __webpack_require__(201);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(204);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _extends2 = __webpack_require__(210);

var _extends3 = _interopRequireDefault(_extends2);

var _typeof2 = __webpack_require__(73);

var _typeof3 = _interopRequireDefault(_typeof2);

var _stringify = __webpack_require__(144);

var _stringify2 = _interopRequireDefault(_stringify);

var _promise = __webpack_require__(156);

var _promise2 = _interopRequireDefault(_promise);

var _Util = __webpack_require__(72);

var _Util2 = _interopRequireDefault(_Util);

var _zeptoWebpack = __webpack_require__(146);

var _zeptoWebpack2 = _interopRequireDefault(_zeptoWebpack);

var _underscore = __webpack_require__(205);

var _underscore2 = _interopRequireDefault(_underscore);

var _UploadStats = __webpack_require__(226);

var _UploadStats2 = _interopRequireDefault(_UploadStats);

var _rxjs = __webpack_require__(230);

var _operators = __webpack_require__(332);

var _Stream = __webpack_require__(215);

var _Stream2 = _interopRequireDefault(_Stream);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _logger = _Util2.default.tagLogger("mgr");

window.emedia = window.emedia || {};

var restApis = {
    createConfr: "/easemob/rtc/req/ticket",
    reqTkt: "/easemob/rtc/req/ticket",
    chanageRoles: "/easemob/rtc/chanage/roles",
    disbandConfr: "/easemob/rtc/disband/conference",
    kickMember: "/easemob/rtc/kick/member",
    selectConfr: "/easemob/rtc/select/confr"
};

function Manager() {
    this._confrs = {};
    this._services = {};
    this._events = {};
    this._videos = {};

    // httpDNS
    this.dns_current = 0;
    this.dns_urls = ['https://rs.easemob.com', 'http://182.92.174.78', 'http://112.126.66.111']; // 可以获取多次

    this.restPrefixArr = [];
    this.restIndex = 0;
}

Manager.prototype.ConfrType = {
    COMMUNICATION: 10,
    COMMUNICATION_MIX: 11,
    LIVE: 12,
    P2P: 13,
    INTERCOMM: 14
};

Manager.prototype.Role = {
    ADMIN: 7,
    TALKER: 3,
    AUDIENCE: 1
};

Manager.prototype.StreamType = {
    VIDEO: 0,
    DESKTOP: 1,
    MIXVIDEO: 2
};

var _ajax = function _ajax(ajaxUrl, confrArgs) {
    return new _promise2.default(function (resolve, reject) {
        _zeptoWebpack2.default.ajax({
            type: 'POST',
            url: ajaxUrl,
            data: (0, _stringify2.default)(confrArgs),
            contentType: 'application/json',
            dataType: 'json',
            success: function success(data, status, xhr) {
                _logger.debug("REST: ", data, " -> ", confrArgs, ajaxUrl);
                if (data.error === 0) {
                    _Util2.default.removeAttribute(data, "error");
                    resolve(data);
                } else {
                    _Util2.default.extend(data, { errorType: "server_refuse" });
                    reject(data);
                }
            },
            error: function error(xhr, errorType, _error) {
                var data = {
                    errorType: "http_error",
                    error: xhr.status,
                    errorMessage: _error
                };
                _logger.debug("REST: ", data, " -> ", confrArgs, ajaxUrl);

                reject({
                    errorType: "http_error",
                    error: xhr.status,
                    errorMessage: _error
                });
            }
        });
    });
};

var _ajax2 = function _ajax2(ajaxUrl, confrArgs) {

    return function onSubscription(observer) {
        _zeptoWebpack2.default.ajax({
            type: 'POST',
            url: ajaxUrl,
            data: (0, _stringify2.default)(confrArgs),
            contentType: 'application/json',
            dataType: 'json',
            success: function success(data, status, xhr) {
                _logger.debug("REST: ", data, " -> ", confrArgs, ajaxUrl);
                if (data.error === 0) {
                    _Util2.default.removeAttribute(data, "error");
                    observer.next(data);
                    observer.complete();
                } else {
                    _Util2.default.extend(data, { errorType: "server_refuse" });
                    observer.error(data);
                }
            },
            error: function error(xhr, errorType, _error2) {
                var data = {
                    errorType: "http_error",
                    error: xhr.status,
                    errorMessage: _error2
                };
                _logger.debug("REST: ", data, " -> ", confrArgs, ajaxUrl);

                observer.error({
                    errorType: "http_error",
                    error: xhr.status,
                    errorMessage: _error2
                });
            }
        });
    };
};

(function loadApi(_urls) {
    _Util2.default.forEach(_urls, function (api, url) {
        Manager.prototype[api] = function (apiArgs) {
            var _url = url;
            _url = _url + "?_ct=" + new Date().getTime();
            apiArgs.region && (_url = _url + "&REGION=" + apiArgs.region);
            apiArgs.confrId && (_url = _url + "&CONFRID=" + apiArgs.confrId);

            var restURL = this.createUrl(_url, api);
            return _ajax2(restURL, apiArgs);
        };
    });
})(restApis);

// from dnsConfig get restPrefix
Manager.prototype.get_dns_config = function () {
    var _this = this;
    var suc = function suc(data, xhr) {

        var restHosts = data.rest.hosts;
        if (!restHosts) {
            return;
        }

        _this.restPrefixArr = restHosts.filter(function (item) {
            return item.protocol == 'https';
        }); // must https
        _this.update_rest_prefix();
        _this.check_rest_prefix();
    };
    var error = function error(res, xhr, msg) {
        console.log('getHttpDNS error', res, msg);
        _this.dns_current++;
        if (_this.dns_current <= _this.dns_urls.length - 1) {
            _this.get_dns_config();
        }
    };

    var options = {
        url: this.dns_urls[this.dns_current] + '/easemob/server.json',
        dataType: 'json',
        type: 'GET',
        data: {
            app_key: encodeURIComponent(emedia.config.appkey)
        },
        success: suc,
        error: error
    };
    _logger.info('get_dns_config options', options);
    $.ajax(options);
};
Manager.prototype.check_rest_prefix = function () {
    // 验证接口是否能通

    var params = {
        grant_type: "password",
        password: "123456",
        timestamp: new Date().getTime(),
        username: "e432598ea3a34ba8ba196df046efdf90"
    };

    var _this = this;

    var org_name = emedia.config.appkey.split('#')[0];
    var app_name = emedia.config.appkey.split('#')[1];

    var url = emedia.config.restPrefix + '/' + org_name + '/' + app_name + '/token';

    var ajax_options = {
        url: url,
        data: (0, _stringify2.default)(params),
        type: 'POST',
        contentType: 'application/json',
        success: function success() {
            _logger.info('check_rest_prefix success');
        },
        error: function error() {
            _logger.error('check_rest_prefix error rest', emedia.config.restPrefix);
            _this.restIndex++;
            if (_this.restIndex < _this.restPrefixArr.length) {
                _this.update_rest_prefix();
                _this.check_rest_prefix();
            }
        }
    };
    $.ajax(ajax_options);
};
Manager.prototype.update_rest_prefix = function () {
    var item = this.restPrefixArr[this.restIndex];
    var restPrefix = item.protocol + '://' + item.domain;

    emedia.config({ restPrefix: restPrefix });
};
Manager.prototype.createUrl = function (url, api) {
    var restURL = emedia.config && emedia.config.restPrefix || "";
    return restURL + url;
};

Manager.prototype.setUrlCreator = function (creator) {
    this.createUrl = creator.bind(this);
};

Manager.prototype.destroy = function () {};

Manager.prototype.ZeroStream = _Stream2.default.extend({
    __init__: function __init__() {
        var self = this;

        self.type = 2;
        self.id = "0";
        self._located = false;

        self.mutedMuted = false;
    },

    onGotRemoteMediaStream: function onGotRemoteMediaStream(remoteMediaStream) {
        var self = this;

        if (!self.remotePlayAudioObject) {
            var _audioId = "__o_remote_play_audio_" + self.id;

            var audioObject = document.createElement("audio");
            audioObject.style.display = "none";
            audioObject.id = "__o_remote_play_audio_" + self.id;
            audioObject.autoplay = true;
            audioObject.playsinline = true;

            //monitorEvents && monitorEvents(audioObject);

            self.remotePlayAudioObject = audioObject;

            document.body.appendChild(audioObject);
        }

        // self.remotePlayAudioObject.autoplay = true;
        // self.remotePlayAudioObject.playsinline = true;
        self.remotePlayAudioObject.srcObject = remoteMediaStream;

        //window.__$_remoteMediaStream = remoteMediaStream;
    }
});

Manager.prototype.setIdentity = function (identityName, identityToken, extInfo) {

    if (emedia.config.isHttpDNS && !window.WebIM) this.get_dns_config();

    this.identityName = identityName;
    this.identityToken = identityToken;
    this.ext = extInfo;

    this._terminalInfo = {
        "browser": emedia.browser,
        "browserVersion": emedia.browserVersion,
        "version": window._emediaVersion || emedia.config.version,
        "userAgent": emedia.config.userAgent
    };

    _logger.info("set identity: ", identityName, identityToken);
    this.destroy();

    emedia.config({
        autoSub: false,
        onlyEnter: true
    });
};

Manager.prototype.EventsObservable = __webpack_require__(430).default;

var errorHandler = (0, _operators.catchError)(function (err, caught) {
    _logger.error(err);
    throw err;
});

function rxCreateConfr(confrType, password, rec, recMerge) {
    var self = this;

    var region = undefined,
        liveCfg = undefined;
    if (arguments.length >= 0 && (0, _typeof3.default)(arguments[0]) === 'object') {
        var args = arguments[0];

        region = args.region;
        confrType = args.confrType;
        password = args.password;
        rec = args.rec;
        recMerge = args.recMerge;
        liveCfg = args.liveCfg;
    }

    if (typeof confrType === 'string') {
        confrType = parseInt(confrType);
    }

    return _rxjs.Observable.create(Manager.prototype.createConfr.call(self, {
        region: region,
        uid: self.identityName,
        token: self.identityToken,
        confrType: confrType,
        password: password,
        terminal: self._terminalInfo,
        rec: rec,
        recMerge: recMerge,
        liveCfg: liveCfg // 推流CDN 参数
    })).pipe((0, _operators.map)(function (response) {
        response.mixed = response.type === 11 || response.type === 12;
        response.id = response.serverConfrId = response.confrId;
        self._confrs[response.confrId] = _underscore2.default.extend({}, response);

        //_util.removeAttribute(response, "ticket");
        //_util.removeAttribute(response, "roleToken");
        _Util2.default.removeAttribute(response, "rtcCfg");

        return response;
    }), errorHandler);
}

function rxCreateConfrSptMnPrg(confrType, password, rec, recMerge, supportWechatMiniProgram) {
    var self = this;

    var params = {};
    if (arguments.length >= 0 && (0, _typeof3.default)(arguments[0]) === 'object') {
        //对象参数写法
        var create_config = arguments[0];

        params = (0, _extends3.default)({
            uid: self.identityName,
            token: self.identityToken,
            terminal: self._terminalInfo

        }, create_config);
    } else {
        // 单个值类型参数
        params = {
            uid: self.identityName,
            token: self.identityToken,
            terminal: self._terminalInfo,

            confrType: confrType,
            password: password,
            rec: rec,
            recMerge: recMerge,
            supportWechatMiniProgram: supportWechatMiniProgram
        };
    }

    if (params.confrType) {
        // 转为 number 类型
        params.confrType = parseInt(params.confrType);
    }

    if (supportWechatMiniProgram) {
        //支持小程序时，指定编码方式
        params.useVCodes = ['VP8', 'H264'];
    }

    return _rxjs.Observable.create(Manager.prototype.createConfr.call(self, params)).pipe((0, _operators.map)(function (response) {
        response.mixed = response.type === 11 || response.type === 12;
        response.id = response.serverConfrId = response.confrId;
        self._confrs[response.confrId] = _underscore2.default.extend({}, response);

        //_util.removeAttribute(response, "ticket");
        //_util.removeAttribute(response, "roleToken");
        _Util2.default.removeAttribute(response, "rtcCfg");

        return response;
    }), errorHandler);
}

function rxReqTkt(confrId, password) {
    var self = this;

    var role;
    if (arguments.length >= 0 && (0, _typeof3.default)(arguments[0]) === 'object') {
        var args = arguments[0];

        confrId = args.confrId;
        password = args.password;
        role = args.role;
    }

    var confr = self._confr(confrId);

    var apiArgs = {
        uid: self.identityName,
        token: self.identityToken,
        confrId: confr && confr.id || confrId,
        password: password,
        role: role,
        terminal: self._terminalInfo
    };

    self._confrs[confrId] && (apiArgs.roleToken = self._confrs[confrId].roleToken);
    return _rxjs.Observable.create(Manager.prototype.reqTkt.call(self, apiArgs)).pipe((0, _operators.map)(function (response) {
        response.mixed = response.type === 11 || response.type === 12;
        response.id = response.serverConfrId = response.confrId = confrId;
        self._confrs[confrId] = _Util2.default.extend(self._confrs[confrId] || {}, response);

        //_util.removeAttribute(response, "ticket");
        //_util.removeAttribute(response, "roleToken");
        _Util2.default.removeAttribute(response, "rtcCfg");

        return response;
    }), errorHandler);
}

function rxChanageRoles(role, uids, confrId) {
    var self = this;

    var confr = self._confr(confrId);
    var service = self._service(confrId);

    var apiArgs = {
        confrId: confr && confr.id || confrId,
        uids: uids,
        role: role,
        roleToken: confr.roleToken
    };

    return _rxjs.Observable.create(Manager.prototype.chanageRoles.call(self, apiArgs)).pipe((0, _operators.map)(function (response) {
        service && service.current && service.current._sysCopy();
        //return response.error === 0;
        return confr.id;
    }), errorHandler);
}

function rxDisbandConfr(confrId, roleToken) {

    var self = this;

    var confr = self._confr(confrId);
    var apiArgs = {
        confrId: confr && confr.id || confrId,
        roleToken: confr && confr.roleToken || roleToken
    };

    return _rxjs.Observable.create(Manager.prototype.disbandConfr.call(self, apiArgs)).pipe((0, _operators.map)(function (response) {
        setTimeout(function () {
            if (self.upload_stats) {
                // 停止质量监控上报
                self.upload_stats.stop();
                delete self.upload_stats;
            }
        }, 3000);

        _Util2.default.removeAttribute(self._confrs, confrId);
        return confr.id;
    }), errorHandler);
}

function rxKickMember(uids, confrId) {
    var self = this;

    var confr = self._confr(confrId);
    var apiArgs = {
        confrId: confr && confr.id || confrId,
        uids: uids,
        roleToken: confr.roleToken
    };

    return _rxjs.Observable.create(Manager.prototype.kickMember.call(self, apiArgs)).pipe((0, _operators.map)(function (response) {
        //return response.error === 0;
        return confr.id;
    }), errorHandler);
}

function rxSelectConfr(confrId, password) {
    var self = this;

    var confr = self._confr(confrId);

    var apiArgs = {
        uid: self.identityName,
        token: self.identityToken,
        confrId: confr && confr.id || confrId,
        password: password
    };

    if (confr) {
        apiArgs.password = password || confr.password;
        apiArgs.roleToken = confr.roleToken;
    }

    return _rxjs.Observable.create(Manager.prototype.selectConfr.call(self, apiArgs)).pipe(errorHandler);
}

function onRemoteStream(confrId, stream) {}

function rxAfterJoinedConfr(confrId, joinMemberId) {
    var self = this;
    var confr = self._confr(confrId);
    var service = self._service(confrId);

    switch (confr.type) {
        case 0: //CONFR
        case 10:
            //COMMUNICATION
            break;
        case 11:
            //COMMUNICATION_MIX  Audio:Mixed
            break;
        case 12:
            //LIVE  Audio:Mixed=
            var zeroStream = new self.ZeroStream();
            service.current._cacheStreams[zeroStream.id] = zeroStream;
            if (service.current.role == single.Role.AUDIENCE) {
                //观众 订阅0
                return rxSubscribe.call(self, confrId, zeroStream, false, true).pipe((0, _operators.concatMap)(function () {
                    return (0, _rxjs.of)(_Util2.default.extend({}, self._confrs[confrId]));;
                }));
            }
            break;
        case 13: //P2P
        case 14:
            //INTERCOMM
            return (0, _rxjs.throwError)("not support conf type: " + confr.type);
        default:
            return (0, _rxjs.throwError)("not support conf type: " + confr.type);
    }

    return (0, _rxjs.of)(_Util2.default.extend({}, self._confrs[confrId]));;
}

function rxSupportRemoteControl(confrId, joinMemberId, service) {
    var self = this;
    emedia.ctrl.support(service, function onHasRemoteControl(stream, controler, controlRequest) {
        self.onHasRemoteControl(stream, controler, controlRequest, confrId);
    }, function onRemoteFreeControl(stream, controler, cId) {
        self.onRemoteFreeControl(stream, controler, cId, confrId);
    });
    _logger.info("support remote control. ", confrId, joinMemberId);

    return (0, _rxjs.of)(_Util2.default.extend({}, self._confrs[confrId]));
}

function rxJoinUseTicket(confrId, ticket, ext) {
    var self = this;

    if (self.joined(confrId)) {
        return (0, _rxjs.throwError)("had joined confr " + confrId + ", if you want join again, please call exitConference");
    }

    var events = self._events[confrId] = new self.EventsObservable(self, confrId, function (stream) {
        onRemoteStream.call(self, confrId, stream);
    });

    self.confrEventsObserver && events.subscribe(self.confrEventsObserver);

    var service = self._service(confrId);
    service = self._services[confrId] = new emedia.XService({
        listeners: events,
        nickName: ext && ext.nickName
    });

    service.setup(ticket, ext);

    return _rxjs.Observable.create(function onSubscription(observer) {

        if (emedia.config.uploadStats) {
            // 开启 stats 上报
            self.upload_stats = new _UploadStats2.default(emedia); // 将 emedia 传入，在里面获取数据

            try {
                self.upload_stats.connect_ws();
            } catch (error) {
                console.error('upload_stats.connect_ws error', error);
            }
        }

        service.join(function (memId) {

            if (self.upload_stats) {
                // 开始上报
                var sessionId = service.current._session._sessionId;
                self.upload_stats.join_success(sessionId);
            }

            self.__current_confrId = confrId;
            self._confrs[confrId].joinId = memId;
            self._confrs[confrId].role = service.current && service.current.role;

            observer.next(self._confrs[confrId]);
            observer.complete();
        }, function (event) {

            if (self.upload_stats) {
                // 上报一条错误信息
                self.upload_stats.join_fail();
            }

            service.exit();
            observer.error({
                errorType: "join_fail",
                error: -200,
                errorMessage: event.message()
            });
        });
    }).pipe((0, _operators.concatMap)(function (joinMemberId, _index) {
        return rxSupportRemoteControl.call(self, confrId, joinMemberId, service);
    }), (0, _operators.concatMap)(function (joinMemberId, _index) {
        return rxAfterJoinedConfr.call(self, confrId, joinMemberId);
    }), errorHandler);
}

function rxJoinUsePassword(confrId, password, ext) {
    var self = this;

    return rxReqTkt.call(self, confrId, password, ext).pipe((0, _operators.concatMap)(function (_confr, _index) {
        return rxJoinUseTicket.call(self, confrId, _confr.ticket, ext);
    }));
}

function rxJoinExistConfrUsePassword(confrId, password, ext) {
    var self = this;
    return rxSelectConfr.call(self, confrId, password, ext).pipe((0, _operators.concatMap)(function (_confr, _index) {
        return rxJoinUsePassword.call(self, confrId, password, ext);
    }));
}

function openUserMedia(confrId, openingStream) {
    var self = this;
    var service = self._service(confrId);

    return _rxjs.Observable.create(function onSubscription(observer) {
        service.openUserMedia(openingStream).then(function () {
            observer.next(openingStream);
            observer.complete();
        }, function fail(evt) {
            observer.error({
                errorType: "open_user_media_fail",
                error: -201,
                errorMessage: evt.message()
            });
        });
    }).pipe(errorHandler);
}

function rxPublish(confrId, userStream) {
    var self = this;
    var service = self._service(confrId);

    return _rxjs.Observable.create(function onSubscription(observer) {
        service.push(userStream, function (pushedStream) {
            observer.next(pushedStream);
            observer.complete();
        }, function fail(evt) {
            observer.error({
                errorType: "push_fail",
                error: -203,
                errorMessage: evt.message()
            });
        });
    }).pipe(errorHandler);
}

function rxResumePauseVideo(pubS, videoConstaints, confrId) {
    var self = this;
    var confr = self._confr(confrId);
    var service = self._service(confrId);

    if (typeof pubS === 'string') {
        pubS = service.getStreamById(pubS);
    } else {
        pubS = service.getStreamById(pubS.id);
    }
    if (!pubS) {
        return (0, _rxjs.throwError)("pub stream not exsits. it is " + pubS);
    }

    // if((typeof videoConstaints !== 'boolean' && pubS.constaints && _.isEqual(videoConstaints, pubS.constaints.video))
    //     || videoConstaints == !pubS.voff){
    //     return of(_.extend({}, confr.av));
    // }

    if (!videoConstaints) {
        return rxVoff.call(self, confrId, pubS, 1);
    }

    if (_underscore2.default.isEqual(videoConstaints, pubS.constaints.video)) {
        return rxVoff.call(self, confrId, pubS, 0);
    }

    return rxChanageVideoConstraints.call(self, confrId, pubS, videoConstaints);
}
// 质量监控上报 开关音视频事件
function upload_aoff_or_voff_event(event, pubS) {

    if (!this.upload_stats) {
        return;
    }

    if (!event || !pubS) {
        return;
    }

    var current = this._services[this.__current_confrId].current;
    if (!current) {
        return;
    }

    var _o = {
        event: event,
        rtcId: pubS.rtcId,
        sId: pubS.id,
        sessionId: current._session._sessionId,
        streamType: pubS.type,
        voff: pubS.voff,
        aoff: pubS.aoff

    };
    this.upload_stats.upload_event(_o);
}
function rxVoff(confrId, pubS, voff) {
    var self = this;
    var service = self._service(confrId);

    return _rxjs.Observable.create(function onSubscription(observer) {
        service.voff(pubS, voff, function fail(evt) {
            observer.error({
                errorType: "voff_fail",
                error: -203,
                errorMessage: evt.message()
            });
        }, function success() {

            var stream = service.getStreamById(pubS.id);
            observer.next(stream);
            observer.complete();

            var event = voff == 1 ? 8 : 6;
            upload_aoff_or_voff_event.bind(self)(event, stream); // 质量监控上报
        });
    }).pipe(errorHandler);
}

function rxChanageVideoConstraints(confrId, pubS, videoConstaints) {
    var self = this;
    var service = self._service(confrId);

    return _rxjs.Observable.create(function onSubscription(observer) {
        var constaints = {};
        if (_underscore2.default.isObject(pubS.constaints)) {
            constaints = _Util2.default.extend(true, {}, pubS.constaints);
        }
        constaints.video = videoConstaints;

        service.chanageConstraints(pubS, constaints, function fail(evt) {
            observer.error({
                errorType: "ChanageVideoConstraints_fail",
                error: -203,
                errorMessage: evt.message()
            });
        }, function success() {
            observer.next(service.getStreamById(pubS.id));
            observer.complete();
        });
    }).pipe(errorHandler);
}

function rxResumePauseAudio(pubS, aoff, confrId) {

    var self = this;
    var confr = self._confr(confrId);
    var service = self._service(confrId);

    if (typeof pubS === 'string') {
        pubS = service.getStreamById(pubS);
    } else {
        pubS = service.getStreamById(pubS.id);
    }
    if (!pubS) {
        return (0, _rxjs.throwError)("pub stream not exsits. it is " + pubS);
    }

    if (confr.type === self.ConfrType.COMMUNICATION_MIX || confr.type === self.ConfrType.LIVE) {
        //混音时，共享桌面带声音，会造成 服务端错误。
        if (pubS.type === 1 && !aoff) {
            _logger.warn("confr mix. not allow desktop with audio.");
            return (0, _rxjs.throwError)("confr mix. not allow desktop with audio.");
        }
    }

    return rxAoff.call(self, confrId, pubS, aoff);
}

function rxAoff(confrId, pubS, aoff) {
    var self = this;
    var service = self._service(confrId);

    return _rxjs.Observable.create(function onSubscription(observer) {
        service.aoff(pubS, aoff, function fail(evt) {
            observer.error({
                errorType: "aoff_fail",
                error: -203,
                errorMessage: evt.message()
            });
        }, function success() {
            var stream = service.getStreamById(pubS.id);
            observer.next(stream);
            observer.complete();

            var event = aoff == 1 ? 7 : 5;
            upload_aoff_or_voff_event.bind(self)(event, stream); // 质量监控上报
        });
    }).pipe(errorHandler);
}

function rxPublishMedia(confrId, constaints, videoTag, ext) {
    var self = this;

    var confr = self._confr(confrId);
    var service = self._service(confrId);

    if (service.current.role == self.Role.AUDIENCE) {
        return (0, _rxjs.throwError)("Audience not allow publish");
    }
    if (confr.av) {
        return (0, _rxjs.throwError)("Audio and video stream has been published. not allow repeat publish.");
    }

    var Stream = confr.mixed ? service.AudioMixerPubstream : service.AVPubstream;
    var stream = confr.av = new Stream({
        constaints: constaints,
        aoff: 0,
        voff: 0,
        ext: ext
    });

    return openUserMedia.call(self, confr.id, stream).pipe((0, _operators.concatMap)(function (userStream) {
        videoTag && _Util2.default.targetDOM(videoTag) && attachMediaStream(videoTag, userStream.localStream);
        return rxPublish.call(self, confr.id, userStream, ext);
    }), (0, _operators.map)(function (pushedStream) {
        confr.av = pushedStream;
        videoTag && self.streamBindVideo(confr.av, videoTag);
        confr.type == self.ConfrType.LIVE && self.hungup(0);
        return _Util2.default.extend({}, pushedStream);
    }), (0, _operators.catchError)(function (err, caught) {
        confr.av && self.hungup(confr.av);
        confr.av = undefined;

        _logger.error(err);
        throw err;
    }));
}

function rxSwitchMobileCamera(confrId) {
    var self = this;

    var confr = self._confr(confrId);
    var service = self._service(confrId);

    if (service.current.role == self.Role.AUDIENCE) {
        return (0, _rxjs.throwError)("Audience not allow publish");
    }

    return _rxjs.Observable.create(function onSubscription(observer) {
        service.switchMobileCamera(confr.av, function fail(evt) {
            observer.error({
                errorType: "switch_camera_fail",
                error: -203,
                errorMessage: evt.message()
            });
        }, function success() {
            observer.complete();
        });
    }).pipe(errorHandler);
}

function rxChanageCamera(confrId) {
    var self = this;

    var confr = self._confr(confrId);
    var service = self._service(confrId);

    if (service.current.role == self.Role.AUDIENCE) {
        return (0, _rxjs.throwError)("Audience not allow publish");
    }

    return _rxjs.Observable.create(function onSubscription(observer) {
        service.chanageCamera(confr.av, function fail(evt) {
            observer.error({
                errorType: "switch_camera_fail",
                error: -203,
                errorMessage: evt.message()
            });
        }, function success() {
            observer.complete();
        });
    }).pipe(errorHandler);
}

function rxShareDesktop(options) {
    var confrId = options.confrId,
        constaints = options.constaints,
        videoTag = options.videoTag,
        ext = options.ext,
        stopSharedCallback = options.stopSharedCallback;


    var self = this;

    var confr = self._confr(confrId);
    var service = self._service(confrId);

    if (service.current.role == self.Role.AUDIENCE) {
        return (0, _rxjs.throwError)("Audience not allow publish");
    }
    if (confr.desktop) {
        return (0, _rxjs.throwError)("desktop stream has been published. not allow repeat publish.");
    }

    if (confr.type === self.ConfrType.COMMUNICATION_MIX || confr.type === self.ConfrType.LIVE) {
        //混音时，共享桌面带声音，会造成 服务端错误。
        if (constaints.audio) {
            _logger.warn("confr mix. not allow desktop with audio.");
            return (0, _rxjs.throwError)("confr mix. not allow desktop with audio.");
        }
    }

    if (!constaints.audio && confr.av && !confr.av.aoff) {
        _logger.warn("repeat audio. desktop and av");
    }

    var stream = confr.desktop = new service.ShareDesktopPubstream({
        screenOptions: constaints.video && constaints.video.screenOptions || ['screen', 'window', 'tab'],
        mandatory: constaints.video && constaints.video.mandatory || {},
        vbitrate: constaints.video && constaints.video.bitrate,
        abitrate: constaints.audio && constaints.audio.bitrate,
        aoff: !!constaints.audio ? 0 : 1,
        ext: ext,
        onMediaInactive: function onMediaInactive() {
            // stopShareDesktop callback

            typeof stopSharedCallback == 'function' && stopSharedCallback();
        }
        // onMediaActive: function () {
        //     typeof sharedCallback == 'function'
        //         && sharedCallback();
        // }
    });

    return openUserMedia.call(self, confr.id, stream).pipe((0, _operators.concatMap)(function (userStream) {
        videoTag && _Util2.default.targetDOM(videoTag) && attachMediaStream(videoTag, userStream.localStream);
        return rxPublish.call(self, confr.id, userStream, ext);
    }), (0, _operators.map)(function (pushedStream) {
        confr.desktop = pushedStream;
        videoTag && _Util2.default.targetDOM(videoTag) && self.streamBindVideo(confr.desktop, videoTag);
        return _Util2.default.extend({}, pushedStream);
    }), (0, _operators.catchError)(function (err, caught) {
        confr.desktop = undefined;
        _logger.error(err);
        throw err;
    }));
}

function rxSubscribe(confrId, stream, subSVideo, subSAudio, videoTag) {
    var self = this;
    var streamId = typeof stream === "string" ? stream : stream.id;

    var confr = self._confr(confrId);
    var service = self._service(confrId);

    if (stream.type === 2 && subSAudio == true && stream.id != 0) {
        //return throwError("Mixed audio stream. not allow repeat sub audio");
        subSAudio = false;
        _logger.warn("Mixed audio stream. not allow repeat sub audio. force reset subSAudio = false");
    }

    videoTag && _Util2.default.targetDOM(videoTag) && self.streamBindVideo(streamId, videoTag);

    return _rxjs.Observable.create(function onSubscription(observer) {
        service.subscribe(streamId, function (remoteMediaStream) {
            try {
                if (streamId != "0") {
                    var cacheStream = service.getStreamById(streamId);
                    var constaints = {
                        video: cacheStream.subArgs ? cacheStream.subArgs.subSVideo : !cacheStream.voff,
                        audio: cacheStream.subArgs ? cacheStream.subArgs.subSAudio : !cacheStream.aoff
                    };
                    if (cacheStream.type === 2) {
                        constaints.audio = true;
                    }
                    self._onMemberMediaChanaged(cacheStream.owner, cacheStream, constaints, confr.confrId);
                }
            } finally {
                observer.next(remoteMediaStream);
                observer.complete();
            }
        }, function (evt) {
            observer.error({
                errorType: "sub_fail",
                error: -203,
                errorMessage: evt.message()
            });
        }, { subSVideo: subSVideo, subSAudio: subSAudio });
    }).pipe(errorHandler);
}

function _streamBindVideo(stream, _videoTag, confrId) {
    var self = this;

    var service = self._service(confrId);
    stream = service.current._cacheStreams[typeof stream === "string" ? stream : stream.id];

    var videoTag = _videoTag || self.crtAndReturnVideo(stream.owner, stream);
    if (!videoTag) {
        return;
    }
    self._videos[stream.id] = videoTag;

    videoTag.setAttribute("autoplay", "autoplay");
    videoTag.setAttribute("playsinline", "playsinline");
    videoTag.setAttribute("hx_stream", stream.id);

    stream.aoff ? videoTag.setAttribute("aoff", "aoff") : videoTag.removeAttribute("aoff");
    stream.voff ? videoTag.setAttribute("voff", "voff") : videoTag.removeAttribute("voff");

    stream.ifMediaStream(function (mediaStream) {
        videoTag && attachMediaStream(videoTag, mediaStream);

        if (videoTag.hasAttribute("flow")) {
            self.onMediaTransmission(videoTag, function cb(trackId, type, subtype, data) {
                (0, _zeptoWebpack2.default)(videoTag).trigger("onMediaTransmission", [trackId, type, subtype, data]);
            });
        }
    });

    var $video = (0, _zeptoWebpack2.default)(videoTag);
    $video.off("hungup");
    $video.on("hungup", function (e, fail, success) {
        self.hungup(stream, confrId);
        success && success();
    });

    $video.off("subscribe");
    $video.on("subscribe", function (e, subSVideo, subSAudio, fail, success) {
        if (stream.located()) {
            fail && fail("local stream not allow sub");
        } else {
            subSVideo = stream.subArgs && stream.subArgs.subSVideo || true;
            subSAudio = stream.subArgs && stream.subArgs.subSAudio || true;
            self.subscribe(stream.owner, stream, subSVideo, subSAudio, confrId).then(success).catch(fail);
        }
    });

    $video.off("pauseVideo");
    $video.on("pauseVideo", function (e, fail, success) {
        stream = service.current._cacheStreams[typeof stream === "string" ? stream : stream.id];

        if (stream.located()) {
            $video[0].__constaints_video = stream.constaints && stream.constaints.video;
            self.pauseVideo(stream, confrId).then(success).catch(fail);
        } else {
            self.subscribe(stream.owner, stream, false, stream.subArgs && stream.subArgs.subSAudio || !stream.aoff, confrId).then(success).catch(fail);
        }
    });

    $video.off("resumeVideo");
    $video.on("resumeVideo", function (e, fail, success, constaintsVideo) {
        stream = service.current._cacheStreams[typeof stream === "string" ? stream : stream.id];

        if (stream.located()) {
            if (constaintsVideo === undefined) {
                constaintsVideo = $video[0].__constaints_video;
                if (constaintsVideo === undefined || constaintsVideo == null) {
                    constaintsVideo = true;
                }
            }
            $video[0].__constaints_video = undefined;

            self.resumeVideo(stream, constaintsVideo, confrId).then(success).catch(fail);
        } else {
            self.subscribe(stream.owner, stream, true, stream.subArgs && stream.subArgs.subSVideo || !stream.voff, confrId).then(success).catch(fail);
        }
    });

    $video.off("pauseAudio");
    $video.on("pauseAudio", function (e, fail, success) {
        if (stream.located()) {
            self.pauseAudio(stream, confrId).then(success).catch(fail);
        } else {
            self.subscribe(stream.owner, stream, stream.subArgs.subSVideo, false, confrId).then(success).catch(fail);
        }
    });

    $video.off("resumeAudio");
    $video.on("resumeAudio", function (e, fail, success) {
        if (stream.located()) {
            self.resumeAudio(stream, confrId).then(success).catch(fail);
        } else {
            self.subscribe(stream.owner, stream, stream.subArgs.subSVideo, true, confrId).then(success).catch(fail);
        }
    });

    $video.off("remoteControl");
    $video.on("remoteControl", function (e, mirror, onDisControlled, onAccept, onNotAllowRemoteControl, onRemoteControlTimeout, onReject, onBusy) {
        if (stream.located()) {
            _logger.error("not allow remote control at local");
            throw "not allow remote control at local";
        } else {
            self.remoteControl(stream, videoTag, videoTag, mirror, onDisControlled, onAccept, onNotAllowRemoteControl, onRemoteControlTimeout, onReject, onBusy, confrId);
        }
    });

    $video.off("chanageCamera");
    $video.on("chanageCamera", function (e, fail, success) {
        self.chanageCamera(confrId).then(success).catch(fail);
    });

    $video.off("captureVideo");
    $video.on("captureVideo", function (e, success, storeLocal, filename) {
        var base64 = self.captureVideo(videoTag, storeLocal, filename, confrId);
        success && success(base64);
    });

    $video.off("capturePictureRemote");
    $video.on("capturePictureRemote", function (e, fail, success) {
        self.capturePictureRemote(stream, false, confrId).then(success).catch(fail);
    });

    $video.off("freezeFrameRemote");
    $video.on("freezeFrameRemote", function (e, fail, success) {
        self.freezeFrameRemote(stream, confrId).then(success).catch(fail);
    });

    $video.off("zoomRemote");
    $video.on("zoomRemote", function (e, multiples, fail, success) {
        self.zoomRemote(stream, multiples, confrId).then(success).catch(fail);
    });

    $video.off("torchRemote");
    $video.on("torchRemote", function (e, torch, fail, success) {
        self.torchRemote(stream, torch, confrId).then(success).catch(fail);
    });

    $video.off("freeRemoteControl");
    $video.on('freeRemoteControl', function (e, fail, success) {
        try {
            self.freeRemoteControl(stream, confrId);
        } finally {
            success && success();
        }
    });

    var constaints = { video: !stream.voff, audio: !stream.aoff, voff: stream.voff, aoff: stream.aoff };
    if (!stream.located()) {
        constaints = {
            video: stream.subArgs ? stream.subArgs.subSVideo : !stream.voff,
            audio: stream.subArgs ? stream.subArgs.subSAudio : !stream.aoff,
            voff: stream.voff,
            aoff: stream.aoff
        };
    }
    $video.trigger("onMediaChanaged", [constaints, stream, stream.owner, confrId]);

    if (videoTag.getAttribute("sound")) {
        service.current._monitSoundChanagedStreams = service.current._monitSoundChanagedStreams || {};
        service.current._monitSoundChanagedStreams[stream.id] = stream.id;
    }
}

function rxFocusExpoRemote(confrId, streamId, videoTag, clickEvent) {
    var self = this;

    if (typeof streamId !== 'string') {
        streamId = streamId.id;
    }

    var confr = self._confr(confrId);
    var service = self._service(confrId);

    return _rxjs.Observable.create(function onSubscription(observer) {
        service.focusExpoRemote(streamId, videoTag, clickEvent, function (evt) {
            observer.error({
                errorType: "focusexpo_remote_fail",
                error: -203,
                errorMessage: evt.message()
            });
        }, function () {
            observer.complete();
        });
    }).pipe(errorHandler);
}

function rxCapturePictureRemote(confrId, streamId, rspBase64Pic) {
    var self = this;

    if (typeof streamId !== 'string') {
        streamId = streamId.id;
    }

    var confr = self._confr(confrId);
    var service = self._service(confrId);

    return _rxjs.Observable.create(function onSubscription(observer) {
        service.capturePictureRemote(streamId, rspBase64Pic, function (base64) {
            observer.next(base64);
            observer.complete();
        }, function (evt) {
            observer.error({
                errorType: "capture_remote_fail",
                error: -203,
                errorMessage: evt.message()
            });
        });
    }).pipe(errorHandler);
}

function rxZoomRemote(confrId, streamId, multiples) {
    var self = this;

    if (typeof streamId !== 'string') {
        streamId = streamId.id;
    }

    var confr = self._confr(confrId);
    var service = self._service(confrId);

    return _rxjs.Observable.create(function onSubscription(observer) {
        service.zoomRemote(streamId, multiples, function fail(evt) {
            observer.error({
                errorType: "capture_remote_fail",
                error: -203,
                errorMessage: evt.message()
            });
        }, function () {
            observer.complete();
        });
    }).pipe(errorHandler);
}

function rxTorchRemote(confrId, streamId, torch) {
    var self = this;

    if (typeof streamId !== 'string') {
        streamId = streamId.id;
    }

    var confr = self._confr(confrId);
    var service = self._service(confrId);

    return _rxjs.Observable.create(function onSubscription(observer) {
        service.torchRemote(streamId, torch, function (torch) {
            observer.next(torch);
            observer.complete();
        }, function fail(evt) {
            observer.error({
                errorType: "torch_remote_fail",
                error: -203,
                errorMessage: evt.message()
            });
        });
    }).pipe(errorHandler);
}

function rxFreezeFrameRemote(confrId, streamId) {
    var self = this;

    if (typeof streamId !== 'string') {
        streamId = streamId.id;
    }

    var confr = self._confr(confrId);
    var service = self._service(confrId);

    return _rxjs.Observable.create(function onSubscription(observer) {
        service.freezeFrameRemote(streamId, function (freezeFrame) {
            observer.next(freezeFrame);
            observer.complete();
        }, function fail(evt) {
            observer.error({
                errorType: "freeze_remote_fail",
                error: -203,
                errorMessage: evt.message()
            });
        });
    }).pipe(errorHandler);
}

var _single = _Util2.default.extend(new Manager(), {
    _confr: function _confr(confrId) {
        var self = this;
        confrId || (confrId = self.__current_confrId);
        return self._confrs[confrId];
    },
    _service: function _service(confrId) {
        var self = this;
        confrId || (confrId = self.__current_confrId);
        return this._services[confrId];
    },

    getStreamById: function getStreamById(streamId, confrId) {
        var self = this;
        var service = self._service(confrId);
        return service && service.getStreamById(streamId);
    },
    getMemberById: function getMemberById(memId, confrId) {
        var self = this;
        var service = self._service(confrId);
        return service && service.getMemberById(memId);
    },

    streamBindVideo: function streamBindVideo(stream, videoTag, confrId) {
        _streamBindVideo.call(this, stream, videoTag, confrId);
    },
    getBindVideoBy: function getBindVideoBy(stream) {
        var self = this;
        if (typeof stream !== "string" && stream && stream.id) {
            stream = stream.id;
        }
        if (typeof stream !== "string") {
            _logger.error("Bad stream ", stream);
            throw "Bad stream " + stream;
        }
        return self._videos[stream];
    },
    createConfr: function createConfr(confrType, password, rec, recMerge) {
        return rxCreateConfr.apply(this, arguments).toPromise();
    },

    createConfrSptMnPrg: function createConfrSptMnPrg(confrType, password, rec, recMerge) {
        return rxCreateConfrSptMnPrg.apply(this, arguments).toPromise();
    },

    reqTkt: function reqTkt(confrId, password) {
        return rxReqTkt.apply(this, arguments).toPromise();
    },

    chanageRoles: function chanageRoles(role, uids, confrId) {
        return rxChanageRoles.apply(this, arguments).toPromise();
    },

    disbandConfr: function disbandConfr(confrId, roleToken) {
        return rxDisbandConfr.apply(this, arguments).toPromise();
    },

    kickMember: function kickMember(uids, confrId) {
        return rxKickMember.apply(this, arguments).toPromise();
    },

    selectConfr: function selectConfr(confrId, password) {
        return rxSelectConfr.apply(this, arguments).toPromise();
    },

    joinUsePassword: function joinUsePassword(confrId, password, ext) {
        return rxJoinExistConfrUsePassword.call(this, confrId, password, ext).toPromise();
    },
    joinUseTicket: function joinUseTicket(confrId, ticket, ext) {
        return rxJoinUseTicket.call(this, confrId, ticket, ext).toPromise();
        // return rxJoinUseTicket.call(this, confrId, ticket, ext);
    },
    joined: function joined(confrId) {
        return confrId && this._confrs[confrId] && this._confrs[confrId].joinId;
    },

    shareDesktopWithAudio: function shareDesktopWithAudio(params) {

        if (navigator.mediaDevices.getDisplayMedia && !emedia.isElectron) {
            return this.shareDesktopWithAudioNew(params);
        }

        var videoConstaints = params.videoConstaints,
            withAudio = params.withAudio,
            videoTag = params.videoTag,
            ext = params.ext,
            confrId = params.confrId,
            sharedCallback = params.sharedCallback,
            stopSharedCallback = params.stopSharedCallback;

        var self = this;

        if (!_Util2.default.targetDOM(videoTag)) {
            confrId = ext;
            ext = videoTag;
            videoTag = undefined;
        }

        var constaints = {
            video: videoConstaints,
            audio: withAudio
        };

        var options = {
            confrId: confrId,
            constaints: constaints,
            videoTag: videoTag,
            ext: ext,
            sharedCallback: sharedCallback,
            stopSharedCallback: stopSharedCallback
        };

        return rxShareDesktop.call(self, options).toPromise();
    },

    // use new navigator api don't rely on plugin
    shareDesktopWithAudioNew: function () {
        var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(params) {
            var confrId, withAudio, ext, video, stopSharedCallback, constaints, desktopMedia, pubS, desktopStream;
            return _regenerator2.default.wrap(function _callee$(_context) {
                while (1) {
                    switch (_context.prev = _context.next) {
                        case 0:
                            confrId = params.confrId, withAudio = params.withAudio, ext = params.ext, video = params.video, stopSharedCallback = params.stopSharedCallback;

                            if (confrId) {
                                _context.next = 3;
                                break;
                            }

                            throw new Error('shareDesktop confrId is required');

                        case 3:
                            constaints = {
                                video: video || true,
                                audio: withAudio
                            };
                            _context.next = 6;
                            return navigator.mediaDevices.getDisplayMedia(constaints);

                        case 6:
                            desktopMedia = _context.sent;
                            // get screen media

                            desktopMedia._located = true; //用于给标签添加 muted 属性
                            pubS = {
                                localStream: desktopMedia,
                                type: 1,
                                aoff: withAudio ? 0 : 1,
                                voff: 0,
                                constaints: constaints,
                                _located: true
                            };
                            _context.prev = 9;
                            _context.next = 12;
                            return rxPublish.call(this, confrId, pubS, ext).toPromise();

                        case 12:
                            desktopStream = _context.sent;
                            // publish stream
                            // [停止共享] 按钮监听
                            desktopMedia.getVideoTracks()[0].addEventListener('ended', function () {
                                if (typeof stopSharedCallback == 'function') {
                                    stopSharedCallback(desktopStream.id);
                                }
                            });

                            return _context.abrupt('return', desktopStream);

                        case 17:
                            _context.prev = 17;
                            _context.t0 = _context['catch'](9);

                        case 19:
                        case 'end':
                            return _context.stop();
                    }
                }
            }, _callee, this, [[9, 17]]);
        }));

        function shareDesktopWithAudioNew(_x) {
            return _ref.apply(this, arguments);
        }

        return shareDesktopWithAudioNew;
    }(),

    changeCamera: function changeCamera(confrId) {
        return rxChanageCamera.call(this, confrId).toPromise();
    },
    switchMobileCamera: function switchMobileCamera(confrId) {
        return rxSwitchMobileCamera.call(this, confrId).toPromise();
    },
    shareVideoWithAudio: function shareVideoWithAudio(videoConstaints, withAudio, videoTag, ext, confrId) {
        var self = this;

        if (!_Util2.default.targetDOM(videoTag)) {
            confrId = ext;
            ext = videoTag;
            videoTag = undefined;
        }

        var constaints = {
            video: videoConstaints,
            audio: withAudio
        };

        return rxPublishMedia.call(self, confrId, constaints, videoTag, ext).toPromise();
    },
    captureVideo: function captureVideo(videoObj, storeLocal, filename, confrId) {
        var self = this;
        var service = self._service(confrId);
        return service.captureVideo(videoObj, storeLocal, filename);
    },

    openUserMedia: function openUserMedia(constaints, confrId) {
        var self = this;
        var service = self._service(confrId);

        return _rxjs.Observable.create(function onSubscription(observer) {
            service.__getUserMedia(constaints, function (attendee, stream) {
                observer.next(stream);
                observer.complete();
            }, function (error) {
                observer.error(error);
            });
        }).pipe(errorHandler).toPromise();
    },

    mediaDevices: function mediaDevices(kind) {
        if (typeof kind === 'function') {
            kind = undefined;
        }

        return _rxjs.Observable.create(function onSubscription(observer) {
            navigator.mediaDevices.enumerateDevices().then(function (deviceInfos) {
                var resultDeviceInfos = [];

                for (var i = 0; i !== deviceInfos.length; ++i) {
                    var deviceInfo = deviceInfos[i];
                    var deviceId = deviceInfo.deviceId;

                    if (!kind) {
                        resultDeviceInfos.push(deviceInfo);
                    }

                    if (kind && kind === deviceInfo.kind) {
                        resultDeviceInfos.push(deviceInfo);
                    } else if (deviceInfo.kind === 'audioinput') {} else if (deviceInfo.kind === 'audiooutput') {} else if (deviceInfo.kind === 'videoinput') {} else {
                        _logger.info('Some other kind of source/device: ', deviceInfo);
                    }
                }

                observer.next(resultDeviceInfos);
                observer.complete();
            }).catch(function handleError(error) {
                _logger.warn('navigator.getUserMedia error: ', error);
                observer.error(error);
            });
        }).pipe(errorHandler).toPromise();
    },
    resumeVideo: function resumeVideo(pubS, videoConstaints, confrId) {
        return rxResumePauseVideo.call(this, pubS, videoConstaints || true, confrId).toPromise();
    },
    pauseVideo: function pauseVideo(pubS, confrId) {
        return rxResumePauseVideo.call(this, pubS, false, confrId).toPromise();
    },

    resumeAudio: function resumeAudio(pubS, confrId) {
        return rxResumePauseAudio.call(this, pubS, false, confrId).toPromise();
    },
    pauseAudio: function pauseAudio(pubS, confrId) {
        return rxResumePauseAudio.call(this, pubS, true, confrId).toPromise();
    },

    freezeFrameRemote: function freezeFrameRemote(stream, confrId) {
        return rxFreezeFrameRemote.call(this, confrId, stream).toPromise();
    },
    torchRemote: function torchRemote(stream, torch, confrId) {
        return rxTorchRemote.call(this, confrId, stream, torch).toPromise();
    },
    zoomRemote: function zoomRemote(stream, multiples, confrId) {
        return rxZoomRemote.call(this, confrId, stream, multiples).toPromise();
    },
    capturePictureRemote: function capturePictureRemote(streamId, confrId) {
        return rxCapturePictureRemote.call(this, confrId, streamId, false).toPromise();
    },

    focusExpoRemote: function focusExpoRemote(stream, videoTag, clickEvent, confrId) {
        return rxFocusExpoRemote.call(this, confrId, stream, videoTag, clickEvent).toPromise();
    },

    onFocusExpoRemoteWhenClickVideo: function onFocusExpoRemoteWhenClickVideo(tag, event, fail, success) {
        var self = this;

        if (typeof event === 'function') {
            success = fail;
            fail = event;
            event = undefined;
        }

        (0, _zeptoWebpack2.default)(tag).off(event || 'click');
        (0, _zeptoWebpack2.default)(tag).on(event || 'click', function (e) {
            var streamId = tag.getAttribute("hx_stream");
            self.focusExpoRemote(streamId, tag, e).then(success).catch(fail);
        });

        return event;
    },
    offEventAtTag: function offEventAtTag(tag, event) {
        event && (0, _zeptoWebpack2.default)(tag).off(event);
    },

    hungup: function hungup(stream, confrId) {
        var self = this;

        var streamId;
        if (typeof stream === "string") {
            streamId = stream;
        } else {
            streamId = stream.id || stream + "";
        }

        var service = self._service(confrId);
        var confr = self._confr(confrId);
        if (!confr || !service) {
            _logger.warn("when hungup stream. not found confr and service.", stream);
            return;
        }

        service.hungup(streamId);

        var hungeAv = false;
        confr.av && (hungeAv = confr.av.id === streamId) && (confr.av = undefined);
        confr.desktop && confr.desktop.id === streamId && (confr.desktop = undefined);

        if (hungeAv && confr.type == self.ConfrType.LIVE && service.current.role == single.Role.AUDIENCE) {
            //观众 订阅0  && service.current.role == single.Role.AUDIENCE
            var zeroStream = service.current && service.current._cacheStreams["0"];
            self.subscribe(service.current, zeroStream, false, true, confrId);
        }
    },

    subscribe: function subscribe(member, stream, subSVideo, subSAudio, videoTag, confrId) {
        var self = this;
        if (!_Util2.default.targetDOM(videoTag)) {
            confrId = videoTag;
            videoTag = undefined;
        }
        return rxSubscribe.call(self, confrId, stream, subSVideo, subSAudio, videoTag).toPromise();
    },

    exit: function exit(closeMyConfrIfICrtConfr, confrId) {
        var self = this;

        var service = self._service(confrId);
        if (!service) {
            _logger.warn("when exit. not found service.", confrId);
            return;
        }
        service.exit(closeMyConfrIfICrtConfr);

        setTimeout(function () {
            if (self.upload_stats) {
                // 停止质量监控上报
                self.upload_stats.stop();
                delete self.upload_stats;
            }
        }, 3000);
    },

    _onExit: function _onExit(confrId, reason, failed) {
        var self = this;
        try {
            self.__current_confrId = undefined;
            self.onExit(reason, failed, confrId);
        } finally {
            _Util2.default.removeAttribute(self._confrs, confrId);
            _Util2.default.removeAttribute(self._services, confrId);
            _Util2.default.removeAttribute(self._videos, confrId);
            _Util2.default.removeAttribute(self._events, confrId);

            // 清空会议属性 cattrs
            self.cattrs = undefined;

            setTimeout(function () {
                if (self.upload_stats) {
                    // 停止质量监控上报
                    self.upload_stats.stop();
                    delete self.upload_stats;
                }
            }, 3000);
        }
    },
    onExit: function onExit(reason, failed, confrId) {},
    _onRoleUpdated: function _onRoleUpdated(role, confrId) {},

    onMemberJoin: function onMemberJoin(member, confrId) {},
    onMemberLeave: function onMemberLeave(member, reason, confrId) {},
    _onRecvRemoteMessage: function _onRecvRemoteMessage(fromMember, argsObject, confrId) {},

    crtAndReturnVideo: function crtAndReturnVideo(member, stream, confrId) {
        //throw "Please set crtAndReturnVideo";
    },
    unloadVideo: function unloadVideo(member, stream, video, confrId) {
        //throw "Please set unloadVideo";
    },

    remoteControl: function remoteControl(stream, videoObj, targetDiv, mirror, onDisControlled, onAccept, onNotAllowRemoteControl, onRemoteControlTimeout, onReject, onBusy, confrId) {
        var self = this;
        var service = self._service(confrId);

        mirror = !!mirror;

        var streamId = typeof stream === "string" ? stream : stream.id;

        if (mirror) {
            emedia.ctrl.mirrorControlled(service, streamId, videoObj, targetDiv, onDisControlled, onAccept, onNotAllowRemoteControl, onRemoteControlTimeout, onReject, onBusy);
        } else {
            emedia.ctrl.controlled(service, streamId, videoObj, targetDiv, onDisControlled, onAccept, onNotAllowRemoteControl, onRemoteControlTimeout, onReject, onBusy);
        }
    },

    freeRemoteControl: function freeRemoteControl(stream, confrId) {
        var self = this;
        var service = self._service(confrId);
        var streamId = typeof stream === "string" ? stream : stream.id;
        emedia.ctrl.disControlled(service, streamId);
    },

    zeptoTrigger: function zeptoTrigger(tag, event) {
        var otherArgs = [];
        Array.prototype.push.apply(otherArgs, Array.prototype.slice.call(arguments, 2));

        //zepto(tag).trigger(event, [fail, success]);
        return _rxjs.Observable.create(function onSubscription(observer) {
            var eventArgs = [function fail() {
                observer.error.apply(observer, arguments);
            }, function success() {
                observer.next.apply(observer, arguments);
                observer.complete();
            }];
            Array.prototype.push.apply(eventArgs, otherArgs);

            (0, _zeptoWebpack2.default)(tag).trigger(event, eventArgs);
        }).pipe(errorHandler).toPromise();
    },
    _onAddMemberStream: function _onAddMemberStream(stream, confrId) {},
    _onRemoveMemberStream: function _onRemoveMemberStream(stream, confrId) {},
    _onUpdateMemberStream: function _onUpdateMemberStream(stream, constaints, confrId) {},
    _onMemberMediaChanaged: function _onMemberMediaChanaged(member, stream, constaints, confrId) {
        var tag = this._videos[stream.id];
        constaints && (constaints.voff = stream.voff, constaints.aoff = stream.aoff);
        tag && (0, _zeptoWebpack2.default)(tag).trigger("onMediaChanaged", [constaints, stream, member, confrId]);
    },
    onMediaChanaged: function onMediaChanaged(tag, cb) {
        // cb video audio
        this.addVideoEventListener(tag, "onMediaChanaged", cb);
    },

    _onMemberSoundChanaged: function _onMemberSoundChanaged(member, stream, meterData, confrId) {
        var tag = this._videos[stream.id];
        tag && (0, _zeptoWebpack2.default)(tag).trigger("onSoundChanaged", [meterData, stream, member, confrId]);
    },
    onSoundChanaged: function onSoundChanaged(tag, cb) {
        // cb video audio
        if (!emedia.config.getMediaMeterIntervalMillis || emedia.config.getMediaMeterIntervalMillis <= 0) {
            _logger.error("monit sound chanaged not config. please config getMediaMeterIntervalMillis");
            throw "monit sound chanaged not config. please config getMediaMeterIntervalMillis";
        }

        tag.setAttribute("sound", "sound");
        this.addVideoEventListener(tag, "onSoundChanaged", cb);
    },

    onMediaTransmission: function onMediaTransmission(tag, cb) {
        // cb video audio
        if (!emedia.helper || typeof emedia.helper.inboundVideo !== "function") {
            _logger.warn("please import helper. <script>");
            return;
        }

        var service = this._service();

        var streamId = tag.getAttribute("hx_stream");
        var stream = streamId && service.getStreamById(streamId);
        var flowWebrtc = tag.getAttribute("flowWebrtc");

        if (stream && stream._webrtc && flowWebrtc == stream._webrtc.__id) {
            return;
        }

        if (tag.hasAttribute("flow") && stream && stream._webrtc) {
            //开启流量监控

            if (stream.located()) {
                emedia.helper.outboundVideo(stream, cb, 1000);
            } else {
                emedia.helper.inboundVideo(stream, cb, 1000);
            }

            tag.setAttribute("flowWebrtc", stream._webrtc.__id);
        } else {
            this.addVideoEventListener(tag, "onMediaTransmission", cb);
            tag.setAttribute("flow", "flow");
        }
    },

    _onTalking: function _onTalking(member, stream, meterData, confrId) {},

    _onNotSupportMemberPublishVideoCodecs: function _onNotSupportMemberPublishVideoCodecs(member, stream, confrId) {
        var tag = this._videos[stream.id];
        tag && (0, _zeptoWebpack2.default)(tag).trigger("onNotSupportVideoCodecs", [stream, member, confrId]);
    },
    onNotSupportVideoCodecs: function onNotSupportVideoCodecs(tag, cb) {
        this.addVideoEventListener(tag, "onNotSupportVideoCodecs", cb);
    },

    _onStreamIceStateChanged: function _onStreamIceStateChanged(member, stream, state, confrId) {
        var tag = this._videos[stream.id];
        tag && (0, _zeptoWebpack2.default)(tag).trigger("onIceStateChanged", [state, stream, member, confrId]);
    },
    onIceStateChanged: function onIceStateChanged(tag, cb) {
        this.addVideoEventListener(tag, "onIceStateChanged", cb);
    },

    onHasRemoteControl: function onHasRemoteControl(stream, controler, controlRequest, confrId) {
        var tag = this._videos[stream.id];
        tag && (0, _zeptoWebpack2.default)(tag).trigger("onRemoteControl", [controler, controlRequest, stream, confrId]);
    },
    onRemoteControl: function onRemoteControl(tag, cb) {
        this.addVideoEventListener(tag, "onRemoteControl", cb);
    },

    onRemoteFreeControl: function onRemoteFreeControl(stream, controler, cId, confrId) {
        var tag = this._videos[stream.id];
        tag && (0, _zeptoWebpack2.default)(tag).trigger("onFreeControl", [controler, cId, stream, confrId]);
    },
    onFreeControl: function onFreeControl(tag, cb) {
        this.addVideoEventListener(tag, "onFreeControl", cb);
    },

    addVideoEventListener: function addVideoEventListener(tag, event, callback) {
        (0, _zeptoWebpack2.default)(tag).off(event);
        (0, _zeptoWebpack2.default)(tag).on(event, function () {
            var args = [];
            for (var i = 1; i < arguments.length; i++) {
                args.push(arguments[i]);
            }
            callback && callback.apply(tag, args);
        });
    }
});

_underscore2.default.each(["hungup", "subscribe", "pauseVideo", "resumeVideo", "pauseAudio", "resumeAudio", "chanageCamera", "freeRemoteControl", "capturePictureRemote", "freezeFrameRemote"], function (val, index) {
    var name = val.replace(/\b[a-z]/g, function (s) {
        return s.toUpperCase();
    });
    _single["trigger" + name] = function (tag) {
        var args = [];
        args.push(tag);
        args.push(val);
        Array.prototype.push.apply(args, Array.prototype.slice.call(arguments, 1));
        return _single.zeptoTrigger.apply(_single, args);
    };
});

_single.triggerTorchRemote = function (tag, torch) {
    return _rxjs.Observable.create(function onSubscription(observer) {
        (0, _zeptoWebpack2.default)(tag).trigger("torchRemote", [torch, function fail() {
            observer.error.apply(observer, arguments);
        }, function success() {
            observer.next.apply(observer, arguments);
            observer.complete();
        }]);
    }).pipe(errorHandler).toPromise();
};

_single.triggerZoomRemote = function (tag, multiples) {
    return _rxjs.Observable.create(function onSubscription(observer) {
        (0, _zeptoWebpack2.default)(tag).trigger("zoomRemote", [multiples, function fail() {
            observer.error.apply(observer, arguments);
        }, function success() {
            observer.next.apply(observer, arguments);
            observer.complete();
        }]);
    }).pipe(errorHandler).toPromise();
};

_single.triggerSubscribe = function (tag, subSVideo, subSAudio) {
    return _rxjs.Observable.create(function onSubscription(observer) {
        (0, _zeptoWebpack2.default)(tag).trigger("subscribe", [subSVideo, subSAudio, function fail() {
            observer.error.apply(observer, arguments);
        }, function success() {
            observer.next.apply(observer, arguments);
            observer.complete();
        }]);
    }).pipe(errorHandler).toPromise();
};

_single.triggerRemoteControl = function (tag, mirror, onDisControlled, onAccept, onNotAllowRemoteControl, onRemoteControlTimeout, onReject, onBusy) {
    (0, _zeptoWebpack2.default)(tag).trigger("remoteControl", [mirror, onDisControlled, onAccept, onNotAllowRemoteControl, onRemoteControlTimeout, onReject, onBusy]);
};
_single.triggerCaptureVideo = function (tag, storeLocal, filename) {
    return _rxjs.Observable.create(function onSubscription(observer) {
        (0, _zeptoWebpack2.default)(tag).trigger("captureVideo", [function success() {
            observer.next.apply(observer, arguments);
            observer.complete();
        }, storeLocal, filename]);
    }).pipe(errorHandler).toPromise();
};

var single = exports.single = _single;

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _defineProperty2 = __webpack_require__(227);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _regenerator = __webpack_require__(201);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(204);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _assign = __webpack_require__(149);

var _assign2 = _interopRequireDefault(_assign);

var _typeof2 = __webpack_require__(73);

var _typeof3 = _interopRequireDefault(_typeof2);

var _stringify = __webpack_require__(144);

var _stringify2 = _interopRequireDefault(_stringify);

var _keys = __webpack_require__(178);

var _keys2 = _interopRequireDefault(_keys);

var _classCallCheck2 = __webpack_require__(228);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(229);

var _createClass3 = _interopRequireDefault(_createClass2);

var _event = __webpack_require__(208);

var _event2 = _interopRequireDefault(_event);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * this.data Array
 * [{
 *  type	整型	0表示初始化数据，1表示音视频统计数据，2为事件，此处填1
 *  counterId	整型	递增ID
 *  appCpuUsage	整型	应用的cpu占用率，0-100
 *  systemCpuUsage	整型	系统的cpu占用率，0-100
 *  streamType	整型	流类型,0为正常音视频流，1为共享桌面流
 *  subMemName	字符串	对方的memName，isPub为false有效
 *  subMemId	字符串	对方的memId，isPub为fasle有效
 *  sId	字符串	流ID
 *  rtcId	字符串	rtcId，sdk生成的
 *  isPub	BOOL	是否上传者
 *  audioInputLevel	整型	采集音量大小，isPub为true时有效
 *  time	整型	时间戳，utc时间，单位毫秒
 *  vKBps	整型	视频码率，单位kbps，isPub为ture时为上行，false时为下行
 *  vFps	整型	视频帧率，单位fps，isPub为ture时为上行，false时为下行
 *  vW	整型	视频宽，isPub为ture时为上行，false时为下行
 *  vH	整型	视频高，isPub为ture时为上行，false时为下行
 *  vP	整型	视频包计数，isPub为ture时为上行，false时为下行
 *  vPL	整型	视频包丢失数，isPub为ture时为上行，false时为下行
 *  vPLR	整型	视频丢包率，0-100，isPub为ture时为上行，false时为下行
 *  aKBps	整型	音频码率，单位kbps，isPub为ture时为上行，false时为下行
 *  aP	整型	音频包计数，isPub为ture时为上行，false时为下行
 *  aPL	整型	音频包丢失计数，isPub为ture时为上行，false时为下行
 *  aPLR	整型	音频丢包率，0-100，isPub为ture时为上行，false时为下行
 *  vCodec	字符串	视频编码
 *  aCodec	字符串	音频编码
 * }]
 */
var UploadStats = function () {
    function UploadStats(emedia) {
        (0, _classCallCheck3.default)(this, UploadStats);

        this.emedia = emedia; // emedia 对象 只可读

        this.streams = [];
        this._intervals_get = null; // 收集数据的 interval
        this._intervals_upload = null; // 上报数据的 interval，从这里取数据上报 --- 唯一的
        this.data = [];
        this.counterId = 1;

        this.prev_obj = {
            //  store video、audio of prev package package_lost; sent and receive ...
            /*
            * {
                [sid]: {
                    time:,
                    audio: {
                        bytes:56780,
                        packets: 890,
                        packetsLost: 2
                     },
                    video: {
                        bytes:56780,
                        packets: 890,
                        packetsLost: 2
                    }
                }
            }
            */
        };

        this.sessionId = null;

        this.network_quality_obj = {
            /**
             * [sId]: {
             *  RTT: { time, value }
             *  aPLR: { time, value}
             *  vPLR: { time, value}
             *  disconnect: { time }
            //  *  status: 0 | 1 | 2 , 0: 没有数据，1:网络不好 2: 网络好 
             * }
            */
        };
        this.network_quality_threshold = { // 网络质量差的阈值 , 连续 time 内大于 value
            RTT: {
                time: 8000, // ms
                value: 500 // ms
            },
            aPLR: {
                time: 8000, // ms
                value: 18 // %
            },
            vPLR: {
                time: 8000, // ms
                value: 23 // %
            },
            disconnect: { time: 5000 // ms
            } }, this.re_timer_count = 0; // 重连次数
    }

    (0, _createClass3.default)(UploadStats, [{
        key: '_get_url',
        value: function _get_url() {

            var url = '';
            var current = this.emedia.useCurrentXService.current;


            if (!current) {
                return url;
            }

            var _current$ticket = current.ticket,
                qoeUpUrl = _current$ticket.qoeUpUrl,
                memName = _current$ticket.memName;

            memName = memName.split('_')[1];

            var appkey = emedia.config.appkey;

            var orgName = appkey.split('#')[0],
                appName = appkey.split('#')[1];

            var ts = new Date().getTime();
            var access_token = emedia.mgr.identityToken;

            url = qoeUpUrl + '?orgName=' + orgName + '&appName=' + appName + '&memName=' + memName + '&ts=' + ts + '&access_token=' + access_token;

            return url;
        }
    }, {
        key: 'connect_ws',
        value: function connect_ws() {
            // 创建websocket长连接

            var url = this._get_url();
            if (!url) {
                console.error('upload stats not have ws url');
                return;
            }

            var socket = new WebSocket(url);

            var _this = this;
            socket.onopen = function () {
                console.log('upload stats ws connected');
                _this.ws_connected = true;
                _this.socket = socket;

                if (_this.re_connect) {
                    // 如果是重连的
                    console.log('has Reconnectioned');

                    console.log('before joinS');
                    if (_this.sessionId) {
                        console.log('have sessID');
                        _this.join_success(_this.sessionId);
                    }
                }
            };

            socket.onclose = function (error) {
                _this._stop_timer();
                _this.ws_connected = false;
                console.error('upload stats ws close', error);

                // 只在有网的状态下和 没有退出会议时重连
                if (!_this.exited_meeting && navigator.onLine) _this.reconnection();
            };

            socket.message = function (evt) {
                console.log('upload stats ws recv msg', evt);
            };

            socket.onerror = function (error) {
                console.error('upload stats ws error', error);
            };

            window.addEventListener("online", function () {
                _this.re_timer_count = 0;
                _this.reconnection();
            });
        }

        // 断网重连 Reconnection

    }, {
        key: 'reconnection',
        value: function reconnection() {

            if (this.ws_connected) return;

            var _this = this;
            this.reconnection_timer = setInterval(function () {
                if (_this.ws_connected || _this.re_timer_count >= 10) {
                    clearInterval(_this.reconnection_timer);
                } else {
                    console.log('reconnection...');
                    _this.re_connect = true;
                    _this.connect_ws();
                    _this.re_timer_count++;
                }
            }, 5000);
        }
    }, {
        key: 'start',
        value: function start() {
            // 开始发送数据 -- 直到退出会议
            var _this = this;
            this._intervals_get = setInterval(_this.get.bind(this), 2000);
            this._intervals_upload = setInterval(_this.upload.bind(this), 500);
        }
    }, {
        key: 'join_success',
        value: function join_success(sessionId) {
            // 加入成功，开始发送 stats

            if (!sessionId) {
                return;
            }

            this.sessionId = sessionId;
            this.data.unshift(this._get_init_data());

            this.start();
        }
    }, {
        key: 'join_fail',
        value: function join_fail() {
            // 加入失败，发送一条错误的 msg

            var _o = {
                type: 0,
                result: 1,
                errorInfo: 'join fail'

                // 直接发送一条数据
            };if (this.socket) {
                this.socket.send(_o);
            }
        }
    }, {
        key: 'get',
        value: function get() {
            // 收集
            if (!this.emedia.useCurrentXService || !this.emedia.useCurrentXService.current || !this.emedia.useCurrentXService.current._cacheStreams) {
                return; // no streams return
            }

            var streams = this.emedia.useCurrentXService.current._cacheStreams; // object { streamid: stream }

            var _this = this;
            (0, _keys2.default)(streams).map(function (key) {
                _this.push_stats_to_data(streams[key]);
            });
        }
    }, {
        key: 'upload',
        value: function upload() {
            // 上报

            if (this.data.length == 0) {
                console.warn('upload_stats upload fun -- this.data.length == 0');
                return;
            }

            if (!this.socket) {
                // 如果没有连接成功, 不发数据
                return;
            }

            var item = this.data.shift(); // 发送出去并删除

            if (item.counterId == undefined) {
                // 给每一个 data 添加 counterId、在这里添加才能保持 唯一性
                item.counterId = this.counterId;
                this.counterId = this.counterId + 1; // 递增
            }

            this.socket.send((0, _stringify2.default)(item));
        }

        // 事件上报

    }, {
        key: 'upload_event',
        value: function upload_event(evt) {
            if (!evt) {
                return;
            }

            var event_obj = this._get_format_event_obj(evt);

            if (!event_obj) {
                return;
            }

            this.data.splice(1, 0, event_obj); // send event frist , but init data must array[0]
        }
        // format event

    }, {
        key: '_get_format_event_obj',
        value: function _get_format_event_obj(evt) {

            var _o = {
                type: 2,
                time: new Date().getTime()
            };

            if ((0, _typeof3.default)(evt.event) != 'object' && // 有的 会有 event obj ignore
            evt.event != undefined) {
                // 从另一个地方接收 EventsObservable.js 直接组织好

                return (0, _assign2.default)(_o, evt);
            }

            var sessionId = this.sessionId;

            if (evt instanceof _event2.default.ICEConnected) {

                var obj = this._get_ice_connect_state_obj(evt.webrtc, 2);
                _o = (0, _assign2.default)(_o, obj);
            } else if (evt instanceof _event2.default.ICEConnectFail) {
                var _obj = this._get_ice_connect_state_obj(evt.webrtc, 4);
                _o = (0, _assign2.default)(_o, _obj);
            } else if (evt instanceof _event2.default.ICEDisconnected) {
                //只要ICE断开
                var _obj2 = this._get_ice_connect_state_obj(evt.webrtc, 5);
                _o = (0, _assign2.default)(_o, _obj2);
            } else if (evt instanceof _event2.default.PushSuccess) {

                if (!evt.hidden) {
                    // hidden: false 为多余的
                    return undefined;
                }

                var _evt$stream = evt.stream,
                    rtcId = _evt$stream.rtcId,
                    voff = _evt$stream.voff,
                    aoff = _evt$stream.aoff,
                    streamType = _evt$stream.type;


                var _obj3 = {
                    event: 14,
                    sessionId: sessionId,
                    rtcId: rtcId,
                    voff: voff,
                    aoff: aoff,
                    streamType: streamType,
                    result: 0
                    // vcode: ???
                };

                _o = (0, _assign2.default)(_o, _obj3);
            } else if (evt instanceof _event2.default.SubSuccess) {
                var _evt$stream2 = evt.stream,
                    _rtcId = _evt$stream2.rtcId,
                    sId = _evt$stream2.id,
                    _streamType = _evt$stream2.type,
                    subMemId = _evt$stream2.memId,
                    subMemName = _evt$stream2.memName;


                var _obj4 = {
                    event: 16,
                    rtcId: _rtcId,
                    sId: sId,
                    sessionId: sessionId,
                    result: 0,
                    streamType: _streamType,
                    subMemName: subMemName,
                    subMemId: subMemId
                };

                _o = (0, _assign2.default)(_o, _obj4);
            } else if (evt instanceof _event2.default.EnterSuccess) {
                var _obj5 = {
                    event: 0,
                    ip: evt.ip
                    // hopeVCode: ???
                };

                _o = (0, _assign2.default)(_o, _obj5);
            }

            if (_o.event == undefined) {
                // filter not use
                return undefined;
            }
            return _o;
        }
    }, {
        key: '_get_ice_connect_state_obj',
        value: function _get_ice_connect_state_obj(webrtc, state) {
            // adopt webrtc get stream
            var current = this.emedia.useCurrentXService.current;


            var stream = null;

            for (var sid in current._linkedStreams) {

                if (current._linkedStreams[sid].rtcId == webrtc.getRtcId()) {
                    stream = current._linkedStreams[sid];
                }
            }

            if (!stream) {
                return {};
            }

            var _o = {
                event: 20,
                rtcId: stream.rtcId,
                connState: state,
                isPub: stream.located(),
                sId: stream.id,
                rtcCfg: stream.rtcCfg,
                voff: stream.voff,
                aoff: stream.aoff
            };

            if (!stream.located()) {
                // 订阅的字段
                var sub_o = {
                    subSId: stream.id,
                    subMemName: stream.memName,
                    subMemId: stream.memId,
                    subVideo: stream.subSVideo,
                    subAudio: stream.subSAudio
                };

                _o = (0, _assign2.default)(_o, sub_o);
            }

            return _o;
        }

        // 停止上报和收集

    }, {
        key: 'stop',
        value: function stop() {
            this.exited_meeting = true;
            this.socket.close();

            this._stop_timer();
        }
    }, {
        key: '_stop_timer',
        value: function _stop_timer() {
            clearInterval(this._intervals_get);
            clearInterval(this._intervals_upload);
        }
    }, {
        key: 'push_stats_to_data',
        value: function () {
            var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(stream) {
                var stats, upload_obj;
                return _regenerator2.default.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                if (stream._webrtc) {
                                    _context.next = 2;
                                    break;
                                }

                                return _context.abrupt('return');

                            case 2:
                                _context.next = 4;
                                return stream._webrtc._rtcPeerConnection.getStats();

                            case 4:
                                stats = _context.sent;
                                upload_obj = this._get_format_upload_obj(stats, stream);


                                this.data.push(upload_obj);

                            case 7:
                            case 'end':
                                return _context.stop();
                        }
                    }
                }, _callee, this);
            }));

            function push_stats_to_data(_x) {
                return _ref.apply(this, arguments);
            }

            return push_stats_to_data;
        }()
    }, {
        key: '_get_init_data',
        value: function _get_init_data() {
            // 初始化的一条数据
            var _o = {};

            var currentXService = this.emedia.useCurrentXService.current;
            if (!currentXService) {
                return;
            }

            var _emedia$config = this.emedia.config,
                appkey = _emedia$config.appkey,
                sdkVersion = _emedia$config.version,
                confrId = currentXService.confrId,
                memId = currentXService._memberId,
                memName = currentXService.memName,
                sessionId = this.sessionId,
                _emedia = this.emedia,
                deviceInfo = _emedia.browser,
                osVersion = _emedia.browserVersion,
                isWifi = _emedia.isWifi;


            _o = {
                type: 0,
                counterId: 0,
                appkey: appkey,
                confrId: confrId,
                memId: memId, //字符串	上传者的memId，result为0时有效
                memName: memName,
                time: new Date().getTime(),
                joinConfrTime: currentXService.ticket.timestamp, //整型	加入会议成功的时间，result为0时有效
                sessionId: sessionId, //字符串	会议的sessionID，result为0时有效
                networkType: 'WIFI', //字符串	网络类型，包括“WIFI”，“LAN”，“4G”
                sdkOS: 'Web',
                sdkVersion: sdkVersion,
                deviceInfo: deviceInfo,
                osVersion: osVersion,
                result: 0 //整型	加入会议的结果，0为成功，其他失败
            };

            return _o;
        }
        // 将 stats 和 stream 融合成后端 需要的 核心方法

    }, {
        key: '_get_format_upload_obj',
        value: function _get_format_upload_obj(stats, stream) {
            // 在 stats 中采集需要的数据
            /**
             * stats： webRtc 的原始数组，包含多种数据
             * stream_info : 流的信息，sId、memId ...
             * sample：https://webrtc.github.io/samples/src/content/peerconnection/constraints/
             */

            // 可以判断sent、received
            var _o = {
                type: 1,
                time: new Date().getTime(),
                streamType: stream.type,
                sId: stream.id,
                rtcId: stream.rtcId
            };

            if (stream.located()) {
                // 上行的流
                _o.isPub = true;
                var outbound_stats_obj = this._get_outbound_stats(stats);

                _o = (0, _assign2.default)(_o, outbound_stats_obj);
            } else {
                // 下行的流
                _o.isPub = false;
                _o.subMemName = stream.memName;
                _o.subMemId = stream.memId;

                var inbound_stats_obj = this._get_inbound_stats(stats);

                _o = (0, _assign2.default)(_o, inbound_stats_obj);
            }

            // 获取码率 和丢包率
            _o = this._calc_KBps_and_PLR(_o);

            // 将 某些 data 的值转化为 int
            _o = this._set_stats_int(_o);

            return _o;
        }

        // 上行数据

    }, {
        key: '_get_outbound_stats',
        value: function _get_outbound_stats(stats) {
            var _o = {};

            stats.forEach(function (item) {

                if (item.type == 'outbound-rtp') {
                    if (item.mediaType == 'audio') {
                        _o.aP = item.packetsSent;

                        _o.aB = item.bytesSent; // 临时存储
                    }
                    if (item.mediaType == 'video') {
                        _o.vW = item.frameWidth;
                        _o.vH = item.frameHeight;
                        _o.vP = item.packetsSent;

                        _o.vB = item.bytesSent; // 临时存储
                    }
                }

                if (item.type == 'remote-inbound-rtp') {
                    // get packetlost
                    if (item.kind == 'audio') {
                        _o.aPL = item.packetsLost;
                    }
                    if (item.kind == 'video') {
                        _o.vPL = item.packetsLost;
                    }
                }

                if (item.type == 'media-source') {

                    if (item.kind == 'audio') {
                        _o.audioInputLevel = item.audioLevel * 1000;
                    }

                    if (item.kind == 'video') {
                        _o.vFps = item.framesPerSecond;
                    }
                }

                if (item.type == 'candidate-pair') {
                    _o.RTT = item.totalRoundTripTime * 1000 / item.responsesReceived; // totalRoundTripTime: s ---> 换算成ms 
                }
            });

            return _o;
        }

        // 下行数据

    }, {
        key: '_get_inbound_stats',
        value: function _get_inbound_stats(stats) {
            var _o = {};
            stats.forEach(function (item) {

                if (item.type == 'inbound-rtp') {
                    if (item.kind == 'audio' || item.id.indexOf('AudioStream') > -1) {
                        //兼容 safiri
                        _o.aP = item.packetsReceived;
                        _o.aPL = item.packetsLost;

                        _o.aB = item.bytesReceived; // 临时存储
                    }

                    if (item.kind == 'video' || item.id.indexOf('VideoStream') > -1) {
                        //兼容 safiri
                        _o.vP = item.packetsReceived;
                        _o.vPL = item.packetsLost;

                        _o.vB = item.bytesReceived; // 临时存储
                    }
                }

                if (item.type == 'track') {
                    if (item.kind == 'video') {
                        _o.vW = item.frameWidth;
                        _o.vH = item.frameHeight;

                        _o.vFR = item.framesReceived; // 暂存
                    }

                    if (item.kind == 'audio') {
                        _o.audioInputLevel = item.audioLevel * 1000; // 貌似一直为 0
                    }
                }

                if (item.type == 'candidate-pair') {
                    _o.RTT = item.totalRoundTripTime * 1000 / item.responsesReceived; // totalRoundTripTime: s ---> 换算成ms 
                }
            });

            return _o;
        }

        // 计算码率和丢包率和下行帧率

    }, {
        key: '_calc_KBps_and_PLR',
        value: function _calc_KBps_and_PLR(upload_obj) {
            var sId = upload_obj.sId,
                aB = upload_obj.aB,
                vB = upload_obj.vB,
                time = upload_obj.time;

            // 计算码率

            upload_obj.aKBps = this._get_KBps_by_sId(sId, 'audio', aB, time) || 0;
            upload_obj.vKBps = this._get_KBps_by_sId(sId, 'video', vB, time) || 0;

            // 计算丢包率
            var aP = upload_obj.aP,
                aPL = upload_obj.aPL,
                vP = upload_obj.vP,
                vPL = upload_obj.vPL;


            var aPLR = this._get_PLR_by_sId(sId, 'audio', aP, aPL);
            var vPLR = this._get_PLR_by_sId(sId, 'video', vP, vPL);

            if (aPLR || aPLR == 0) {
                upload_obj.aPLR = aPLR;
            }

            if (vPLR || vPLR == 0) {
                upload_obj.vPLR = vPLR;
            }

            // 下行帧率
            if (!upload_obj.isPub) {
                var vFR = upload_obj.vFR;


                if (this.prev_obj[sId] && this.prev_obj[sId]['video'] && this.prev_obj[sId]['video']['framesReceived']) {
                    var prev_time = this.prev_obj[sId].time;
                    var prev_vFR = this.prev_obj[sId]['video']['framesReceived'];

                    var interval = (time - prev_time) / 1000; // 单位：s
                    var vFps = (vFR - prev_vFR) / interval;
                    if (vFps < 0) {
                        vFps = 0;
                    };
                    upload_obj.vFps = vFps;
                }
            }
            // 获取网络质量
            // const network_quality = this._network_quality(upload_obj);
            // const network_disconnect = this._network_disconnect(upload_obj);
            var network_quality = this._get_w_quality(upload_obj);

            if (network_quality != 2) {

                var event_obj = {
                    time: new Date().getTime(),
                    event: 4,
                    type: 2,
                    counterId: this.counterId,
                    sessionId: this.sessionId,
                    rtcId: upload_obj.rtcId,
                    sId: upload_obj.sId,
                    isPub: upload_obj.isPub,
                    streamType: upload_obj.sId,
                    aoff: upload_obj.aoff,
                    voff: upload_obj.voff,
                    subMemName: upload_obj.subMemName,
                    subMemId: upload_obj.subMemId
                };

                this.data.push(event_obj); // 上报事件
            }

            // 触发网络状态检测回调
            if (this.emedia.mgr && this.emedia.mgr.onNetworkQuality) {
                var callback = this.emedia.mgr.onNetworkQuality;

                if (typeof callback == 'function') {
                    callback(upload_obj.sId, network_quality);
                }
            }

            // 存储上一个数据
            this._set_prev_obj(upload_obj);

            // 删除 aB、vB、vFR 发送不需要，只用来计算码率
            delete upload_obj.aB; // audio bytesSent or bytesReceived
            delete upload_obj.vB; // video bytesSent or bytesReceived
            delete upload_obj.vFR; // video framesReceived 
            delete upload_obj.RTT; // RTT 计算网络质量

            return upload_obj;
        }
    }, {
        key: '_set_stats_int',
        value: function _set_stats_int(_o) {
            // 将stats 转换为 整型

            var need_int_keys = ['audioInputLevel', 'vKBps', 'vFps', 'vW', 'vH', 'vP', 'vPL', 'vPLR', 'aKBps', 'aP', 'aPL', 'aPLR'];
            for (var key in _o) {
                if (need_int_keys.indexOf(key) > -1) {
                    _o[key] = Math.round(_o[key]);
                }
            }

            return _o;
        }

        // 通过和上一次的字节比较 计算码率 通过 sId

    }, {
        key: '_get_KBps_by_sId',
        value: function _get_KBps_by_sId(sId, kind, bytes, time) {

            if (!sId || !kind || !bytes) {
                return null;
            }

            var prev_info = this.prev_obj[sId];

            if (!prev_info || !prev_info[kind] || !prev_info[kind]['bytes']) {
                // 首次或者 没有
                return null;
            }

            var prev_time = prev_info.time;
            var prev_bytes = prev_info[kind].bytes;


            var interval = parseInt(time - prev_time); // 时间间隔 ms

            var increment = bytes - prev_bytes;

            if (increment < 0) {
                // 这种情况出现在 开启摄像头， 直接置为 0 
                increment = 0;
            }

            var bytes_rate = increment / (interval / 1000).toFixed(2); // 以 S 为单位

            return bytes_rate / 1000; // KBps
        }

        /**
         * 丢包率
         * 某一时间段内 --  丢包数量/(接收或者发送包数+丢包数量)
         * kind: video or audio
         * end_type: sent or received
         * package_num : total of package sent or receive, 
         * package_loat_num: total of package lost  sent or receive
         * */

    }, {
        key: '_get_PLR_by_sId',
        value: function _get_PLR_by_sId(sId, kind, packets, packets_lost) {

            if (!sId) {
                return null;
            }

            if (!kind || !packets || !packets_lost) {
                return 0;
            }

            var prev_info = this.prev_obj[sId];

            if (!prev_info || !prev_info[kind] || !prev_info[kind]['packets'] || !prev_info[kind]['packets_lost']) {
                return 0;
            }

            var _prev_info$kind = prev_info[kind],
                prev_packets = _prev_info$kind.packets,
                prev_packets_lost = _prev_info$kind.packets_lost;


            var packets_increment = packets - prev_packets,
                packets_lost_increment = packets_lost - prev_packets_lost;

            var packets_lost_rate = packets_lost_increment / (packets_increment + packets_lost_increment);
            packets_lost_rate = Math.round(packets_lost_rate * 100);

            return packets_lost_rate;
        }

        // 存储上次数据

    }, {
        key: '_set_prev_obj',
        value: function _set_prev_obj(_o) {
            var sId = _o.sId;

            if (!sId) {
                return;
            }

            var aB = _o.aB,
                vB = _o.vB,
                time = _o.time,
                aP = _o.aP,
                aPL = _o.aPL,
                vP = _o.vP,
                vPL = _o.vPL,
                vFR = _o.vFR;


            var audio = {},
                video = {};

            if (aB) {
                audio.bytes = aB;
            }
            if (aP) {
                audio.packets = aP;
            }
            if (aPL || aPL == 0) {
                audio.packets_lost = aPL;
            }
            // video
            if (vB) {
                video.bytes = vB;
            }
            if (vP) {
                video.packets = vP;
            }
            if (vPL || vPL == 0) {
                video.packets_lost = vPL;
            }
            if (vFR) {
                video.framesReceived = vFR;
            }

            if ((0, _keys2.default)(audio).length == 0 && (0, _keys2.default)(video).length == 0) {
                // 都是空对象
                return;
            }

            if (!this.prev_obj[sId]) {
                this.prev_obj[sId] = {};
            }
            this.prev_obj[sId].time = time;

            if ((0, _keys2.default)(audio).length > 0) {
                this.prev_obj[sId].audio = audio;
            }

            if ((0, _keys2.default)(video).length > 0) {
                this.prev_obj[sId].video = video;
            }
        }

        // 检测网络质量 0 无数据 1 网络差 2 网络好

    }, {
        key: '_get_w_quality',
        value: function _get_w_quality(upload_obj) {
            var RTT = upload_obj.RTT,
                aPLR = upload_obj.aPLR,
                vPLR = upload_obj.vPLR,
                time = upload_obj.time,
                vKBps = upload_obj.vKBps,
                aKBps = upload_obj.aKBps,
                sId = upload_obj.sId;


            if (!sId) {
                return 2;
            }

            var _this = this;
            // start calc disconnect
            var is_dis = function is_dis() {
                var sId_info = _this.network_quality_obj[sId];

                // 断网检测 vKBps, aKBps 同时为零连续一段时间 基本可判断 断网
                if (!sId_info) {
                    // 首次获取数据
                    _this.network_quality_obj[sId] = { disconnect: { time: time } };
                    return false;
                }

                if (!sId_info['disconnect']) {
                    // 第一次计算这个, 赋值
                    _this.network_quality_obj[sId] = { disconnect: { time: time } };
                    return false;
                }

                var frist_time = sId_info['disconnect'].time;

                var timeout = _this.network_quality_threshold['disconnect'].time;

                if (time - frist_time >= timeout) {
                    // 累计到一定时间
                    return true;
                }

                return false;
                // 初始化或者 比较是否累计到了一定时间
                // time 当前时间
                // s --> f_dis_time 流下面的第一次 无数据时间
                // dis_timeout 设定的累计时间
            };

            // stop disconnect
            var reset_dis_time = function reset_dis_time() {
                var sId_info = _this.network_quality_obj[sId];
                if (!sId_info || !sId_info['disconnect']) return; //从未赋值过，返回

                _this.network_quality_obj[sId]['disconnect'] = undefined;
            };

            // start calc weak
            // 检测弱网

            var is_weak = function is_weak(type) {
                if (!type || !time) {
                    return false;
                }

                var sId_info = _this.network_quality_obj[sId];

                if (!sId_info) {
                    // 第一次接收数据 type、
                    _this.network_quality_obj[sId] = (0, _defineProperty3.default)({}, type, { time: time });

                    return false;
                }
                if (!sId_info[type]) {
                    // 第一次达到弱网阈值 type
                    _this.network_quality_obj[sId][type] = { time: time };
                    return false;
                }

                var frist_time = sId_info[type].time;
                var timeout = _this.network_quality_threshold[type].time;

                // 达到阈值，并且timeout 返回 true
                if (time - frist_time >= timeout) {
                    return true;
                }

                return false;
            };
            // stop weak
            var reset_weak_tiem = function reset_weak_tiem(type) {
                var sId_info = _this.network_quality_obj[sId];

                if (!sId_info || !sId_info[type]) return; //从未赋值过，返回

                _this.network_quality_obj[sId][type] = undefined;
            };
            // good

            // vKBps=0,aKBps=0;


            if (!vKBps && !aKBps) {
                if (is_dis()) {
                    return 0;
                }

                return 2;
            } else {
                reset_dis_time();

                var checks = ['RTT', 'aPLR', 'vPLR']; // 检测弱网的条件，一个符合则弱网
                var weak = 2;

                for (var index = 0; index < checks.length; index++) {
                    var type = checks[index];
                    var threshold = this.network_quality_threshold[type].value;

                    if (upload_obj[type] >= threshold) {
                        // 达到阈值，开始计算
                        if (is_weak(type, time)) weak = 1;
                    } else {
                        reset_weak_tiem(type);
                    }
                }

                return weak;
            }
        }
    }]);
    return UploadStats;
}();

exports.default = UploadStats;

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(197);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (obj, key, value) {
  if (key in obj) {
    (0, _defineProperty2.default)(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(197);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

/***/ }),
/* 230 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(231);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Observable", function() { return _internal_Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"]; });

/* harmony import */ var _internal_observable_ConnectableObservable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(248);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ConnectableObservable", function() { return _internal_observable_ConnectableObservable__WEBPACK_IMPORTED_MODULE_1__["ConnectableObservable"]; });

/* harmony import */ var _internal_operators_groupBy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(253);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GroupedObservable", function() { return _internal_operators_groupBy__WEBPACK_IMPORTED_MODULE_2__["GroupedObservable"]; });

/* harmony import */ var _internal_symbol_observable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(245);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "observable", function() { return _internal_symbol_observable__WEBPACK_IMPORTED_MODULE_3__["observable"]; });

/* harmony import */ var _internal_Subject__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(249);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Subject", function() { return _internal_Subject__WEBPACK_IMPORTED_MODULE_4__["Subject"]; });

/* harmony import */ var _internal_BehaviorSubject__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(254);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BehaviorSubject", function() { return _internal_BehaviorSubject__WEBPACK_IMPORTED_MODULE_5__["BehaviorSubject"]; });

/* harmony import */ var _internal_ReplaySubject__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(255);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ReplaySubject", function() { return _internal_ReplaySubject__WEBPACK_IMPORTED_MODULE_6__["ReplaySubject"]; });

/* harmony import */ var _internal_AsyncSubject__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(272);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AsyncSubject", function() { return _internal_AsyncSubject__WEBPACK_IMPORTED_MODULE_7__["AsyncSubject"]; });

/* harmony import */ var _internal_scheduler_asap__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(273);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "asapScheduler", function() { return _internal_scheduler_asap__WEBPACK_IMPORTED_MODULE_8__["asap"]; });

/* harmony import */ var _internal_scheduler_async__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(277);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "asyncScheduler", function() { return _internal_scheduler_async__WEBPACK_IMPORTED_MODULE_9__["async"]; });

/* harmony import */ var _internal_scheduler_queue__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(256);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "queueScheduler", function() { return _internal_scheduler_queue__WEBPACK_IMPORTED_MODULE_10__["queue"]; });

/* harmony import */ var _internal_scheduler_animationFrame__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(278);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "animationFrameScheduler", function() { return _internal_scheduler_animationFrame__WEBPACK_IMPORTED_MODULE_11__["animationFrame"]; });

/* harmony import */ var _internal_scheduler_VirtualTimeScheduler__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(281);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VirtualTimeScheduler", function() { return _internal_scheduler_VirtualTimeScheduler__WEBPACK_IMPORTED_MODULE_12__["VirtualTimeScheduler"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VirtualAction", function() { return _internal_scheduler_VirtualTimeScheduler__WEBPACK_IMPORTED_MODULE_12__["VirtualAction"]; });

/* harmony import */ var _internal_Scheduler__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(262);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Scheduler", function() { return _internal_Scheduler__WEBPACK_IMPORTED_MODULE_13__["Scheduler"]; });

/* harmony import */ var _internal_Subscription__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(239);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Subscription", function() { return _internal_Subscription__WEBPACK_IMPORTED_MODULE_14__["Subscription"]; });

/* harmony import */ var _internal_Subscriber__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(233);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Subscriber", function() { return _internal_Subscriber__WEBPACK_IMPORTED_MODULE_15__["Subscriber"]; });

/* harmony import */ var _internal_Notification__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(264);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Notification", function() { return _internal_Notification__WEBPACK_IMPORTED_MODULE_16__["Notification"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NotificationKind", function() { return _internal_Notification__WEBPACK_IMPORTED_MODULE_16__["NotificationKind"]; });

/* harmony import */ var _internal_util_pipe__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(246);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pipe", function() { return _internal_util_pipe__WEBPACK_IMPORTED_MODULE_17__["pipe"]; });

/* harmony import */ var _internal_util_noop__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(247);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "noop", function() { return _internal_util_noop__WEBPACK_IMPORTED_MODULE_18__["noop"]; });

/* harmony import */ var _internal_util_identity__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(282);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return _internal_util_identity__WEBPACK_IMPORTED_MODULE_19__["identity"]; });

/* harmony import */ var _internal_util_isObservable__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(283);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isObservable", function() { return _internal_util_isObservable__WEBPACK_IMPORTED_MODULE_20__["isObservable"]; });

/* harmony import */ var _internal_util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(284);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ArgumentOutOfRangeError", function() { return _internal_util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_21__["ArgumentOutOfRangeError"]; });

/* harmony import */ var _internal_util_EmptyError__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(285);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EmptyError", function() { return _internal_util_EmptyError__WEBPACK_IMPORTED_MODULE_22__["EmptyError"]; });

/* harmony import */ var _internal_util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(250);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ObjectUnsubscribedError", function() { return _internal_util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_23__["ObjectUnsubscribedError"]; });

/* harmony import */ var _internal_util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(242);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "UnsubscriptionError", function() { return _internal_util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_24__["UnsubscriptionError"]; });

/* harmony import */ var _internal_util_TimeoutError__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(286);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimeoutError", function() { return _internal_util_TimeoutError__WEBPACK_IMPORTED_MODULE_25__["TimeoutError"]; });

/* harmony import */ var _internal_observable_bindCallback__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(287);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bindCallback", function() { return _internal_observable_bindCallback__WEBPACK_IMPORTED_MODULE_26__["bindCallback"]; });

/* harmony import */ var _internal_observable_bindNodeCallback__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(289);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bindNodeCallback", function() { return _internal_observable_bindNodeCallback__WEBPACK_IMPORTED_MODULE_27__["bindNodeCallback"]; });

/* harmony import */ var _internal_observable_combineLatest__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(290);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "combineLatest", function() { return _internal_observable_combineLatest__WEBPACK_IMPORTED_MODULE_28__["combineLatest"]; });

/* harmony import */ var _internal_observable_concat__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(301);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concat", function() { return _internal_observable_concat__WEBPACK_IMPORTED_MODULE_29__["concat"]; });

/* harmony import */ var _internal_observable_defer__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(312);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "defer", function() { return _internal_observable_defer__WEBPACK_IMPORTED_MODULE_30__["defer"]; });

/* harmony import */ var _internal_observable_empty__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(265);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "empty", function() { return _internal_observable_empty__WEBPACK_IMPORTED_MODULE_31__["empty"]; });

/* harmony import */ var _internal_observable_forkJoin__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(313);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "forkJoin", function() { return _internal_observable_forkJoin__WEBPACK_IMPORTED_MODULE_32__["forkJoin"]; });

/* harmony import */ var _internal_observable_from__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(305);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "from", function() { return _internal_observable_from__WEBPACK_IMPORTED_MODULE_33__["from"]; });

/* harmony import */ var _internal_observable_fromEvent__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(314);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fromEvent", function() { return _internal_observable_fromEvent__WEBPACK_IMPORTED_MODULE_34__["fromEvent"]; });

/* harmony import */ var _internal_observable_fromEventPattern__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(315);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fromEventPattern", function() { return _internal_observable_fromEventPattern__WEBPACK_IMPORTED_MODULE_35__["fromEventPattern"]; });

/* harmony import */ var _internal_observable_generate__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(316);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "generate", function() { return _internal_observable_generate__WEBPACK_IMPORTED_MODULE_36__["generate"]; });

/* harmony import */ var _internal_observable_iif__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(317);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "iif", function() { return _internal_observable_iif__WEBPACK_IMPORTED_MODULE_37__["iif"]; });

/* harmony import */ var _internal_observable_interval__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(318);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interval", function() { return _internal_observable_interval__WEBPACK_IMPORTED_MODULE_38__["interval"]; });

/* harmony import */ var _internal_observable_merge__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(320);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return _internal_observable_merge__WEBPACK_IMPORTED_MODULE_39__["merge"]; });

/* harmony import */ var _internal_observable_never__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(321);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "never", function() { return _internal_observable_never__WEBPACK_IMPORTED_MODULE_40__["never"]; });

/* harmony import */ var _internal_observable_of__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(266);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "of", function() { return _internal_observable_of__WEBPACK_IMPORTED_MODULE_41__["of"]; });

/* harmony import */ var _internal_observable_onErrorResumeNext__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(322);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "onErrorResumeNext", function() { return _internal_observable_onErrorResumeNext__WEBPACK_IMPORTED_MODULE_42__["onErrorResumeNext"]; });

/* harmony import */ var _internal_observable_pairs__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(323);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pairs", function() { return _internal_observable_pairs__WEBPACK_IMPORTED_MODULE_43__["pairs"]; });

/* harmony import */ var _internal_observable_partition__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(324);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "partition", function() { return _internal_observable_partition__WEBPACK_IMPORTED_MODULE_44__["partition"]; });

/* harmony import */ var _internal_observable_race__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(327);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "race", function() { return _internal_observable_race__WEBPACK_IMPORTED_MODULE_45__["race"]; });

/* harmony import */ var _internal_observable_range__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(328);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "range", function() { return _internal_observable_range__WEBPACK_IMPORTED_MODULE_46__["range"]; });

/* harmony import */ var _internal_observable_throwError__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(271);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "throwError", function() { return _internal_observable_throwError__WEBPACK_IMPORTED_MODULE_47__["throwError"]; });

/* harmony import */ var _internal_observable_timer__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(329);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timer", function() { return _internal_observable_timer__WEBPACK_IMPORTED_MODULE_48__["timer"]; });

/* harmony import */ var _internal_observable_using__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(330);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "using", function() { return _internal_observable_using__WEBPACK_IMPORTED_MODULE_49__["using"]; });

/* harmony import */ var _internal_observable_zip__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(331);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zip", function() { return _internal_observable_zip__WEBPACK_IMPORTED_MODULE_50__["zip"]; });

/* harmony import */ var _internal_scheduled_scheduled__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(306);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scheduled", function() { return _internal_scheduled_scheduled__WEBPACK_IMPORTED_MODULE_51__["scheduled"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EMPTY", function() { return _internal_observable_empty__WEBPACK_IMPORTED_MODULE_31__["EMPTY"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NEVER", function() { return _internal_observable_never__WEBPACK_IMPORTED_MODULE_40__["NEVER"]; });

/* harmony import */ var _internal_config__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(237);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "config", function() { return _internal_config__WEBPACK_IMPORTED_MODULE_52__["config"]; });

/** PURE_IMPORTS_START  PURE_IMPORTS_END */























































//# sourceMappingURL=index.js.map


/***/ }),
/* 231 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Observable", function() { return Observable; });
/* harmony import */ var _util_canReportError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(232);
/* harmony import */ var _util_toSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(244);
/* harmony import */ var _symbol_observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(245);
/* harmony import */ var _util_pipe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(246);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(237);
/** PURE_IMPORTS_START _util_canReportError,_util_toSubscriber,_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */





var Observable = /*@__PURE__*/ (function () {
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = Object(_util_toSubscriber__WEBPACK_IMPORTED_MODULE_1__["toSubscriber"])(observerOrNext, error, complete);
        if (operator) {
            sink.add(operator.call(sink, this.source));
        }
        else {
            sink.add(this.source || (_config__WEBPACK_IMPORTED_MODULE_4__["config"].useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?
                this._subscribe(sink) :
                this._trySubscribe(sink));
        }
        if (_config__WEBPACK_IMPORTED_MODULE_4__["config"].useDeprecatedSynchronousErrorHandling) {
            if (sink.syncErrorThrowable) {
                sink.syncErrorThrowable = false;
                if (sink.syncErrorThrown) {
                    throw sink.syncErrorValue;
                }
            }
        }
        return sink;
    };
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        }
        catch (err) {
            if (_config__WEBPACK_IMPORTED_MODULE_4__["config"].useDeprecatedSynchronousErrorHandling) {
                sink.syncErrorThrown = true;
                sink.syncErrorValue = err;
            }
            if (Object(_util_canReportError__WEBPACK_IMPORTED_MODULE_0__["canReportError"])(sink)) {
                sink.error(err);
            }
            else {
                console.warn(err);
            }
        }
    };
    Observable.prototype.forEach = function (next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var subscription;
            subscription = _this.subscribe(function (value) {
                try {
                    next(value);
                }
                catch (err) {
                    reject(err);
                    if (subscription) {
                        subscription.unsubscribe();
                    }
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        var source = this.source;
        return source && source.subscribe(subscriber);
    };
    Observable.prototype[_symbol_observable__WEBPACK_IMPORTED_MODULE_2__["observable"]] = function () {
        return this;
    };
    Observable.prototype.pipe = function () {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i] = arguments[_i];
        }
        if (operations.length === 0) {
            return this;
        }
        return Object(_util_pipe__WEBPACK_IMPORTED_MODULE_3__["pipeFromArray"])(operations)(this);
    };
    Observable.prototype.toPromise = function (promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var value;
            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
        });
    };
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}());

function getPromiseCtor(promiseCtor) {
    if (!promiseCtor) {
        promiseCtor = _config__WEBPACK_IMPORTED_MODULE_4__["config"].Promise || Promise;
    }
    if (!promiseCtor) {
        throw new Error('no Promise impl found');
    }
    return promiseCtor;
}
//# sourceMappingURL=Observable.js.map


/***/ }),
/* 232 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "canReportError", function() { return canReportError; });
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(233);
/** PURE_IMPORTS_START _Subscriber PURE_IMPORTS_END */

function canReportError(observer) {
    while (observer) {
        var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
        if (closed_1 || isStopped) {
            return false;
        }
        else if (destination && destination instanceof _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]) {
            observer = destination;
        }
        else {
            observer = null;
        }
    }
    return true;
}
//# sourceMappingURL=canReportError.js.map


/***/ }),
/* 233 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Subscriber", function() { return Subscriber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SafeSubscriber", function() { return SafeSubscriber; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(235);
/* harmony import */ var _Observer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(236);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(239);
/* harmony import */ var _internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(243);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(237);
/* harmony import */ var _util_hostReportError__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(238);
/** PURE_IMPORTS_START tslib,_util_isFunction,_Observer,_Subscription,_internal_symbol_rxSubscriber,_config,_util_hostReportError PURE_IMPORTS_END */







var Subscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](Subscriber, _super);
    function Subscriber(destinationOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this.syncErrorValue = null;
        _this.syncErrorThrown = false;
        _this.syncErrorThrowable = false;
        _this.isStopped = false;
        switch (arguments.length) {
            case 0:
                _this.destination = _Observer__WEBPACK_IMPORTED_MODULE_2__["empty"];
                break;
            case 1:
                if (!destinationOrNext) {
                    _this.destination = _Observer__WEBPACK_IMPORTED_MODULE_2__["empty"];
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                        _this.destination = destinationOrNext;
                        destinationOrNext.add(_this);
                    }
                    else {
                        _this.syncErrorThrowable = true;
                        _this.destination = new SafeSubscriber(_this, destinationOrNext);
                    }
                    break;
                }
            default:
                _this.syncErrorThrowable = true;
                _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
                break;
        }
        return _this;
    }
    Subscriber.prototype[_internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_4__["rxSubscriber"]] = function () { return this; };
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _parentOrParents = this._parentOrParents;
        this._parentOrParents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parentOrParents = _parentOrParents;
        return this;
    };
    return Subscriber;
}(_Subscription__WEBPACK_IMPORTED_MODULE_3__["Subscription"]));

var SafeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this._parentSubscriber = _parentSubscriber;
        var next;
        var context = _this;
        if (Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (observerOrNext !== _Observer__WEBPACK_IMPORTED_MODULE_2__["empty"]) {
                context = Object.create(observerOrNext);
                if (Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(context.unsubscribe)) {
                    _this.add(context.unsubscribe.bind(context));
                }
                context.unsubscribe = _this.unsubscribe.bind(_this);
            }
        }
        _this._context = context;
        _this._next = next;
        _this._error = error;
        _this._complete = complete;
        return _this;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!_config__WEBPACK_IMPORTED_MODULE_5__["config"].useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            }
            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            var useDeprecatedSynchronousErrorHandling = _config__WEBPACK_IMPORTED_MODULE_5__["config"].useDeprecatedSynchronousErrorHandling;
            if (this._error) {
                if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            }
            else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                if (useDeprecatedSynchronousErrorHandling) {
                    throw err;
                }
                Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__["hostReportError"])(err);
            }
            else {
                if (useDeprecatedSynchronousErrorHandling) {
                    _parentSubscriber.syncErrorValue = err;
                    _parentSubscriber.syncErrorThrown = true;
                }
                else {
                    Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__["hostReportError"])(err);
                }
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        var _this = this;
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                var wrappedComplete = function () { return _this._complete.call(_this._context); };
                if (!_config__WEBPACK_IMPORTED_MODULE_5__["config"].useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(wrappedComplete);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                    this.unsubscribe();
                }
            }
            else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            this.unsubscribe();
            if (_config__WEBPACK_IMPORTED_MODULE_5__["config"].useDeprecatedSynchronousErrorHandling) {
                throw err;
            }
            else {
                Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__["hostReportError"])(err);
            }
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        if (!_config__WEBPACK_IMPORTED_MODULE_5__["config"].useDeprecatedSynchronousErrorHandling) {
            throw new Error('bad call');
        }
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            if (_config__WEBPACK_IMPORTED_MODULE_5__["config"].useDeprecatedSynchronousErrorHandling) {
                parent.syncErrorValue = err;
                parent.syncErrorThrown = true;
                return true;
            }
            else {
                Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__["hostReportError"])(err);
                return true;
            }
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber));

//# sourceMappingURL=Subscriber.js.map


/***/ }),
/* 234 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__extends", function() { return __extends; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__rest", function() { return __rest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__decorate", function() { return __decorate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__param", function() { return __param; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__metadata", function() { return __metadata; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__awaiter", function() { return __awaiter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__generator", function() { return __generator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__exportStar", function() { return __exportStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__values", function() { return __values; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__read", function() { return __read; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spread", function() { return __spread; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spreadArrays", function() { return __spreadArrays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__await", function() { return __await; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncGenerator", function() { return __asyncGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncDelegator", function() { return __asyncDelegator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncValues", function() { return __asyncValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__makeTemplateObject", function() { return __makeTemplateObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importStar", function() { return __importStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importDefault", function() { return __importDefault; });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __exportStar(m, exports) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}


/***/ }),
/* 235 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFunction", function() { return isFunction; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isFunction(x) {
    return typeof x === 'function';
}
//# sourceMappingURL=isFunction.js.map


/***/ }),
/* 236 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "empty", function() { return empty; });
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(237);
/* harmony import */ var _util_hostReportError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(238);
/** PURE_IMPORTS_START _config,_util_hostReportError PURE_IMPORTS_END */


var empty = {
    closed: true,
    next: function (value) { },
    error: function (err) {
        if (_config__WEBPACK_IMPORTED_MODULE_0__["config"].useDeprecatedSynchronousErrorHandling) {
            throw err;
        }
        else {
            Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_1__["hostReportError"])(err);
        }
    },
    complete: function () { }
};
//# sourceMappingURL=Observer.js.map


/***/ }),
/* 237 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "config", function() { return config; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var _enable_super_gross_mode_that_will_cause_bad_things = false;
var config = {
    Promise: undefined,
    set useDeprecatedSynchronousErrorHandling(value) {
        if (value) {
            var error = /*@__PURE__*/ new Error();
            /*@__PURE__*/ console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
        }
        else if (_enable_super_gross_mode_that_will_cause_bad_things) {
            /*@__PURE__*/ console.log('RxJS: Back to a better error behavior. Thank you. <3');
        }
        _enable_super_gross_mode_that_will_cause_bad_things = value;
    },
    get useDeprecatedSynchronousErrorHandling() {
        return _enable_super_gross_mode_that_will_cause_bad_things;
    },
};
//# sourceMappingURL=config.js.map


/***/ }),
/* 238 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hostReportError", function() { return hostReportError; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function hostReportError(err) {
    setTimeout(function () { throw err; }, 0);
}
//# sourceMappingURL=hostReportError.js.map


/***/ }),
/* 239 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Subscription", function() { return Subscription; });
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(240);
/* harmony import */ var _util_isObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(241);
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(235);
/* harmony import */ var _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(242);
/** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_UnsubscriptionError PURE_IMPORTS_END */




var Subscription = /*@__PURE__*/ (function () {
    function Subscription(unsubscribe) {
        this.closed = false;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    Subscription.prototype.unsubscribe = function () {
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this, _parentOrParents = _a._parentOrParents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (_parentOrParents instanceof Subscription) {
            _parentOrParents.remove(this);
        }
        else if (_parentOrParents !== null) {
            for (var index = 0; index < _parentOrParents.length; ++index) {
                var parent_1 = _parentOrParents[index];
                parent_1.remove(this);
            }
        }
        if (Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_2__["isFunction"])(_unsubscribe)) {
            try {
                _unsubscribe.call(this);
            }
            catch (e) {
                errors = e instanceof _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_3__["UnsubscriptionError"] ? flattenUnsubscriptionErrors(e.errors) : [e];
            }
        }
        if (Object(_util_isArray__WEBPACK_IMPORTED_MODULE_0__["isArray"])(_subscriptions)) {
            var index = -1;
            var len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (Object(_util_isObject__WEBPACK_IMPORTED_MODULE_1__["isObject"])(sub)) {
                    try {
                        sub.unsubscribe();
                    }
                    catch (e) {
                        errors = errors || [];
                        if (e instanceof _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_3__["UnsubscriptionError"]) {
                            errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
                        }
                        else {
                            errors.push(e);
                        }
                    }
                }
            }
        }
        if (errors) {
            throw new _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_3__["UnsubscriptionError"](errors);
        }
    };
    Subscription.prototype.add = function (teardown) {
        var subscription = teardown;
        if (!teardown) {
            return Subscription.EMPTY;
        }
        switch (typeof teardown) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                }
                else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                }
                else if (!(subscription instanceof Subscription)) {
                    var tmp = subscription;
                    subscription = new Subscription();
                    subscription._subscriptions = [tmp];
                }
                break;
            default: {
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
            }
        }
        var _parentOrParents = subscription._parentOrParents;
        if (_parentOrParents === null) {
            subscription._parentOrParents = this;
        }
        else if (_parentOrParents instanceof Subscription) {
            if (_parentOrParents === this) {
                return subscription;
            }
            subscription._parentOrParents = [_parentOrParents, this];
        }
        else if (_parentOrParents.indexOf(this) === -1) {
            _parentOrParents.push(this);
        }
        else {
            return subscription;
        }
        var subscriptions = this._subscriptions;
        if (subscriptions === null) {
            this._subscriptions = [subscription];
        }
        else {
            subscriptions.push(subscription);
        }
        return subscription;
    };
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.EMPTY = (function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());

function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) { return errs.concat((err instanceof _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_3__["UnsubscriptionError"]) ? err.errors : err); }, []);
}
//# sourceMappingURL=Subscription.js.map


/***/ }),
/* 240 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isArray", function() { return isArray; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var isArray = /*@__PURE__*/ (function () { return Array.isArray || (function (x) { return x && typeof x.length === 'number'; }); })();
//# sourceMappingURL=isArray.js.map


/***/ }),
/* 241 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isObject", function() { return isObject; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isObject(x) {
    return x !== null && typeof x === 'object';
}
//# sourceMappingURL=isObject.js.map


/***/ }),
/* 242 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsubscriptionError", function() { return UnsubscriptionError; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var UnsubscriptionErrorImpl = /*@__PURE__*/ (function () {
    function UnsubscriptionErrorImpl(errors) {
        Error.call(this);
        this.message = errors ?
            errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ') : '';
        this.name = 'UnsubscriptionError';
        this.errors = errors;
        return this;
    }
    UnsubscriptionErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
    return UnsubscriptionErrorImpl;
})();
var UnsubscriptionError = UnsubscriptionErrorImpl;
//# sourceMappingURL=UnsubscriptionError.js.map


/***/ }),
/* 243 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rxSubscriber", function() { return rxSubscriber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$$rxSubscriber", function() { return $$rxSubscriber; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var rxSubscriber = /*@__PURE__*/ (function () {
    return typeof Symbol === 'function'
        ? /*@__PURE__*/ Symbol('rxSubscriber')
        : '@@rxSubscriber_' + /*@__PURE__*/ Math.random();
})();
var $$rxSubscriber = rxSubscriber;
//# sourceMappingURL=rxSubscriber.js.map


/***/ }),
/* 244 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toSubscriber", function() { return toSubscriber; });
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(233);
/* harmony import */ var _symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(243);
/* harmony import */ var _Observer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(236);
/** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */



function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]) {
            return nextOrObserver;
        }
        if (nextOrObserver[_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_1__["rxSubscriber"]]) {
            return nextOrObserver[_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_1__["rxSubscriber"]]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"](_Observer__WEBPACK_IMPORTED_MODULE_2__["empty"]);
    }
    return new _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"](nextOrObserver, error, complete);
}
//# sourceMappingURL=toSubscriber.js.map


/***/ }),
/* 245 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "observable", function() { return observable; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var observable = /*@__PURE__*/ (function () { return typeof Symbol === 'function' && Symbol.observable || '@@observable'; })();
//# sourceMappingURL=observable.js.map


/***/ }),
/* 246 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pipe", function() { return pipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pipeFromArray", function() { return pipeFromArray; });
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(247);
/** PURE_IMPORTS_START _noop PURE_IMPORTS_END */

function pipe() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
    }
    return pipeFromArray(fns);
}
function pipeFromArray(fns) {
    if (!fns) {
        return _noop__WEBPACK_IMPORTED_MODULE_0__["noop"];
    }
    if (fns.length === 1) {
        return fns[0];
    }
    return function piped(input) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
    };
}
//# sourceMappingURL=pipe.js.map


/***/ }),
/* 247 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "noop", function() { return noop; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function noop() { }
//# sourceMappingURL=noop.js.map


/***/ }),
/* 248 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConnectableObservable", function() { return ConnectableObservable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "connectableObservableDescriptor", function() { return connectableObservableDescriptor; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(249);
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(231);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(233);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(239);
/* harmony import */ var _operators_refCount__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(252);
/** PURE_IMPORTS_START tslib,_Subject,_Observable,_Subscriber,_Subscription,_operators_refCount PURE_IMPORTS_END */






var ConnectableObservable = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](ConnectableObservable, _super);
    function ConnectableObservable(source, subjectFactory) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subjectFactory = subjectFactory;
        _this._refCount = 0;
        _this._isComplete = false;
        return _this;
    }
    ConnectableObservable.prototype._subscribe = function (subscriber) {
        return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable.prototype.getSubject = function () {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
            this._subject = this.subjectFactory();
        }
        return this._subject;
    };
    ConnectableObservable.prototype.connect = function () {
        var connection = this._connection;
        if (!connection) {
            this._isComplete = false;
            connection = this._connection = new _Subscription__WEBPACK_IMPORTED_MODULE_4__["Subscription"]();
            connection.add(this.source
                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
            if (connection.closed) {
                this._connection = null;
                connection = _Subscription__WEBPACK_IMPORTED_MODULE_4__["Subscription"].EMPTY;
            }
        }
        return connection;
    };
    ConnectableObservable.prototype.refCount = function () {
        return Object(_operators_refCount__WEBPACK_IMPORTED_MODULE_5__["refCount"])()(this);
    };
    return ConnectableObservable;
}(_Observable__WEBPACK_IMPORTED_MODULE_2__["Observable"]));

var connectableObservableDescriptor = /*@__PURE__*/ (function () {
    var connectableProto = ConnectableObservable.prototype;
    return {
        operator: { value: null },
        _refCount: { value: 0, writable: true },
        _subject: { value: null, writable: true },
        _connection: { value: null, writable: true },
        _subscribe: { value: connectableProto._subscribe },
        _isComplete: { value: connectableProto._isComplete, writable: true },
        getSubject: { value: connectableProto.getSubject },
        connect: { value: connectableProto.connect },
        refCount: { value: connectableProto.refCount }
    };
})();
var ConnectableSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](ConnectableSubscriber, _super);
    function ConnectableSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    ConnectableSubscriber.prototype._error = function (err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
    };
    ConnectableSubscriber.prototype._complete = function () {
        this.connectable._isComplete = true;
        this._unsubscribe();
        _super.prototype._complete.call(this);
    };
    ConnectableSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (connectable) {
            this.connectable = null;
            var connection = connectable._connection;
            connectable._refCount = 0;
            connectable._subject = null;
            connectable._connection = null;
            if (connection) {
                connection.unsubscribe();
            }
        }
    };
    return ConnectableSubscriber;
}(_Subject__WEBPACK_IMPORTED_MODULE_1__["SubjectSubscriber"]));
var RefCountOperator = /*@__PURE__*/ (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_3__["Subscriber"]));
//# sourceMappingURL=ConnectableObservable.js.map


/***/ }),
/* 249 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubjectSubscriber", function() { return SubjectSubscriber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Subject", function() { return Subject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnonymousSubject", function() { return AnonymousSubject; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(231);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(233);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(239);
/* harmony import */ var _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(250);
/* harmony import */ var _SubjectSubscription__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(251);
/* harmony import */ var _internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(243);
/** PURE_IMPORTS_START tslib,_Observable,_Subscriber,_Subscription,_util_ObjectUnsubscribedError,_SubjectSubscription,_internal_symbol_rxSubscriber PURE_IMPORTS_END */







var SubjectSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        return _this;
    }
    return SubjectSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_2__["Subscriber"]));

var Subject = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](Subject, _super);
    function Subject() {
        var _this = _super.call(this) || this;
        _this.observers = [];
        _this.closed = false;
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
    }
    Subject.prototype[_internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_6__["rxSubscriber"]] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__["ObjectUnsubscribedError"]();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__["ObjectUnsubscribedError"]();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__["ObjectUnsubscribedError"]();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject.prototype._trySubscribe = function (subscriber) {
        if (this.closed) {
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__["ObjectUnsubscribedError"]();
        }
        else {
            return _super.prototype._trySubscribe.call(this, subscriber);
        }
    };
    Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__["ObjectUnsubscribedError"]();
        }
        else if (this.hasError) {
            subscriber.error(this.thrownError);
            return _Subscription__WEBPACK_IMPORTED_MODULE_3__["Subscription"].EMPTY;
        }
        else if (this.isStopped) {
            subscriber.complete();
            return _Subscription__WEBPACK_IMPORTED_MODULE_3__["Subscription"].EMPTY;
        }
        else {
            this.observers.push(subscriber);
            return new _SubjectSubscription__WEBPACK_IMPORTED_MODULE_5__["SubjectSubscription"](this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new _Observable__WEBPACK_IMPORTED_MODULE_1__["Observable"]();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(_Observable__WEBPACK_IMPORTED_MODULE_1__["Observable"]));

var AnonymousSubject = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        }
        else {
            return _Subscription__WEBPACK_IMPORTED_MODULE_3__["Subscription"].EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject));

//# sourceMappingURL=Subject.js.map


/***/ }),
/* 250 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectUnsubscribedError", function() { return ObjectUnsubscribedError; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var ObjectUnsubscribedErrorImpl = /*@__PURE__*/ (function () {
    function ObjectUnsubscribedErrorImpl() {
        Error.call(this);
        this.message = 'object unsubscribed';
        this.name = 'ObjectUnsubscribedError';
        return this;
    }
    ObjectUnsubscribedErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
    return ObjectUnsubscribedErrorImpl;
})();
var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;
//# sourceMappingURL=ObjectUnsubscribedError.js.map


/***/ }),
/* 251 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubjectSubscription", function() { return SubjectSubscription; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(239);
/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */


var SubjectSubscription = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        var _this = _super.call(this) || this;
        _this.subject = subject;
        _this.subscriber = subscriber;
        _this.closed = false;
        return _this;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(_Subscription__WEBPACK_IMPORTED_MODULE_1__["Subscription"]));

//# sourceMappingURL=SubjectSubscription.js.map


/***/ }),
/* 252 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "refCount", function() { return refCount; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(233);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function refCount() {
    return function refCountOperatorFunction(source) {
        return source.lift(new RefCountOperator(source));
    };
}
var RefCountOperator = /*@__PURE__*/ (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=refCount.js.map


/***/ }),
/* 253 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "groupBy", function() { return groupBy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GroupedObservable", function() { return GroupedObservable; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(233);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(239);
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(231);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(249);
/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription,_Observable,_Subject PURE_IMPORTS_END */





function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
    return function (source) {
        return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
    };
}
var GroupByOperator = /*@__PURE__*/ (function () {
    function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {
        this.keySelector = keySelector;
        this.elementSelector = elementSelector;
        this.durationSelector = durationSelector;
        this.subjectSelector = subjectSelector;
    }
    GroupByOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
    };
    return GroupByOperator;
}());
var GroupBySubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](GroupBySubscriber, _super);
    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.elementSelector = elementSelector;
        _this.durationSelector = durationSelector;
        _this.subjectSelector = subjectSelector;
        _this.groups = null;
        _this.attemptedToUnsubscribe = false;
        _this.count = 0;
        return _this;
    }
    GroupBySubscriber.prototype._next = function (value) {
        var key;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            this.error(err);
            return;
        }
        this._group(value, key);
    };
    GroupBySubscriber.prototype._group = function (value, key) {
        var groups = this.groups;
        if (!groups) {
            groups = this.groups = new Map();
        }
        var group = groups.get(key);
        var element;
        if (this.elementSelector) {
            try {
                element = this.elementSelector(value);
            }
            catch (err) {
                this.error(err);
            }
        }
        else {
            element = value;
        }
        if (!group) {
            group = (this.subjectSelector ? this.subjectSelector() : new _Subject__WEBPACK_IMPORTED_MODULE_4__["Subject"]());
            groups.set(key, group);
            var groupedObservable = new GroupedObservable(key, group, this);
            this.destination.next(groupedObservable);
            if (this.durationSelector) {
                var duration = void 0;
                try {
                    duration = this.durationSelector(new GroupedObservable(key, group));
                }
                catch (err) {
                    this.error(err);
                    return;
                }
                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
            }
        }
        if (!group.closed) {
            group.next(element);
        }
    };
    GroupBySubscriber.prototype._error = function (err) {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.error(err);
            });
            groups.clear();
        }
        this.destination.error(err);
    };
    GroupBySubscriber.prototype._complete = function () {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.complete();
            });
            groups.clear();
        }
        this.destination.complete();
    };
    GroupBySubscriber.prototype.removeGroup = function (key) {
        this.groups.delete(key);
    };
    GroupBySubscriber.prototype.unsubscribe = function () {
        if (!this.closed) {
            this.attemptedToUnsubscribe = true;
            if (this.count === 0) {
                _super.prototype.unsubscribe.call(this);
            }
        }
    };
    return GroupBySubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
var GroupDurationSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](GroupDurationSubscriber, _super);
    function GroupDurationSubscriber(key, group, parent) {
        var _this = _super.call(this, group) || this;
        _this.key = key;
        _this.group = group;
        _this.parent = parent;
        return _this;
    }
    GroupDurationSubscriber.prototype._next = function (value) {
        this.complete();
    };
    GroupDurationSubscriber.prototype._unsubscribe = function () {
        var _a = this, parent = _a.parent, key = _a.key;
        this.key = this.parent = null;
        if (parent) {
            parent.removeGroup(key);
        }
    };
    return GroupDurationSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
var GroupedObservable = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](GroupedObservable, _super);
    function GroupedObservable(key, groupSubject, refCountSubscription) {
        var _this = _super.call(this) || this;
        _this.key = key;
        _this.groupSubject = groupSubject;
        _this.refCountSubscription = refCountSubscription;
        return _this;
    }
    GroupedObservable.prototype._subscribe = function (subscriber) {
        var subscription = new _Subscription__WEBPACK_IMPORTED_MODULE_2__["Subscription"]();
        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;
        if (refCountSubscription && !refCountSubscription.closed) {
            subscription.add(new InnerRefCountSubscription(refCountSubscription));
        }
        subscription.add(groupSubject.subscribe(subscriber));
        return subscription;
    };
    return GroupedObservable;
}(_Observable__WEBPACK_IMPORTED_MODULE_3__["Observable"]));

var InnerRefCountSubscription = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](InnerRefCountSubscription, _super);
    function InnerRefCountSubscription(parent) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        parent.count++;
        return _this;
    }
    InnerRefCountSubscription.prototype.unsubscribe = function () {
        var parent = this.parent;
        if (!parent.closed && !this.closed) {
            _super.prototype.unsubscribe.call(this);
            parent.count -= 1;
            if (parent.count === 0 && parent.attemptedToUnsubscribe) {
                parent.unsubscribe();
            }
        }
    };
    return InnerRefCountSubscription;
}(_Subscription__WEBPACK_IMPORTED_MODULE_2__["Subscription"]));
//# sourceMappingURL=groupBy.js.map


/***/ }),
/* 254 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BehaviorSubject", function() { return BehaviorSubject; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(249);
/* harmony import */ var _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(250);
/** PURE_IMPORTS_START tslib,_Subject,_util_ObjectUnsubscribedError PURE_IMPORTS_END */



var BehaviorSubject = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](BehaviorSubject, _super);
    function BehaviorSubject(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
    }
    Object.defineProperty(BehaviorSubject.prototype, "value", {
        get: function () {
            return this.getValue();
        },
        enumerable: true,
        configurable: true
    });
    BehaviorSubject.prototype._subscribe = function (subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        if (subscription && !subscription.closed) {
            subscriber.next(this._value);
        }
        return subscription;
    };
    BehaviorSubject.prototype.getValue = function () {
        if (this.hasError) {
            throw this.thrownError;
        }
        else if (this.closed) {
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_2__["ObjectUnsubscribedError"]();
        }
        else {
            return this._value;
        }
    };
    BehaviorSubject.prototype.next = function (value) {
        _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject;
}(_Subject__WEBPACK_IMPORTED_MODULE_1__["Subject"]));

//# sourceMappingURL=BehaviorSubject.js.map


/***/ }),
/* 255 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReplaySubject", function() { return ReplaySubject; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(249);
/* harmony import */ var _scheduler_queue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(256);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(239);
/* harmony import */ var _operators_observeOn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(263);
/* harmony import */ var _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(250);
/* harmony import */ var _SubjectSubscription__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(251);
/** PURE_IMPORTS_START tslib,_Subject,_scheduler_queue,_Subscription,_operators_observeOn,_util_ObjectUnsubscribedError,_SubjectSubscription PURE_IMPORTS_END */







var ReplaySubject = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](ReplaySubject, _super);
    function ReplaySubject(bufferSize, windowTime, scheduler) {
        if (bufferSize === void 0) {
            bufferSize = Number.POSITIVE_INFINITY;
        }
        if (windowTime === void 0) {
            windowTime = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this) || this;
        _this.scheduler = scheduler;
        _this._events = [];
        _this._infiniteTimeWindow = false;
        _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        _this._windowTime = windowTime < 1 ? 1 : windowTime;
        if (windowTime === Number.POSITIVE_INFINITY) {
            _this._infiniteTimeWindow = true;
            _this.next = _this.nextInfiniteTimeWindow;
        }
        else {
            _this.next = _this.nextTimeWindow;
        }
        return _this;
    }
    ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {
        var _events = this._events;
        _events.push(value);
        if (_events.length > this._bufferSize) {
            _events.shift();
        }
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype.nextTimeWindow = function (value) {
        this._events.push(new ReplayEvent(this._getNow(), value));
        this._trimBufferThenGetEvents();
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype._subscribe = function (subscriber) {
        var _infiniteTimeWindow = this._infiniteTimeWindow;
        var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
        var scheduler = this.scheduler;
        var len = _events.length;
        var subscription;
        if (this.closed) {
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_5__["ObjectUnsubscribedError"]();
        }
        else if (this.isStopped || this.hasError) {
            subscription = _Subscription__WEBPACK_IMPORTED_MODULE_3__["Subscription"].EMPTY;
        }
        else {
            this.observers.push(subscriber);
            subscription = new _SubjectSubscription__WEBPACK_IMPORTED_MODULE_6__["SubjectSubscription"](this, subscriber);
        }
        if (scheduler) {
            subscriber.add(subscriber = new _operators_observeOn__WEBPACK_IMPORTED_MODULE_4__["ObserveOnSubscriber"](subscriber, scheduler));
        }
        if (_infiniteTimeWindow) {
            for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i]);
            }
        }
        else {
            for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i].value);
            }
        }
        if (this.hasError) {
            subscriber.error(this.thrownError);
        }
        else if (this.isStopped) {
            subscriber.complete();
        }
        return subscription;
    };
    ReplaySubject.prototype._getNow = function () {
        return (this.scheduler || _scheduler_queue__WEBPACK_IMPORTED_MODULE_2__["queue"]).now();
    };
    ReplaySubject.prototype._trimBufferThenGetEvents = function () {
        var now = this._getNow();
        var _bufferSize = this._bufferSize;
        var _windowTime = this._windowTime;
        var _events = this._events;
        var eventsCount = _events.length;
        var spliceCount = 0;
        while (spliceCount < eventsCount) {
            if ((now - _events[spliceCount].time) < _windowTime) {
                break;
            }
            spliceCount++;
        }
        if (eventsCount > _bufferSize) {
            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        }
        if (spliceCount > 0) {
            _events.splice(0, spliceCount);
        }
        return _events;
    };
    return ReplaySubject;
}(_Subject__WEBPACK_IMPORTED_MODULE_1__["Subject"]));

var ReplayEvent = /*@__PURE__*/ (function () {
    function ReplayEvent(time, value) {
        this.time = time;
        this.value = value;
    }
    return ReplayEvent;
}());
//# sourceMappingURL=ReplaySubject.js.map


/***/ }),
/* 256 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "queue", function() { return queue; });
/* harmony import */ var _QueueAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(257);
/* harmony import */ var _QueueScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(260);
/** PURE_IMPORTS_START _QueueAction,_QueueScheduler PURE_IMPORTS_END */


var queue = /*@__PURE__*/ new _QueueScheduler__WEBPACK_IMPORTED_MODULE_1__["QueueScheduler"](_QueueAction__WEBPACK_IMPORTED_MODULE_0__["QueueAction"]);
//# sourceMappingURL=queue.js.map


/***/ }),
/* 257 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QueueAction", function() { return QueueAction; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _AsyncAction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(258);
/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */


var QueueAction = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](QueueAction, _super);
    function QueueAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    QueueAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay > 0) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
    };
    QueueAction.prototype.execute = function (state, delay) {
        return (delay > 0 || this.closed) ?
            _super.prototype.execute.call(this, state, delay) :
            this._execute(state, delay);
    };
    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        return scheduler.flush(this);
    };
    return QueueAction;
}(_AsyncAction__WEBPACK_IMPORTED_MODULE_1__["AsyncAction"]));

//# sourceMappingURL=QueueAction.js.map


/***/ }),
/* 258 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AsyncAction", function() { return AsyncAction; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Action__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(259);
/** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */


var AsyncAction = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
    }
    AsyncAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (this.closed) {
            return this;
        }
        this.state = state;
        var id = this.id;
        var scheduler = this.scheduler;
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.pending = true;
        this.delay = delay;
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay !== null && this.delay === delay && this.pending === false) {
            return id;
        }
        clearInterval(id);
        return undefined;
    };
    AsyncAction.prototype.execute = function (state, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
            return error;
        }
        else if (this.pending === false && this.id != null) {
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction.prototype._execute = function (state, delay) {
        var errored = false;
        var errorValue = undefined;
        try {
            this.work(state);
        }
        catch (e) {
            errored = true;
            errorValue = !!e && e || new Error(e);
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction.prototype._unsubscribe = function () {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
            actions.splice(index, 1);
        }
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
    };
    return AsyncAction;
}(_Action__WEBPACK_IMPORTED_MODULE_1__["Action"]));

//# sourceMappingURL=AsyncAction.js.map


/***/ }),
/* 259 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Action", function() { return Action; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(239);
/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */


var Action = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](Action, _super);
    function Action(scheduler, work) {
        return _super.call(this) || this;
    }
    Action.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return this;
    };
    return Action;
}(_Subscription__WEBPACK_IMPORTED_MODULE_1__["Subscription"]));

//# sourceMappingURL=Action.js.map


/***/ }),
/* 260 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QueueScheduler", function() { return QueueScheduler; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _AsyncScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(261);
/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */


var QueueScheduler = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](QueueScheduler, _super);
    function QueueScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return QueueScheduler;
}(_AsyncScheduler__WEBPACK_IMPORTED_MODULE_1__["AsyncScheduler"]));

//# sourceMappingURL=QueueScheduler.js.map


/***/ }),
/* 261 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AsyncScheduler", function() { return AsyncScheduler; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Scheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(262);
/** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */


var AsyncScheduler = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](AsyncScheduler, _super);
    function AsyncScheduler(SchedulerAction, now) {
        if (now === void 0) {
            now = _Scheduler__WEBPACK_IMPORTED_MODULE_1__["Scheduler"].now;
        }
        var _this = _super.call(this, SchedulerAction, function () {
            if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {
                return AsyncScheduler.delegate.now();
            }
            else {
                return now();
            }
        }) || this;
        _this.actions = [];
        _this.active = false;
        _this.scheduled = undefined;
        return _this;
    }
    AsyncScheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) {
            delay = 0;
        }
        if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
            return AsyncScheduler.delegate.schedule(work, delay, state);
        }
        else {
            return _super.prototype.schedule.call(this, work, delay, state);
        }
    };
    AsyncScheduler.prototype.flush = function (action) {
        var actions = this.actions;
        if (this.active) {
            actions.push(action);
            return;
        }
        var error;
        this.active = true;
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (action = actions.shift());
        this.active = false;
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler;
}(_Scheduler__WEBPACK_IMPORTED_MODULE_1__["Scheduler"]));

//# sourceMappingURL=AsyncScheduler.js.map


/***/ }),
/* 262 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Scheduler", function() { return Scheduler; });
var Scheduler = /*@__PURE__*/ (function () {
    function Scheduler(SchedulerAction, now) {
        if (now === void 0) {
            now = Scheduler.now;
        }
        this.SchedulerAction = SchedulerAction;
        this.now = now;
    }
    Scheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) {
            delay = 0;
        }
        return new this.SchedulerAction(this, work).schedule(state, delay);
    };
    Scheduler.now = function () { return Date.now(); };
    return Scheduler;
}());

//# sourceMappingURL=Scheduler.js.map


/***/ }),
/* 263 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "observeOn", function() { return observeOn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObserveOnOperator", function() { return ObserveOnOperator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObserveOnSubscriber", function() { return ObserveOnSubscriber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObserveOnMessage", function() { return ObserveOnMessage; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(233);
/* harmony import */ var _Notification__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(264);
/** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */



function observeOn(scheduler, delay) {
    if (delay === void 0) {
        delay = 0;
    }
    return function observeOnOperatorFunction(source) {
        return source.lift(new ObserveOnOperator(scheduler, delay));
    };
}
var ObserveOnOperator = /*@__PURE__*/ (function () {
    function ObserveOnOperator(scheduler, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
    };
    return ObserveOnOperator;
}());

var ObserveOnSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](ObserveOnSubscriber, _super);
    function ObserveOnSubscriber(destination, scheduler, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        var _this = _super.call(this, destination) || this;
        _this.scheduler = scheduler;
        _this.delay = delay;
        return _this;
    }
    ObserveOnSubscriber.dispatch = function (arg) {
        var notification = arg.notification, destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
        var destination = this.destination;
        destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
    };
    ObserveOnSubscriber.prototype._next = function (value) {
        this.scheduleMessage(_Notification__WEBPACK_IMPORTED_MODULE_2__["Notification"].createNext(value));
    };
    ObserveOnSubscriber.prototype._error = function (err) {
        this.scheduleMessage(_Notification__WEBPACK_IMPORTED_MODULE_2__["Notification"].createError(err));
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype._complete = function () {
        this.scheduleMessage(_Notification__WEBPACK_IMPORTED_MODULE_2__["Notification"].createComplete());
        this.unsubscribe();
    };
    return ObserveOnSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));

var ObserveOnMessage = /*@__PURE__*/ (function () {
    function ObserveOnMessage(notification, destination) {
        this.notification = notification;
        this.destination = destination;
    }
    return ObserveOnMessage;
}());

//# sourceMappingURL=observeOn.js.map


/***/ }),
/* 264 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NotificationKind", function() { return NotificationKind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Notification", function() { return Notification; });
/* harmony import */ var _observable_empty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(265);
/* harmony import */ var _observable_of__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(266);
/* harmony import */ var _observable_throwError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(271);
/** PURE_IMPORTS_START _observable_empty,_observable_of,_observable_throwError PURE_IMPORTS_END */



var NotificationKind;
/*@__PURE__*/ (function (NotificationKind) {
    NotificationKind["NEXT"] = "N";
    NotificationKind["ERROR"] = "E";
    NotificationKind["COMPLETE"] = "C";
})(NotificationKind || (NotificationKind = {}));
var Notification = /*@__PURE__*/ (function () {
    function Notification(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === 'N';
    }
    Notification.prototype.observe = function (observer) {
        switch (this.kind) {
            case 'N':
                return observer.next && observer.next(this.value);
            case 'E':
                return observer.error && observer.error(this.error);
            case 'C':
                return observer.complete && observer.complete();
        }
    };
    Notification.prototype.do = function (next, error, complete) {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return next && next(this.value);
            case 'E':
                return error && error(this.error);
            case 'C':
                return complete && complete();
        }
    };
    Notification.prototype.accept = function (nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
            return this.observe(nextOrObserver);
        }
        else {
            return this.do(nextOrObserver, error, complete);
        }
    };
    Notification.prototype.toObservable = function () {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return Object(_observable_of__WEBPACK_IMPORTED_MODULE_1__["of"])(this.value);
            case 'E':
                return Object(_observable_throwError__WEBPACK_IMPORTED_MODULE_2__["throwError"])(this.error);
            case 'C':
                return Object(_observable_empty__WEBPACK_IMPORTED_MODULE_0__["empty"])();
        }
        throw new Error('unexpected notification kind value');
    };
    Notification.createNext = function (value) {
        if (typeof value !== 'undefined') {
            return new Notification('N', value);
        }
        return Notification.undefinedValueNotification;
    };
    Notification.createError = function (err) {
        return new Notification('E', undefined, err);
    };
    Notification.createComplete = function () {
        return Notification.completeNotification;
    };
    Notification.completeNotification = new Notification('C');
    Notification.undefinedValueNotification = new Notification('N', undefined);
    return Notification;
}());

//# sourceMappingURL=Notification.js.map


/***/ }),
/* 265 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EMPTY", function() { return EMPTY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "empty", function() { return empty; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(231);
/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */

var EMPTY = /*@__PURE__*/ new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) { return subscriber.complete(); });
function empty(scheduler) {
    return scheduler ? emptyScheduled(scheduler) : EMPTY;
}
function emptyScheduled(scheduler) {
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });
}
//# sourceMappingURL=empty.js.map


/***/ }),
/* 266 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "of", function() { return of; });
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(267);
/* harmony import */ var _fromArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(268);
/* harmony import */ var _scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(270);
/** PURE_IMPORTS_START _util_isScheduler,_fromArray,_scheduled_scheduleArray PURE_IMPORTS_END */



function of() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var scheduler = args[args.length - 1];
    if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_0__["isScheduler"])(scheduler)) {
        args.pop();
        return Object(_scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_2__["scheduleArray"])(args, scheduler);
    }
    else {
        return Object(_fromArray__WEBPACK_IMPORTED_MODULE_1__["fromArray"])(args);
    }
}
//# sourceMappingURL=of.js.map


/***/ }),
/* 267 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isScheduler", function() { return isScheduler; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isScheduler(value) {
    return value && typeof value.schedule === 'function';
}
//# sourceMappingURL=isScheduler.js.map


/***/ }),
/* 268 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromArray", function() { return fromArray; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(231);
/* harmony import */ var _util_subscribeToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(269);
/* harmony import */ var _scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(270);
/** PURE_IMPORTS_START _Observable,_util_subscribeToArray,_scheduled_scheduleArray PURE_IMPORTS_END */



function fromArray(input, scheduler) {
    if (!scheduler) {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](Object(_util_subscribeToArray__WEBPACK_IMPORTED_MODULE_1__["subscribeToArray"])(input));
    }
    else {
        return Object(_scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_2__["scheduleArray"])(input, scheduler);
    }
}
//# sourceMappingURL=fromArray.js.map


/***/ }),
/* 269 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subscribeToArray", function() { return subscribeToArray; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var subscribeToArray = function (array) {
    return function (subscriber) {
        for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
            subscriber.next(array[i]);
        }
        subscriber.complete();
    };
};
//# sourceMappingURL=subscribeToArray.js.map


/***/ }),
/* 270 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheduleArray", function() { return scheduleArray; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(231);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(239);
/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */


function scheduleArray(input, scheduler) {
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
        var sub = new _Subscription__WEBPACK_IMPORTED_MODULE_1__["Subscription"]();
        var i = 0;
        sub.add(scheduler.schedule(function () {
            if (i === input.length) {
                subscriber.complete();
                return;
            }
            subscriber.next(input[i++]);
            if (!subscriber.closed) {
                sub.add(this.schedule());
            }
        }));
        return sub;
    });
}
//# sourceMappingURL=scheduleArray.js.map


/***/ }),
/* 271 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "throwError", function() { return throwError; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(231);
/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */

function throwError(error, scheduler) {
    if (!scheduler) {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) { return subscriber.error(error); });
    }
    else {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) { return scheduler.schedule(dispatch, 0, { error: error, subscriber: subscriber }); });
    }
}
function dispatch(_a) {
    var error = _a.error, subscriber = _a.subscriber;
    subscriber.error(error);
}
//# sourceMappingURL=throwError.js.map


/***/ }),
/* 272 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AsyncSubject", function() { return AsyncSubject; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(249);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(239);
/** PURE_IMPORTS_START tslib,_Subject,_Subscription PURE_IMPORTS_END */



var AsyncSubject = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](AsyncSubject, _super);
    function AsyncSubject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.value = null;
        _this.hasNext = false;
        _this.hasCompleted = false;
        return _this;
    }
    AsyncSubject.prototype._subscribe = function (subscriber) {
        if (this.hasError) {
            subscriber.error(this.thrownError);
            return _Subscription__WEBPACK_IMPORTED_MODULE_2__["Subscription"].EMPTY;
        }
        else if (this.hasCompleted && this.hasNext) {
            subscriber.next(this.value);
            subscriber.complete();
            return _Subscription__WEBPACK_IMPORTED_MODULE_2__["Subscription"].EMPTY;
        }
        return _super.prototype._subscribe.call(this, subscriber);
    };
    AsyncSubject.prototype.next = function (value) {
        if (!this.hasCompleted) {
            this.value = value;
            this.hasNext = true;
        }
    };
    AsyncSubject.prototype.error = function (error) {
        if (!this.hasCompleted) {
            _super.prototype.error.call(this, error);
        }
    };
    AsyncSubject.prototype.complete = function () {
        this.hasCompleted = true;
        if (this.hasNext) {
            _super.prototype.next.call(this, this.value);
        }
        _super.prototype.complete.call(this);
    };
    return AsyncSubject;
}(_Subject__WEBPACK_IMPORTED_MODULE_1__["Subject"]));

//# sourceMappingURL=AsyncSubject.js.map


/***/ }),
/* 273 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asap", function() { return asap; });
/* harmony import */ var _AsapAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(274);
/* harmony import */ var _AsapScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(276);
/** PURE_IMPORTS_START _AsapAction,_AsapScheduler PURE_IMPORTS_END */


var asap = /*@__PURE__*/ new _AsapScheduler__WEBPACK_IMPORTED_MODULE_1__["AsapScheduler"](_AsapAction__WEBPACK_IMPORTED_MODULE_0__["AsapAction"]);
//# sourceMappingURL=asap.js.map


/***/ }),
/* 274 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AsapAction", function() { return AsapAction; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _util_Immediate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(275);
/* harmony import */ var _AsyncAction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(258);
/** PURE_IMPORTS_START tslib,_util_Immediate,_AsyncAction PURE_IMPORTS_END */



var AsapAction = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](AsapAction, _super);
    function AsapAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = _util_Immediate__WEBPACK_IMPORTED_MODULE_1__["Immediate"].setImmediate(scheduler.flush.bind(scheduler, null)));
    };
    AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        if (scheduler.actions.length === 0) {
            _util_Immediate__WEBPACK_IMPORTED_MODULE_1__["Immediate"].clearImmediate(id);
            scheduler.scheduled = undefined;
        }
        return undefined;
    };
    return AsapAction;
}(_AsyncAction__WEBPACK_IMPORTED_MODULE_2__["AsyncAction"]));

//# sourceMappingURL=AsapAction.js.map


/***/ }),
/* 275 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Immediate", function() { return Immediate; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var nextHandle = 1;
var tasksByHandle = {};
function runIfPresent(handle) {
    var cb = tasksByHandle[handle];
    if (cb) {
        cb();
    }
}
var Immediate = {
    setImmediate: function (cb) {
        var handle = nextHandle++;
        tasksByHandle[handle] = cb;
        Promise.resolve().then(function () { return runIfPresent(handle); });
        return handle;
    },
    clearImmediate: function (handle) {
        delete tasksByHandle[handle];
    },
};
//# sourceMappingURL=Immediate.js.map


/***/ }),
/* 276 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AsapScheduler", function() { return AsapScheduler; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _AsyncScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(261);
/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */


var AsapScheduler = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](AsapScheduler, _super);
    function AsapScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AsapScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsapScheduler;
}(_AsyncScheduler__WEBPACK_IMPORTED_MODULE_1__["AsyncScheduler"]));

//# sourceMappingURL=AsapScheduler.js.map


/***/ }),
/* 277 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "async", function() { return async; });
/* harmony import */ var _AsyncAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(258);
/* harmony import */ var _AsyncScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(261);
/** PURE_IMPORTS_START _AsyncAction,_AsyncScheduler PURE_IMPORTS_END */


var async = /*@__PURE__*/ new _AsyncScheduler__WEBPACK_IMPORTED_MODULE_1__["AsyncScheduler"](_AsyncAction__WEBPACK_IMPORTED_MODULE_0__["AsyncAction"]);
//# sourceMappingURL=async.js.map


/***/ }),
/* 278 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "animationFrame", function() { return animationFrame; });
/* harmony import */ var _AnimationFrameAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(279);
/* harmony import */ var _AnimationFrameScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(280);
/** PURE_IMPORTS_START _AnimationFrameAction,_AnimationFrameScheduler PURE_IMPORTS_END */


var animationFrame = /*@__PURE__*/ new _AnimationFrameScheduler__WEBPACK_IMPORTED_MODULE_1__["AnimationFrameScheduler"](_AnimationFrameAction__WEBPACK_IMPORTED_MODULE_0__["AnimationFrameAction"]);
//# sourceMappingURL=animationFrame.js.map


/***/ }),
/* 279 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationFrameAction", function() { return AnimationFrameAction; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _AsyncAction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(258);
/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */


var AnimationFrameAction = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](AnimationFrameAction, _super);
    function AnimationFrameAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function () { return scheduler.flush(null); }));
    };
    AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        if (scheduler.actions.length === 0) {
            cancelAnimationFrame(id);
            scheduler.scheduled = undefined;
        }
        return undefined;
    };
    return AnimationFrameAction;
}(_AsyncAction__WEBPACK_IMPORTED_MODULE_1__["AsyncAction"]));

//# sourceMappingURL=AnimationFrameAction.js.map


/***/ }),
/* 280 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationFrameScheduler", function() { return AnimationFrameScheduler; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _AsyncScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(261);
/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */


var AnimationFrameScheduler = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](AnimationFrameScheduler, _super);
    function AnimationFrameScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AnimationFrameScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AnimationFrameScheduler;
}(_AsyncScheduler__WEBPACK_IMPORTED_MODULE_1__["AsyncScheduler"]));

//# sourceMappingURL=AnimationFrameScheduler.js.map


/***/ }),
/* 281 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VirtualTimeScheduler", function() { return VirtualTimeScheduler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VirtualAction", function() { return VirtualAction; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _AsyncAction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(258);
/* harmony import */ var _AsyncScheduler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(261);
/** PURE_IMPORTS_START tslib,_AsyncAction,_AsyncScheduler PURE_IMPORTS_END */



var VirtualTimeScheduler = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](VirtualTimeScheduler, _super);
    function VirtualTimeScheduler(SchedulerAction, maxFrames) {
        if (SchedulerAction === void 0) {
            SchedulerAction = VirtualAction;
        }
        if (maxFrames === void 0) {
            maxFrames = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this, SchedulerAction, function () { return _this.frame; }) || this;
        _this.maxFrames = maxFrames;
        _this.frame = 0;
        _this.index = -1;
        return _this;
    }
    VirtualTimeScheduler.prototype.flush = function () {
        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
        var error, action;
        while ((action = actions[0]) && action.delay <= maxFrames) {
            actions.shift();
            this.frame = action.delay;
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        }
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    VirtualTimeScheduler.frameTimeFactor = 10;
    return VirtualTimeScheduler;
}(_AsyncScheduler__WEBPACK_IMPORTED_MODULE_2__["AsyncScheduler"]));

var VirtualAction = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](VirtualAction, _super);
    function VirtualAction(scheduler, work, index) {
        if (index === void 0) {
            index = scheduler.index += 1;
        }
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.index = index;
        _this.active = true;
        _this.index = scheduler.index = index;
        return _this;
    }
    VirtualAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (!this.id) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.active = false;
        var action = new VirtualAction(this.scheduler, this.work);
        this.add(action);
        return action.schedule(state, delay);
    };
    VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        this.delay = scheduler.frame + delay;
        var actions = scheduler.actions;
        actions.push(this);
        actions.sort(VirtualAction.sortActions);
        return true;
    };
    VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return undefined;
    };
    VirtualAction.prototype._execute = function (state, delay) {
        if (this.active === true) {
            return _super.prototype._execute.call(this, state, delay);
        }
    };
    VirtualAction.sortActions = function (a, b) {
        if (a.delay === b.delay) {
            if (a.index === b.index) {
                return 0;
            }
            else if (a.index > b.index) {
                return 1;
            }
            else {
                return -1;
            }
        }
        else if (a.delay > b.delay) {
            return 1;
        }
        else {
            return -1;
        }
    };
    return VirtualAction;
}(_AsyncAction__WEBPACK_IMPORTED_MODULE_1__["AsyncAction"]));

//# sourceMappingURL=VirtualTimeScheduler.js.map


/***/ }),
/* 282 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function identity(x) {
    return x;
}
//# sourceMappingURL=identity.js.map


/***/ }),
/* 283 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isObservable", function() { return isObservable; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(231);
/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */

function isObservable(obj) {
    return !!obj && (obj instanceof _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"] || (typeof obj.lift === 'function' && typeof obj.subscribe === 'function'));
}
//# sourceMappingURL=isObservable.js.map


/***/ }),
/* 284 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArgumentOutOfRangeError", function() { return ArgumentOutOfRangeError; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var ArgumentOutOfRangeErrorImpl = /*@__PURE__*/ (function () {
    function ArgumentOutOfRangeErrorImpl() {
        Error.call(this);
        this.message = 'argument out of range';
        this.name = 'ArgumentOutOfRangeError';
        return this;
    }
    ArgumentOutOfRangeErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
    return ArgumentOutOfRangeErrorImpl;
})();
var ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;
//# sourceMappingURL=ArgumentOutOfRangeError.js.map


/***/ }),
/* 285 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EmptyError", function() { return EmptyError; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var EmptyErrorImpl = /*@__PURE__*/ (function () {
    function EmptyErrorImpl() {
        Error.call(this);
        this.message = 'no elements in sequence';
        this.name = 'EmptyError';
        return this;
    }
    EmptyErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
    return EmptyErrorImpl;
})();
var EmptyError = EmptyErrorImpl;
//# sourceMappingURL=EmptyError.js.map


/***/ }),
/* 286 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimeoutError", function() { return TimeoutError; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var TimeoutErrorImpl = /*@__PURE__*/ (function () {
    function TimeoutErrorImpl() {
        Error.call(this);
        this.message = 'Timeout has occurred';
        this.name = 'TimeoutError';
        return this;
    }
    TimeoutErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
    return TimeoutErrorImpl;
})();
var TimeoutError = TimeoutErrorImpl;
//# sourceMappingURL=TimeoutError.js.map


/***/ }),
/* 287 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bindCallback", function() { return bindCallback; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(231);
/* harmony import */ var _AsyncSubject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(272);
/* harmony import */ var _operators_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(288);
/* harmony import */ var _util_canReportError__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(232);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(240);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(267);
/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_canReportError,_util_isArray,_util_isScheduler PURE_IMPORTS_END */






function bindCallback(callbackFunc, resultSelector, scheduler) {
    if (resultSelector) {
        if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_5__["isScheduler"])(resultSelector)) {
            scheduler = resultSelector;
        }
        else {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return bindCallback(callbackFunc, scheduler).apply(void 0, args).pipe(Object(_operators_map__WEBPACK_IMPORTED_MODULE_2__["map"])(function (args) { return Object(_util_isArray__WEBPACK_IMPORTED_MODULE_4__["isArray"])(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
            };
        }
    }
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var context = this;
        var subject;
        var params = {
            context: context,
            subject: subject,
            callbackFunc: callbackFunc,
            scheduler: scheduler,
        };
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
            if (!scheduler) {
                if (!subject) {
                    subject = new _AsyncSubject__WEBPACK_IMPORTED_MODULE_1__["AsyncSubject"]();
                    var handler = function () {
                        var innerArgs = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            innerArgs[_i] = arguments[_i];
                        }
                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
                        subject.complete();
                    };
                    try {
                        callbackFunc.apply(context, args.concat([handler]));
                    }
                    catch (err) {
                        if (Object(_util_canReportError__WEBPACK_IMPORTED_MODULE_3__["canReportError"])(subject)) {
                            subject.error(err);
                        }
                        else {
                            console.warn(err);
                        }
                    }
                }
                return subject.subscribe(subscriber);
            }
            else {
                var state = {
                    args: args, subscriber: subscriber, params: params,
                };
                return scheduler.schedule(dispatch, 0, state);
            }
        });
    };
}
function dispatch(state) {
    var _this = this;
    var self = this;
    var args = state.args, subscriber = state.subscriber, params = state.params;
    var callbackFunc = params.callbackFunc, context = params.context, scheduler = params.scheduler;
    var subject = params.subject;
    if (!subject) {
        subject = params.subject = new _AsyncSubject__WEBPACK_IMPORTED_MODULE_1__["AsyncSubject"]();
        var handler = function () {
            var innerArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                innerArgs[_i] = arguments[_i];
            }
            var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
            _this.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));
        };
        try {
            callbackFunc.apply(context, args.concat([handler]));
        }
        catch (err) {
            subject.error(err);
        }
    }
    this.add(subject.subscribe(subscriber));
}
function dispatchNext(state) {
    var value = state.value, subject = state.subject;
    subject.next(value);
    subject.complete();
}
function dispatchError(state) {
    var err = state.err, subject = state.subject;
    subject.error(err);
}
//# sourceMappingURL=bindCallback.js.map


/***/ }),
/* 288 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "map", function() { return map; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MapOperator", function() { return MapOperator; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(233);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function map(project, thisArg) {
    return function mapOperation(source) {
        if (typeof project !== 'function') {
            throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
        }
        return source.lift(new MapOperator(project, thisArg));
    };
}
var MapOperator = /*@__PURE__*/ (function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}());

var MapSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.count = 0;
        _this.thisArg = thisArg || _this;
        return _this;
    }
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=map.js.map


/***/ }),
/* 289 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bindNodeCallback", function() { return bindNodeCallback; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(231);
/* harmony import */ var _AsyncSubject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(272);
/* harmony import */ var _operators_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(288);
/* harmony import */ var _util_canReportError__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(232);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(267);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(240);
/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_canReportError,_util_isScheduler,_util_isArray PURE_IMPORTS_END */






function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
    if (resultSelector) {
        if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_4__["isScheduler"])(resultSelector)) {
            scheduler = resultSelector;
        }
        else {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return bindNodeCallback(callbackFunc, scheduler).apply(void 0, args).pipe(Object(_operators_map__WEBPACK_IMPORTED_MODULE_2__["map"])(function (args) { return Object(_util_isArray__WEBPACK_IMPORTED_MODULE_5__["isArray"])(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
            };
        }
    }
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var params = {
            subject: undefined,
            args: args,
            callbackFunc: callbackFunc,
            scheduler: scheduler,
            context: this,
        };
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
            var context = params.context;
            var subject = params.subject;
            if (!scheduler) {
                if (!subject) {
                    subject = params.subject = new _AsyncSubject__WEBPACK_IMPORTED_MODULE_1__["AsyncSubject"]();
                    var handler = function () {
                        var innerArgs = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            innerArgs[_i] = arguments[_i];
                        }
                        var err = innerArgs.shift();
                        if (err) {
                            subject.error(err);
                            return;
                        }
                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
                        subject.complete();
                    };
                    try {
                        callbackFunc.apply(context, args.concat([handler]));
                    }
                    catch (err) {
                        if (Object(_util_canReportError__WEBPACK_IMPORTED_MODULE_3__["canReportError"])(subject)) {
                            subject.error(err);
                        }
                        else {
                            console.warn(err);
                        }
                    }
                }
                return subject.subscribe(subscriber);
            }
            else {
                return scheduler.schedule(dispatch, 0, { params: params, subscriber: subscriber, context: context });
            }
        });
    };
}
function dispatch(state) {
    var _this = this;
    var params = state.params, subscriber = state.subscriber, context = state.context;
    var callbackFunc = params.callbackFunc, args = params.args, scheduler = params.scheduler;
    var subject = params.subject;
    if (!subject) {
        subject = params.subject = new _AsyncSubject__WEBPACK_IMPORTED_MODULE_1__["AsyncSubject"]();
        var handler = function () {
            var innerArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                innerArgs[_i] = arguments[_i];
            }
            var err = innerArgs.shift();
            if (err) {
                _this.add(scheduler.schedule(dispatchError, 0, { err: err, subject: subject }));
            }
            else {
                var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
                _this.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));
            }
        };
        try {
            callbackFunc.apply(context, args.concat([handler]));
        }
        catch (err) {
            this.add(scheduler.schedule(dispatchError, 0, { err: err, subject: subject }));
        }
    }
    this.add(subject.subscribe(subscriber));
}
function dispatchNext(arg) {
    var value = arg.value, subject = arg.subject;
    subject.next(value);
    subject.complete();
}
function dispatchError(arg) {
    var err = arg.err, subject = arg.subject;
    subject.error(err);
}
//# sourceMappingURL=bindNodeCallback.js.map


/***/ }),
/* 290 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "combineLatest", function() { return combineLatest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CombineLatestOperator", function() { return CombineLatestOperator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CombineLatestSubscriber", function() { return CombineLatestSubscriber; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(267);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(240);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(291);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(292);
/* harmony import */ var _fromArray__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(268);
/** PURE_IMPORTS_START tslib,_util_isScheduler,_util_isArray,_OuterSubscriber,_util_subscribeToResult,_fromArray PURE_IMPORTS_END */






var NONE = {};
function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var resultSelector = null;
    var scheduler = null;
    if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_1__["isScheduler"])(observables[observables.length - 1])) {
        scheduler = observables.pop();
    }
    if (typeof observables[observables.length - 1] === 'function') {
        resultSelector = observables.pop();
    }
    if (observables.length === 1 && Object(_util_isArray__WEBPACK_IMPORTED_MODULE_2__["isArray"])(observables[0])) {
        observables = observables[0];
    }
    return Object(_fromArray__WEBPACK_IMPORTED_MODULE_5__["fromArray"])(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
}
var CombineLatestOperator = /*@__PURE__*/ (function () {
    function CombineLatestOperator(resultSelector) {
        this.resultSelector = resultSelector;
    }
    CombineLatestOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
    };
    return CombineLatestOperator;
}());

var CombineLatestSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](CombineLatestSubscriber, _super);
    function CombineLatestSubscriber(destination, resultSelector) {
        var _this = _super.call(this, destination) || this;
        _this.resultSelector = resultSelector;
        _this.active = 0;
        _this.values = [];
        _this.observables = [];
        return _this;
    }
    CombineLatestSubscriber.prototype._next = function (observable) {
        this.values.push(NONE);
        this.observables.push(observable);
    };
    CombineLatestSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            this.active = len;
            this.toRespond = len;
            for (var i = 0; i < len; i++) {
                var observable = observables[i];
                this.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__["subscribeToResult"])(this, observable, observable, i));
            }
        }
    };
    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
        if ((this.active -= 1) === 0) {
            this.destination.complete();
        }
    };
    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var values = this.values;
        var oldVal = values[outerIndex];
        var toRespond = !this.toRespond
            ? 0
            : oldVal === NONE ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;
        if (toRespond === 0) {
            if (this.resultSelector) {
                this._tryResultSelector(values);
            }
            else {
                this.destination.next(values.slice());
            }
        }
    };
    CombineLatestSubscriber.prototype._tryResultSelector = function (values) {
        var result;
        try {
            result = this.resultSelector.apply(this, values);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return CombineLatestSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__["OuterSubscriber"]));

//# sourceMappingURL=combineLatest.js.map


/***/ }),
/* 291 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OuterSubscriber", function() { return OuterSubscriber; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(233);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


var OuterSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](OuterSubscriber, _super);
    function OuterSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));

//# sourceMappingURL=OuterSubscriber.js.map


/***/ }),
/* 292 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subscribeToResult", function() { return subscribeToResult; });
/* harmony import */ var _InnerSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(293);
/* harmony import */ var _subscribeTo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(294);
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(231);
/** PURE_IMPORTS_START _InnerSubscriber,_subscribeTo,_Observable PURE_IMPORTS_END */



function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, destination) {
    if (destination === void 0) {
        destination = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_0__["InnerSubscriber"](outerSubscriber, outerValue, outerIndex);
    }
    if (destination.closed) {
        return undefined;
    }
    if (result instanceof _Observable__WEBPACK_IMPORTED_MODULE_2__["Observable"]) {
        return result.subscribe(destination);
    }
    return Object(_subscribeTo__WEBPACK_IMPORTED_MODULE_1__["subscribeTo"])(result)(destination);
}
//# sourceMappingURL=subscribeToResult.js.map


/***/ }),
/* 293 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InnerSubscriber", function() { return InnerSubscriber; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(233);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


var InnerSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](InnerSubscriber, _super);
    function InnerSubscriber(parent, outerValue, outerIndex) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.outerValue = outerValue;
        _this.outerIndex = outerIndex;
        _this.index = 0;
        return _this;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));

//# sourceMappingURL=InnerSubscriber.js.map


/***/ }),
/* 294 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subscribeTo", function() { return subscribeTo; });
/* harmony import */ var _subscribeToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(269);
/* harmony import */ var _subscribeToPromise__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(295);
/* harmony import */ var _subscribeToIterable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(296);
/* harmony import */ var _subscribeToObservable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(298);
/* harmony import */ var _isArrayLike__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(299);
/* harmony import */ var _isPromise__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(300);
/* harmony import */ var _isObject__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(241);
/* harmony import */ var _symbol_iterator__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(297);
/* harmony import */ var _symbol_observable__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(245);
/** PURE_IMPORTS_START _subscribeToArray,_subscribeToPromise,_subscribeToIterable,_subscribeToObservable,_isArrayLike,_isPromise,_isObject,_symbol_iterator,_symbol_observable PURE_IMPORTS_END */









var subscribeTo = function (result) {
    if (!!result && typeof result[_symbol_observable__WEBPACK_IMPORTED_MODULE_8__["observable"]] === 'function') {
        return Object(_subscribeToObservable__WEBPACK_IMPORTED_MODULE_3__["subscribeToObservable"])(result);
    }
    else if (Object(_isArrayLike__WEBPACK_IMPORTED_MODULE_4__["isArrayLike"])(result)) {
        return Object(_subscribeToArray__WEBPACK_IMPORTED_MODULE_0__["subscribeToArray"])(result);
    }
    else if (Object(_isPromise__WEBPACK_IMPORTED_MODULE_5__["isPromise"])(result)) {
        return Object(_subscribeToPromise__WEBPACK_IMPORTED_MODULE_1__["subscribeToPromise"])(result);
    }
    else if (!!result && typeof result[_symbol_iterator__WEBPACK_IMPORTED_MODULE_7__["iterator"]] === 'function') {
        return Object(_subscribeToIterable__WEBPACK_IMPORTED_MODULE_2__["subscribeToIterable"])(result);
    }
    else {
        var value = Object(_isObject__WEBPACK_IMPORTED_MODULE_6__["isObject"])(result) ? 'an invalid object' : "'" + result + "'";
        var msg = "You provided " + value + " where a stream was expected."
            + ' You can provide an Observable, Promise, Array, or Iterable.';
        throw new TypeError(msg);
    }
};
//# sourceMappingURL=subscribeTo.js.map


/***/ }),
/* 295 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subscribeToPromise", function() { return subscribeToPromise; });
/* harmony import */ var _hostReportError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(238);
/** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */

var subscribeToPromise = function (promise) {
    return function (subscriber) {
        promise.then(function (value) {
            if (!subscriber.closed) {
                subscriber.next(value);
                subscriber.complete();
            }
        }, function (err) { return subscriber.error(err); })
            .then(null, _hostReportError__WEBPACK_IMPORTED_MODULE_0__["hostReportError"]);
        return subscriber;
    };
};
//# sourceMappingURL=subscribeToPromise.js.map


/***/ }),
/* 296 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subscribeToIterable", function() { return subscribeToIterable; });
/* harmony import */ var _symbol_iterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(297);
/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */

var subscribeToIterable = function (iterable) {
    return function (subscriber) {
        var iterator = iterable[_symbol_iterator__WEBPACK_IMPORTED_MODULE_0__["iterator"]]();
        do {
            var item = iterator.next();
            if (item.done) {
                subscriber.complete();
                break;
            }
            subscriber.next(item.value);
            if (subscriber.closed) {
                break;
            }
        } while (true);
        if (typeof iterator.return === 'function') {
            subscriber.add(function () {
                if (iterator.return) {
                    iterator.return();
                }
            });
        }
        return subscriber;
    };
};
//# sourceMappingURL=subscribeToIterable.js.map


/***/ }),
/* 297 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSymbolIterator", function() { return getSymbolIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "iterator", function() { return iterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$$iterator", function() { return $$iterator; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function getSymbolIterator() {
    if (typeof Symbol !== 'function' || !Symbol.iterator) {
        return '@@iterator';
    }
    return Symbol.iterator;
}
var iterator = /*@__PURE__*/ getSymbolIterator();
var $$iterator = iterator;
//# sourceMappingURL=iterator.js.map


/***/ }),
/* 298 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subscribeToObservable", function() { return subscribeToObservable; });
/* harmony import */ var _symbol_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(245);
/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */

var subscribeToObservable = function (obj) {
    return function (subscriber) {
        var obs = obj[_symbol_observable__WEBPACK_IMPORTED_MODULE_0__["observable"]]();
        if (typeof obs.subscribe !== 'function') {
            throw new TypeError('Provided object does not correctly implement Symbol.observable');
        }
        else {
            return obs.subscribe(subscriber);
        }
    };
};
//# sourceMappingURL=subscribeToObservable.js.map


/***/ }),
/* 299 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isArrayLike", function() { return isArrayLike; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });
//# sourceMappingURL=isArrayLike.js.map


/***/ }),
/* 300 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPromise", function() { return isPromise; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isPromise(value) {
    return !!value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}
//# sourceMappingURL=isPromise.js.map


/***/ }),
/* 301 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concat", function() { return concat; });
/* harmony import */ var _of__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(266);
/* harmony import */ var _operators_concatAll__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(302);
/** PURE_IMPORTS_START _of,_operators_concatAll PURE_IMPORTS_END */


function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return Object(_operators_concatAll__WEBPACK_IMPORTED_MODULE_1__["concatAll"])()(_of__WEBPACK_IMPORTED_MODULE_0__["of"].apply(void 0, observables));
}
//# sourceMappingURL=concat.js.map


/***/ }),
/* 302 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concatAll", function() { return concatAll; });
/* harmony import */ var _mergeAll__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(303);
/** PURE_IMPORTS_START _mergeAll PURE_IMPORTS_END */

function concatAll() {
    return Object(_mergeAll__WEBPACK_IMPORTED_MODULE_0__["mergeAll"])(1);
}
//# sourceMappingURL=concatAll.js.map


/***/ }),
/* 303 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeAll", function() { return mergeAll; });
/* harmony import */ var _mergeMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(304);
/* harmony import */ var _util_identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(282);
/** PURE_IMPORTS_START _mergeMap,_util_identity PURE_IMPORTS_END */


function mergeAll(concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    return Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__["mergeMap"])(_util_identity__WEBPACK_IMPORTED_MODULE_1__["identity"], concurrent);
}
//# sourceMappingURL=mergeAll.js.map


/***/ }),
/* 304 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeMap", function() { return mergeMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MergeMapOperator", function() { return MergeMapOperator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MergeMapSubscriber", function() { return MergeMapSubscriber; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(292);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(291);
/* harmony import */ var _InnerSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(293);
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(288);
/* harmony import */ var _observable_from__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(305);
/** PURE_IMPORTS_START tslib,_util_subscribeToResult,_OuterSubscriber,_InnerSubscriber,_map,_observable_from PURE_IMPORTS_END */






function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    if (typeof resultSelector === 'function') {
        return function (source) { return source.pipe(mergeMap(function (a, i) { return Object(_observable_from__WEBPACK_IMPORTED_MODULE_5__["from"])(project(a, i)).pipe(Object(_map__WEBPACK_IMPORTED_MODULE_4__["map"])(function (b, ii) { return resultSelector(a, b, i, ii); })); }, concurrent)); };
    }
    else if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
    }
    return function (source) { return source.lift(new MergeMapOperator(project, concurrent)); };
}
var MergeMapOperator = /*@__PURE__*/ (function () {
    function MergeMapOperator(project, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        this.project = project;
        this.concurrent = concurrent;
    }
    MergeMapOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
    };
    return MergeMapOperator;
}());

var MergeMapSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](MergeMapSubscriber, _super);
    function MergeMapSubscriber(destination, project, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
    }
    MergeMapSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            this._tryNext(value);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeMapSubscriber.prototype._tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.active++;
        this._innerSub(result, value, index);
    };
    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
        var innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_3__["InnerSubscriber"](this, undefined, undefined);
        var destination = this.destination;
        destination.add(innerSubscriber);
        Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__["subscribeToResult"])(this, ish, value, index, innerSubscriber);
    };
    MergeMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__["OuterSubscriber"]));

//# sourceMappingURL=mergeMap.js.map


/***/ }),
/* 305 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "from", function() { return from; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(231);
/* harmony import */ var _util_subscribeTo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(294);
/* harmony import */ var _scheduled_scheduled__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(306);
/** PURE_IMPORTS_START _Observable,_util_subscribeTo,_scheduled_scheduled PURE_IMPORTS_END */



function from(input, scheduler) {
    if (!scheduler) {
        if (input instanceof _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"]) {
            return input;
        }
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](Object(_util_subscribeTo__WEBPACK_IMPORTED_MODULE_1__["subscribeTo"])(input));
    }
    else {
        return Object(_scheduled_scheduled__WEBPACK_IMPORTED_MODULE_2__["scheduled"])(input, scheduler);
    }
}
//# sourceMappingURL=from.js.map


/***/ }),
/* 306 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheduled", function() { return scheduled; });
/* harmony import */ var _scheduleObservable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(307);
/* harmony import */ var _schedulePromise__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(308);
/* harmony import */ var _scheduleArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(270);
/* harmony import */ var _scheduleIterable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(309);
/* harmony import */ var _util_isInteropObservable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(310);
/* harmony import */ var _util_isPromise__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(300);
/* harmony import */ var _util_isArrayLike__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(299);
/* harmony import */ var _util_isIterable__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(311);
/** PURE_IMPORTS_START _scheduleObservable,_schedulePromise,_scheduleArray,_scheduleIterable,_util_isInteropObservable,_util_isPromise,_util_isArrayLike,_util_isIterable PURE_IMPORTS_END */








function scheduled(input, scheduler) {
    if (input != null) {
        if (Object(_util_isInteropObservable__WEBPACK_IMPORTED_MODULE_4__["isInteropObservable"])(input)) {
            return Object(_scheduleObservable__WEBPACK_IMPORTED_MODULE_0__["scheduleObservable"])(input, scheduler);
        }
        else if (Object(_util_isPromise__WEBPACK_IMPORTED_MODULE_5__["isPromise"])(input)) {
            return Object(_schedulePromise__WEBPACK_IMPORTED_MODULE_1__["schedulePromise"])(input, scheduler);
        }
        else if (Object(_util_isArrayLike__WEBPACK_IMPORTED_MODULE_6__["isArrayLike"])(input)) {
            return Object(_scheduleArray__WEBPACK_IMPORTED_MODULE_2__["scheduleArray"])(input, scheduler);
        }
        else if (Object(_util_isIterable__WEBPACK_IMPORTED_MODULE_7__["isIterable"])(input) || typeof input === 'string') {
            return Object(_scheduleIterable__WEBPACK_IMPORTED_MODULE_3__["scheduleIterable"])(input, scheduler);
        }
    }
    throw new TypeError((input !== null && typeof input || input) + ' is not observable');
}
//# sourceMappingURL=scheduled.js.map


/***/ }),
/* 307 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheduleObservable", function() { return scheduleObservable; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(231);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(239);
/* harmony import */ var _symbol_observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(245);
/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_observable PURE_IMPORTS_END */



function scheduleObservable(input, scheduler) {
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
        var sub = new _Subscription__WEBPACK_IMPORTED_MODULE_1__["Subscription"]();
        sub.add(scheduler.schedule(function () {
            var observable = input[_symbol_observable__WEBPACK_IMPORTED_MODULE_2__["observable"]]();
            sub.add(observable.subscribe({
                next: function (value) { sub.add(scheduler.schedule(function () { return subscriber.next(value); })); },
                error: function (err) { sub.add(scheduler.schedule(function () { return subscriber.error(err); })); },
                complete: function () { sub.add(scheduler.schedule(function () { return subscriber.complete(); })); },
            }));
        }));
        return sub;
    });
}
//# sourceMappingURL=scheduleObservable.js.map


/***/ }),
/* 308 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "schedulePromise", function() { return schedulePromise; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(231);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(239);
/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */


function schedulePromise(input, scheduler) {
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
        var sub = new _Subscription__WEBPACK_IMPORTED_MODULE_1__["Subscription"]();
        sub.add(scheduler.schedule(function () {
            return input.then(function (value) {
                sub.add(scheduler.schedule(function () {
                    subscriber.next(value);
                    sub.add(scheduler.schedule(function () { return subscriber.complete(); }));
                }));
            }, function (err) {
                sub.add(scheduler.schedule(function () { return subscriber.error(err); }));
            });
        }));
        return sub;
    });
}
//# sourceMappingURL=schedulePromise.js.map


/***/ }),
/* 309 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheduleIterable", function() { return scheduleIterable; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(231);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(239);
/* harmony import */ var _symbol_iterator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(297);
/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_iterator PURE_IMPORTS_END */



function scheduleIterable(input, scheduler) {
    if (!input) {
        throw new Error('Iterable cannot be null');
    }
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
        var sub = new _Subscription__WEBPACK_IMPORTED_MODULE_1__["Subscription"]();
        var iterator;
        sub.add(function () {
            if (iterator && typeof iterator.return === 'function') {
                iterator.return();
            }
        });
        sub.add(scheduler.schedule(function () {
            iterator = input[_symbol_iterator__WEBPACK_IMPORTED_MODULE_2__["iterator"]]();
            sub.add(scheduler.schedule(function () {
                if (subscriber.closed) {
                    return;
                }
                var value;
                var done;
                try {
                    var result = iterator.next();
                    value = result.value;
                    done = result.done;
                }
                catch (err) {
                    subscriber.error(err);
                    return;
                }
                if (done) {
                    subscriber.complete();
                }
                else {
                    subscriber.next(value);
                    this.schedule();
                }
            }));
        }));
        return sub;
    });
}
//# sourceMappingURL=scheduleIterable.js.map


/***/ }),
/* 310 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isInteropObservable", function() { return isInteropObservable; });
/* harmony import */ var _symbol_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(245);
/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */

function isInteropObservable(input) {
    return input && typeof input[_symbol_observable__WEBPACK_IMPORTED_MODULE_0__["observable"]] === 'function';
}
//# sourceMappingURL=isInteropObservable.js.map


/***/ }),
/* 311 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIterable", function() { return isIterable; });
/* harmony import */ var _symbol_iterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(297);
/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */

function isIterable(input) {
    return input && typeof input[_symbol_iterator__WEBPACK_IMPORTED_MODULE_0__["iterator"]] === 'function';
}
//# sourceMappingURL=isIterable.js.map


/***/ }),
/* 312 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defer", function() { return defer; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(231);
/* harmony import */ var _from__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(305);
/* harmony import */ var _empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(265);
/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */



function defer(observableFactory) {
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
        var input;
        try {
            input = observableFactory();
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var source = input ? Object(_from__WEBPACK_IMPORTED_MODULE_1__["from"])(input) : Object(_empty__WEBPACK_IMPORTED_MODULE_2__["empty"])();
        return source.subscribe(subscriber);
    });
}
//# sourceMappingURL=defer.js.map


/***/ }),
/* 313 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forkJoin", function() { return forkJoin; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(231);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(240);
/* harmony import */ var _operators_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(288);
/* harmony import */ var _util_isObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(241);
/* harmony import */ var _from__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(305);
/** PURE_IMPORTS_START _Observable,_util_isArray,_operators_map,_util_isObject,_from PURE_IMPORTS_END */





function forkJoin() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    if (sources.length === 1) {
        var first_1 = sources[0];
        if (Object(_util_isArray__WEBPACK_IMPORTED_MODULE_1__["isArray"])(first_1)) {
            return forkJoinInternal(first_1, null);
        }
        if (Object(_util_isObject__WEBPACK_IMPORTED_MODULE_3__["isObject"])(first_1) && Object.getPrototypeOf(first_1) === Object.prototype) {
            var keys = Object.keys(first_1);
            return forkJoinInternal(keys.map(function (key) { return first_1[key]; }), keys);
        }
    }
    if (typeof sources[sources.length - 1] === 'function') {
        var resultSelector_1 = sources.pop();
        sources = (sources.length === 1 && Object(_util_isArray__WEBPACK_IMPORTED_MODULE_1__["isArray"])(sources[0])) ? sources[0] : sources;
        return forkJoinInternal(sources, null).pipe(Object(_operators_map__WEBPACK_IMPORTED_MODULE_2__["map"])(function (args) { return resultSelector_1.apply(void 0, args); }));
    }
    return forkJoinInternal(sources, null);
}
function forkJoinInternal(sources, keys) {
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
        var len = sources.length;
        if (len === 0) {
            subscriber.complete();
            return;
        }
        var values = new Array(len);
        var completed = 0;
        var emitted = 0;
        var _loop_1 = function (i) {
            var source = Object(_from__WEBPACK_IMPORTED_MODULE_4__["from"])(sources[i]);
            var hasValue = false;
            subscriber.add(source.subscribe({
                next: function (value) {
                    if (!hasValue) {
                        hasValue = true;
                        emitted++;
                    }
                    values[i] = value;
                },
                error: function (err) { return subscriber.error(err); },
                complete: function () {
                    completed++;
                    if (completed === len || !hasValue) {
                        if (emitted === len) {
                            subscriber.next(keys ?
                                keys.reduce(function (result, key, i) { return (result[key] = values[i], result); }, {}) :
                                values);
                        }
                        subscriber.complete();
                    }
                }
            }));
        };
        for (var i = 0; i < len; i++) {
            _loop_1(i);
        }
    });
}
//# sourceMappingURL=forkJoin.js.map


/***/ }),
/* 314 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromEvent", function() { return fromEvent; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(231);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(240);
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(235);
/* harmony import */ var _operators_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(288);
/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */




var toString = /*@__PURE__*/ (function () { return Object.prototype.toString; })();
function fromEvent(target, eventName, options, resultSelector) {
    if (Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_2__["isFunction"])(options)) {
        resultSelector = options;
        options = undefined;
    }
    if (resultSelector) {
        return fromEvent(target, eventName, options).pipe(Object(_operators_map__WEBPACK_IMPORTED_MODULE_3__["map"])(function (args) { return Object(_util_isArray__WEBPACK_IMPORTED_MODULE_1__["isArray"])(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
    }
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
        function handler(e) {
            if (arguments.length > 1) {
                subscriber.next(Array.prototype.slice.call(arguments));
            }
            else {
                subscriber.next(e);
            }
        }
        setupSubscription(target, eventName, handler, subscriber, options);
    });
}
function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
    var unsubscribe;
    if (isEventTarget(sourceObj)) {
        var source_1 = sourceObj;
        sourceObj.addEventListener(eventName, handler, options);
        unsubscribe = function () { return source_1.removeEventListener(eventName, handler, options); };
    }
    else if (isJQueryStyleEventEmitter(sourceObj)) {
        var source_2 = sourceObj;
        sourceObj.on(eventName, handler);
        unsubscribe = function () { return source_2.off(eventName, handler); };
    }
    else if (isNodeStyleEventEmitter(sourceObj)) {
        var source_3 = sourceObj;
        sourceObj.addListener(eventName, handler);
        unsubscribe = function () { return source_3.removeListener(eventName, handler); };
    }
    else if (sourceObj && sourceObj.length) {
        for (var i = 0, len = sourceObj.length; i < len; i++) {
            setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
        }
    }
    else {
        throw new TypeError('Invalid event target');
    }
    subscriber.add(unsubscribe);
}
function isNodeStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
}
function isJQueryStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
}
function isEventTarget(sourceObj) {
    return sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
}
//# sourceMappingURL=fromEvent.js.map


/***/ }),
/* 315 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromEventPattern", function() { return fromEventPattern; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(231);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(240);
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(235);
/* harmony import */ var _operators_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(288);
/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */




function fromEventPattern(addHandler, removeHandler, resultSelector) {
    if (resultSelector) {
        return fromEventPattern(addHandler, removeHandler).pipe(Object(_operators_map__WEBPACK_IMPORTED_MODULE_3__["map"])(function (args) { return Object(_util_isArray__WEBPACK_IMPORTED_MODULE_1__["isArray"])(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
    }
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
        var handler = function () {
            var e = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                e[_i] = arguments[_i];
            }
            return subscriber.next(e.length === 1 ? e[0] : e);
        };
        var retValue;
        try {
            retValue = addHandler(handler);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        if (!Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_2__["isFunction"])(removeHandler)) {
            return undefined;
        }
        return function () { return removeHandler(handler, retValue); };
    });
}
//# sourceMappingURL=fromEventPattern.js.map


/***/ }),
/* 316 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generate", function() { return generate; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(231);
/* harmony import */ var _util_identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(282);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(267);
/** PURE_IMPORTS_START _Observable,_util_identity,_util_isScheduler PURE_IMPORTS_END */



function generate(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {
    var resultSelector;
    var initialState;
    if (arguments.length == 1) {
        var options = initialStateOrOptions;
        initialState = options.initialState;
        condition = options.condition;
        iterate = options.iterate;
        resultSelector = options.resultSelector || _util_identity__WEBPACK_IMPORTED_MODULE_1__["identity"];
        scheduler = options.scheduler;
    }
    else if (resultSelectorOrObservable === undefined || Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_2__["isScheduler"])(resultSelectorOrObservable)) {
        initialState = initialStateOrOptions;
        resultSelector = _util_identity__WEBPACK_IMPORTED_MODULE_1__["identity"];
        scheduler = resultSelectorOrObservable;
    }
    else {
        initialState = initialStateOrOptions;
        resultSelector = resultSelectorOrObservable;
    }
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
        var state = initialState;
        if (scheduler) {
            return scheduler.schedule(dispatch, 0, {
                subscriber: subscriber,
                iterate: iterate,
                condition: condition,
                resultSelector: resultSelector,
                state: state
            });
        }
        do {
            if (condition) {
                var conditionResult = void 0;
                try {
                    conditionResult = condition(state);
                }
                catch (err) {
                    subscriber.error(err);
                    return undefined;
                }
                if (!conditionResult) {
                    subscriber.complete();
                    break;
                }
            }
            var value = void 0;
            try {
                value = resultSelector(state);
            }
            catch (err) {
                subscriber.error(err);
                return undefined;
            }
            subscriber.next(value);
            if (subscriber.closed) {
                break;
            }
            try {
                state = iterate(state);
            }
            catch (err) {
                subscriber.error(err);
                return undefined;
            }
        } while (true);
        return undefined;
    });
}
function dispatch(state) {
    var subscriber = state.subscriber, condition = state.condition;
    if (subscriber.closed) {
        return undefined;
    }
    if (state.needIterate) {
        try {
            state.state = state.iterate(state.state);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
    }
    else {
        state.needIterate = true;
    }
    if (condition) {
        var conditionResult = void 0;
        try {
            conditionResult = condition(state.state);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        if (!conditionResult) {
            subscriber.complete();
            return undefined;
        }
        if (subscriber.closed) {
            return undefined;
        }
    }
    var value;
    try {
        value = state.resultSelector(state.state);
    }
    catch (err) {
        subscriber.error(err);
        return undefined;
    }
    if (subscriber.closed) {
        return undefined;
    }
    subscriber.next(value);
    if (subscriber.closed) {
        return undefined;
    }
    return this.schedule(state);
}
//# sourceMappingURL=generate.js.map


/***/ }),
/* 317 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "iif", function() { return iif; });
/* harmony import */ var _defer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(312);
/* harmony import */ var _empty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(265);
/** PURE_IMPORTS_START _defer,_empty PURE_IMPORTS_END */


function iif(condition, trueResult, falseResult) {
    if (trueResult === void 0) {
        trueResult = _empty__WEBPACK_IMPORTED_MODULE_1__["EMPTY"];
    }
    if (falseResult === void 0) {
        falseResult = _empty__WEBPACK_IMPORTED_MODULE_1__["EMPTY"];
    }
    return Object(_defer__WEBPACK_IMPORTED_MODULE_0__["defer"])(function () { return condition() ? trueResult : falseResult; });
}
//# sourceMappingURL=iif.js.map


/***/ }),
/* 318 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interval", function() { return interval; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(231);
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(277);
/* harmony import */ var _util_isNumeric__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(319);
/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric PURE_IMPORTS_END */



function interval(period, scheduler) {
    if (period === void 0) {
        period = 0;
    }
    if (scheduler === void 0) {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__["async"];
    }
    if (!Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_2__["isNumeric"])(period) || period < 0) {
        period = 0;
    }
    if (!scheduler || typeof scheduler.schedule !== 'function') {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__["async"];
    }
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
        subscriber.add(scheduler.schedule(dispatch, period, { subscriber: subscriber, counter: 0, period: period }));
        return subscriber;
    });
}
function dispatch(state) {
    var subscriber = state.subscriber, counter = state.counter, period = state.period;
    subscriber.next(counter);
    this.schedule({ subscriber: subscriber, counter: counter + 1, period: period }, period);
}
//# sourceMappingURL=interval.js.map


/***/ }),
/* 319 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNumeric", function() { return isNumeric; });
/* harmony import */ var _isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(240);
/** PURE_IMPORTS_START _isArray PURE_IMPORTS_END */

function isNumeric(val) {
    return !Object(_isArray__WEBPACK_IMPORTED_MODULE_0__["isArray"])(val) && (val - parseFloat(val) + 1) >= 0;
}
//# sourceMappingURL=isNumeric.js.map


/***/ }),
/* 320 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return merge; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(231);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(267);
/* harmony import */ var _operators_mergeAll__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(303);
/* harmony import */ var _fromArray__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(268);
/** PURE_IMPORTS_START _Observable,_util_isScheduler,_operators_mergeAll,_fromArray PURE_IMPORTS_END */




function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var concurrent = Number.POSITIVE_INFINITY;
    var scheduler = null;
    var last = observables[observables.length - 1];
    if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_1__["isScheduler"])(last)) {
        scheduler = observables.pop();
        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
            concurrent = observables.pop();
        }
    }
    else if (typeof last === 'number') {
        concurrent = observables.pop();
    }
    if (scheduler === null && observables.length === 1 && observables[0] instanceof _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"]) {
        return observables[0];
    }
    return Object(_operators_mergeAll__WEBPACK_IMPORTED_MODULE_2__["mergeAll"])(concurrent)(Object(_fromArray__WEBPACK_IMPORTED_MODULE_3__["fromArray"])(observables, scheduler));
}
//# sourceMappingURL=merge.js.map


/***/ }),
/* 321 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NEVER", function() { return NEVER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "never", function() { return never; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(231);
/* harmony import */ var _util_noop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(247);
/** PURE_IMPORTS_START _Observable,_util_noop PURE_IMPORTS_END */


var NEVER = /*@__PURE__*/ new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](_util_noop__WEBPACK_IMPORTED_MODULE_1__["noop"]);
function never() {
    return NEVER;
}
//# sourceMappingURL=never.js.map


/***/ }),
/* 322 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onErrorResumeNext", function() { return onErrorResumeNext; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(231);
/* harmony import */ var _from__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(305);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(240);
/* harmony import */ var _empty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(265);
/** PURE_IMPORTS_START _Observable,_from,_util_isArray,_empty PURE_IMPORTS_END */




function onErrorResumeNext() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    if (sources.length === 0) {
        return _empty__WEBPACK_IMPORTED_MODULE_3__["EMPTY"];
    }
    var first = sources[0], remainder = sources.slice(1);
    if (sources.length === 1 && Object(_util_isArray__WEBPACK_IMPORTED_MODULE_2__["isArray"])(first)) {
        return onErrorResumeNext.apply(void 0, first);
    }
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
        var subNext = function () { return subscriber.add(onErrorResumeNext.apply(void 0, remainder).subscribe(subscriber)); };
        return Object(_from__WEBPACK_IMPORTED_MODULE_1__["from"])(first).subscribe({
            next: function (value) { subscriber.next(value); },
            error: subNext,
            complete: subNext,
        });
    });
}
//# sourceMappingURL=onErrorResumeNext.js.map


/***/ }),
/* 323 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pairs", function() { return pairs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dispatch", function() { return dispatch; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(231);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(239);
/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */


function pairs(obj, scheduler) {
    if (!scheduler) {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
            var keys = Object.keys(obj);
            for (var i = 0; i < keys.length && !subscriber.closed; i++) {
                var key = keys[i];
                if (obj.hasOwnProperty(key)) {
                    subscriber.next([key, obj[key]]);
                }
            }
            subscriber.complete();
        });
    }
    else {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
            var keys = Object.keys(obj);
            var subscription = new _Subscription__WEBPACK_IMPORTED_MODULE_1__["Subscription"]();
            subscription.add(scheduler.schedule(dispatch, 0, { keys: keys, index: 0, subscriber: subscriber, subscription: subscription, obj: obj }));
            return subscription;
        });
    }
}
function dispatch(state) {
    var keys = state.keys, index = state.index, subscriber = state.subscriber, subscription = state.subscription, obj = state.obj;
    if (!subscriber.closed) {
        if (index < keys.length) {
            var key = keys[index];
            subscriber.next([key, obj[key]]);
            subscription.add(this.schedule({ keys: keys, index: index + 1, subscriber: subscriber, subscription: subscription, obj: obj }));
        }
        else {
            subscriber.complete();
        }
    }
}
//# sourceMappingURL=pairs.js.map


/***/ }),
/* 324 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "partition", function() { return partition; });
/* harmony import */ var _util_not__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(325);
/* harmony import */ var _util_subscribeTo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(294);
/* harmony import */ var _operators_filter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(326);
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(231);
/** PURE_IMPORTS_START _util_not,_util_subscribeTo,_operators_filter,_Observable PURE_IMPORTS_END */




function partition(source, predicate, thisArg) {
    return [
        Object(_operators_filter__WEBPACK_IMPORTED_MODULE_2__["filter"])(predicate, thisArg)(new _Observable__WEBPACK_IMPORTED_MODULE_3__["Observable"](Object(_util_subscribeTo__WEBPACK_IMPORTED_MODULE_1__["subscribeTo"])(source))),
        Object(_operators_filter__WEBPACK_IMPORTED_MODULE_2__["filter"])(Object(_util_not__WEBPACK_IMPORTED_MODULE_0__["not"])(predicate, thisArg))(new _Observable__WEBPACK_IMPORTED_MODULE_3__["Observable"](Object(_util_subscribeTo__WEBPACK_IMPORTED_MODULE_1__["subscribeTo"])(source)))
    ];
}
//# sourceMappingURL=partition.js.map


/***/ }),
/* 325 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "not", function() { return not; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function not(pred, thisArg) {
    function notPred() {
        return !(notPred.pred.apply(notPred.thisArg, arguments));
    }
    notPred.pred = pred;
    notPred.thisArg = thisArg;
    return notPred;
}
//# sourceMappingURL=not.js.map


/***/ }),
/* 326 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "filter", function() { return filter; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(233);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function filter(predicate, thisArg) {
    return function filterOperatorFunction(source) {
        return source.lift(new FilterOperator(predicate, thisArg));
    };
}
var FilterOperator = /*@__PURE__*/ (function () {
    function FilterOperator(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
    }
    FilterOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator;
}());
var FilterSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](FilterSubscriber, _super);
    function FilterSubscriber(destination, predicate, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.count = 0;
        return _this;
    }
    FilterSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.predicate.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.destination.next(value);
        }
    };
    return FilterSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=filter.js.map


/***/ }),
/* 327 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "race", function() { return race; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RaceOperator", function() { return RaceOperator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RaceSubscriber", function() { return RaceSubscriber; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(240);
/* harmony import */ var _fromArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(268);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(291);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(292);
/** PURE_IMPORTS_START tslib,_util_isArray,_fromArray,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */





function race() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    if (observables.length === 1) {
        if (Object(_util_isArray__WEBPACK_IMPORTED_MODULE_1__["isArray"])(observables[0])) {
            observables = observables[0];
        }
        else {
            return observables[0];
        }
    }
    return Object(_fromArray__WEBPACK_IMPORTED_MODULE_2__["fromArray"])(observables, undefined).lift(new RaceOperator());
}
var RaceOperator = /*@__PURE__*/ (function () {
    function RaceOperator() {
    }
    RaceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RaceSubscriber(subscriber));
    };
    return RaceOperator;
}());

var RaceSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](RaceSubscriber, _super);
    function RaceSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasFirst = false;
        _this.observables = [];
        _this.subscriptions = [];
        return _this;
    }
    RaceSubscriber.prototype._next = function (observable) {
        this.observables.push(observable);
    };
    RaceSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            for (var i = 0; i < len && !this.hasFirst; i++) {
                var observable = observables[i];
                var subscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__["subscribeToResult"])(this, observable, observable, i);
                if (this.subscriptions) {
                    this.subscriptions.push(subscription);
                }
                this.add(subscription);
            }
            this.observables = null;
        }
    };
    RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (!this.hasFirst) {
            this.hasFirst = true;
            for (var i = 0; i < this.subscriptions.length; i++) {
                if (i !== outerIndex) {
                    var subscription = this.subscriptions[i];
                    subscription.unsubscribe();
                    this.remove(subscription);
                }
            }
            this.subscriptions = null;
        }
        this.destination.next(innerValue);
    };
    return RaceSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__["OuterSubscriber"]));

//# sourceMappingURL=race.js.map


/***/ }),
/* 328 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "range", function() { return range; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dispatch", function() { return dispatch; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(231);
/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */

function range(start, count, scheduler) {
    if (start === void 0) {
        start = 0;
    }
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
        if (count === undefined) {
            count = start;
            start = 0;
        }
        var index = 0;
        var current = start;
        if (scheduler) {
            return scheduler.schedule(dispatch, 0, {
                index: index, count: count, start: start, subscriber: subscriber
            });
        }
        else {
            do {
                if (index++ >= count) {
                    subscriber.complete();
                    break;
                }
                subscriber.next(current++);
                if (subscriber.closed) {
                    break;
                }
            } while (true);
        }
        return undefined;
    });
}
function dispatch(state) {
    var start = state.start, index = state.index, count = state.count, subscriber = state.subscriber;
    if (index >= count) {
        subscriber.complete();
        return;
    }
    subscriber.next(start);
    if (subscriber.closed) {
        return;
    }
    state.index = index + 1;
    state.start = start + 1;
    this.schedule(state);
}
//# sourceMappingURL=range.js.map


/***/ }),
/* 329 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timer", function() { return timer; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(231);
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(277);
/* harmony import */ var _util_isNumeric__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(319);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(267);
/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */




function timer(dueTime, periodOrScheduler, scheduler) {
    if (dueTime === void 0) {
        dueTime = 0;
    }
    var period = -1;
    if (Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_2__["isNumeric"])(periodOrScheduler)) {
        period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
    }
    else if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_3__["isScheduler"])(periodOrScheduler)) {
        scheduler = periodOrScheduler;
    }
    if (!Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_3__["isScheduler"])(scheduler)) {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__["async"];
    }
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
        var due = Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_2__["isNumeric"])(dueTime)
            ? dueTime
            : (+dueTime - scheduler.now());
        return scheduler.schedule(dispatch, due, {
            index: 0, period: period, subscriber: subscriber
        });
    });
}
function dispatch(state) {
    var index = state.index, period = state.period, subscriber = state.subscriber;
    subscriber.next(index);
    if (subscriber.closed) {
        return;
    }
    else if (period === -1) {
        return subscriber.complete();
    }
    state.index = index + 1;
    this.schedule(state, period);
}
//# sourceMappingURL=timer.js.map


/***/ }),
/* 330 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "using", function() { return using; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(231);
/* harmony import */ var _from__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(305);
/* harmony import */ var _empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(265);
/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */



function using(resourceFactory, observableFactory) {
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (subscriber) {
        var resource;
        try {
            resource = resourceFactory();
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var result;
        try {
            result = observableFactory(resource);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var source = result ? Object(_from__WEBPACK_IMPORTED_MODULE_1__["from"])(result) : _empty__WEBPACK_IMPORTED_MODULE_2__["EMPTY"];
        var subscription = source.subscribe(subscriber);
        return function () {
            subscription.unsubscribe();
            if (resource) {
                resource.unsubscribe();
            }
        };
    });
}
//# sourceMappingURL=using.js.map


/***/ }),
/* 331 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zip", function() { return zip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZipOperator", function() { return ZipOperator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZipSubscriber", function() { return ZipSubscriber; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _fromArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(268);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(240);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(233);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(291);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(292);
/* harmony import */ var _internal_symbol_iterator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(297);
/** PURE_IMPORTS_START tslib,_fromArray,_util_isArray,_Subscriber,_OuterSubscriber,_util_subscribeToResult,_.._internal_symbol_iterator PURE_IMPORTS_END */







function zip() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var resultSelector = observables[observables.length - 1];
    if (typeof resultSelector === 'function') {
        observables.pop();
    }
    return Object(_fromArray__WEBPACK_IMPORTED_MODULE_1__["fromArray"])(observables, undefined).lift(new ZipOperator(resultSelector));
}
var ZipOperator = /*@__PURE__*/ (function () {
    function ZipOperator(resultSelector) {
        this.resultSelector = resultSelector;
    }
    ZipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
    };
    return ZipOperator;
}());

var ZipSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](ZipSubscriber, _super);
    function ZipSubscriber(destination, resultSelector, values) {
        if (values === void 0) {
            values = Object.create(null);
        }
        var _this = _super.call(this, destination) || this;
        _this.iterators = [];
        _this.active = 0;
        _this.resultSelector = (typeof resultSelector === 'function') ? resultSelector : null;
        _this.values = values;
        return _this;
    }
    ZipSubscriber.prototype._next = function (value) {
        var iterators = this.iterators;
        if (Object(_util_isArray__WEBPACK_IMPORTED_MODULE_2__["isArray"])(value)) {
            iterators.push(new StaticArrayIterator(value));
        }
        else if (typeof value[_internal_symbol_iterator__WEBPACK_IMPORTED_MODULE_6__["iterator"]] === 'function') {
            iterators.push(new StaticIterator(value[_internal_symbol_iterator__WEBPACK_IMPORTED_MODULE_6__["iterator"]]()));
        }
        else {
            iterators.push(new ZipBufferIterator(this.destination, this, value));
        }
    };
    ZipSubscriber.prototype._complete = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        this.unsubscribe();
        if (len === 0) {
            this.destination.complete();
            return;
        }
        this.active = len;
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (iterator.stillUnsubscribed) {
                var destination = this.destination;
                destination.add(iterator.subscribe(iterator, i));
            }
            else {
                this.active--;
            }
        }
    };
    ZipSubscriber.prototype.notifyInactive = function () {
        this.active--;
        if (this.active === 0) {
            this.destination.complete();
        }
    };
    ZipSubscriber.prototype.checkIterators = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        var destination = this.destination;
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {
                return;
            }
        }
        var shouldComplete = false;
        var args = [];
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            var result = iterator.next();
            if (iterator.hasCompleted()) {
                shouldComplete = true;
            }
            if (result.done) {
                destination.complete();
                return;
            }
            args.push(result.value);
        }
        if (this.resultSelector) {
            this._tryresultSelector(args);
        }
        else {
            destination.next(args);
        }
        if (shouldComplete) {
            destination.complete();
        }
    };
    ZipSubscriber.prototype._tryresultSelector = function (args) {
        var result;
        try {
            result = this.resultSelector.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return ZipSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_3__["Subscriber"]));

var StaticIterator = /*@__PURE__*/ (function () {
    function StaticIterator(iterator) {
        this.iterator = iterator;
        this.nextResult = iterator.next();
    }
    StaticIterator.prototype.hasValue = function () {
        return true;
    };
    StaticIterator.prototype.next = function () {
        var result = this.nextResult;
        this.nextResult = this.iterator.next();
        return result;
    };
    StaticIterator.prototype.hasCompleted = function () {
        var nextResult = this.nextResult;
        return nextResult && nextResult.done;
    };
    return StaticIterator;
}());
var StaticArrayIterator = /*@__PURE__*/ (function () {
    function StaticArrayIterator(array) {
        this.array = array;
        this.index = 0;
        this.length = 0;
        this.length = array.length;
    }
    StaticArrayIterator.prototype[_internal_symbol_iterator__WEBPACK_IMPORTED_MODULE_6__["iterator"]] = function () {
        return this;
    };
    StaticArrayIterator.prototype.next = function (value) {
        var i = this.index++;
        var array = this.array;
        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };
    };
    StaticArrayIterator.prototype.hasValue = function () {
        return this.array.length > this.index;
    };
    StaticArrayIterator.prototype.hasCompleted = function () {
        return this.array.length === this.index;
    };
    return StaticArrayIterator;
}());
var ZipBufferIterator = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](ZipBufferIterator, _super);
    function ZipBufferIterator(destination, parent, observable) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        _this.observable = observable;
        _this.stillUnsubscribed = true;
        _this.buffer = [];
        _this.isComplete = false;
        return _this;
    }
    ZipBufferIterator.prototype[_internal_symbol_iterator__WEBPACK_IMPORTED_MODULE_6__["iterator"]] = function () {
        return this;
    };
    ZipBufferIterator.prototype.next = function () {
        var buffer = this.buffer;
        if (buffer.length === 0 && this.isComplete) {
            return { value: null, done: true };
        }
        else {
            return { value: buffer.shift(), done: false };
        }
    };
    ZipBufferIterator.prototype.hasValue = function () {
        return this.buffer.length > 0;
    };
    ZipBufferIterator.prototype.hasCompleted = function () {
        return this.buffer.length === 0 && this.isComplete;
    };
    ZipBufferIterator.prototype.notifyComplete = function () {
        if (this.buffer.length > 0) {
            this.isComplete = true;
            this.parent.notifyInactive();
        }
        else {
            this.destination.complete();
        }
    };
    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.buffer.push(innerValue);
        this.parent.checkIterators();
    };
    ZipBufferIterator.prototype.subscribe = function (value, index) {
        return Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_5__["subscribeToResult"])(this, this.observable, this, index);
    };
    return ZipBufferIterator;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_4__["OuterSubscriber"]));
//# sourceMappingURL=zip.js.map


/***/ }),
/* 332 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_operators_audit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(333);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "audit", function() { return _internal_operators_audit__WEBPACK_IMPORTED_MODULE_0__["audit"]; });

/* harmony import */ var _internal_operators_auditTime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(334);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "auditTime", function() { return _internal_operators_auditTime__WEBPACK_IMPORTED_MODULE_1__["auditTime"]; });

/* harmony import */ var _internal_operators_buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(335);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "buffer", function() { return _internal_operators_buffer__WEBPACK_IMPORTED_MODULE_2__["buffer"]; });

/* harmony import */ var _internal_operators_bufferCount__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(336);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bufferCount", function() { return _internal_operators_bufferCount__WEBPACK_IMPORTED_MODULE_3__["bufferCount"]; });

/* harmony import */ var _internal_operators_bufferTime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(337);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bufferTime", function() { return _internal_operators_bufferTime__WEBPACK_IMPORTED_MODULE_4__["bufferTime"]; });

/* harmony import */ var _internal_operators_bufferToggle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(338);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bufferToggle", function() { return _internal_operators_bufferToggle__WEBPACK_IMPORTED_MODULE_5__["bufferToggle"]; });

/* harmony import */ var _internal_operators_bufferWhen__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(339);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bufferWhen", function() { return _internal_operators_bufferWhen__WEBPACK_IMPORTED_MODULE_6__["bufferWhen"]; });

/* harmony import */ var _internal_operators_catchError__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(340);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "catchError", function() { return _internal_operators_catchError__WEBPACK_IMPORTED_MODULE_7__["catchError"]; });

/* harmony import */ var _internal_operators_combineAll__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(341);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "combineAll", function() { return _internal_operators_combineAll__WEBPACK_IMPORTED_MODULE_8__["combineAll"]; });

/* harmony import */ var _internal_operators_combineLatest__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(342);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "combineLatest", function() { return _internal_operators_combineLatest__WEBPACK_IMPORTED_MODULE_9__["combineLatest"]; });

/* harmony import */ var _internal_operators_concat__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(343);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concat", function() { return _internal_operators_concat__WEBPACK_IMPORTED_MODULE_10__["concat"]; });

/* harmony import */ var _internal_operators_concatAll__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(302);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concatAll", function() { return _internal_operators_concatAll__WEBPACK_IMPORTED_MODULE_11__["concatAll"]; });

/* harmony import */ var _internal_operators_concatMap__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(344);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concatMap", function() { return _internal_operators_concatMap__WEBPACK_IMPORTED_MODULE_12__["concatMap"]; });

/* harmony import */ var _internal_operators_concatMapTo__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(345);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concatMapTo", function() { return _internal_operators_concatMapTo__WEBPACK_IMPORTED_MODULE_13__["concatMapTo"]; });

/* harmony import */ var _internal_operators_count__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(346);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "count", function() { return _internal_operators_count__WEBPACK_IMPORTED_MODULE_14__["count"]; });

/* harmony import */ var _internal_operators_debounce__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(347);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "debounce", function() { return _internal_operators_debounce__WEBPACK_IMPORTED_MODULE_15__["debounce"]; });

/* harmony import */ var _internal_operators_debounceTime__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(348);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "debounceTime", function() { return _internal_operators_debounceTime__WEBPACK_IMPORTED_MODULE_16__["debounceTime"]; });

/* harmony import */ var _internal_operators_defaultIfEmpty__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(349);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "defaultIfEmpty", function() { return _internal_operators_defaultIfEmpty__WEBPACK_IMPORTED_MODULE_17__["defaultIfEmpty"]; });

/* harmony import */ var _internal_operators_delay__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(350);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "delay", function() { return _internal_operators_delay__WEBPACK_IMPORTED_MODULE_18__["delay"]; });

/* harmony import */ var _internal_operators_delayWhen__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(352);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "delayWhen", function() { return _internal_operators_delayWhen__WEBPACK_IMPORTED_MODULE_19__["delayWhen"]; });

/* harmony import */ var _internal_operators_dematerialize__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(353);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dematerialize", function() { return _internal_operators_dematerialize__WEBPACK_IMPORTED_MODULE_20__["dematerialize"]; });

/* harmony import */ var _internal_operators_distinct__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(354);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "distinct", function() { return _internal_operators_distinct__WEBPACK_IMPORTED_MODULE_21__["distinct"]; });

/* harmony import */ var _internal_operators_distinctUntilChanged__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(355);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "distinctUntilChanged", function() { return _internal_operators_distinctUntilChanged__WEBPACK_IMPORTED_MODULE_22__["distinctUntilChanged"]; });

/* harmony import */ var _internal_operators_distinctUntilKeyChanged__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(356);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "distinctUntilKeyChanged", function() { return _internal_operators_distinctUntilKeyChanged__WEBPACK_IMPORTED_MODULE_23__["distinctUntilKeyChanged"]; });

/* harmony import */ var _internal_operators_elementAt__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(357);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "elementAt", function() { return _internal_operators_elementAt__WEBPACK_IMPORTED_MODULE_24__["elementAt"]; });

/* harmony import */ var _internal_operators_endWith__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(360);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "endWith", function() { return _internal_operators_endWith__WEBPACK_IMPORTED_MODULE_25__["endWith"]; });

/* harmony import */ var _internal_operators_every__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(361);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "every", function() { return _internal_operators_every__WEBPACK_IMPORTED_MODULE_26__["every"]; });

/* harmony import */ var _internal_operators_exhaust__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(362);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "exhaust", function() { return _internal_operators_exhaust__WEBPACK_IMPORTED_MODULE_27__["exhaust"]; });

/* harmony import */ var _internal_operators_exhaustMap__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(363);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "exhaustMap", function() { return _internal_operators_exhaustMap__WEBPACK_IMPORTED_MODULE_28__["exhaustMap"]; });

/* harmony import */ var _internal_operators_expand__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(364);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "expand", function() { return _internal_operators_expand__WEBPACK_IMPORTED_MODULE_29__["expand"]; });

/* harmony import */ var _internal_operators_filter__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(326);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "filter", function() { return _internal_operators_filter__WEBPACK_IMPORTED_MODULE_30__["filter"]; });

/* harmony import */ var _internal_operators_finalize__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(365);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "finalize", function() { return _internal_operators_finalize__WEBPACK_IMPORTED_MODULE_31__["finalize"]; });

/* harmony import */ var _internal_operators_find__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(366);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "find", function() { return _internal_operators_find__WEBPACK_IMPORTED_MODULE_32__["find"]; });

/* harmony import */ var _internal_operators_findIndex__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(367);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "findIndex", function() { return _internal_operators_findIndex__WEBPACK_IMPORTED_MODULE_33__["findIndex"]; });

/* harmony import */ var _internal_operators_first__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(368);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "first", function() { return _internal_operators_first__WEBPACK_IMPORTED_MODULE_34__["first"]; });

/* harmony import */ var _internal_operators_groupBy__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(253);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "groupBy", function() { return _internal_operators_groupBy__WEBPACK_IMPORTED_MODULE_35__["groupBy"]; });

/* harmony import */ var _internal_operators_ignoreElements__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(369);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ignoreElements", function() { return _internal_operators_ignoreElements__WEBPACK_IMPORTED_MODULE_36__["ignoreElements"]; });

/* harmony import */ var _internal_operators_isEmpty__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(370);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isEmpty", function() { return _internal_operators_isEmpty__WEBPACK_IMPORTED_MODULE_37__["isEmpty"]; });

/* harmony import */ var _internal_operators_last__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(371);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "last", function() { return _internal_operators_last__WEBPACK_IMPORTED_MODULE_38__["last"]; });

/* harmony import */ var _internal_operators_map__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(288);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "map", function() { return _internal_operators_map__WEBPACK_IMPORTED_MODULE_39__["map"]; });

/* harmony import */ var _internal_operators_mapTo__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(373);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mapTo", function() { return _internal_operators_mapTo__WEBPACK_IMPORTED_MODULE_40__["mapTo"]; });

/* harmony import */ var _internal_operators_materialize__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(374);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "materialize", function() { return _internal_operators_materialize__WEBPACK_IMPORTED_MODULE_41__["materialize"]; });

/* harmony import */ var _internal_operators_max__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(375);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "max", function() { return _internal_operators_max__WEBPACK_IMPORTED_MODULE_42__["max"]; });

/* harmony import */ var _internal_operators_merge__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(378);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return _internal_operators_merge__WEBPACK_IMPORTED_MODULE_43__["merge"]; });

/* harmony import */ var _internal_operators_mergeAll__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(303);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mergeAll", function() { return _internal_operators_mergeAll__WEBPACK_IMPORTED_MODULE_44__["mergeAll"]; });

/* harmony import */ var _internal_operators_mergeMap__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(304);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mergeMap", function() { return _internal_operators_mergeMap__WEBPACK_IMPORTED_MODULE_45__["mergeMap"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "flatMap", function() { return _internal_operators_mergeMap__WEBPACK_IMPORTED_MODULE_45__["mergeMap"]; });

/* harmony import */ var _internal_operators_mergeMapTo__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(379);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mergeMapTo", function() { return _internal_operators_mergeMapTo__WEBPACK_IMPORTED_MODULE_46__["mergeMapTo"]; });

/* harmony import */ var _internal_operators_mergeScan__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(380);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mergeScan", function() { return _internal_operators_mergeScan__WEBPACK_IMPORTED_MODULE_47__["mergeScan"]; });

/* harmony import */ var _internal_operators_min__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(381);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "min", function() { return _internal_operators_min__WEBPACK_IMPORTED_MODULE_48__["min"]; });

/* harmony import */ var _internal_operators_multicast__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(382);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "multicast", function() { return _internal_operators_multicast__WEBPACK_IMPORTED_MODULE_49__["multicast"]; });

/* harmony import */ var _internal_operators_observeOn__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(263);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "observeOn", function() { return _internal_operators_observeOn__WEBPACK_IMPORTED_MODULE_50__["observeOn"]; });

/* harmony import */ var _internal_operators_onErrorResumeNext__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(383);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "onErrorResumeNext", function() { return _internal_operators_onErrorResumeNext__WEBPACK_IMPORTED_MODULE_51__["onErrorResumeNext"]; });

/* harmony import */ var _internal_operators_pairwise__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(384);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pairwise", function() { return _internal_operators_pairwise__WEBPACK_IMPORTED_MODULE_52__["pairwise"]; });

/* harmony import */ var _internal_operators_partition__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(385);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "partition", function() { return _internal_operators_partition__WEBPACK_IMPORTED_MODULE_53__["partition"]; });

/* harmony import */ var _internal_operators_pluck__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(386);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pluck", function() { return _internal_operators_pluck__WEBPACK_IMPORTED_MODULE_54__["pluck"]; });

/* harmony import */ var _internal_operators_publish__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(387);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "publish", function() { return _internal_operators_publish__WEBPACK_IMPORTED_MODULE_55__["publish"]; });

/* harmony import */ var _internal_operators_publishBehavior__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(388);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "publishBehavior", function() { return _internal_operators_publishBehavior__WEBPACK_IMPORTED_MODULE_56__["publishBehavior"]; });

/* harmony import */ var _internal_operators_publishLast__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(389);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "publishLast", function() { return _internal_operators_publishLast__WEBPACK_IMPORTED_MODULE_57__["publishLast"]; });

/* harmony import */ var _internal_operators_publishReplay__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(390);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "publishReplay", function() { return _internal_operators_publishReplay__WEBPACK_IMPORTED_MODULE_58__["publishReplay"]; });

/* harmony import */ var _internal_operators_race__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(391);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "race", function() { return _internal_operators_race__WEBPACK_IMPORTED_MODULE_59__["race"]; });

/* harmony import */ var _internal_operators_reduce__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(376);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reduce", function() { return _internal_operators_reduce__WEBPACK_IMPORTED_MODULE_60__["reduce"]; });

/* harmony import */ var _internal_operators_repeat__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(392);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "repeat", function() { return _internal_operators_repeat__WEBPACK_IMPORTED_MODULE_61__["repeat"]; });

/* harmony import */ var _internal_operators_repeatWhen__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(393);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "repeatWhen", function() { return _internal_operators_repeatWhen__WEBPACK_IMPORTED_MODULE_62__["repeatWhen"]; });

/* harmony import */ var _internal_operators_retry__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(394);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "retry", function() { return _internal_operators_retry__WEBPACK_IMPORTED_MODULE_63__["retry"]; });

/* harmony import */ var _internal_operators_retryWhen__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(395);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "retryWhen", function() { return _internal_operators_retryWhen__WEBPACK_IMPORTED_MODULE_64__["retryWhen"]; });

/* harmony import */ var _internal_operators_refCount__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(252);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "refCount", function() { return _internal_operators_refCount__WEBPACK_IMPORTED_MODULE_65__["refCount"]; });

/* harmony import */ var _internal_operators_sample__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(396);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sample", function() { return _internal_operators_sample__WEBPACK_IMPORTED_MODULE_66__["sample"]; });

/* harmony import */ var _internal_operators_sampleTime__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(397);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sampleTime", function() { return _internal_operators_sampleTime__WEBPACK_IMPORTED_MODULE_67__["sampleTime"]; });

/* harmony import */ var _internal_operators_scan__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(377);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scan", function() { return _internal_operators_scan__WEBPACK_IMPORTED_MODULE_68__["scan"]; });

/* harmony import */ var _internal_operators_sequenceEqual__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(398);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sequenceEqual", function() { return _internal_operators_sequenceEqual__WEBPACK_IMPORTED_MODULE_69__["sequenceEqual"]; });

/* harmony import */ var _internal_operators_share__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(399);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "share", function() { return _internal_operators_share__WEBPACK_IMPORTED_MODULE_70__["share"]; });

/* harmony import */ var _internal_operators_shareReplay__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(400);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "shareReplay", function() { return _internal_operators_shareReplay__WEBPACK_IMPORTED_MODULE_71__["shareReplay"]; });

/* harmony import */ var _internal_operators_single__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(401);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "single", function() { return _internal_operators_single__WEBPACK_IMPORTED_MODULE_72__["single"]; });

/* harmony import */ var _internal_operators_skip__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(402);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "skip", function() { return _internal_operators_skip__WEBPACK_IMPORTED_MODULE_73__["skip"]; });

/* harmony import */ var _internal_operators_skipLast__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(403);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "skipLast", function() { return _internal_operators_skipLast__WEBPACK_IMPORTED_MODULE_74__["skipLast"]; });

/* harmony import */ var _internal_operators_skipUntil__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(404);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "skipUntil", function() { return _internal_operators_skipUntil__WEBPACK_IMPORTED_MODULE_75__["skipUntil"]; });

/* harmony import */ var _internal_operators_skipWhile__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(405);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "skipWhile", function() { return _internal_operators_skipWhile__WEBPACK_IMPORTED_MODULE_76__["skipWhile"]; });

/* harmony import */ var _internal_operators_startWith__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(406);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "startWith", function() { return _internal_operators_startWith__WEBPACK_IMPORTED_MODULE_77__["startWith"]; });

/* harmony import */ var _internal_operators_subscribeOn__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(407);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "subscribeOn", function() { return _internal_operators_subscribeOn__WEBPACK_IMPORTED_MODULE_78__["subscribeOn"]; });

/* harmony import */ var _internal_operators_switchAll__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(409);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "switchAll", function() { return _internal_operators_switchAll__WEBPACK_IMPORTED_MODULE_79__["switchAll"]; });

/* harmony import */ var _internal_operators_switchMap__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(410);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "switchMap", function() { return _internal_operators_switchMap__WEBPACK_IMPORTED_MODULE_80__["switchMap"]; });

/* harmony import */ var _internal_operators_switchMapTo__WEBPACK_IMPORTED_MODULE_81__ = __webpack_require__(411);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "switchMapTo", function() { return _internal_operators_switchMapTo__WEBPACK_IMPORTED_MODULE_81__["switchMapTo"]; });

/* harmony import */ var _internal_operators_take__WEBPACK_IMPORTED_MODULE_82__ = __webpack_require__(359);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "take", function() { return _internal_operators_take__WEBPACK_IMPORTED_MODULE_82__["take"]; });

/* harmony import */ var _internal_operators_takeLast__WEBPACK_IMPORTED_MODULE_83__ = __webpack_require__(372);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "takeLast", function() { return _internal_operators_takeLast__WEBPACK_IMPORTED_MODULE_83__["takeLast"]; });

/* harmony import */ var _internal_operators_takeUntil__WEBPACK_IMPORTED_MODULE_84__ = __webpack_require__(412);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "takeUntil", function() { return _internal_operators_takeUntil__WEBPACK_IMPORTED_MODULE_84__["takeUntil"]; });

/* harmony import */ var _internal_operators_takeWhile__WEBPACK_IMPORTED_MODULE_85__ = __webpack_require__(413);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "takeWhile", function() { return _internal_operators_takeWhile__WEBPACK_IMPORTED_MODULE_85__["takeWhile"]; });

/* harmony import */ var _internal_operators_tap__WEBPACK_IMPORTED_MODULE_86__ = __webpack_require__(414);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tap", function() { return _internal_operators_tap__WEBPACK_IMPORTED_MODULE_86__["tap"]; });

/* harmony import */ var _internal_operators_throttle__WEBPACK_IMPORTED_MODULE_87__ = __webpack_require__(415);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "throttle", function() { return _internal_operators_throttle__WEBPACK_IMPORTED_MODULE_87__["throttle"]; });

/* harmony import */ var _internal_operators_throttleTime__WEBPACK_IMPORTED_MODULE_88__ = __webpack_require__(416);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "throttleTime", function() { return _internal_operators_throttleTime__WEBPACK_IMPORTED_MODULE_88__["throttleTime"]; });

/* harmony import */ var _internal_operators_throwIfEmpty__WEBPACK_IMPORTED_MODULE_89__ = __webpack_require__(358);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "throwIfEmpty", function() { return _internal_operators_throwIfEmpty__WEBPACK_IMPORTED_MODULE_89__["throwIfEmpty"]; });

/* harmony import */ var _internal_operators_timeInterval__WEBPACK_IMPORTED_MODULE_90__ = __webpack_require__(417);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeInterval", function() { return _internal_operators_timeInterval__WEBPACK_IMPORTED_MODULE_90__["timeInterval"]; });

/* harmony import */ var _internal_operators_timeout__WEBPACK_IMPORTED_MODULE_91__ = __webpack_require__(418);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeout", function() { return _internal_operators_timeout__WEBPACK_IMPORTED_MODULE_91__["timeout"]; });

/* harmony import */ var _internal_operators_timeoutWith__WEBPACK_IMPORTED_MODULE_92__ = __webpack_require__(419);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeoutWith", function() { return _internal_operators_timeoutWith__WEBPACK_IMPORTED_MODULE_92__["timeoutWith"]; });

/* harmony import */ var _internal_operators_timestamp__WEBPACK_IMPORTED_MODULE_93__ = __webpack_require__(420);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timestamp", function() { return _internal_operators_timestamp__WEBPACK_IMPORTED_MODULE_93__["timestamp"]; });

/* harmony import */ var _internal_operators_toArray__WEBPACK_IMPORTED_MODULE_94__ = __webpack_require__(421);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toArray", function() { return _internal_operators_toArray__WEBPACK_IMPORTED_MODULE_94__["toArray"]; });

/* harmony import */ var _internal_operators_window__WEBPACK_IMPORTED_MODULE_95__ = __webpack_require__(422);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "window", function() { return _internal_operators_window__WEBPACK_IMPORTED_MODULE_95__["window"]; });

/* harmony import */ var _internal_operators_windowCount__WEBPACK_IMPORTED_MODULE_96__ = __webpack_require__(423);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "windowCount", function() { return _internal_operators_windowCount__WEBPACK_IMPORTED_MODULE_96__["windowCount"]; });

/* harmony import */ var _internal_operators_windowTime__WEBPACK_IMPORTED_MODULE_97__ = __webpack_require__(424);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "windowTime", function() { return _internal_operators_windowTime__WEBPACK_IMPORTED_MODULE_97__["windowTime"]; });

/* harmony import */ var _internal_operators_windowToggle__WEBPACK_IMPORTED_MODULE_98__ = __webpack_require__(425);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "windowToggle", function() { return _internal_operators_windowToggle__WEBPACK_IMPORTED_MODULE_98__["windowToggle"]; });

/* harmony import */ var _internal_operators_windowWhen__WEBPACK_IMPORTED_MODULE_99__ = __webpack_require__(426);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "windowWhen", function() { return _internal_operators_windowWhen__WEBPACK_IMPORTED_MODULE_99__["windowWhen"]; });

/* harmony import */ var _internal_operators_withLatestFrom__WEBPACK_IMPORTED_MODULE_100__ = __webpack_require__(427);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "withLatestFrom", function() { return _internal_operators_withLatestFrom__WEBPACK_IMPORTED_MODULE_100__["withLatestFrom"]; });

/* harmony import */ var _internal_operators_zip__WEBPACK_IMPORTED_MODULE_101__ = __webpack_require__(428);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zip", function() { return _internal_operators_zip__WEBPACK_IMPORTED_MODULE_101__["zip"]; });

/* harmony import */ var _internal_operators_zipAll__WEBPACK_IMPORTED_MODULE_102__ = __webpack_require__(429);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zipAll", function() { return _internal_operators_zipAll__WEBPACK_IMPORTED_MODULE_102__["zipAll"]; });

/** PURE_IMPORTS_START  PURE_IMPORTS_END */








































































































//# sourceMappingURL=index.js.map


/***/ }),
/* 333 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "audit", function() { return audit; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(291);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(292);
/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */



function audit(durationSelector) {
    return function auditOperatorFunction(source) {
        return source.lift(new AuditOperator(durationSelector));
    };
}
var AuditOperator = /*@__PURE__*/ (function () {
    function AuditOperator(durationSelector) {
        this.durationSelector = durationSelector;
    }
    AuditOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
    };
    return AuditOperator;
}());
var AuditSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](AuditSubscriber, _super);
    function AuditSubscriber(destination, durationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.durationSelector = durationSelector;
        _this.hasValue = false;
        return _this;
    }
    AuditSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
        if (!this.throttled) {
            var duration = void 0;
            try {
                var durationSelector = this.durationSelector;
                duration = durationSelector(value);
            }
            catch (err) {
                return this.destination.error(err);
            }
            var innerSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(this, duration);
            if (!innerSubscription || innerSubscription.closed) {
                this.clearThrottle();
            }
            else {
                this.add(this.throttled = innerSubscription);
            }
        }
    };
    AuditSubscriber.prototype.clearThrottle = function () {
        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;
        if (throttled) {
            this.remove(throttled);
            this.throttled = null;
            throttled.unsubscribe();
        }
        if (hasValue) {
            this.value = null;
            this.hasValue = false;
            this.destination.next(value);
        }
    };
    AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
        this.clearThrottle();
    };
    AuditSubscriber.prototype.notifyComplete = function () {
        this.clearThrottle();
    };
    return AuditSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"]));
//# sourceMappingURL=audit.js.map


/***/ }),
/* 334 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "auditTime", function() { return auditTime; });
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(277);
/* harmony import */ var _audit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(333);
/* harmony import */ var _observable_timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(329);
/** PURE_IMPORTS_START _scheduler_async,_audit,_observable_timer PURE_IMPORTS_END */



function auditTime(duration, scheduler) {
    if (scheduler === void 0) {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_0__["async"];
    }
    return Object(_audit__WEBPACK_IMPORTED_MODULE_1__["audit"])(function () { return Object(_observable_timer__WEBPACK_IMPORTED_MODULE_2__["timer"])(duration, scheduler); });
}
//# sourceMappingURL=auditTime.js.map


/***/ }),
/* 335 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buffer", function() { return buffer; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(291);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(292);
/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */



function buffer(closingNotifier) {
    return function bufferOperatorFunction(source) {
        return source.lift(new BufferOperator(closingNotifier));
    };
}
var BufferOperator = /*@__PURE__*/ (function () {
    function BufferOperator(closingNotifier) {
        this.closingNotifier = closingNotifier;
    }
    BufferOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
    };
    return BufferOperator;
}());
var BufferSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](BufferSubscriber, _super);
    function BufferSubscriber(destination, closingNotifier) {
        var _this = _super.call(this, destination) || this;
        _this.buffer = [];
        _this.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(_this, closingNotifier));
        return _this;
    }
    BufferSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var buffer = this.buffer;
        this.buffer = [];
        this.destination.next(buffer);
    };
    return BufferSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"]));
//# sourceMappingURL=buffer.js.map


/***/ }),
/* 336 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bufferCount", function() { return bufferCount; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(233);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function bufferCount(bufferSize, startBufferEvery) {
    if (startBufferEvery === void 0) {
        startBufferEvery = null;
    }
    return function bufferCountOperatorFunction(source) {
        return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));
    };
}
var BufferCountOperator = /*@__PURE__*/ (function () {
    function BufferCountOperator(bufferSize, startBufferEvery) {
        this.bufferSize = bufferSize;
        this.startBufferEvery = startBufferEvery;
        if (!startBufferEvery || bufferSize === startBufferEvery) {
            this.subscriberClass = BufferCountSubscriber;
        }
        else {
            this.subscriberClass = BufferSkipCountSubscriber;
        }
    }
    BufferCountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));
    };
    return BufferCountOperator;
}());
var BufferCountSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](BufferCountSubscriber, _super);
    function BufferCountSubscriber(destination, bufferSize) {
        var _this = _super.call(this, destination) || this;
        _this.bufferSize = bufferSize;
        _this.buffer = [];
        return _this;
    }
    BufferCountSubscriber.prototype._next = function (value) {
        var buffer = this.buffer;
        buffer.push(value);
        if (buffer.length == this.bufferSize) {
            this.destination.next(buffer);
            this.buffer = [];
        }
    };
    BufferCountSubscriber.prototype._complete = function () {
        var buffer = this.buffer;
        if (buffer.length > 0) {
            this.destination.next(buffer);
        }
        _super.prototype._complete.call(this);
    };
    return BufferCountSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
var BufferSkipCountSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](BufferSkipCountSubscriber, _super);
    function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {
        var _this = _super.call(this, destination) || this;
        _this.bufferSize = bufferSize;
        _this.startBufferEvery = startBufferEvery;
        _this.buffers = [];
        _this.count = 0;
        return _this;
    }
    BufferSkipCountSubscriber.prototype._next = function (value) {
        var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers, count = _a.count;
        this.count++;
        if (count % startBufferEvery === 0) {
            buffers.push([]);
        }
        for (var i = buffers.length; i--;) {
            var buffer = buffers[i];
            buffer.push(value);
            if (buffer.length === bufferSize) {
                buffers.splice(i, 1);
                this.destination.next(buffer);
            }
        }
    };
    BufferSkipCountSubscriber.prototype._complete = function () {
        var _a = this, buffers = _a.buffers, destination = _a.destination;
        while (buffers.length > 0) {
            var buffer = buffers.shift();
            if (buffer.length > 0) {
                destination.next(buffer);
            }
        }
        _super.prototype._complete.call(this);
    };
    return BufferSkipCountSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=bufferCount.js.map


/***/ }),
/* 337 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bufferTime", function() { return bufferTime; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(277);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(233);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(267);
/** PURE_IMPORTS_START tslib,_scheduler_async,_Subscriber,_util_isScheduler PURE_IMPORTS_END */




function bufferTime(bufferTimeSpan) {
    var length = arguments.length;
    var scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__["async"];
    if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_3__["isScheduler"])(arguments[arguments.length - 1])) {
        scheduler = arguments[arguments.length - 1];
        length--;
    }
    var bufferCreationInterval = null;
    if (length >= 2) {
        bufferCreationInterval = arguments[1];
    }
    var maxBufferSize = Number.POSITIVE_INFINITY;
    if (length >= 3) {
        maxBufferSize = arguments[2];
    }
    return function bufferTimeOperatorFunction(source) {
        return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));
    };
}
var BufferTimeOperator = /*@__PURE__*/ (function () {
    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        this.bufferTimeSpan = bufferTimeSpan;
        this.bufferCreationInterval = bufferCreationInterval;
        this.maxBufferSize = maxBufferSize;
        this.scheduler = scheduler;
    }
    BufferTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
    };
    return BufferTimeOperator;
}());
var Context = /*@__PURE__*/ (function () {
    function Context() {
        this.buffer = [];
    }
    return Context;
}());
var BufferTimeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](BufferTimeSubscriber, _super);
    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.bufferTimeSpan = bufferTimeSpan;
        _this.bufferCreationInterval = bufferCreationInterval;
        _this.maxBufferSize = maxBufferSize;
        _this.scheduler = scheduler;
        _this.contexts = [];
        var context = _this.openContext();
        _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
        if (_this.timespanOnly) {
            var timeSpanOnlyState = { subscriber: _this, context: context, bufferTimeSpan: bufferTimeSpan };
            _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
        else {
            var closeState = { subscriber: _this, context: context };
            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: _this, scheduler: scheduler };
            _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
            _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
        }
        return _this;
    }
    BufferTimeSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        var len = contexts.length;
        var filledBufferContext;
        for (var i = 0; i < len; i++) {
            var context_1 = contexts[i];
            var buffer = context_1.buffer;
            buffer.push(value);
            if (buffer.length == this.maxBufferSize) {
                filledBufferContext = context_1;
            }
        }
        if (filledBufferContext) {
            this.onBufferFull(filledBufferContext);
        }
    };
    BufferTimeSubscriber.prototype._error = function (err) {
        this.contexts.length = 0;
        _super.prototype._error.call(this, err);
    };
    BufferTimeSubscriber.prototype._complete = function () {
        var _a = this, contexts = _a.contexts, destination = _a.destination;
        while (contexts.length > 0) {
            var context_2 = contexts.shift();
            destination.next(context_2.buffer);
        }
        _super.prototype._complete.call(this);
    };
    BufferTimeSubscriber.prototype._unsubscribe = function () {
        this.contexts = null;
    };
    BufferTimeSubscriber.prototype.onBufferFull = function (context) {
        this.closeContext(context);
        var closeAction = context.closeAction;
        closeAction.unsubscribe();
        this.remove(closeAction);
        if (!this.closed && this.timespanOnly) {
            context = this.openContext();
            var bufferTimeSpan = this.bufferTimeSpan;
            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };
            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
    };
    BufferTimeSubscriber.prototype.openContext = function () {
        var context = new Context();
        this.contexts.push(context);
        return context;
    };
    BufferTimeSubscriber.prototype.closeContext = function (context) {
        this.destination.next(context.buffer);
        var contexts = this.contexts;
        var spliceIndex = contexts ? contexts.indexOf(context) : -1;
        if (spliceIndex >= 0) {
            contexts.splice(contexts.indexOf(context), 1);
        }
    };
    return BufferTimeSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_2__["Subscriber"]));
function dispatchBufferTimeSpanOnly(state) {
    var subscriber = state.subscriber;
    var prevContext = state.context;
    if (prevContext) {
        subscriber.closeContext(prevContext);
    }
    if (!subscriber.closed) {
        state.context = subscriber.openContext();
        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
    }
}
function dispatchBufferCreation(state) {
    var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;
    var context = subscriber.openContext();
    var action = this;
    if (!subscriber.closed) {
        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));
        action.schedule(state, bufferCreationInterval);
    }
}
function dispatchBufferClose(arg) {
    var subscriber = arg.subscriber, context = arg.context;
    subscriber.closeContext(context);
}
//# sourceMappingURL=bufferTime.js.map


/***/ }),
/* 338 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bufferToggle", function() { return bufferToggle; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(239);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(292);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(291);
/** PURE_IMPORTS_START tslib,_Subscription,_util_subscribeToResult,_OuterSubscriber PURE_IMPORTS_END */




function bufferToggle(openings, closingSelector) {
    return function bufferToggleOperatorFunction(source) {
        return source.lift(new BufferToggleOperator(openings, closingSelector));
    };
}
var BufferToggleOperator = /*@__PURE__*/ (function () {
    function BufferToggleOperator(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
    }
    BufferToggleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
    };
    return BufferToggleOperator;
}());
var BufferToggleSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](BufferToggleSubscriber, _super);
    function BufferToggleSubscriber(destination, openings, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.openings = openings;
        _this.closingSelector = closingSelector;
        _this.contexts = [];
        _this.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(_this, openings));
        return _this;
    }
    BufferToggleSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        var len = contexts.length;
        for (var i = 0; i < len; i++) {
            contexts[i].buffer.push(value);
        }
    };
    BufferToggleSubscriber.prototype._error = function (err) {
        var contexts = this.contexts;
        while (contexts.length > 0) {
            var context_1 = contexts.shift();
            context_1.subscription.unsubscribe();
            context_1.buffer = null;
            context_1.subscription = null;
        }
        this.contexts = null;
        _super.prototype._error.call(this, err);
    };
    BufferToggleSubscriber.prototype._complete = function () {
        var contexts = this.contexts;
        while (contexts.length > 0) {
            var context_2 = contexts.shift();
            this.destination.next(context_2.buffer);
            context_2.subscription.unsubscribe();
            context_2.buffer = null;
            context_2.subscription = null;
        }
        this.contexts = null;
        _super.prototype._complete.call(this);
    };
    BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
    };
    BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {
        this.closeBuffer(innerSub.context);
    };
    BufferToggleSubscriber.prototype.openBuffer = function (value) {
        try {
            var closingSelector = this.closingSelector;
            var closingNotifier = closingSelector.call(this, value);
            if (closingNotifier) {
                this.trySubscribe(closingNotifier);
            }
        }
        catch (err) {
            this._error(err);
        }
    };
    BufferToggleSubscriber.prototype.closeBuffer = function (context) {
        var contexts = this.contexts;
        if (contexts && context) {
            var buffer = context.buffer, subscription = context.subscription;
            this.destination.next(buffer);
            contexts.splice(contexts.indexOf(context), 1);
            this.remove(subscription);
            subscription.unsubscribe();
        }
    };
    BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {
        var contexts = this.contexts;
        var buffer = [];
        var subscription = new _Subscription__WEBPACK_IMPORTED_MODULE_1__["Subscription"]();
        var context = { buffer: buffer, subscription: subscription };
        contexts.push(context);
        var innerSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(this, closingNotifier, context);
        if (!innerSubscription || innerSubscription.closed) {
            this.closeBuffer(context);
        }
        else {
            innerSubscription.context = context;
            this.add(innerSubscription);
            subscription.add(innerSubscription);
        }
    };
    return BufferToggleSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__["OuterSubscriber"]));
//# sourceMappingURL=bufferToggle.js.map


/***/ }),
/* 339 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bufferWhen", function() { return bufferWhen; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(239);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(291);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(292);
/** PURE_IMPORTS_START tslib,_Subscription,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */




function bufferWhen(closingSelector) {
    return function (source) {
        return source.lift(new BufferWhenOperator(closingSelector));
    };
}
var BufferWhenOperator = /*@__PURE__*/ (function () {
    function BufferWhenOperator(closingSelector) {
        this.closingSelector = closingSelector;
    }
    BufferWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
    };
    return BufferWhenOperator;
}());
var BufferWhenSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](BufferWhenSubscriber, _super);
    function BufferWhenSubscriber(destination, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.closingSelector = closingSelector;
        _this.subscribing = false;
        _this.openBuffer();
        return _this;
    }
    BufferWhenSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferWhenSubscriber.prototype._complete = function () {
        var buffer = this.buffer;
        if (buffer) {
            this.destination.next(buffer);
        }
        _super.prototype._complete.call(this);
    };
    BufferWhenSubscriber.prototype._unsubscribe = function () {
        this.buffer = null;
        this.subscribing = false;
    };
    BufferWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openBuffer();
    };
    BufferWhenSubscriber.prototype.notifyComplete = function () {
        if (this.subscribing) {
            this.complete();
        }
        else {
            this.openBuffer();
        }
    };
    BufferWhenSubscriber.prototype.openBuffer = function () {
        var closingSubscription = this.closingSubscription;
        if (closingSubscription) {
            this.remove(closingSubscription);
            closingSubscription.unsubscribe();
        }
        var buffer = this.buffer;
        if (this.buffer) {
            this.destination.next(buffer);
        }
        this.buffer = [];
        var closingNotifier;
        try {
            var closingSelector = this.closingSelector;
            closingNotifier = closingSelector();
        }
        catch (err) {
            return this.error(err);
        }
        closingSubscription = new _Subscription__WEBPACK_IMPORTED_MODULE_1__["Subscription"]();
        this.closingSubscription = closingSubscription;
        this.add(closingSubscription);
        this.subscribing = true;
        closingSubscription.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__["subscribeToResult"])(this, closingNotifier));
        this.subscribing = false;
    };
    return BufferWhenSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__["OuterSubscriber"]));
//# sourceMappingURL=bufferWhen.js.map


/***/ }),
/* 340 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "catchError", function() { return catchError; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(291);
/* harmony import */ var _InnerSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(293);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(292);
/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */




function catchError(selector) {
    return function catchErrorOperatorFunction(source) {
        var operator = new CatchOperator(selector);
        var caught = source.lift(operator);
        return (operator.caught = caught);
    };
}
var CatchOperator = /*@__PURE__*/ (function () {
    function CatchOperator(selector) {
        this.selector = selector;
    }
    CatchOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
    };
    return CatchOperator;
}());
var CatchSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](CatchSubscriber, _super);
    function CatchSubscriber(destination, selector, caught) {
        var _this = _super.call(this, destination) || this;
        _this.selector = selector;
        _this.caught = caught;
        return _this;
    }
    CatchSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var result = void 0;
            try {
                result = this.selector(err, this.caught);
            }
            catch (err2) {
                _super.prototype.error.call(this, err2);
                return;
            }
            this._unsubscribeAndRecycle();
            var innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_2__["InnerSubscriber"](this, undefined, undefined);
            this.add(innerSubscriber);
            Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__["subscribeToResult"])(this, result, undefined, undefined, innerSubscriber);
        }
    };
    return CatchSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"]));
//# sourceMappingURL=catchError.js.map


/***/ }),
/* 341 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "combineAll", function() { return combineAll; });
/* harmony import */ var _observable_combineLatest__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(290);
/** PURE_IMPORTS_START _observable_combineLatest PURE_IMPORTS_END */

function combineAll(project) {
    return function (source) { return source.lift(new _observable_combineLatest__WEBPACK_IMPORTED_MODULE_0__["CombineLatestOperator"](project)); };
}
//# sourceMappingURL=combineAll.js.map


/***/ }),
/* 342 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "combineLatest", function() { return combineLatest; });
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(240);
/* harmony import */ var _observable_combineLatest__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(290);
/* harmony import */ var _observable_from__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(305);
/** PURE_IMPORTS_START _util_isArray,_observable_combineLatest,_observable_from PURE_IMPORTS_END */



var none = {};
function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var project = null;
    if (typeof observables[observables.length - 1] === 'function') {
        project = observables.pop();
    }
    if (observables.length === 1 && Object(_util_isArray__WEBPACK_IMPORTED_MODULE_0__["isArray"])(observables[0])) {
        observables = observables[0].slice();
    }
    return function (source) { return source.lift.call(Object(_observable_from__WEBPACK_IMPORTED_MODULE_2__["from"])([source].concat(observables)), new _observable_combineLatest__WEBPACK_IMPORTED_MODULE_1__["CombineLatestOperator"](project)); };
}
//# sourceMappingURL=combineLatest.js.map


/***/ }),
/* 343 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concat", function() { return concat; });
/* harmony import */ var _observable_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(301);
/** PURE_IMPORTS_START _observable_concat PURE_IMPORTS_END */

function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return function (source) { return source.lift.call(_observable_concat__WEBPACK_IMPORTED_MODULE_0__["concat"].apply(void 0, [source].concat(observables))); };
}
//# sourceMappingURL=concat.js.map


/***/ }),
/* 344 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concatMap", function() { return concatMap; });
/* harmony import */ var _mergeMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(304);
/** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */

function concatMap(project, resultSelector) {
    return Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__["mergeMap"])(project, resultSelector, 1);
}
//# sourceMappingURL=concatMap.js.map


/***/ }),
/* 345 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concatMapTo", function() { return concatMapTo; });
/* harmony import */ var _concatMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(344);
/** PURE_IMPORTS_START _concatMap PURE_IMPORTS_END */

function concatMapTo(innerObservable, resultSelector) {
    return Object(_concatMap__WEBPACK_IMPORTED_MODULE_0__["concatMap"])(function () { return innerObservable; }, resultSelector);
}
//# sourceMappingURL=concatMapTo.js.map


/***/ }),
/* 346 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "count", function() { return count; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(233);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function count(predicate) {
    return function (source) { return source.lift(new CountOperator(predicate, source)); };
}
var CountOperator = /*@__PURE__*/ (function () {
    function CountOperator(predicate, source) {
        this.predicate = predicate;
        this.source = source;
    }
    CountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
    };
    return CountOperator;
}());
var CountSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](CountSubscriber, _super);
    function CountSubscriber(destination, predicate, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.count = 0;
        _this.index = 0;
        return _this;
    }
    CountSubscriber.prototype._next = function (value) {
        if (this.predicate) {
            this._tryPredicate(value);
        }
        else {
            this.count++;
        }
    };
    CountSubscriber.prototype._tryPredicate = function (value) {
        var result;
        try {
            result = this.predicate(value, this.index++, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.count++;
        }
    };
    CountSubscriber.prototype._complete = function () {
        this.destination.next(this.count);
        this.destination.complete();
    };
    return CountSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=count.js.map


/***/ }),
/* 347 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "debounce", function() { return debounce; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(291);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(292);
/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */



function debounce(durationSelector) {
    return function (source) { return source.lift(new DebounceOperator(durationSelector)); };
}
var DebounceOperator = /*@__PURE__*/ (function () {
    function DebounceOperator(durationSelector) {
        this.durationSelector = durationSelector;
    }
    DebounceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
    };
    return DebounceOperator;
}());
var DebounceSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](DebounceSubscriber, _super);
    function DebounceSubscriber(destination, durationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.durationSelector = durationSelector;
        _this.hasValue = false;
        _this.durationSubscription = null;
        return _this;
    }
    DebounceSubscriber.prototype._next = function (value) {
        try {
            var result = this.durationSelector.call(this, value);
            if (result) {
                this._tryNext(value, result);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    DebounceSubscriber.prototype._complete = function () {
        this.emitValue();
        this.destination.complete();
    };
    DebounceSubscriber.prototype._tryNext = function (value, duration) {
        var subscription = this.durationSubscription;
        this.value = value;
        this.hasValue = true;
        if (subscription) {
            subscription.unsubscribe();
            this.remove(subscription);
        }
        subscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(this, duration);
        if (subscription && !subscription.closed) {
            this.add(this.durationSubscription = subscription);
        }
    };
    DebounceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.emitValue();
    };
    DebounceSubscriber.prototype.notifyComplete = function () {
        this.emitValue();
    };
    DebounceSubscriber.prototype.emitValue = function () {
        if (this.hasValue) {
            var value = this.value;
            var subscription = this.durationSubscription;
            if (subscription) {
                this.durationSubscription = null;
                subscription.unsubscribe();
                this.remove(subscription);
            }
            this.value = null;
            this.hasValue = false;
            _super.prototype._next.call(this, value);
        }
    };
    return DebounceSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"]));
//# sourceMappingURL=debounce.js.map


/***/ }),
/* 348 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "debounceTime", function() { return debounceTime; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(233);
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(277);
/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */



function debounceTime(dueTime, scheduler) {
    if (scheduler === void 0) {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_2__["async"];
    }
    return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };
}
var DebounceTimeOperator = /*@__PURE__*/ (function () {
    function DebounceTimeOperator(dueTime, scheduler) {
        this.dueTime = dueTime;
        this.scheduler = scheduler;
    }
    DebounceTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
    };
    return DebounceTimeOperator;
}());
var DebounceTimeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](DebounceTimeSubscriber, _super);
    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.dueTime = dueTime;
        _this.scheduler = scheduler;
        _this.debouncedSubscription = null;
        _this.lastValue = null;
        _this.hasValue = false;
        return _this;
    }
    DebounceTimeSubscriber.prototype._next = function (value) {
        this.clearDebounce();
        this.lastValue = value;
        this.hasValue = true;
        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
    };
    DebounceTimeSubscriber.prototype._complete = function () {
        this.debouncedNext();
        this.destination.complete();
    };
    DebounceTimeSubscriber.prototype.debouncedNext = function () {
        this.clearDebounce();
        if (this.hasValue) {
            var lastValue = this.lastValue;
            this.lastValue = null;
            this.hasValue = false;
            this.destination.next(lastValue);
        }
    };
    DebounceTimeSubscriber.prototype.clearDebounce = function () {
        var debouncedSubscription = this.debouncedSubscription;
        if (debouncedSubscription !== null) {
            this.remove(debouncedSubscription);
            debouncedSubscription.unsubscribe();
            this.debouncedSubscription = null;
        }
    };
    return DebounceTimeSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
function dispatchNext(subscriber) {
    subscriber.debouncedNext();
}
//# sourceMappingURL=debounceTime.js.map


/***/ }),
/* 349 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultIfEmpty", function() { return defaultIfEmpty; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(233);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function defaultIfEmpty(defaultValue) {
    if (defaultValue === void 0) {
        defaultValue = null;
    }
    return function (source) { return source.lift(new DefaultIfEmptyOperator(defaultValue)); };
}
var DefaultIfEmptyOperator = /*@__PURE__*/ (function () {
    function DefaultIfEmptyOperator(defaultValue) {
        this.defaultValue = defaultValue;
    }
    DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
    };
    return DefaultIfEmptyOperator;
}());
var DefaultIfEmptySubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](DefaultIfEmptySubscriber, _super);
    function DefaultIfEmptySubscriber(destination, defaultValue) {
        var _this = _super.call(this, destination) || this;
        _this.defaultValue = defaultValue;
        _this.isEmpty = true;
        return _this;
    }
    DefaultIfEmptySubscriber.prototype._next = function (value) {
        this.isEmpty = false;
        this.destination.next(value);
    };
    DefaultIfEmptySubscriber.prototype._complete = function () {
        if (this.isEmpty) {
            this.destination.next(this.defaultValue);
        }
        this.destination.complete();
    };
    return DefaultIfEmptySubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=defaultIfEmpty.js.map


/***/ }),
/* 350 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "delay", function() { return delay; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(277);
/* harmony import */ var _util_isDate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(351);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(233);
/* harmony import */ var _Notification__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(264);
/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_Subscriber,_Notification PURE_IMPORTS_END */





function delay(delay, scheduler) {
    if (scheduler === void 0) {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__["async"];
    }
    var absoluteDelay = Object(_util_isDate__WEBPACK_IMPORTED_MODULE_2__["isDate"])(delay);
    var delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);
    return function (source) { return source.lift(new DelayOperator(delayFor, scheduler)); };
}
var DelayOperator = /*@__PURE__*/ (function () {
    function DelayOperator(delay, scheduler) {
        this.delay = delay;
        this.scheduler = scheduler;
    }
    DelayOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
    };
    return DelayOperator;
}());
var DelaySubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](DelaySubscriber, _super);
    function DelaySubscriber(destination, delay, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.delay = delay;
        _this.scheduler = scheduler;
        _this.queue = [];
        _this.active = false;
        _this.errored = false;
        return _this;
    }
    DelaySubscriber.dispatch = function (state) {
        var source = state.source;
        var queue = source.queue;
        var scheduler = state.scheduler;
        var destination = state.destination;
        while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {
            queue.shift().notification.observe(destination);
        }
        if (queue.length > 0) {
            var delay_1 = Math.max(0, queue[0].time - scheduler.now());
            this.schedule(state, delay_1);
        }
        else {
            this.unsubscribe();
            source.active = false;
        }
    };
    DelaySubscriber.prototype._schedule = function (scheduler) {
        this.active = true;
        var destination = this.destination;
        destination.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
            source: this, destination: this.destination, scheduler: scheduler
        }));
    };
    DelaySubscriber.prototype.scheduleNotification = function (notification) {
        if (this.errored === true) {
            return;
        }
        var scheduler = this.scheduler;
        var message = new DelayMessage(scheduler.now() + this.delay, notification);
        this.queue.push(message);
        if (this.active === false) {
            this._schedule(scheduler);
        }
    };
    DelaySubscriber.prototype._next = function (value) {
        this.scheduleNotification(_Notification__WEBPACK_IMPORTED_MODULE_4__["Notification"].createNext(value));
    };
    DelaySubscriber.prototype._error = function (err) {
        this.errored = true;
        this.queue = [];
        this.destination.error(err);
        this.unsubscribe();
    };
    DelaySubscriber.prototype._complete = function () {
        this.scheduleNotification(_Notification__WEBPACK_IMPORTED_MODULE_4__["Notification"].createComplete());
        this.unsubscribe();
    };
    return DelaySubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_3__["Subscriber"]));
var DelayMessage = /*@__PURE__*/ (function () {
    function DelayMessage(time, notification) {
        this.time = time;
        this.notification = notification;
    }
    return DelayMessage;
}());
//# sourceMappingURL=delay.js.map


/***/ }),
/* 351 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDate", function() { return isDate; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isDate(value) {
    return value instanceof Date && !isNaN(+value);
}
//# sourceMappingURL=isDate.js.map


/***/ }),
/* 352 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "delayWhen", function() { return delayWhen; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(233);
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(231);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(291);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(292);
/** PURE_IMPORTS_START tslib,_Subscriber,_Observable,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */





function delayWhen(delayDurationSelector, subscriptionDelay) {
    if (subscriptionDelay) {
        return function (source) {
            return new SubscriptionDelayObservable(source, subscriptionDelay)
                .lift(new DelayWhenOperator(delayDurationSelector));
        };
    }
    return function (source) { return source.lift(new DelayWhenOperator(delayDurationSelector)); };
}
var DelayWhenOperator = /*@__PURE__*/ (function () {
    function DelayWhenOperator(delayDurationSelector) {
        this.delayDurationSelector = delayDurationSelector;
    }
    DelayWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
    };
    return DelayWhenOperator;
}());
var DelayWhenSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](DelayWhenSubscriber, _super);
    function DelayWhenSubscriber(destination, delayDurationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.delayDurationSelector = delayDurationSelector;
        _this.completed = false;
        _this.delayNotifierSubscriptions = [];
        _this.index = 0;
        return _this;
    }
    DelayWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(outerValue);
        this.removeSubscription(innerSub);
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {
        var value = this.removeSubscription(innerSub);
        if (value) {
            this.destination.next(value);
        }
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype._next = function (value) {
        var index = this.index++;
        try {
            var delayNotifier = this.delayDurationSelector(value, index);
            if (delayNotifier) {
                this.tryDelay(delayNotifier, value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    DelayWhenSubscriber.prototype._complete = function () {
        this.completed = true;
        this.tryComplete();
        this.unsubscribe();
    };
    DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {
        subscription.unsubscribe();
        var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
        if (subscriptionIdx !== -1) {
            this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
        }
        return subscription.outerValue;
    };
    DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {
        var notifierSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__["subscribeToResult"])(this, delayNotifier, value);
        if (notifierSubscription && !notifierSubscription.closed) {
            var destination = this.destination;
            destination.add(notifierSubscription);
            this.delayNotifierSubscriptions.push(notifierSubscription);
        }
    };
    DelayWhenSubscriber.prototype.tryComplete = function () {
        if (this.completed && this.delayNotifierSubscriptions.length === 0) {
            this.destination.complete();
        }
    };
    return DelayWhenSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__["OuterSubscriber"]));
var SubscriptionDelayObservable = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](SubscriptionDelayObservable, _super);
    function SubscriptionDelayObservable(source, subscriptionDelay) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subscriptionDelay = subscriptionDelay;
        return _this;
    }
    SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {
        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
    };
    return SubscriptionDelayObservable;
}(_Observable__WEBPACK_IMPORTED_MODULE_2__["Observable"]));
var SubscriptionDelaySubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](SubscriptionDelaySubscriber, _super);
    function SubscriptionDelaySubscriber(parent, source) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.source = source;
        _this.sourceSubscribed = false;
        return _this;
    }
    SubscriptionDelaySubscriber.prototype._next = function (unused) {
        this.subscribeToSource();
    };
    SubscriptionDelaySubscriber.prototype._error = function (err) {
        this.unsubscribe();
        this.parent.error(err);
    };
    SubscriptionDelaySubscriber.prototype._complete = function () {
        this.unsubscribe();
        this.subscribeToSource();
    };
    SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {
        if (!this.sourceSubscribed) {
            this.sourceSubscribed = true;
            this.unsubscribe();
            this.source.subscribe(this.parent);
        }
    };
    return SubscriptionDelaySubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=delayWhen.js.map


/***/ }),
/* 353 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dematerialize", function() { return dematerialize; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(233);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function dematerialize() {
    return function dematerializeOperatorFunction(source) {
        return source.lift(new DeMaterializeOperator());
    };
}
var DeMaterializeOperator = /*@__PURE__*/ (function () {
    function DeMaterializeOperator() {
    }
    DeMaterializeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DeMaterializeSubscriber(subscriber));
    };
    return DeMaterializeOperator;
}());
var DeMaterializeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](DeMaterializeSubscriber, _super);
    function DeMaterializeSubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    DeMaterializeSubscriber.prototype._next = function (value) {
        value.observe(this.destination);
    };
    return DeMaterializeSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=dematerialize.js.map


/***/ }),
/* 354 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distinct", function() { return distinct; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DistinctSubscriber", function() { return DistinctSubscriber; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(291);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(292);
/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */



function distinct(keySelector, flushes) {
    return function (source) { return source.lift(new DistinctOperator(keySelector, flushes)); };
}
var DistinctOperator = /*@__PURE__*/ (function () {
    function DistinctOperator(keySelector, flushes) {
        this.keySelector = keySelector;
        this.flushes = flushes;
    }
    DistinctOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
    };
    return DistinctOperator;
}());
var DistinctSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](DistinctSubscriber, _super);
    function DistinctSubscriber(destination, keySelector, flushes) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.values = new Set();
        if (flushes) {
            _this.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(_this, flushes));
        }
        return _this;
    }
    DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values.clear();
    };
    DistinctSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    DistinctSubscriber.prototype._next = function (value) {
        if (this.keySelector) {
            this._useKeySelector(value);
        }
        else {
            this._finalizeNext(value, value);
        }
    };
    DistinctSubscriber.prototype._useKeySelector = function (value) {
        var key;
        var destination = this.destination;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this._finalizeNext(key, value);
    };
    DistinctSubscriber.prototype._finalizeNext = function (key, value) {
        var values = this.values;
        if (!values.has(key)) {
            values.add(key);
            this.destination.next(value);
        }
    };
    return DistinctSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"]));

//# sourceMappingURL=distinct.js.map


/***/ }),
/* 355 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distinctUntilChanged", function() { return distinctUntilChanged; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(233);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function distinctUntilChanged(compare, keySelector) {
    return function (source) { return source.lift(new DistinctUntilChangedOperator(compare, keySelector)); };
}
var DistinctUntilChangedOperator = /*@__PURE__*/ (function () {
    function DistinctUntilChangedOperator(compare, keySelector) {
        this.compare = compare;
        this.keySelector = keySelector;
    }
    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
    };
    return DistinctUntilChangedOperator;
}());
var DistinctUntilChangedSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](DistinctUntilChangedSubscriber, _super);
    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.hasKey = false;
        if (typeof compare === 'function') {
            _this.compare = compare;
        }
        return _this;
    }
    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
        return x === y;
    };
    DistinctUntilChangedSubscriber.prototype._next = function (value) {
        var key;
        try {
            var keySelector = this.keySelector;
            key = keySelector ? keySelector(value) : value;
        }
        catch (err) {
            return this.destination.error(err);
        }
        var result = false;
        if (this.hasKey) {
            try {
                var compare = this.compare;
                result = compare(this.key, key);
            }
            catch (err) {
                return this.destination.error(err);
            }
        }
        else {
            this.hasKey = true;
        }
        if (!result) {
            this.key = key;
            this.destination.next(value);
        }
    };
    return DistinctUntilChangedSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=distinctUntilChanged.js.map


/***/ }),
/* 356 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distinctUntilKeyChanged", function() { return distinctUntilKeyChanged; });
/* harmony import */ var _distinctUntilChanged__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(355);
/** PURE_IMPORTS_START _distinctUntilChanged PURE_IMPORTS_END */

function distinctUntilKeyChanged(key, compare) {
    return Object(_distinctUntilChanged__WEBPACK_IMPORTED_MODULE_0__["distinctUntilChanged"])(function (x, y) { return compare ? compare(x[key], y[key]) : x[key] === y[key]; });
}
//# sourceMappingURL=distinctUntilKeyChanged.js.map


/***/ }),
/* 357 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elementAt", function() { return elementAt; });
/* harmony import */ var _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(284);
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(326);
/* harmony import */ var _throwIfEmpty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(358);
/* harmony import */ var _defaultIfEmpty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(349);
/* harmony import */ var _take__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(359);
/** PURE_IMPORTS_START _util_ArgumentOutOfRangeError,_filter,_throwIfEmpty,_defaultIfEmpty,_take PURE_IMPORTS_END */





function elementAt(index, defaultValue) {
    if (index < 0) {
        throw new _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_0__["ArgumentOutOfRangeError"]();
    }
    var hasDefaultValue = arguments.length >= 2;
    return function (source) {
        return source.pipe(Object(_filter__WEBPACK_IMPORTED_MODULE_1__["filter"])(function (v, i) { return i === index; }), Object(_take__WEBPACK_IMPORTED_MODULE_4__["take"])(1), hasDefaultValue
            ? Object(_defaultIfEmpty__WEBPACK_IMPORTED_MODULE_3__["defaultIfEmpty"])(defaultValue)
            : Object(_throwIfEmpty__WEBPACK_IMPORTED_MODULE_2__["throwIfEmpty"])(function () { return new _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_0__["ArgumentOutOfRangeError"](); }));
    };
}
//# sourceMappingURL=elementAt.js.map


/***/ }),
/* 358 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "throwIfEmpty", function() { return throwIfEmpty; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _util_EmptyError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(285);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(233);
/** PURE_IMPORTS_START tslib,_util_EmptyError,_Subscriber PURE_IMPORTS_END */



function throwIfEmpty(errorFactory) {
    if (errorFactory === void 0) {
        errorFactory = defaultErrorFactory;
    }
    return function (source) {
        return source.lift(new ThrowIfEmptyOperator(errorFactory));
    };
}
var ThrowIfEmptyOperator = /*@__PURE__*/ (function () {
    function ThrowIfEmptyOperator(errorFactory) {
        this.errorFactory = errorFactory;
    }
    ThrowIfEmptyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrowIfEmptySubscriber(subscriber, this.errorFactory));
    };
    return ThrowIfEmptyOperator;
}());
var ThrowIfEmptySubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](ThrowIfEmptySubscriber, _super);
    function ThrowIfEmptySubscriber(destination, errorFactory) {
        var _this = _super.call(this, destination) || this;
        _this.errorFactory = errorFactory;
        _this.hasValue = false;
        return _this;
    }
    ThrowIfEmptySubscriber.prototype._next = function (value) {
        this.hasValue = true;
        this.destination.next(value);
    };
    ThrowIfEmptySubscriber.prototype._complete = function () {
        if (!this.hasValue) {
            var err = void 0;
            try {
                err = this.errorFactory();
            }
            catch (e) {
                err = e;
            }
            this.destination.error(err);
        }
        else {
            return this.destination.complete();
        }
    };
    return ThrowIfEmptySubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_2__["Subscriber"]));
function defaultErrorFactory() {
    return new _util_EmptyError__WEBPACK_IMPORTED_MODULE_1__["EmptyError"]();
}
//# sourceMappingURL=throwIfEmpty.js.map


/***/ }),
/* 359 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "take", function() { return take; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(233);
/* harmony import */ var _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(284);
/* harmony import */ var _observable_empty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(265);
/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */




function take(count) {
    return function (source) {
        if (count === 0) {
            return Object(_observable_empty__WEBPACK_IMPORTED_MODULE_3__["empty"])();
        }
        else {
            return source.lift(new TakeOperator(count));
        }
    };
}
var TakeOperator = /*@__PURE__*/ (function () {
    function TakeOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_2__["ArgumentOutOfRangeError"];
        }
    }
    TakeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeSubscriber(subscriber, this.total));
    };
    return TakeOperator;
}());
var TakeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](TakeSubscriber, _super);
    function TakeSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
    }
    TakeSubscriber.prototype._next = function (value) {
        var total = this.total;
        var count = ++this.count;
        if (count <= total) {
            this.destination.next(value);
            if (count === total) {
                this.destination.complete();
                this.unsubscribe();
            }
        }
    };
    return TakeSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=take.js.map


/***/ }),
/* 360 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "endWith", function() { return endWith; });
/* harmony import */ var _observable_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(301);
/* harmony import */ var _observable_of__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(266);
/** PURE_IMPORTS_START _observable_concat,_observable_of PURE_IMPORTS_END */


function endWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        array[_i] = arguments[_i];
    }
    return function (source) { return Object(_observable_concat__WEBPACK_IMPORTED_MODULE_0__["concat"])(source, _observable_of__WEBPACK_IMPORTED_MODULE_1__["of"].apply(void 0, array)); };
}
//# sourceMappingURL=endWith.js.map


/***/ }),
/* 361 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "every", function() { return every; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(233);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function every(predicate, thisArg) {
    return function (source) { return source.lift(new EveryOperator(predicate, thisArg, source)); };
}
var EveryOperator = /*@__PURE__*/ (function () {
    function EveryOperator(predicate, thisArg, source) {
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.source = source;
    }
    EveryOperator.prototype.call = function (observer, source) {
        return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
    };
    return EveryOperator;
}());
var EverySubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](EverySubscriber, _super);
    function EverySubscriber(destination, predicate, thisArg, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.source = source;
        _this.index = 0;
        _this.thisArg = thisArg || _this;
        return _this;
    }
    EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {
        this.destination.next(everyValueMatch);
        this.destination.complete();
    };
    EverySubscriber.prototype._next = function (value) {
        var result = false;
        try {
            result = this.predicate.call(this.thisArg, value, this.index++, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (!result) {
            this.notifyComplete(false);
        }
    };
    EverySubscriber.prototype._complete = function () {
        this.notifyComplete(true);
    };
    return EverySubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=every.js.map


/***/ }),
/* 362 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exhaust", function() { return exhaust; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(291);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(292);
/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */



function exhaust() {
    return function (source) { return source.lift(new SwitchFirstOperator()); };
}
var SwitchFirstOperator = /*@__PURE__*/ (function () {
    function SwitchFirstOperator() {
    }
    SwitchFirstOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchFirstSubscriber(subscriber));
    };
    return SwitchFirstOperator;
}());
var SwitchFirstSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](SwitchFirstSubscriber, _super);
    function SwitchFirstSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasCompleted = false;
        _this.hasSubscription = false;
        return _this;
    }
    SwitchFirstSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.hasSubscription = true;
            this.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(this, value));
        }
    };
    SwitchFirstSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
    };
    SwitchFirstSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return SwitchFirstSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"]));
//# sourceMappingURL=exhaust.js.map


/***/ }),
/* 363 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exhaustMap", function() { return exhaustMap; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(291);
/* harmony import */ var _InnerSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(293);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(292);
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(288);
/* harmony import */ var _observable_from__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(305);
/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */






function exhaustMap(project, resultSelector) {
    if (resultSelector) {
        return function (source) { return source.pipe(exhaustMap(function (a, i) { return Object(_observable_from__WEBPACK_IMPORTED_MODULE_5__["from"])(project(a, i)).pipe(Object(_map__WEBPACK_IMPORTED_MODULE_4__["map"])(function (b, ii) { return resultSelector(a, b, i, ii); })); })); };
    }
    return function (source) {
        return source.lift(new ExhaustMapOperator(project));
    };
}
var ExhaustMapOperator = /*@__PURE__*/ (function () {
    function ExhaustMapOperator(project) {
        this.project = project;
    }
    ExhaustMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ExhaustMapSubscriber(subscriber, this.project));
    };
    return ExhaustMapOperator;
}());
var ExhaustMapSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](ExhaustMapSubscriber, _super);
    function ExhaustMapSubscriber(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.hasSubscription = false;
        _this.hasCompleted = false;
        _this.index = 0;
        return _this;
    }
    ExhaustMapSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.tryNext(value);
        }
    };
    ExhaustMapSubscriber.prototype.tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.hasSubscription = true;
        this._innerSub(result, value, index);
    };
    ExhaustMapSubscriber.prototype._innerSub = function (result, value, index) {
        var innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_2__["InnerSubscriber"](this, undefined, undefined);
        var destination = this.destination;
        destination.add(innerSubscriber);
        Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__["subscribeToResult"])(this, result, value, index, innerSubscriber);
    };
    ExhaustMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    ExhaustMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    ExhaustMapSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    ExhaustMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var destination = this.destination;
        destination.remove(innerSub);
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return ExhaustMapSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"]));
//# sourceMappingURL=exhaustMap.js.map


/***/ }),
/* 364 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expand", function() { return expand; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExpandOperator", function() { return ExpandOperator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExpandSubscriber", function() { return ExpandSubscriber; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(291);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(292);
/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */



function expand(project, concurrent, scheduler) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    if (scheduler === void 0) {
        scheduler = undefined;
    }
    concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
    return function (source) { return source.lift(new ExpandOperator(project, concurrent, scheduler)); };
}
var ExpandOperator = /*@__PURE__*/ (function () {
    function ExpandOperator(project, concurrent, scheduler) {
        this.project = project;
        this.concurrent = concurrent;
        this.scheduler = scheduler;
    }
    ExpandOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
    };
    return ExpandOperator;
}());

var ExpandSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](ExpandSubscriber, _super);
    function ExpandSubscriber(destination, project, concurrent, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.scheduler = scheduler;
        _this.index = 0;
        _this.active = 0;
        _this.hasCompleted = false;
        if (concurrent < Number.POSITIVE_INFINITY) {
            _this.buffer = [];
        }
        return _this;
    }
    ExpandSubscriber.dispatch = function (arg) {
        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;
        subscriber.subscribeToProjection(result, value, index);
    };
    ExpandSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (destination.closed) {
            this._complete();
            return;
        }
        var index = this.index++;
        if (this.active < this.concurrent) {
            destination.next(value);
            try {
                var project = this.project;
                var result = project(value, index);
                if (!this.scheduler) {
                    this.subscribeToProjection(result, value, index);
                }
                else {
                    var state = { subscriber: this, result: result, value: value, index: index };
                    var destination_1 = this.destination;
                    destination_1.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));
                }
            }
            catch (e) {
                destination.error(e);
            }
        }
        else {
            this.buffer.push(value);
        }
    };
    ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {
        this.active++;
        var destination = this.destination;
        destination.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(this, result, value, index));
    };
    ExpandSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this._next(innerValue);
    };
    ExpandSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        var destination = this.destination;
        destination.remove(innerSub);
        this.active--;
        if (buffer && buffer.length > 0) {
            this._next(buffer.shift());
        }
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
    };
    return ExpandSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"]));

//# sourceMappingURL=expand.js.map


/***/ }),
/* 365 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "finalize", function() { return finalize; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(233);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(239);
/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription PURE_IMPORTS_END */



function finalize(callback) {
    return function (source) { return source.lift(new FinallyOperator(callback)); };
}
var FinallyOperator = /*@__PURE__*/ (function () {
    function FinallyOperator(callback) {
        this.callback = callback;
    }
    FinallyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FinallySubscriber(subscriber, this.callback));
    };
    return FinallyOperator;
}());
var FinallySubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](FinallySubscriber, _super);
    function FinallySubscriber(destination, callback) {
        var _this = _super.call(this, destination) || this;
        _this.add(new _Subscription__WEBPACK_IMPORTED_MODULE_2__["Subscription"](callback));
        return _this;
    }
    return FinallySubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=finalize.js.map


/***/ }),
/* 366 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "find", function() { return find; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FindValueOperator", function() { return FindValueOperator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FindValueSubscriber", function() { return FindValueSubscriber; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(233);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function find(predicate, thisArg) {
    if (typeof predicate !== 'function') {
        throw new TypeError('predicate is not a function');
    }
    return function (source) { return source.lift(new FindValueOperator(predicate, source, false, thisArg)); };
}
var FindValueOperator = /*@__PURE__*/ (function () {
    function FindValueOperator(predicate, source, yieldIndex, thisArg) {
        this.predicate = predicate;
        this.source = source;
        this.yieldIndex = yieldIndex;
        this.thisArg = thisArg;
    }
    FindValueOperator.prototype.call = function (observer, source) {
        return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));
    };
    return FindValueOperator;
}());

var FindValueSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](FindValueSubscriber, _super);
    function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.yieldIndex = yieldIndex;
        _this.thisArg = thisArg;
        _this.index = 0;
        return _this;
    }
    FindValueSubscriber.prototype.notifyComplete = function (value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
        this.unsubscribe();
    };
    FindValueSubscriber.prototype._next = function (value) {
        var _a = this, predicate = _a.predicate, thisArg = _a.thisArg;
        var index = this.index++;
        try {
            var result = predicate.call(thisArg || this, value, index, this.source);
            if (result) {
                this.notifyComplete(this.yieldIndex ? index : value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    FindValueSubscriber.prototype._complete = function () {
        this.notifyComplete(this.yieldIndex ? -1 : undefined);
    };
    return FindValueSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));

//# sourceMappingURL=find.js.map


/***/ }),
/* 367 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findIndex", function() { return findIndex; });
/* harmony import */ var _operators_find__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(366);
/** PURE_IMPORTS_START _operators_find PURE_IMPORTS_END */

function findIndex(predicate, thisArg) {
    return function (source) { return source.lift(new _operators_find__WEBPACK_IMPORTED_MODULE_0__["FindValueOperator"](predicate, source, true, thisArg)); };
}
//# sourceMappingURL=findIndex.js.map


/***/ }),
/* 368 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "first", function() { return first; });
/* harmony import */ var _util_EmptyError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(285);
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(326);
/* harmony import */ var _take__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(359);
/* harmony import */ var _defaultIfEmpty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(349);
/* harmony import */ var _throwIfEmpty__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(358);
/* harmony import */ var _util_identity__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(282);
/** PURE_IMPORTS_START _util_EmptyError,_filter,_take,_defaultIfEmpty,_throwIfEmpty,_util_identity PURE_IMPORTS_END */






function first(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function (source) { return source.pipe(predicate ? Object(_filter__WEBPACK_IMPORTED_MODULE_1__["filter"])(function (v, i) { return predicate(v, i, source); }) : _util_identity__WEBPACK_IMPORTED_MODULE_5__["identity"], Object(_take__WEBPACK_IMPORTED_MODULE_2__["take"])(1), hasDefaultValue ? Object(_defaultIfEmpty__WEBPACK_IMPORTED_MODULE_3__["defaultIfEmpty"])(defaultValue) : Object(_throwIfEmpty__WEBPACK_IMPORTED_MODULE_4__["throwIfEmpty"])(function () { return new _util_EmptyError__WEBPACK_IMPORTED_MODULE_0__["EmptyError"](); })); };
}
//# sourceMappingURL=first.js.map


/***/ }),
/* 369 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ignoreElements", function() { return ignoreElements; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(233);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function ignoreElements() {
    return function ignoreElementsOperatorFunction(source) {
        return source.lift(new IgnoreElementsOperator());
    };
}
var IgnoreElementsOperator = /*@__PURE__*/ (function () {
    function IgnoreElementsOperator() {
    }
    IgnoreElementsOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new IgnoreElementsSubscriber(subscriber));
    };
    return IgnoreElementsOperator;
}());
var IgnoreElementsSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](IgnoreElementsSubscriber, _super);
    function IgnoreElementsSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    IgnoreElementsSubscriber.prototype._next = function (unused) {
    };
    return IgnoreElementsSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=ignoreElements.js.map


/***/ }),
/* 370 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEmpty", function() { return isEmpty; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(233);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function isEmpty() {
    return function (source) { return source.lift(new IsEmptyOperator()); };
}
var IsEmptyOperator = /*@__PURE__*/ (function () {
    function IsEmptyOperator() {
    }
    IsEmptyOperator.prototype.call = function (observer, source) {
        return source.subscribe(new IsEmptySubscriber(observer));
    };
    return IsEmptyOperator;
}());
var IsEmptySubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](IsEmptySubscriber, _super);
    function IsEmptySubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {
        var destination = this.destination;
        destination.next(isEmpty);
        destination.complete();
    };
    IsEmptySubscriber.prototype._next = function (value) {
        this.notifyComplete(false);
    };
    IsEmptySubscriber.prototype._complete = function () {
        this.notifyComplete(true);
    };
    return IsEmptySubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=isEmpty.js.map


/***/ }),
/* 371 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "last", function() { return last; });
/* harmony import */ var _util_EmptyError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(285);
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(326);
/* harmony import */ var _takeLast__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(372);
/* harmony import */ var _throwIfEmpty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(358);
/* harmony import */ var _defaultIfEmpty__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(349);
/* harmony import */ var _util_identity__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(282);
/** PURE_IMPORTS_START _util_EmptyError,_filter,_takeLast,_throwIfEmpty,_defaultIfEmpty,_util_identity PURE_IMPORTS_END */






function last(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function (source) { return source.pipe(predicate ? Object(_filter__WEBPACK_IMPORTED_MODULE_1__["filter"])(function (v, i) { return predicate(v, i, source); }) : _util_identity__WEBPACK_IMPORTED_MODULE_5__["identity"], Object(_takeLast__WEBPACK_IMPORTED_MODULE_2__["takeLast"])(1), hasDefaultValue ? Object(_defaultIfEmpty__WEBPACK_IMPORTED_MODULE_4__["defaultIfEmpty"])(defaultValue) : Object(_throwIfEmpty__WEBPACK_IMPORTED_MODULE_3__["throwIfEmpty"])(function () { return new _util_EmptyError__WEBPACK_IMPORTED_MODULE_0__["EmptyError"](); })); };
}
//# sourceMappingURL=last.js.map


/***/ }),
/* 372 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "takeLast", function() { return takeLast; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(233);
/* harmony import */ var _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(284);
/* harmony import */ var _observable_empty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(265);
/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */




function takeLast(count) {
    return function takeLastOperatorFunction(source) {
        if (count === 0) {
            return Object(_observable_empty__WEBPACK_IMPORTED_MODULE_3__["empty"])();
        }
        else {
            return source.lift(new TakeLastOperator(count));
        }
    };
}
var TakeLastOperator = /*@__PURE__*/ (function () {
    function TakeLastOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_2__["ArgumentOutOfRangeError"];
        }
    }
    TakeLastOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
    };
    return TakeLastOperator;
}());
var TakeLastSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](TakeLastSubscriber, _super);
    function TakeLastSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.ring = new Array();
        _this.count = 0;
        return _this;
    }
    TakeLastSubscriber.prototype._next = function (value) {
        var ring = this.ring;
        var total = this.total;
        var count = this.count++;
        if (ring.length < total) {
            ring.push(value);
        }
        else {
            var index = count % total;
            ring[index] = value;
        }
    };
    TakeLastSubscriber.prototype._complete = function () {
        var destination = this.destination;
        var count = this.count;
        if (count > 0) {
            var total = this.count >= this.total ? this.total : this.count;
            var ring = this.ring;
            for (var i = 0; i < total; i++) {
                var idx = (count++) % total;
                destination.next(ring[idx]);
            }
        }
        destination.complete();
    };
    return TakeLastSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=takeLast.js.map


/***/ }),
/* 373 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapTo", function() { return mapTo; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(233);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function mapTo(value) {
    return function (source) { return source.lift(new MapToOperator(value)); };
}
var MapToOperator = /*@__PURE__*/ (function () {
    function MapToOperator(value) {
        this.value = value;
    }
    MapToOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapToSubscriber(subscriber, this.value));
    };
    return MapToOperator;
}());
var MapToSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](MapToSubscriber, _super);
    function MapToSubscriber(destination, value) {
        var _this = _super.call(this, destination) || this;
        _this.value = value;
        return _this;
    }
    MapToSubscriber.prototype._next = function (x) {
        this.destination.next(this.value);
    };
    return MapToSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=mapTo.js.map


/***/ }),
/* 374 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "materialize", function() { return materialize; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(233);
/* harmony import */ var _Notification__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(264);
/** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */



function materialize() {
    return function materializeOperatorFunction(source) {
        return source.lift(new MaterializeOperator());
    };
}
var MaterializeOperator = /*@__PURE__*/ (function () {
    function MaterializeOperator() {
    }
    MaterializeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MaterializeSubscriber(subscriber));
    };
    return MaterializeOperator;
}());
var MaterializeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](MaterializeSubscriber, _super);
    function MaterializeSubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    MaterializeSubscriber.prototype._next = function (value) {
        this.destination.next(_Notification__WEBPACK_IMPORTED_MODULE_2__["Notification"].createNext(value));
    };
    MaterializeSubscriber.prototype._error = function (err) {
        var destination = this.destination;
        destination.next(_Notification__WEBPACK_IMPORTED_MODULE_2__["Notification"].createError(err));
        destination.complete();
    };
    MaterializeSubscriber.prototype._complete = function () {
        var destination = this.destination;
        destination.next(_Notification__WEBPACK_IMPORTED_MODULE_2__["Notification"].createComplete());
        destination.complete();
    };
    return MaterializeSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=materialize.js.map


/***/ }),
/* 375 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony import */ var _reduce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(376);
/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */

function max(comparer) {
    var max = (typeof comparer === 'function')
        ? function (x, y) { return comparer(x, y) > 0 ? x : y; }
        : function (x, y) { return x > y ? x : y; };
    return Object(_reduce__WEBPACK_IMPORTED_MODULE_0__["reduce"])(max);
}
//# sourceMappingURL=max.js.map


/***/ }),
/* 376 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reduce", function() { return reduce; });
/* harmony import */ var _scan__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(377);
/* harmony import */ var _takeLast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(372);
/* harmony import */ var _defaultIfEmpty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(349);
/* harmony import */ var _util_pipe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(246);
/** PURE_IMPORTS_START _scan,_takeLast,_defaultIfEmpty,_util_pipe PURE_IMPORTS_END */




function reduce(accumulator, seed) {
    if (arguments.length >= 2) {
        return function reduceOperatorFunctionWithSeed(source) {
            return Object(_util_pipe__WEBPACK_IMPORTED_MODULE_3__["pipe"])(Object(_scan__WEBPACK_IMPORTED_MODULE_0__["scan"])(accumulator, seed), Object(_takeLast__WEBPACK_IMPORTED_MODULE_1__["takeLast"])(1), Object(_defaultIfEmpty__WEBPACK_IMPORTED_MODULE_2__["defaultIfEmpty"])(seed))(source);
        };
    }
    return function reduceOperatorFunction(source) {
        return Object(_util_pipe__WEBPACK_IMPORTED_MODULE_3__["pipe"])(Object(_scan__WEBPACK_IMPORTED_MODULE_0__["scan"])(function (acc, value, index) { return accumulator(acc, value, index + 1); }), Object(_takeLast__WEBPACK_IMPORTED_MODULE_1__["takeLast"])(1))(source);
    };
}
//# sourceMappingURL=reduce.js.map


/***/ }),
/* 377 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scan", function() { return scan; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(233);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function scan(accumulator, seed) {
    var hasSeed = false;
    if (arguments.length >= 2) {
        hasSeed = true;
    }
    return function scanOperatorFunction(source) {
        return source.lift(new ScanOperator(accumulator, seed, hasSeed));
    };
}
var ScanOperator = /*@__PURE__*/ (function () {
    function ScanOperator(accumulator, seed, hasSeed) {
        if (hasSeed === void 0) {
            hasSeed = false;
        }
        this.accumulator = accumulator;
        this.seed = seed;
        this.hasSeed = hasSeed;
    }
    ScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
    };
    return ScanOperator;
}());
var ScanSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](ScanSubscriber, _super);
    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this._seed = _seed;
        _this.hasSeed = hasSeed;
        _this.index = 0;
        return _this;
    }
    Object.defineProperty(ScanSubscriber.prototype, "seed", {
        get: function () {
            return this._seed;
        },
        set: function (value) {
            this.hasSeed = true;
            this._seed = value;
        },
        enumerable: true,
        configurable: true
    });
    ScanSubscriber.prototype._next = function (value) {
        if (!this.hasSeed) {
            this.seed = value;
            this.destination.next(value);
        }
        else {
            return this._tryNext(value);
        }
    };
    ScanSubscriber.prototype._tryNext = function (value) {
        var index = this.index++;
        var result;
        try {
            result = this.accumulator(this.seed, value, index);
        }
        catch (err) {
            this.destination.error(err);
        }
        this.seed = result;
        this.destination.next(result);
    };
    return ScanSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=scan.js.map


/***/ }),
/* 378 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return merge; });
/* harmony import */ var _observable_merge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(320);
/** PURE_IMPORTS_START _observable_merge PURE_IMPORTS_END */

function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return function (source) { return source.lift.call(_observable_merge__WEBPACK_IMPORTED_MODULE_0__["merge"].apply(void 0, [source].concat(observables))); };
}
//# sourceMappingURL=merge.js.map


/***/ }),
/* 379 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeMapTo", function() { return mergeMapTo; });
/* harmony import */ var _mergeMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(304);
/** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */

function mergeMapTo(innerObservable, resultSelector, concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    if (typeof resultSelector === 'function') {
        return Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__["mergeMap"])(function () { return innerObservable; }, resultSelector, concurrent);
    }
    if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
    }
    return Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__["mergeMap"])(function () { return innerObservable; }, concurrent);
}
//# sourceMappingURL=mergeMapTo.js.map


/***/ }),
/* 380 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeScan", function() { return mergeScan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MergeScanOperator", function() { return MergeScanOperator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MergeScanSubscriber", function() { return MergeScanSubscriber; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(292);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(291);
/* harmony import */ var _InnerSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(293);
/** PURE_IMPORTS_START tslib,_util_subscribeToResult,_OuterSubscriber,_InnerSubscriber PURE_IMPORTS_END */




function mergeScan(accumulator, seed, concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    return function (source) { return source.lift(new MergeScanOperator(accumulator, seed, concurrent)); };
}
var MergeScanOperator = /*@__PURE__*/ (function () {
    function MergeScanOperator(accumulator, seed, concurrent) {
        this.accumulator = accumulator;
        this.seed = seed;
        this.concurrent = concurrent;
    }
    MergeScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));
    };
    return MergeScanOperator;
}());

var MergeScanSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](MergeScanSubscriber, _super);
    function MergeScanSubscriber(destination, accumulator, acc, concurrent) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this.acc = acc;
        _this.concurrent = concurrent;
        _this.hasValue = false;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
    }
    MergeScanSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            var index = this.index++;
            var destination = this.destination;
            var ish = void 0;
            try {
                var accumulator = this.accumulator;
                ish = accumulator(this.acc, value, index);
            }
            catch (e) {
                return destination.error(e);
            }
            this.active++;
            this._innerSub(ish, value, index);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeScanSubscriber.prototype._innerSub = function (ish, value, index) {
        var innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_3__["InnerSubscriber"](this, undefined, undefined);
        var destination = this.destination;
        destination.add(innerSubscriber);
        Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__["subscribeToResult"])(this, ish, value, index, innerSubscriber);
    };
    MergeScanSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            if (this.hasValue === false) {
                this.destination.next(this.acc);
            }
            this.destination.complete();
        }
        this.unsubscribe();
    };
    MergeScanSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var destination = this.destination;
        this.acc = innerValue;
        this.hasValue = true;
        destination.next(innerValue);
    };
    MergeScanSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        var destination = this.destination;
        destination.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            if (this.hasValue === false) {
                this.destination.next(this.acc);
            }
            this.destination.complete();
        }
    };
    return MergeScanSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__["OuterSubscriber"]));

//# sourceMappingURL=mergeScan.js.map


/***/ }),
/* 381 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony import */ var _reduce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(376);
/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */

function min(comparer) {
    var min = (typeof comparer === 'function')
        ? function (x, y) { return comparer(x, y) < 0 ? x : y; }
        : function (x, y) { return x < y ? x : y; };
    return Object(_reduce__WEBPACK_IMPORTED_MODULE_0__["reduce"])(min);
}
//# sourceMappingURL=min.js.map


/***/ }),
/* 382 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multicast", function() { return multicast; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MulticastOperator", function() { return MulticastOperator; });
/* harmony import */ var _observable_ConnectableObservable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(248);
/** PURE_IMPORTS_START _observable_ConnectableObservable PURE_IMPORTS_END */

function multicast(subjectOrSubjectFactory, selector) {
    return function multicastOperatorFunction(source) {
        var subjectFactory;
        if (typeof subjectOrSubjectFactory === 'function') {
            subjectFactory = subjectOrSubjectFactory;
        }
        else {
            subjectFactory = function subjectFactory() {
                return subjectOrSubjectFactory;
            };
        }
        if (typeof selector === 'function') {
            return source.lift(new MulticastOperator(subjectFactory, selector));
        }
        var connectable = Object.create(source, _observable_ConnectableObservable__WEBPACK_IMPORTED_MODULE_0__["connectableObservableDescriptor"]);
        connectable.source = source;
        connectable.subjectFactory = subjectFactory;
        return connectable;
    };
}
var MulticastOperator = /*@__PURE__*/ (function () {
    function MulticastOperator(subjectFactory, selector) {
        this.subjectFactory = subjectFactory;
        this.selector = selector;
    }
    MulticastOperator.prototype.call = function (subscriber, source) {
        var selector = this.selector;
        var subject = this.subjectFactory();
        var subscription = selector(subject).subscribe(subscriber);
        subscription.add(source.subscribe(subject));
        return subscription;
    };
    return MulticastOperator;
}());

//# sourceMappingURL=multicast.js.map


/***/ }),
/* 383 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onErrorResumeNext", function() { return onErrorResumeNext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onErrorResumeNextStatic", function() { return onErrorResumeNextStatic; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _observable_from__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(305);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(240);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(291);
/* harmony import */ var _InnerSubscriber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(293);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(292);
/** PURE_IMPORTS_START tslib,_observable_from,_util_isArray,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */






function onErrorResumeNext() {
    var nextSources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        nextSources[_i] = arguments[_i];
    }
    if (nextSources.length === 1 && Object(_util_isArray__WEBPACK_IMPORTED_MODULE_2__["isArray"])(nextSources[0])) {
        nextSources = nextSources[0];
    }
    return function (source) { return source.lift(new OnErrorResumeNextOperator(nextSources)); };
}
function onErrorResumeNextStatic() {
    var nextSources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        nextSources[_i] = arguments[_i];
    }
    var source = null;
    if (nextSources.length === 1 && Object(_util_isArray__WEBPACK_IMPORTED_MODULE_2__["isArray"])(nextSources[0])) {
        nextSources = nextSources[0];
    }
    source = nextSources.shift();
    return Object(_observable_from__WEBPACK_IMPORTED_MODULE_1__["from"])(source, null).lift(new OnErrorResumeNextOperator(nextSources));
}
var OnErrorResumeNextOperator = /*@__PURE__*/ (function () {
    function OnErrorResumeNextOperator(nextSources) {
        this.nextSources = nextSources;
    }
    OnErrorResumeNextOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
    };
    return OnErrorResumeNextOperator;
}());
var OnErrorResumeNextSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](OnErrorResumeNextSubscriber, _super);
    function OnErrorResumeNextSubscriber(destination, nextSources) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.nextSources = nextSources;
        return _this;
    }
    OnErrorResumeNextSubscriber.prototype.notifyError = function (error, innerSub) {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype.notifyComplete = function (innerSub) {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype._error = function (err) {
        this.subscribeToNextSource();
        this.unsubscribe();
    };
    OnErrorResumeNextSubscriber.prototype._complete = function () {
        this.subscribeToNextSource();
        this.unsubscribe();
    };
    OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {
        var next = this.nextSources.shift();
        if (!!next) {
            var innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_4__["InnerSubscriber"](this, undefined, undefined);
            var destination = this.destination;
            destination.add(innerSubscriber);
            Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_5__["subscribeToResult"])(this, next, undefined, undefined, innerSubscriber);
        }
        else {
            this.destination.complete();
        }
    };
    return OnErrorResumeNextSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__["OuterSubscriber"]));
//# sourceMappingURL=onErrorResumeNext.js.map


/***/ }),
/* 384 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pairwise", function() { return pairwise; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(233);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function pairwise() {
    return function (source) { return source.lift(new PairwiseOperator()); };
}
var PairwiseOperator = /*@__PURE__*/ (function () {
    function PairwiseOperator() {
    }
    PairwiseOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new PairwiseSubscriber(subscriber));
    };
    return PairwiseOperator;
}());
var PairwiseSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](PairwiseSubscriber, _super);
    function PairwiseSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasPrev = false;
        return _this;
    }
    PairwiseSubscriber.prototype._next = function (value) {
        var pair;
        if (this.hasPrev) {
            pair = [this.prev, value];
        }
        else {
            this.hasPrev = true;
        }
        this.prev = value;
        if (pair) {
            this.destination.next(pair);
        }
    };
    return PairwiseSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=pairwise.js.map


/***/ }),
/* 385 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "partition", function() { return partition; });
/* harmony import */ var _util_not__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(325);
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(326);
/** PURE_IMPORTS_START _util_not,_filter PURE_IMPORTS_END */


function partition(predicate, thisArg) {
    return function (source) {
        return [
            Object(_filter__WEBPACK_IMPORTED_MODULE_1__["filter"])(predicate, thisArg)(source),
            Object(_filter__WEBPACK_IMPORTED_MODULE_1__["filter"])(Object(_util_not__WEBPACK_IMPORTED_MODULE_0__["not"])(predicate, thisArg))(source)
        ];
    };
}
//# sourceMappingURL=partition.js.map


/***/ }),
/* 386 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pluck", function() { return pluck; });
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(288);
/** PURE_IMPORTS_START _map PURE_IMPORTS_END */

function pluck() {
    var properties = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        properties[_i] = arguments[_i];
    }
    var length = properties.length;
    if (length === 0) {
        throw new Error('list of properties cannot be empty.');
    }
    return function (source) { return Object(_map__WEBPACK_IMPORTED_MODULE_0__["map"])(plucker(properties, length))(source); };
}
function plucker(props, length) {
    var mapper = function (x) {
        var currentProp = x;
        for (var i = 0; i < length; i++) {
            var p = currentProp[props[i]];
            if (typeof p !== 'undefined') {
                currentProp = p;
            }
            else {
                return undefined;
            }
        }
        return currentProp;
    };
    return mapper;
}
//# sourceMappingURL=pluck.js.map


/***/ }),
/* 387 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "publish", function() { return publish; });
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _multicast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(382);
/** PURE_IMPORTS_START _Subject,_multicast PURE_IMPORTS_END */


function publish(selector) {
    return selector ?
        Object(_multicast__WEBPACK_IMPORTED_MODULE_1__["multicast"])(function () { return new _Subject__WEBPACK_IMPORTED_MODULE_0__["Subject"](); }, selector) :
        Object(_multicast__WEBPACK_IMPORTED_MODULE_1__["multicast"])(new _Subject__WEBPACK_IMPORTED_MODULE_0__["Subject"]());
}
//# sourceMappingURL=publish.js.map


/***/ }),
/* 388 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "publishBehavior", function() { return publishBehavior; });
/* harmony import */ var _BehaviorSubject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(254);
/* harmony import */ var _multicast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(382);
/** PURE_IMPORTS_START _BehaviorSubject,_multicast PURE_IMPORTS_END */


function publishBehavior(value) {
    return function (source) { return Object(_multicast__WEBPACK_IMPORTED_MODULE_1__["multicast"])(new _BehaviorSubject__WEBPACK_IMPORTED_MODULE_0__["BehaviorSubject"](value))(source); };
}
//# sourceMappingURL=publishBehavior.js.map


/***/ }),
/* 389 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "publishLast", function() { return publishLast; });
/* harmony import */ var _AsyncSubject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(272);
/* harmony import */ var _multicast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(382);
/** PURE_IMPORTS_START _AsyncSubject,_multicast PURE_IMPORTS_END */


function publishLast() {
    return function (source) { return Object(_multicast__WEBPACK_IMPORTED_MODULE_1__["multicast"])(new _AsyncSubject__WEBPACK_IMPORTED_MODULE_0__["AsyncSubject"]())(source); };
}
//# sourceMappingURL=publishLast.js.map


/***/ }),
/* 390 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "publishReplay", function() { return publishReplay; });
/* harmony import */ var _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(255);
/* harmony import */ var _multicast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(382);
/** PURE_IMPORTS_START _ReplaySubject,_multicast PURE_IMPORTS_END */


function publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {
    if (selectorOrScheduler && typeof selectorOrScheduler !== 'function') {
        scheduler = selectorOrScheduler;
    }
    var selector = typeof selectorOrScheduler === 'function' ? selectorOrScheduler : undefined;
    var subject = new _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__["ReplaySubject"](bufferSize, windowTime, scheduler);
    return function (source) { return Object(_multicast__WEBPACK_IMPORTED_MODULE_1__["multicast"])(function () { return subject; }, selector)(source); };
}
//# sourceMappingURL=publishReplay.js.map


/***/ }),
/* 391 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "race", function() { return race; });
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(240);
/* harmony import */ var _observable_race__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(327);
/** PURE_IMPORTS_START _util_isArray,_observable_race PURE_IMPORTS_END */


function race() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return function raceOperatorFunction(source) {
        if (observables.length === 1 && Object(_util_isArray__WEBPACK_IMPORTED_MODULE_0__["isArray"])(observables[0])) {
            observables = observables[0];
        }
        return source.lift.call(_observable_race__WEBPACK_IMPORTED_MODULE_1__["race"].apply(void 0, [source].concat(observables)));
    };
}
//# sourceMappingURL=race.js.map


/***/ }),
/* 392 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "repeat", function() { return repeat; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(233);
/* harmony import */ var _observable_empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(265);
/** PURE_IMPORTS_START tslib,_Subscriber,_observable_empty PURE_IMPORTS_END */



function repeat(count) {
    if (count === void 0) {
        count = -1;
    }
    return function (source) {
        if (count === 0) {
            return Object(_observable_empty__WEBPACK_IMPORTED_MODULE_2__["empty"])();
        }
        else if (count < 0) {
            return source.lift(new RepeatOperator(-1, source));
        }
        else {
            return source.lift(new RepeatOperator(count - 1, source));
        }
    };
}
var RepeatOperator = /*@__PURE__*/ (function () {
    function RepeatOperator(count, source) {
        this.count = count;
        this.source = source;
    }
    RepeatOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
    };
    return RepeatOperator;
}());
var RepeatSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](RepeatSubscriber, _super);
    function RepeatSubscriber(destination, count, source) {
        var _this = _super.call(this, destination) || this;
        _this.count = count;
        _this.source = source;
        return _this;
    }
    RepeatSubscriber.prototype.complete = function () {
        if (!this.isStopped) {
            var _a = this, source = _a.source, count = _a.count;
            if (count === 0) {
                return _super.prototype.complete.call(this);
            }
            else if (count > -1) {
                this.count = count - 1;
            }
            source.subscribe(this._unsubscribeAndRecycle());
        }
    };
    return RepeatSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=repeat.js.map


/***/ }),
/* 393 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "repeatWhen", function() { return repeatWhen; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(249);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(291);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(292);
/** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */




function repeatWhen(notifier) {
    return function (source) { return source.lift(new RepeatWhenOperator(notifier)); };
}
var RepeatWhenOperator = /*@__PURE__*/ (function () {
    function RepeatWhenOperator(notifier) {
        this.notifier = notifier;
    }
    RepeatWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));
    };
    return RepeatWhenOperator;
}());
var RepeatWhenSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](RepeatWhenSubscriber, _super);
    function RepeatWhenSubscriber(destination, notifier, source) {
        var _this = _super.call(this, destination) || this;
        _this.notifier = notifier;
        _this.source = source;
        _this.sourceIsBeingSubscribedTo = true;
        return _this;
    }
    RepeatWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.sourceIsBeingSubscribedTo = true;
        this.source.subscribe(this);
    };
    RepeatWhenSubscriber.prototype.notifyComplete = function (innerSub) {
        if (this.sourceIsBeingSubscribedTo === false) {
            return _super.prototype.complete.call(this);
        }
    };
    RepeatWhenSubscriber.prototype.complete = function () {
        this.sourceIsBeingSubscribedTo = false;
        if (!this.isStopped) {
            if (!this.retries) {
                this.subscribeToRetries();
            }
            if (!this.retriesSubscription || this.retriesSubscription.closed) {
                return _super.prototype.complete.call(this);
            }
            this._unsubscribeAndRecycle();
            this.notifications.next();
        }
    };
    RepeatWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;
        if (notifications) {
            notifications.unsubscribe();
            this.notifications = null;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = null;
        }
        this.retries = null;
    };
    RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function () {
        var _unsubscribe = this._unsubscribe;
        this._unsubscribe = null;
        _super.prototype._unsubscribeAndRecycle.call(this);
        this._unsubscribe = _unsubscribe;
        return this;
    };
    RepeatWhenSubscriber.prototype.subscribeToRetries = function () {
        this.notifications = new _Subject__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
        var retries;
        try {
            var notifier = this.notifier;
            retries = notifier(this.notifications);
        }
        catch (e) {
            return _super.prototype.complete.call(this);
        }
        this.retries = retries;
        this.retriesSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__["subscribeToResult"])(this, retries);
    };
    return RepeatWhenSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__["OuterSubscriber"]));
//# sourceMappingURL=repeatWhen.js.map


/***/ }),
/* 394 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "retry", function() { return retry; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(233);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function retry(count) {
    if (count === void 0) {
        count = -1;
    }
    return function (source) { return source.lift(new RetryOperator(count, source)); };
}
var RetryOperator = /*@__PURE__*/ (function () {
    function RetryOperator(count, source) {
        this.count = count;
        this.source = source;
    }
    RetryOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
    };
    return RetryOperator;
}());
var RetrySubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](RetrySubscriber, _super);
    function RetrySubscriber(destination, count, source) {
        var _this = _super.call(this, destination) || this;
        _this.count = count;
        _this.source = source;
        return _this;
    }
    RetrySubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _a = this, source = _a.source, count = _a.count;
            if (count === 0) {
                return _super.prototype.error.call(this, err);
            }
            else if (count > -1) {
                this.count = count - 1;
            }
            source.subscribe(this._unsubscribeAndRecycle());
        }
    };
    return RetrySubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=retry.js.map


/***/ }),
/* 395 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "retryWhen", function() { return retryWhen; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(249);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(291);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(292);
/** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */




function retryWhen(notifier) {
    return function (source) { return source.lift(new RetryWhenOperator(notifier, source)); };
}
var RetryWhenOperator = /*@__PURE__*/ (function () {
    function RetryWhenOperator(notifier, source) {
        this.notifier = notifier;
        this.source = source;
    }
    RetryWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
    };
    return RetryWhenOperator;
}());
var RetryWhenSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](RetryWhenSubscriber, _super);
    function RetryWhenSubscriber(destination, notifier, source) {
        var _this = _super.call(this, destination) || this;
        _this.notifier = notifier;
        _this.source = source;
        return _this;
    }
    RetryWhenSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var errors = this.errors;
            var retries = this.retries;
            var retriesSubscription = this.retriesSubscription;
            if (!retries) {
                errors = new _Subject__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
                try {
                    var notifier = this.notifier;
                    retries = notifier(errors);
                }
                catch (e) {
                    return _super.prototype.error.call(this, e);
                }
                retriesSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__["subscribeToResult"])(this, retries);
            }
            else {
                this.errors = null;
                this.retriesSubscription = null;
            }
            this._unsubscribeAndRecycle();
            this.errors = errors;
            this.retries = retries;
            this.retriesSubscription = retriesSubscription;
            errors.next(err);
        }
    };
    RetryWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;
        if (errors) {
            errors.unsubscribe();
            this.errors = null;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = null;
        }
        this.retries = null;
    };
    RetryWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _unsubscribe = this._unsubscribe;
        this._unsubscribe = null;
        this._unsubscribeAndRecycle();
        this._unsubscribe = _unsubscribe;
        this.source.subscribe(this);
    };
    return RetryWhenSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__["OuterSubscriber"]));
//# sourceMappingURL=retryWhen.js.map


/***/ }),
/* 396 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sample", function() { return sample; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(291);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(292);
/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */



function sample(notifier) {
    return function (source) { return source.lift(new SampleOperator(notifier)); };
}
var SampleOperator = /*@__PURE__*/ (function () {
    function SampleOperator(notifier) {
        this.notifier = notifier;
    }
    SampleOperator.prototype.call = function (subscriber, source) {
        var sampleSubscriber = new SampleSubscriber(subscriber);
        var subscription = source.subscribe(sampleSubscriber);
        subscription.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(sampleSubscriber, this.notifier));
        return subscription;
    };
    return SampleOperator;
}());
var SampleSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](SampleSubscriber, _super);
    function SampleSubscriber() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.hasValue = false;
        return _this;
    }
    SampleSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
    };
    SampleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.emitValue();
    };
    SampleSubscriber.prototype.notifyComplete = function () {
        this.emitValue();
    };
    SampleSubscriber.prototype.emitValue = function () {
        if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.value);
        }
    };
    return SampleSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"]));
//# sourceMappingURL=sample.js.map


/***/ }),
/* 397 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sampleTime", function() { return sampleTime; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(233);
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(277);
/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */



function sampleTime(period, scheduler) {
    if (scheduler === void 0) {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_2__["async"];
    }
    return function (source) { return source.lift(new SampleTimeOperator(period, scheduler)); };
}
var SampleTimeOperator = /*@__PURE__*/ (function () {
    function SampleTimeOperator(period, scheduler) {
        this.period = period;
        this.scheduler = scheduler;
    }
    SampleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
    };
    return SampleTimeOperator;
}());
var SampleTimeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](SampleTimeSubscriber, _super);
    function SampleTimeSubscriber(destination, period, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.period = period;
        _this.scheduler = scheduler;
        _this.hasValue = false;
        _this.add(scheduler.schedule(dispatchNotification, period, { subscriber: _this, period: period }));
        return _this;
    }
    SampleTimeSubscriber.prototype._next = function (value) {
        this.lastValue = value;
        this.hasValue = true;
    };
    SampleTimeSubscriber.prototype.notifyNext = function () {
        if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.lastValue);
        }
    };
    return SampleTimeSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
function dispatchNotification(state) {
    var subscriber = state.subscriber, period = state.period;
    subscriber.notifyNext();
    this.schedule(state, period);
}
//# sourceMappingURL=sampleTime.js.map


/***/ }),
/* 398 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sequenceEqual", function() { return sequenceEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SequenceEqualOperator", function() { return SequenceEqualOperator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SequenceEqualSubscriber", function() { return SequenceEqualSubscriber; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(233);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function sequenceEqual(compareTo, comparator) {
    return function (source) { return source.lift(new SequenceEqualOperator(compareTo, comparator)); };
}
var SequenceEqualOperator = /*@__PURE__*/ (function () {
    function SequenceEqualOperator(compareTo, comparator) {
        this.compareTo = compareTo;
        this.comparator = comparator;
    }
    SequenceEqualOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparator));
    };
    return SequenceEqualOperator;
}());

var SequenceEqualSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](SequenceEqualSubscriber, _super);
    function SequenceEqualSubscriber(destination, compareTo, comparator) {
        var _this = _super.call(this, destination) || this;
        _this.compareTo = compareTo;
        _this.comparator = comparator;
        _this._a = [];
        _this._b = [];
        _this._oneComplete = false;
        _this.destination.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _this)));
        return _this;
    }
    SequenceEqualSubscriber.prototype._next = function (value) {
        if (this._oneComplete && this._b.length === 0) {
            this.emit(false);
        }
        else {
            this._a.push(value);
            this.checkValues();
        }
    };
    SequenceEqualSubscriber.prototype._complete = function () {
        if (this._oneComplete) {
            this.emit(this._a.length === 0 && this._b.length === 0);
        }
        else {
            this._oneComplete = true;
        }
        this.unsubscribe();
    };
    SequenceEqualSubscriber.prototype.checkValues = function () {
        var _c = this, _a = _c._a, _b = _c._b, comparator = _c.comparator;
        while (_a.length > 0 && _b.length > 0) {
            var a = _a.shift();
            var b = _b.shift();
            var areEqual = false;
            try {
                areEqual = comparator ? comparator(a, b) : a === b;
            }
            catch (e) {
                this.destination.error(e);
            }
            if (!areEqual) {
                this.emit(false);
            }
        }
    };
    SequenceEqualSubscriber.prototype.emit = function (value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
    };
    SequenceEqualSubscriber.prototype.nextB = function (value) {
        if (this._oneComplete && this._a.length === 0) {
            this.emit(false);
        }
        else {
            this._b.push(value);
            this.checkValues();
        }
    };
    SequenceEqualSubscriber.prototype.completeB = function () {
        if (this._oneComplete) {
            this.emit(this._a.length === 0 && this._b.length === 0);
        }
        else {
            this._oneComplete = true;
        }
    };
    return SequenceEqualSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));

var SequenceEqualCompareToSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](SequenceEqualCompareToSubscriber, _super);
    function SequenceEqualCompareToSubscriber(destination, parent) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        return _this;
    }
    SequenceEqualCompareToSubscriber.prototype._next = function (value) {
        this.parent.nextB(value);
    };
    SequenceEqualCompareToSubscriber.prototype._error = function (err) {
        this.parent.error(err);
        this.unsubscribe();
    };
    SequenceEqualCompareToSubscriber.prototype._complete = function () {
        this.parent.completeB();
        this.unsubscribe();
    };
    return SequenceEqualCompareToSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=sequenceEqual.js.map


/***/ }),
/* 399 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "share", function() { return share; });
/* harmony import */ var _multicast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(382);
/* harmony import */ var _refCount__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(252);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(249);
/** PURE_IMPORTS_START _multicast,_refCount,_Subject PURE_IMPORTS_END */



function shareSubjectFactory() {
    return new _Subject__WEBPACK_IMPORTED_MODULE_2__["Subject"]();
}
function share() {
    return function (source) { return Object(_refCount__WEBPACK_IMPORTED_MODULE_1__["refCount"])()(Object(_multicast__WEBPACK_IMPORTED_MODULE_0__["multicast"])(shareSubjectFactory)(source)); };
}
//# sourceMappingURL=share.js.map


/***/ }),
/* 400 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shareReplay", function() { return shareReplay; });
/* harmony import */ var _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(255);
/** PURE_IMPORTS_START _ReplaySubject PURE_IMPORTS_END */

function shareReplay(configOrBufferSize, windowTime, scheduler) {
    var config;
    if (configOrBufferSize && typeof configOrBufferSize === 'object') {
        config = configOrBufferSize;
    }
    else {
        config = {
            bufferSize: configOrBufferSize,
            windowTime: windowTime,
            refCount: false,
            scheduler: scheduler
        };
    }
    return function (source) { return source.lift(shareReplayOperator(config)); };
}
function shareReplayOperator(_a) {
    var _b = _a.bufferSize, bufferSize = _b === void 0 ? Number.POSITIVE_INFINITY : _b, _c = _a.windowTime, windowTime = _c === void 0 ? Number.POSITIVE_INFINITY : _c, useRefCount = _a.refCount, scheduler = _a.scheduler;
    var subject;
    var refCount = 0;
    var subscription;
    var hasError = false;
    var isComplete = false;
    return function shareReplayOperation(source) {
        refCount++;
        if (!subject || hasError) {
            hasError = false;
            subject = new _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__["ReplaySubject"](bufferSize, windowTime, scheduler);
            subscription = source.subscribe({
                next: function (value) { subject.next(value); },
                error: function (err) {
                    hasError = true;
                    subject.error(err);
                },
                complete: function () {
                    isComplete = true;
                    subject.complete();
                },
            });
        }
        var innerSub = subject.subscribe(this);
        this.add(function () {
            refCount--;
            innerSub.unsubscribe();
            if (subscription && !isComplete && useRefCount && refCount === 0) {
                subscription.unsubscribe();
                subscription = undefined;
                subject = undefined;
            }
        });
    };
}
//# sourceMappingURL=shareReplay.js.map


/***/ }),
/* 401 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "single", function() { return single; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(233);
/* harmony import */ var _util_EmptyError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(285);
/** PURE_IMPORTS_START tslib,_Subscriber,_util_EmptyError PURE_IMPORTS_END */



function single(predicate) {
    return function (source) { return source.lift(new SingleOperator(predicate, source)); };
}
var SingleOperator = /*@__PURE__*/ (function () {
    function SingleOperator(predicate, source) {
        this.predicate = predicate;
        this.source = source;
    }
    SingleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
    };
    return SingleOperator;
}());
var SingleSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](SingleSubscriber, _super);
    function SingleSubscriber(destination, predicate, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.seenValue = false;
        _this.index = 0;
        return _this;
    }
    SingleSubscriber.prototype.applySingleValue = function (value) {
        if (this.seenValue) {
            this.destination.error('Sequence contains more than one element');
        }
        else {
            this.seenValue = true;
            this.singleValue = value;
        }
    };
    SingleSubscriber.prototype._next = function (value) {
        var index = this.index++;
        if (this.predicate) {
            this.tryNext(value, index);
        }
        else {
            this.applySingleValue(value);
        }
    };
    SingleSubscriber.prototype.tryNext = function (value, index) {
        try {
            if (this.predicate(value, index, this.source)) {
                this.applySingleValue(value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    SingleSubscriber.prototype._complete = function () {
        var destination = this.destination;
        if (this.index > 0) {
            destination.next(this.seenValue ? this.singleValue : undefined);
            destination.complete();
        }
        else {
            destination.error(new _util_EmptyError__WEBPACK_IMPORTED_MODULE_2__["EmptyError"]);
        }
    };
    return SingleSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=single.js.map


/***/ }),
/* 402 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "skip", function() { return skip; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(233);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function skip(count) {
    return function (source) { return source.lift(new SkipOperator(count)); };
}
var SkipOperator = /*@__PURE__*/ (function () {
    function SkipOperator(total) {
        this.total = total;
    }
    SkipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipSubscriber(subscriber, this.total));
    };
    return SkipOperator;
}());
var SkipSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](SkipSubscriber, _super);
    function SkipSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
    }
    SkipSubscriber.prototype._next = function (x) {
        if (++this.count > this.total) {
            this.destination.next(x);
        }
    };
    return SkipSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=skip.js.map


/***/ }),
/* 403 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "skipLast", function() { return skipLast; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(233);
/* harmony import */ var _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(284);
/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError PURE_IMPORTS_END */



function skipLast(count) {
    return function (source) { return source.lift(new SkipLastOperator(count)); };
}
var SkipLastOperator = /*@__PURE__*/ (function () {
    function SkipLastOperator(_skipCount) {
        this._skipCount = _skipCount;
        if (this._skipCount < 0) {
            throw new _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_2__["ArgumentOutOfRangeError"];
        }
    }
    SkipLastOperator.prototype.call = function (subscriber, source) {
        if (this._skipCount === 0) {
            return source.subscribe(new _Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"](subscriber));
        }
        else {
            return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));
        }
    };
    return SkipLastOperator;
}());
var SkipLastSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](SkipLastSubscriber, _super);
    function SkipLastSubscriber(destination, _skipCount) {
        var _this = _super.call(this, destination) || this;
        _this._skipCount = _skipCount;
        _this._count = 0;
        _this._ring = new Array(_skipCount);
        return _this;
    }
    SkipLastSubscriber.prototype._next = function (value) {
        var skipCount = this._skipCount;
        var count = this._count++;
        if (count < skipCount) {
            this._ring[count] = value;
        }
        else {
            var currentIndex = count % skipCount;
            var ring = this._ring;
            var oldValue = ring[currentIndex];
            ring[currentIndex] = value;
            this.destination.next(oldValue);
        }
    };
    return SkipLastSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=skipLast.js.map


/***/ }),
/* 404 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "skipUntil", function() { return skipUntil; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(291);
/* harmony import */ var _InnerSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(293);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(292);
/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */




function skipUntil(notifier) {
    return function (source) { return source.lift(new SkipUntilOperator(notifier)); };
}
var SkipUntilOperator = /*@__PURE__*/ (function () {
    function SkipUntilOperator(notifier) {
        this.notifier = notifier;
    }
    SkipUntilOperator.prototype.call = function (destination, source) {
        return source.subscribe(new SkipUntilSubscriber(destination, this.notifier));
    };
    return SkipUntilOperator;
}());
var SkipUntilSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](SkipUntilSubscriber, _super);
    function SkipUntilSubscriber(destination, notifier) {
        var _this = _super.call(this, destination) || this;
        _this.hasValue = false;
        var innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_2__["InnerSubscriber"](_this, undefined, undefined);
        _this.add(innerSubscriber);
        _this.innerSubscription = innerSubscriber;
        Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__["subscribeToResult"])(_this, notifier, undefined, undefined, innerSubscriber);
        return _this;
    }
    SkipUntilSubscriber.prototype._next = function (value) {
        if (this.hasValue) {
            _super.prototype._next.call(this, value);
        }
    };
    SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.hasValue = true;
        if (this.innerSubscription) {
            this.innerSubscription.unsubscribe();
        }
    };
    SkipUntilSubscriber.prototype.notifyComplete = function () {
    };
    return SkipUntilSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"]));
//# sourceMappingURL=skipUntil.js.map


/***/ }),
/* 405 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "skipWhile", function() { return skipWhile; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(233);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function skipWhile(predicate) {
    return function (source) { return source.lift(new SkipWhileOperator(predicate)); };
}
var SkipWhileOperator = /*@__PURE__*/ (function () {
    function SkipWhileOperator(predicate) {
        this.predicate = predicate;
    }
    SkipWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
    };
    return SkipWhileOperator;
}());
var SkipWhileSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](SkipWhileSubscriber, _super);
    function SkipWhileSubscriber(destination, predicate) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.skipping = true;
        _this.index = 0;
        return _this;
    }
    SkipWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (this.skipping) {
            this.tryCallPredicate(value);
        }
        if (!this.skipping) {
            destination.next(value);
        }
    };
    SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {
        try {
            var result = this.predicate(value, this.index++);
            this.skipping = Boolean(result);
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    return SkipWhileSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=skipWhile.js.map


/***/ }),
/* 406 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "startWith", function() { return startWith; });
/* harmony import */ var _observable_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(301);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(267);
/** PURE_IMPORTS_START _observable_concat,_util_isScheduler PURE_IMPORTS_END */


function startWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        array[_i] = arguments[_i];
    }
    var scheduler = array[array.length - 1];
    if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_1__["isScheduler"])(scheduler)) {
        array.pop();
        return function (source) { return Object(_observable_concat__WEBPACK_IMPORTED_MODULE_0__["concat"])(array, source, scheduler); };
    }
    else {
        return function (source) { return Object(_observable_concat__WEBPACK_IMPORTED_MODULE_0__["concat"])(array, source); };
    }
}
//# sourceMappingURL=startWith.js.map


/***/ }),
/* 407 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subscribeOn", function() { return subscribeOn; });
/* harmony import */ var _observable_SubscribeOnObservable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(408);
/** PURE_IMPORTS_START _observable_SubscribeOnObservable PURE_IMPORTS_END */

function subscribeOn(scheduler, delay) {
    if (delay === void 0) {
        delay = 0;
    }
    return function subscribeOnOperatorFunction(source) {
        return source.lift(new SubscribeOnOperator(scheduler, delay));
    };
}
var SubscribeOnOperator = /*@__PURE__*/ (function () {
    function SubscribeOnOperator(scheduler, delay) {
        this.scheduler = scheduler;
        this.delay = delay;
    }
    SubscribeOnOperator.prototype.call = function (subscriber, source) {
        return new _observable_SubscribeOnObservable__WEBPACK_IMPORTED_MODULE_0__["SubscribeOnObservable"](source, this.delay, this.scheduler).subscribe(subscriber);
    };
    return SubscribeOnOperator;
}());
//# sourceMappingURL=subscribeOn.js.map


/***/ }),
/* 408 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubscribeOnObservable", function() { return SubscribeOnObservable; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(231);
/* harmony import */ var _scheduler_asap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(273);
/* harmony import */ var _util_isNumeric__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(319);
/** PURE_IMPORTS_START tslib,_Observable,_scheduler_asap,_util_isNumeric PURE_IMPORTS_END */




var SubscribeOnObservable = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](SubscribeOnObservable, _super);
    function SubscribeOnObservable(source, delayTime, scheduler) {
        if (delayTime === void 0) {
            delayTime = 0;
        }
        if (scheduler === void 0) {
            scheduler = _scheduler_asap__WEBPACK_IMPORTED_MODULE_2__["asap"];
        }
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.delayTime = delayTime;
        _this.scheduler = scheduler;
        if (!Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_3__["isNumeric"])(delayTime) || delayTime < 0) {
            _this.delayTime = 0;
        }
        if (!scheduler || typeof scheduler.schedule !== 'function') {
            _this.scheduler = _scheduler_asap__WEBPACK_IMPORTED_MODULE_2__["asap"];
        }
        return _this;
    }
    SubscribeOnObservable.create = function (source, delay, scheduler) {
        if (delay === void 0) {
            delay = 0;
        }
        if (scheduler === void 0) {
            scheduler = _scheduler_asap__WEBPACK_IMPORTED_MODULE_2__["asap"];
        }
        return new SubscribeOnObservable(source, delay, scheduler);
    };
    SubscribeOnObservable.dispatch = function (arg) {
        var source = arg.source, subscriber = arg.subscriber;
        return this.add(source.subscribe(subscriber));
    };
    SubscribeOnObservable.prototype._subscribe = function (subscriber) {
        var delay = this.delayTime;
        var source = this.source;
        var scheduler = this.scheduler;
        return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {
            source: source, subscriber: subscriber
        });
    };
    return SubscribeOnObservable;
}(_Observable__WEBPACK_IMPORTED_MODULE_1__["Observable"]));

//# sourceMappingURL=SubscribeOnObservable.js.map


/***/ }),
/* 409 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "switchAll", function() { return switchAll; });
/* harmony import */ var _switchMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(410);
/* harmony import */ var _util_identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(282);
/** PURE_IMPORTS_START _switchMap,_util_identity PURE_IMPORTS_END */


function switchAll() {
    return Object(_switchMap__WEBPACK_IMPORTED_MODULE_0__["switchMap"])(_util_identity__WEBPACK_IMPORTED_MODULE_1__["identity"]);
}
//# sourceMappingURL=switchAll.js.map


/***/ }),
/* 410 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "switchMap", function() { return switchMap; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(291);
/* harmony import */ var _InnerSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(293);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(292);
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(288);
/* harmony import */ var _observable_from__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(305);
/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */






function switchMap(project, resultSelector) {
    if (typeof resultSelector === 'function') {
        return function (source) { return source.pipe(switchMap(function (a, i) { return Object(_observable_from__WEBPACK_IMPORTED_MODULE_5__["from"])(project(a, i)).pipe(Object(_map__WEBPACK_IMPORTED_MODULE_4__["map"])(function (b, ii) { return resultSelector(a, b, i, ii); })); })); };
    }
    return function (source) { return source.lift(new SwitchMapOperator(project)); };
}
var SwitchMapOperator = /*@__PURE__*/ (function () {
    function SwitchMapOperator(project) {
        this.project = project;
    }
    SwitchMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
    };
    return SwitchMapOperator;
}());
var SwitchMapSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](SwitchMapSubscriber, _super);
    function SwitchMapSubscriber(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.index = 0;
        return _this;
    }
    SwitchMapSubscriber.prototype._next = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (error) {
            this.destination.error(error);
            return;
        }
        this._innerSub(result, value, index);
    };
    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        var innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_2__["InnerSubscriber"](this, undefined, undefined);
        var destination = this.destination;
        destination.add(innerSubscriber);
        this.innerSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__["subscribeToResult"])(this, result, value, index, innerSubscriber);
    };
    SwitchMapSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
        this.unsubscribe();
    };
    SwitchMapSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = null;
    };
    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var destination = this.destination;
        destination.remove(innerSub);
        this.innerSubscription = null;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    return SwitchMapSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"]));
//# sourceMappingURL=switchMap.js.map


/***/ }),
/* 411 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "switchMapTo", function() { return switchMapTo; });
/* harmony import */ var _switchMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(410);
/** PURE_IMPORTS_START _switchMap PURE_IMPORTS_END */

function switchMapTo(innerObservable, resultSelector) {
    return resultSelector ? Object(_switchMap__WEBPACK_IMPORTED_MODULE_0__["switchMap"])(function () { return innerObservable; }, resultSelector) : Object(_switchMap__WEBPACK_IMPORTED_MODULE_0__["switchMap"])(function () { return innerObservable; });
}
//# sourceMappingURL=switchMapTo.js.map


/***/ }),
/* 412 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "takeUntil", function() { return takeUntil; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(291);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(292);
/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */



function takeUntil(notifier) {
    return function (source) { return source.lift(new TakeUntilOperator(notifier)); };
}
var TakeUntilOperator = /*@__PURE__*/ (function () {
    function TakeUntilOperator(notifier) {
        this.notifier = notifier;
    }
    TakeUntilOperator.prototype.call = function (subscriber, source) {
        var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
        var notifierSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(takeUntilSubscriber, this.notifier);
        if (notifierSubscription && !takeUntilSubscriber.seenValue) {
            takeUntilSubscriber.add(notifierSubscription);
            return source.subscribe(takeUntilSubscriber);
        }
        return takeUntilSubscriber;
    };
    return TakeUntilOperator;
}());
var TakeUntilSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](TakeUntilSubscriber, _super);
    function TakeUntilSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.seenValue = false;
        return _this;
    }
    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.seenValue = true;
        this.complete();
    };
    TakeUntilSubscriber.prototype.notifyComplete = function () {
    };
    return TakeUntilSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"]));
//# sourceMappingURL=takeUntil.js.map


/***/ }),
/* 413 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "takeWhile", function() { return takeWhile; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(233);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function takeWhile(predicate, inclusive) {
    if (inclusive === void 0) {
        inclusive = false;
    }
    return function (source) {
        return source.lift(new TakeWhileOperator(predicate, inclusive));
    };
}
var TakeWhileOperator = /*@__PURE__*/ (function () {
    function TakeWhileOperator(predicate, inclusive) {
        this.predicate = predicate;
        this.inclusive = inclusive;
    }
    TakeWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));
    };
    return TakeWhileOperator;
}());
var TakeWhileSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](TakeWhileSubscriber, _super);
    function TakeWhileSubscriber(destination, predicate, inclusive) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.inclusive = inclusive;
        _this.index = 0;
        return _this;
    }
    TakeWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        var result;
        try {
            result = this.predicate(value, this.index++);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this.nextOrComplete(value, result);
    };
    TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {
        var destination = this.destination;
        if (Boolean(predicateResult)) {
            destination.next(value);
        }
        else {
            if (this.inclusive) {
                destination.next(value);
            }
            destination.complete();
        }
    };
    return TakeWhileSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=takeWhile.js.map


/***/ }),
/* 414 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tap", function() { return tap; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(233);
/* harmony import */ var _util_noop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(247);
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(235);
/** PURE_IMPORTS_START tslib,_Subscriber,_util_noop,_util_isFunction PURE_IMPORTS_END */




function tap(nextOrObserver, error, complete) {
    return function tapOperatorFunction(source) {
        return source.lift(new DoOperator(nextOrObserver, error, complete));
    };
}
var DoOperator = /*@__PURE__*/ (function () {
    function DoOperator(nextOrObserver, error, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
    }
    DoOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
    };
    return DoOperator;
}());
var TapSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](TapSubscriber, _super);
    function TapSubscriber(destination, observerOrNext, error, complete) {
        var _this = _super.call(this, destination) || this;
        _this._tapNext = _util_noop__WEBPACK_IMPORTED_MODULE_2__["noop"];
        _this._tapError = _util_noop__WEBPACK_IMPORTED_MODULE_2__["noop"];
        _this._tapComplete = _util_noop__WEBPACK_IMPORTED_MODULE_2__["noop"];
        _this._tapError = error || _util_noop__WEBPACK_IMPORTED_MODULE_2__["noop"];
        _this._tapComplete = complete || _util_noop__WEBPACK_IMPORTED_MODULE_2__["noop"];
        if (Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_3__["isFunction"])(observerOrNext)) {
            _this._context = _this;
            _this._tapNext = observerOrNext;
        }
        else if (observerOrNext) {
            _this._context = observerOrNext;
            _this._tapNext = observerOrNext.next || _util_noop__WEBPACK_IMPORTED_MODULE_2__["noop"];
            _this._tapError = observerOrNext.error || _util_noop__WEBPACK_IMPORTED_MODULE_2__["noop"];
            _this._tapComplete = observerOrNext.complete || _util_noop__WEBPACK_IMPORTED_MODULE_2__["noop"];
        }
        return _this;
    }
    TapSubscriber.prototype._next = function (value) {
        try {
            this._tapNext.call(this._context, value);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(value);
    };
    TapSubscriber.prototype._error = function (err) {
        try {
            this._tapError.call(this._context, err);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.error(err);
    };
    TapSubscriber.prototype._complete = function () {
        try {
            this._tapComplete.call(this._context);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        return this.destination.complete();
    };
    return TapSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=tap.js.map


/***/ }),
/* 415 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultThrottleConfig", function() { return defaultThrottleConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "throttle", function() { return throttle; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(291);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(292);
/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */



var defaultThrottleConfig = {
    leading: true,
    trailing: false
};
function throttle(durationSelector, config) {
    if (config === void 0) {
        config = defaultThrottleConfig;
    }
    return function (source) { return source.lift(new ThrottleOperator(durationSelector, config.leading, config.trailing)); };
}
var ThrottleOperator = /*@__PURE__*/ (function () {
    function ThrottleOperator(durationSelector, leading, trailing) {
        this.durationSelector = durationSelector;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
    };
    return ThrottleOperator;
}());
var ThrottleSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](ThrottleSubscriber, _super);
    function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.durationSelector = durationSelector;
        _this._leading = _leading;
        _this._trailing = _trailing;
        _this._hasValue = false;
        return _this;
    }
    ThrottleSubscriber.prototype._next = function (value) {
        this._hasValue = true;
        this._sendValue = value;
        if (!this._throttled) {
            if (this._leading) {
                this.send();
            }
            else {
                this.throttle(value);
            }
        }
    };
    ThrottleSubscriber.prototype.send = function () {
        var _a = this, _hasValue = _a._hasValue, _sendValue = _a._sendValue;
        if (_hasValue) {
            this.destination.next(_sendValue);
            this.throttle(_sendValue);
        }
        this._hasValue = false;
        this._sendValue = null;
    };
    ThrottleSubscriber.prototype.throttle = function (value) {
        var duration = this.tryDurationSelector(value);
        if (!!duration) {
            this.add(this._throttled = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(this, duration));
        }
    };
    ThrottleSubscriber.prototype.tryDurationSelector = function (value) {
        try {
            return this.durationSelector(value);
        }
        catch (err) {
            this.destination.error(err);
            return null;
        }
    };
    ThrottleSubscriber.prototype.throttlingDone = function () {
        var _a = this, _throttled = _a._throttled, _trailing = _a._trailing;
        if (_throttled) {
            _throttled.unsubscribe();
        }
        this._throttled = null;
        if (_trailing) {
            this.send();
        }
    };
    ThrottleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.throttlingDone();
    };
    ThrottleSubscriber.prototype.notifyComplete = function () {
        this.throttlingDone();
    };
    return ThrottleSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"]));
//# sourceMappingURL=throttle.js.map


/***/ }),
/* 416 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "throttleTime", function() { return throttleTime; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(233);
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(277);
/* harmony import */ var _throttle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(415);
/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async,_throttle PURE_IMPORTS_END */




function throttleTime(duration, scheduler, config) {
    if (scheduler === void 0) {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_2__["async"];
    }
    if (config === void 0) {
        config = _throttle__WEBPACK_IMPORTED_MODULE_3__["defaultThrottleConfig"];
    }
    return function (source) { return source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing)); };
}
var ThrottleTimeOperator = /*@__PURE__*/ (function () {
    function ThrottleTimeOperator(duration, scheduler, leading, trailing) {
        this.duration = duration;
        this.scheduler = scheduler;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
    };
    return ThrottleTimeOperator;
}());
var ThrottleTimeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](ThrottleTimeSubscriber, _super);
    function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {
        var _this = _super.call(this, destination) || this;
        _this.duration = duration;
        _this.scheduler = scheduler;
        _this.leading = leading;
        _this.trailing = trailing;
        _this._hasTrailingValue = false;
        _this._trailingValue = null;
        return _this;
    }
    ThrottleTimeSubscriber.prototype._next = function (value) {
        if (this.throttled) {
            if (this.trailing) {
                this._trailingValue = value;
                this._hasTrailingValue = true;
            }
        }
        else {
            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));
            if (this.leading) {
                this.destination.next(value);
            }
            else if (this.trailing) {
                this._trailingValue = value;
                this._hasTrailingValue = true;
            }
        }
    };
    ThrottleTimeSubscriber.prototype._complete = function () {
        if (this._hasTrailingValue) {
            this.destination.next(this._trailingValue);
            this.destination.complete();
        }
        else {
            this.destination.complete();
        }
    };
    ThrottleTimeSubscriber.prototype.clearThrottle = function () {
        var throttled = this.throttled;
        if (throttled) {
            if (this.trailing && this._hasTrailingValue) {
                this.destination.next(this._trailingValue);
                this._trailingValue = null;
                this._hasTrailingValue = false;
            }
            throttled.unsubscribe();
            this.remove(throttled);
            this.throttled = null;
        }
    };
    return ThrottleTimeSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
function dispatchNext(arg) {
    var subscriber = arg.subscriber;
    subscriber.clearThrottle();
}
//# sourceMappingURL=throttleTime.js.map


/***/ }),
/* 417 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timeInterval", function() { return timeInterval; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimeInterval", function() { return TimeInterval; });
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(277);
/* harmony import */ var _scan__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(377);
/* harmony import */ var _observable_defer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(312);
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(288);
/** PURE_IMPORTS_START _scheduler_async,_scan,_observable_defer,_map PURE_IMPORTS_END */




function timeInterval(scheduler) {
    if (scheduler === void 0) {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_0__["async"];
    }
    return function (source) {
        return Object(_observable_defer__WEBPACK_IMPORTED_MODULE_2__["defer"])(function () {
            return source.pipe(Object(_scan__WEBPACK_IMPORTED_MODULE_1__["scan"])(function (_a, value) {
                var current = _a.current;
                return ({ value: value, current: scheduler.now(), last: current });
            }, { current: scheduler.now(), value: undefined, last: undefined }), Object(_map__WEBPACK_IMPORTED_MODULE_3__["map"])(function (_a) {
                var current = _a.current, last = _a.last, value = _a.value;
                return new TimeInterval(value, current - last);
            }));
        });
    };
}
var TimeInterval = /*@__PURE__*/ (function () {
    function TimeInterval(value, interval) {
        this.value = value;
        this.interval = interval;
    }
    return TimeInterval;
}());

//# sourceMappingURL=timeInterval.js.map


/***/ }),
/* 418 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timeout", function() { return timeout; });
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(277);
/* harmony import */ var _util_TimeoutError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(286);
/* harmony import */ var _timeoutWith__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(419);
/* harmony import */ var _observable_throwError__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(271);
/** PURE_IMPORTS_START _scheduler_async,_util_TimeoutError,_timeoutWith,_observable_throwError PURE_IMPORTS_END */




function timeout(due, scheduler) {
    if (scheduler === void 0) {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_0__["async"];
    }
    return Object(_timeoutWith__WEBPACK_IMPORTED_MODULE_2__["timeoutWith"])(due, Object(_observable_throwError__WEBPACK_IMPORTED_MODULE_3__["throwError"])(new _util_TimeoutError__WEBPACK_IMPORTED_MODULE_1__["TimeoutError"]()), scheduler);
}
//# sourceMappingURL=timeout.js.map


/***/ }),
/* 419 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timeoutWith", function() { return timeoutWith; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(277);
/* harmony import */ var _util_isDate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(351);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(291);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(292);
/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */





function timeoutWith(due, withObservable, scheduler) {
    if (scheduler === void 0) {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__["async"];
    }
    return function (source) {
        var absoluteTimeout = Object(_util_isDate__WEBPACK_IMPORTED_MODULE_2__["isDate"])(due);
        var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);
        return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
    };
}
var TimeoutWithOperator = /*@__PURE__*/ (function () {
    function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {
        this.waitFor = waitFor;
        this.absoluteTimeout = absoluteTimeout;
        this.withObservable = withObservable;
        this.scheduler = scheduler;
    }
    TimeoutWithOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
    };
    return TimeoutWithOperator;
}());
var TimeoutWithSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](TimeoutWithSubscriber, _super);
    function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.absoluteTimeout = absoluteTimeout;
        _this.waitFor = waitFor;
        _this.withObservable = withObservable;
        _this.scheduler = scheduler;
        _this.action = null;
        _this.scheduleTimeout();
        return _this;
    }
    TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {
        var withObservable = subscriber.withObservable;
        subscriber._unsubscribeAndRecycle();
        subscriber.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__["subscribeToResult"])(subscriber, withObservable));
    };
    TimeoutWithSubscriber.prototype.scheduleTimeout = function () {
        var action = this.action;
        if (action) {
            this.action = action.schedule(this, this.waitFor);
        }
        else {
            this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));
        }
    };
    TimeoutWithSubscriber.prototype._next = function (value) {
        if (!this.absoluteTimeout) {
            this.scheduleTimeout();
        }
        _super.prototype._next.call(this, value);
    };
    TimeoutWithSubscriber.prototype._unsubscribe = function () {
        this.action = null;
        this.scheduler = null;
        this.withObservable = null;
    };
    return TimeoutWithSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__["OuterSubscriber"]));
//# sourceMappingURL=timeoutWith.js.map


/***/ }),
/* 420 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timestamp", function() { return timestamp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Timestamp", function() { return Timestamp; });
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(277);
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(288);
/** PURE_IMPORTS_START _scheduler_async,_map PURE_IMPORTS_END */


function timestamp(scheduler) {
    if (scheduler === void 0) {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_0__["async"];
    }
    return Object(_map__WEBPACK_IMPORTED_MODULE_1__["map"])(function (value) { return new Timestamp(value, scheduler.now()); });
}
var Timestamp = /*@__PURE__*/ (function () {
    function Timestamp(value, timestamp) {
        this.value = value;
        this.timestamp = timestamp;
    }
    return Timestamp;
}());

//# sourceMappingURL=timestamp.js.map


/***/ }),
/* 421 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toArray", function() { return toArray; });
/* harmony import */ var _reduce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(376);
/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */

function toArrayReducer(arr, item, index) {
    if (index === 0) {
        return [item];
    }
    arr.push(item);
    return arr;
}
function toArray() {
    return Object(_reduce__WEBPACK_IMPORTED_MODULE_0__["reduce"])(toArrayReducer, []);
}
//# sourceMappingURL=toArray.js.map


/***/ }),
/* 422 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "window", function() { return window; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(249);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(291);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(292);
/** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */




function window(windowBoundaries) {
    return function windowOperatorFunction(source) {
        return source.lift(new WindowOperator(windowBoundaries));
    };
}
var WindowOperator = /*@__PURE__*/ (function () {
    function WindowOperator(windowBoundaries) {
        this.windowBoundaries = windowBoundaries;
    }
    WindowOperator.prototype.call = function (subscriber, source) {
        var windowSubscriber = new WindowSubscriber(subscriber);
        var sourceSubscription = source.subscribe(windowSubscriber);
        if (!sourceSubscription.closed) {
            windowSubscriber.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__["subscribeToResult"])(windowSubscriber, this.windowBoundaries));
        }
        return sourceSubscription;
    };
    return WindowOperator;
}());
var WindowSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](WindowSubscriber, _super);
    function WindowSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.window = new _Subject__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
        destination.next(_this.window);
        return _this;
    }
    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openWindow();
    };
    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
        this._complete();
    };
    WindowSubscriber.prototype._next = function (value) {
        this.window.next(value);
    };
    WindowSubscriber.prototype._error = function (err) {
        this.window.error(err);
        this.destination.error(err);
    };
    WindowSubscriber.prototype._complete = function () {
        this.window.complete();
        this.destination.complete();
    };
    WindowSubscriber.prototype._unsubscribe = function () {
        this.window = null;
    };
    WindowSubscriber.prototype.openWindow = function () {
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        var destination = this.destination;
        var newWindow = this.window = new _Subject__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
        destination.next(newWindow);
    };
    return WindowSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__["OuterSubscriber"]));
//# sourceMappingURL=window.js.map


/***/ }),
/* 423 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "windowCount", function() { return windowCount; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(233);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(249);
/** PURE_IMPORTS_START tslib,_Subscriber,_Subject PURE_IMPORTS_END */



function windowCount(windowSize, startWindowEvery) {
    if (startWindowEvery === void 0) {
        startWindowEvery = 0;
    }
    return function windowCountOperatorFunction(source) {
        return source.lift(new WindowCountOperator(windowSize, startWindowEvery));
    };
}
var WindowCountOperator = /*@__PURE__*/ (function () {
    function WindowCountOperator(windowSize, startWindowEvery) {
        this.windowSize = windowSize;
        this.startWindowEvery = startWindowEvery;
    }
    WindowCountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
    };
    return WindowCountOperator;
}());
var WindowCountSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](WindowCountSubscriber, _super);
    function WindowCountSubscriber(destination, windowSize, startWindowEvery) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.windowSize = windowSize;
        _this.startWindowEvery = startWindowEvery;
        _this.windows = [new _Subject__WEBPACK_IMPORTED_MODULE_2__["Subject"]()];
        _this.count = 0;
        destination.next(_this.windows[0]);
        return _this;
    }
    WindowCountSubscriber.prototype._next = function (value) {
        var startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;
        var destination = this.destination;
        var windowSize = this.windowSize;
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len && !this.closed; i++) {
            windows[i].next(value);
        }
        var c = this.count - windowSize + 1;
        if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {
            windows.shift().complete();
        }
        if (++this.count % startWindowEvery === 0 && !this.closed) {
            var window_1 = new _Subject__WEBPACK_IMPORTED_MODULE_2__["Subject"]();
            windows.push(window_1);
            destination.next(window_1);
        }
    };
    WindowCountSubscriber.prototype._error = function (err) {
        var windows = this.windows;
        if (windows) {
            while (windows.length > 0 && !this.closed) {
                windows.shift().error(err);
            }
        }
        this.destination.error(err);
    };
    WindowCountSubscriber.prototype._complete = function () {
        var windows = this.windows;
        if (windows) {
            while (windows.length > 0 && !this.closed) {
                windows.shift().complete();
            }
        }
        this.destination.complete();
    };
    WindowCountSubscriber.prototype._unsubscribe = function () {
        this.count = 0;
        this.windows = null;
    };
    return WindowCountSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"]));
//# sourceMappingURL=windowCount.js.map


/***/ }),
/* 424 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "windowTime", function() { return windowTime; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(249);
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(277);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(233);
/* harmony import */ var _util_isNumeric__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(319);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(267);
/** PURE_IMPORTS_START tslib,_Subject,_scheduler_async,_Subscriber,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */






function windowTime(windowTimeSpan) {
    var scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_2__["async"];
    var windowCreationInterval = null;
    var maxWindowSize = Number.POSITIVE_INFINITY;
    if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_5__["isScheduler"])(arguments[3])) {
        scheduler = arguments[3];
    }
    if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_5__["isScheduler"])(arguments[2])) {
        scheduler = arguments[2];
    }
    else if (Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_4__["isNumeric"])(arguments[2])) {
        maxWindowSize = arguments[2];
    }
    if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_5__["isScheduler"])(arguments[1])) {
        scheduler = arguments[1];
    }
    else if (Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_4__["isNumeric"])(arguments[1])) {
        windowCreationInterval = arguments[1];
    }
    return function windowTimeOperatorFunction(source) {
        return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));
    };
}
var WindowTimeOperator = /*@__PURE__*/ (function () {
    function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        this.windowTimeSpan = windowTimeSpan;
        this.windowCreationInterval = windowCreationInterval;
        this.maxWindowSize = maxWindowSize;
        this.scheduler = scheduler;
    }
    WindowTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
    };
    return WindowTimeOperator;
}());
var CountedSubject = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](CountedSubject, _super);
    function CountedSubject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._numberOfNextedValues = 0;
        return _this;
    }
    CountedSubject.prototype.next = function (value) {
        this._numberOfNextedValues++;
        _super.prototype.next.call(this, value);
    };
    Object.defineProperty(CountedSubject.prototype, "numberOfNextedValues", {
        get: function () {
            return this._numberOfNextedValues;
        },
        enumerable: true,
        configurable: true
    });
    return CountedSubject;
}(_Subject__WEBPACK_IMPORTED_MODULE_1__["Subject"]));
var WindowTimeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](WindowTimeSubscriber, _super);
    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.windowTimeSpan = windowTimeSpan;
        _this.windowCreationInterval = windowCreationInterval;
        _this.maxWindowSize = maxWindowSize;
        _this.scheduler = scheduler;
        _this.windows = [];
        var window = _this.openWindow();
        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
            var closeState = { subscriber: _this, window: window, context: null };
            var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: _this, scheduler: scheduler };
            _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
            _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
        }
        else {
            var timeSpanOnlyState = { subscriber: _this, window: window, windowTimeSpan: windowTimeSpan };
            _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
        }
        return _this;
    }
    WindowTimeSubscriber.prototype._next = function (value) {
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len; i++) {
            var window_1 = windows[i];
            if (!window_1.closed) {
                window_1.next(value);
                if (window_1.numberOfNextedValues >= this.maxWindowSize) {
                    this.closeWindow(window_1);
                }
            }
        }
    };
    WindowTimeSubscriber.prototype._error = function (err) {
        var windows = this.windows;
        while (windows.length > 0) {
            windows.shift().error(err);
        }
        this.destination.error(err);
    };
    WindowTimeSubscriber.prototype._complete = function () {
        var windows = this.windows;
        while (windows.length > 0) {
            var window_2 = windows.shift();
            if (!window_2.closed) {
                window_2.complete();
            }
        }
        this.destination.complete();
    };
    WindowTimeSubscriber.prototype.openWindow = function () {
        var window = new CountedSubject();
        this.windows.push(window);
        var destination = this.destination;
        destination.next(window);
        return window;
    };
    WindowTimeSubscriber.prototype.closeWindow = function (window) {
        window.complete();
        var windows = this.windows;
        windows.splice(windows.indexOf(window), 1);
    };
    return WindowTimeSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_3__["Subscriber"]));
function dispatchWindowTimeSpanOnly(state) {
    var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window = state.window;
    if (window) {
        subscriber.closeWindow(window);
    }
    state.window = subscriber.openWindow();
    this.schedule(state, windowTimeSpan);
}
function dispatchWindowCreation(state) {
    var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;
    var window = subscriber.openWindow();
    var action = this;
    var context = { action: action, subscription: null };
    var timeSpanState = { subscriber: subscriber, window: window, context: context };
    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
    action.add(context.subscription);
    action.schedule(state, windowCreationInterval);
}
function dispatchWindowClose(state) {
    var subscriber = state.subscriber, window = state.window, context = state.context;
    if (context && context.action && context.subscription) {
        context.action.remove(context.subscription);
    }
    subscriber.closeWindow(window);
}
//# sourceMappingURL=windowTime.js.map


/***/ }),
/* 425 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "windowToggle", function() { return windowToggle; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(249);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(239);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(291);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(292);
/** PURE_IMPORTS_START tslib,_Subject,_Subscription,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */





function windowToggle(openings, closingSelector) {
    return function (source) { return source.lift(new WindowToggleOperator(openings, closingSelector)); };
}
var WindowToggleOperator = /*@__PURE__*/ (function () {
    function WindowToggleOperator(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
    }
    WindowToggleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
    };
    return WindowToggleOperator;
}());
var WindowToggleSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](WindowToggleSubscriber, _super);
    function WindowToggleSubscriber(destination, openings, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.openings = openings;
        _this.closingSelector = closingSelector;
        _this.contexts = [];
        _this.add(_this.openSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__["subscribeToResult"])(_this, openings, openings));
        return _this;
    }
    WindowToggleSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        if (contexts) {
            var len = contexts.length;
            for (var i = 0; i < len; i++) {
                contexts[i].window.next(value);
            }
        }
    };
    WindowToggleSubscriber.prototype._error = function (err) {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context_1 = contexts[index];
                context_1.window.error(err);
                context_1.subscription.unsubscribe();
            }
        }
        _super.prototype._error.call(this, err);
    };
    WindowToggleSubscriber.prototype._complete = function () {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context_2 = contexts[index];
                context_2.window.complete();
                context_2.subscription.unsubscribe();
            }
        }
        _super.prototype._complete.call(this);
    };
    WindowToggleSubscriber.prototype._unsubscribe = function () {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context_3 = contexts[index];
                context_3.window.unsubscribe();
                context_3.subscription.unsubscribe();
            }
        }
    };
    WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (outerValue === this.openings) {
            var closingNotifier = void 0;
            try {
                var closingSelector = this.closingSelector;
                closingNotifier = closingSelector(innerValue);
            }
            catch (e) {
                return this.error(e);
            }
            var window_1 = new _Subject__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
            var subscription = new _Subscription__WEBPACK_IMPORTED_MODULE_2__["Subscription"]();
            var context_4 = { window: window_1, subscription: subscription };
            this.contexts.push(context_4);
            var innerSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__["subscribeToResult"])(this, closingNotifier, context_4);
            if (innerSubscription.closed) {
                this.closeWindow(this.contexts.length - 1);
            }
            else {
                innerSubscription.context = context_4;
                subscription.add(innerSubscription);
            }
            this.destination.next(window_1);
        }
        else {
            this.closeWindow(this.contexts.indexOf(outerValue));
        }
    };
    WindowToggleSubscriber.prototype.notifyError = function (err) {
        this.error(err);
    };
    WindowToggleSubscriber.prototype.notifyComplete = function (inner) {
        if (inner !== this.openSubscription) {
            this.closeWindow(this.contexts.indexOf(inner.context));
        }
    };
    WindowToggleSubscriber.prototype.closeWindow = function (index) {
        if (index === -1) {
            return;
        }
        var contexts = this.contexts;
        var context = contexts[index];
        var window = context.window, subscription = context.subscription;
        contexts.splice(index, 1);
        window.complete();
        subscription.unsubscribe();
    };
    return WindowToggleSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__["OuterSubscriber"]));
//# sourceMappingURL=windowToggle.js.map


/***/ }),
/* 426 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "windowWhen", function() { return windowWhen; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(249);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(291);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(292);
/** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */




function windowWhen(closingSelector) {
    return function windowWhenOperatorFunction(source) {
        return source.lift(new WindowOperator(closingSelector));
    };
}
var WindowOperator = /*@__PURE__*/ (function () {
    function WindowOperator(closingSelector) {
        this.closingSelector = closingSelector;
    }
    WindowOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));
    };
    return WindowOperator;
}());
var WindowSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](WindowSubscriber, _super);
    function WindowSubscriber(destination, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.closingSelector = closingSelector;
        _this.openWindow();
        return _this;
    }
    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openWindow(innerSub);
    };
    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
        this.openWindow(innerSub);
    };
    WindowSubscriber.prototype._next = function (value) {
        this.window.next(value);
    };
    WindowSubscriber.prototype._error = function (err) {
        this.window.error(err);
        this.destination.error(err);
        this.unsubscribeClosingNotification();
    };
    WindowSubscriber.prototype._complete = function () {
        this.window.complete();
        this.destination.complete();
        this.unsubscribeClosingNotification();
    };
    WindowSubscriber.prototype.unsubscribeClosingNotification = function () {
        if (this.closingNotification) {
            this.closingNotification.unsubscribe();
        }
    };
    WindowSubscriber.prototype.openWindow = function (innerSub) {
        if (innerSub === void 0) {
            innerSub = null;
        }
        if (innerSub) {
            this.remove(innerSub);
            innerSub.unsubscribe();
        }
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        var window = this.window = new _Subject__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
        this.destination.next(window);
        var closingNotifier;
        try {
            var closingSelector = this.closingSelector;
            closingNotifier = closingSelector();
        }
        catch (e) {
            this.destination.error(e);
            this.window.error(e);
            return;
        }
        this.add(this.closingNotification = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__["subscribeToResult"])(this, closingNotifier));
    };
    return WindowSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__["OuterSubscriber"]));
//# sourceMappingURL=windowWhen.js.map


/***/ }),
/* 427 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "withLatestFrom", function() { return withLatestFrom; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(291);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(292);
/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */



function withLatestFrom() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return function (source) {
        var project;
        if (typeof args[args.length - 1] === 'function') {
            project = args.pop();
        }
        var observables = args;
        return source.lift(new WithLatestFromOperator(observables, project));
    };
}
var WithLatestFromOperator = /*@__PURE__*/ (function () {
    function WithLatestFromOperator(observables, project) {
        this.observables = observables;
        this.project = project;
    }
    WithLatestFromOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
    };
    return WithLatestFromOperator;
}());
var WithLatestFromSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](WithLatestFromSubscriber, _super);
    function WithLatestFromSubscriber(destination, observables, project) {
        var _this = _super.call(this, destination) || this;
        _this.observables = observables;
        _this.project = project;
        _this.toRespond = [];
        var len = observables.length;
        _this.values = new Array(len);
        for (var i = 0; i < len; i++) {
            _this.toRespond.push(i);
        }
        for (var i = 0; i < len; i++) {
            var observable = observables[i];
            _this.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(_this, observable, observable, i));
        }
        return _this;
    }
    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values[outerIndex] = innerValue;
        var toRespond = this.toRespond;
        if (toRespond.length > 0) {
            var found = toRespond.indexOf(outerIndex);
            if (found !== -1) {
                toRespond.splice(found, 1);
            }
        }
    };
    WithLatestFromSubscriber.prototype.notifyComplete = function () {
    };
    WithLatestFromSubscriber.prototype._next = function (value) {
        if (this.toRespond.length === 0) {
            var args = [value].concat(this.values);
            if (this.project) {
                this._tryProject(args);
            }
            else {
                this.destination.next(args);
            }
        }
    };
    WithLatestFromSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return WithLatestFromSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"]));
//# sourceMappingURL=withLatestFrom.js.map


/***/ }),
/* 428 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zip", function() { return zip; });
/* harmony import */ var _observable_zip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(331);
/** PURE_IMPORTS_START _observable_zip PURE_IMPORTS_END */

function zip() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return function zipOperatorFunction(source) {
        return source.lift.call(_observable_zip__WEBPACK_IMPORTED_MODULE_0__["zip"].apply(void 0, [source].concat(observables)));
    };
}
//# sourceMappingURL=zip.js.map


/***/ }),
/* 429 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zipAll", function() { return zipAll; });
/* harmony import */ var _observable_zip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(331);
/** PURE_IMPORTS_START _observable_zip PURE_IMPORTS_END */

function zipAll(project) {
    return function (source) { return source.lift(new _observable_zip__WEBPACK_IMPORTED_MODULE_0__["ZipOperator"](project)); };
}
//# sourceMappingURL=zipAll.js.map


/***/ }),
/* 430 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Util = __webpack_require__(72);

var _Util2 = _interopRequireDefault(_Util);

var _rxjs = __webpack_require__(230);

var _zeptoWebpack = __webpack_require__(146);

var _zeptoWebpack2 = _interopRequireDefault(_zeptoWebpack);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function EventsObservable(mgr, confrId, onRemoteStream) {
    this.mgr = mgr;
    this.confrId = confrId;
    init.apply(this);
    this.subject = new _rxjs.Subject();
    this.onRemoteStream = onRemoteStream;
}

function init() {
    _Util2.default.extend(this, {
        subscribe: function subscribe(observerOrNext, error, complete) {
            return this.subject.subscribe(observerOrNext, error, complete);
        }
    }, { //以下监听，this object == me == service.current
        onMeExit: function onMeExit(reason, failed) {
            this.mgr._onExit(this.confrId, reason, failed);

            if (this.mgr.upload_stats) {
                // upload call analysis

                this.mgr.upload_stats.upload_event({
                    event: 1,
                    reason: reason,
                    sessionId: this._session._sessionId
                });
            }
        },

        onAddMember: function onAddMember(member) {
            this.mgr.onMemberJoin(member, this.confrId);

            if (this.mgr.upload_stats) {
                // upload call analysis
                var role = member.role,
                    addMemName = member.memName,
                    addMemId = member.id;


                this.mgr.upload_stats.upload_event({
                    event: 10,
                    role: role,
                    addMemName: addMemName,
                    addMemId: addMemId
                });
            }
        },
        onRemoveMember: function onRemoveMember(member, reason) {
            this.mgr.onMemberLeave(member, reason, this.confrId);

            if (this.mgr.upload_stats) {
                // upload call analysis
                var role = member.role,
                    removeMemName = member.memName,
                    removeMemId = member.id;


                this.mgr.upload_stats.upload_event({
                    event: 11,
                    role: role,
                    removeMemName: removeMemName,
                    removeMemId: removeMemId
                });
            }
        },

        onAddStream: function onAddStream(stream) {

            if (stream.id == 0) {
                return;
            }
            if (!stream.located()) {
                this.onRemoteStream && this.onRemoteStream(stream);
            }

            this.mgr.streamBindVideo(stream, undefined, this.confrId);
            this.mgr._onAddMemberStream(stream, this.confrId);

            if (!stream.located()) {
                // only sub stream

                if (this.mgr.upload_stats) {
                    // upload call analysis
                    var sId = stream.id,
                        voff = stream.voff,
                        aoff = stream.aoff,
                        streamType = stream.type,
                        addMemId = stream.memId,
                        addMemName = stream.memName;


                    this.mgr.upload_stats.upload_event({
                        event: 12,
                        sId: sId,
                        voff: voff,
                        aoff: aoff,
                        streamType: streamType,
                        addMemId: addMemId,
                        addMemName: addMemName
                    });
                }
            }
        },
        onRemoveStream: function onRemoveStream(stream) {
            if (stream.id == 0) {
                return;
            }

            var confr = this.mgr._confr(this.confrId);
            if (confr && stream && stream.located()) {
                confr.av && confr.av.id === stream.id && (confr.av = undefined);
                confr.desktop && confr.desktop.id === stream.id && (confr.desktop = undefined);
            }

            var video = _Util2.default.removeAttribute(this.mgr._videos, stream.id);
            this.mgr._onRemoveMemberStream(stream, this.confrId);
            video && this.mgr.unloadVideo(stream.owner, stream, video);

            if (!stream.located()) {
                // only sub stream

                if (this.mgr.upload_stats) {
                    // upload call analysis
                    var sId = stream.id,
                        streamType = stream.type,
                        removeMemId = stream.memId,
                        removeMemName = stream.memName;


                    this.mgr.upload_stats.upload_event({
                        event: 13,
                        sId: sId,
                        streamType: streamType,
                        removeMemId: removeMemId,
                        removeMemName: removeMemName
                    });
                }
            }
        },
        onUpdateStream: function onUpdateStream(stream, update) {
            if (stream.id == 0) {
                return;
            }

            var self = this;

            var videoTag = this.mgr._videos[stream.id];
            if (videoTag) {
                update && update.ifMediaStream(function (mediaStream) {
                    videoTag && attachMediaStream(videoTag, mediaStream);

                    if (videoTag && videoTag.hasAttribute("flow")) {
                        self.mgr.onMediaTransmission(videoTag, function cb(trackId, type, subtype, data) {
                            (0, _zeptoWebpack2.default)(videoTag).trigger("onMediaTransmission", [trackId, type, subtype, data]);
                        });
                    }
                });

                stream.aoff ? videoTag.setAttribute("aoff", "aoff") : videoTag.removeAttribute("aoff");
                stream.voff ? videoTag.setAttribute("voff", "voff") : videoTag.removeAttribute("voff");
            }

            var constaints = { video: !stream.voff, audio: !stream.aoff };
            update && update.ifVoff(function (voff) {
                constaints || (constaints = {});
                constaints.video = !voff;
                if (!stream.located()) {
                    //constaints.video = constaints.video && (!stream.subArgs ||(stream.subArgs && stream.subArgs.subSVideo));
                    constaints.video = stream.subArgs ? stream.subArgs.subSVideo : !stream.voff;
                }
            });
            update && update.ifAoff(function (aoff) {
                constaints || (constaints = {});
                constaints.audio = !aoff;
                if (!stream.located()) {
                    //constaints.audio = constaints.audio && (!stream.subArgs ||(stream.subArgs && stream.subArgs.subSAudio));
                    constaints.audio = stream.subArgs ? stream.subArgs.subSAudio : !stream.aoff;

                    if (stream.type === 2) {
                        constaints.audio = true;
                    }
                }
            });

            constaints && this.mgr._onMemberMediaChanaged(stream.owner, stream, constaints, this.confrId);
            constaints && this.mgr._onUpdateMemberStream(stream, constaints, this.confrId);
        },
        onNetworkWeak: function onNetworkWeak() {},
        onNotSupportPublishVideoCodecs: function onNotSupportPublishVideoCodecs(stream) {
            this.mgr._onNotSupportMemberPublishVideoCodecs(stream, this.confrId);
        },
        onRecvRemoteMessage: function onRecvRemoteMessage(fromMember, argsObject) {
            this.mgr._onRecvRemoteMessage(fromMember, argsObject, this.confrId);
        },

        onSoundChanage: function onSoundChanage(member, stream, meterData) {
            this.mgr._onMemberSoundChanaged(member, stream, meterData, this.confrId);
        },
        onTalking: function onTalking(member, stream, meterData) {
            this.mgr._onTalking(member, stream, meterData, this.confrId);
        },

        onRoleUpdate: function onRoleUpdate(role, roleToken) {

            var confr = this.mgr._confrs[this.confrId];
            roleToken && (confr.roleToken = roleToken);
            confr.role = role;

            if (role == this.mgr.Role.AUDIENCE) {
                confr.av && this.mgr.hungup(confr.av);
                confr.desktop && this.mgr.hungup(confr.desktop);
            }

            this.mgr._onRoleUpdated(role, this.confrId);

            if (this.mgr.upload_stats) {
                // upload call analysis

                this.mgr.upload_stats.upload_event({
                    event: 21,
                    role: role,
                    sessionId: this._session._sessionId
                });
            }
        },

        onNotifyEvent: function onNotifyEvent(evt) {
            var self = this;

            try {
                if (evt instanceof emedia.event.ICEChanage) {
                    var webrtc = evt.webrtc;
                    var state = evt.state;
                    _Util2.default.forEach(self._cacheStreams, function (sid, stream) {
                        if (stream.rtcId == webrtc.getRtcId()) {

                            var _stream = _Util2.default.extend({}, stream);
                            var _member = _Util2.default.extend({}, stream.owner);

                            self.mgr._onStreamIceStateChanged(_member, _stream, state, self.confrId);
                        }
                    });
                }
            } finally {
                self.subject.next(evt);
            }
        }
    });
}

exports.default = EventsObservable;

/***/ }),
/* 431 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _stringify = __webpack_require__(144);

var _stringify2 = _interopRequireDefault(_stringify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _util = __webpack_require__(72);
var _logger = _util.tagLogger("PannelVideo");

var Mouse = __webpack_require__(432);
var Keyboard = __webpack_require__(433);
var MouseTrack = __webpack_require__(221);
var MouseTrigger = __webpack_require__(222);
var TotalBuffer = __webpack_require__(434);

function overrideOnRemoveMember(service) {
    overrideOnRemoveMember._overrideCount++;
    if (overrideOnRemoveMember.overrideObj === service) {
        return;
    }

    overrideOnRemoveMember.overrideObj = service;
    onRemoveMember.override = service.listeners.onRemoveMember;
    onRemoveMember.overrideService = service;
    service.listeners.onRemoveMember = onRemoveMember;
}
overrideOnRemoveMember._overrideCount = 0;

function onRemoveMember(member, reason) {
    try {
        var remoteControls = member && member.id && selectRemoteControlByMemId(onRemoveMember.overrideService, member.id);

        if (remoteControls && remoteControls.length) {
            _util.forEach(remoteControls, function (_index, ctrl) {
                _logger.warn("Remove member. free remote controller. it is ", ctrl.id, ctrl._ctrlStream.id, ctrl._controller.memName, member.id);

                ctrl._free(); //超时清空

                ctrl._callbacks && ctrl._callbacks.onRemoteFreeControl && ctrl._callbacks.onRemoteFreeControl(ctrl._ctrlStream, ctrl._controller, ctrl._cId);
            });
        }
    } finally {
        onRemoveMember.override && onRemoveMember.override.apply(this, arguments);
    }
}

function overrideOnRemoveStream(service) {
    overrideOnRemoveStream._overrideCount++;
    if (overrideOnRemoveStream.overrideObj === service) {
        return;
    }

    overrideOnRemoveStream.overrideObj = service;
    onRemoveStream.override = service.listeners.onRemoveStream;
    onRemoveStream.overrideService = service;
    service.listeners.onRemoveStream = onRemoveStream;
}
overrideOnRemoveStream._overrideCount = 0;

function resetOnRemoveStream(service) {
    // overrideOnRemoveStream._overrideCount--;
    //
    // if(overrideOnRemoveStream._overrideCount === 0){
    //     service.current.onRemoveStream = onRemoveStream.override;
    //     overrideOnRemoveStream.overrideObj = undefined;
    // }
}

function onRemoveStream(stream) {
    doCleanAfterStreamClose(onRemoveStream.overrideService, stream);

    onRemoveStream.override && onRemoveStream.override.apply(this, arguments);
}

function doCleanAfterStreamClose(service, stream) {
    disControlled(service, stream.id);

    var controls = getRemoteControl(service, stream);
    controls && _util.forEach(controls, function (_i, control) {
        control._free && control._free();
    });

    _util.removeAttribute(service.current.__remoteControls, stream.id);
}

function overrideOnHungup(service) {
    overrideOnHungup._overrideCount++;
    if (overrideOnHungup.overrideObj === service) {
        return;
    }

    overrideOnHungup.overrideObj = service;
    var override = service.onHungup;

    service.onHungup = function onHungup(stream) {
        doCleanAfterStreamClose(service, stream);
        override && override.apply(this, arguments);
    }.bind(service);
}
overrideOnHungup._overrideCount = 0;

function overrideOnRemotePannelControl(service, callbacks) {
    overrideOnRemotePannelControl._overrideCount++;
    if (overrideOnRemotePannelControl.overrideObj === service) {
        return;
    }

    overrideOnRemotePannelControl.overrideObj = service;
    var override = service._onRemotePannelControl;

    service._onRemotePannelControl = function _onRemotePannelControl(evt) {
        handlePannelRemoteMessage(this, evt, false, callbacks);
        override && override.apply(this, arguments);
    }.bind(service);
}
overrideOnRemotePannelControl._overrideCount = 0;

function resetOnRemotePannelControl(service) {
    // overrideOnRemotePannelControl._overrideCount--;
    //
    // if(overrideOnRemotePannelControl._overrideCount === 0){
    //     service._onRemotePannelControl = _onRemotePannelControl.override;
    //     overrideOnRemotePannelControl.overrideObj = undefined;
    // }
}

function codeCtrlMessage(service, stream, ctrl) {
    var actions = [];

    ctrl && _util.forEach(ctrl.actions, function (i, m) {
        m.xy && actions.push({
            x: Math.round(m.xy.x * 10000),
            y: Math.round(m.xy.y * 10000),
            oper: m.oper,
            btn: m.btn,
            sn: m.sn,
            _time: m._time
        });

        m.xy || actions.push({
            oper: m.oper,
            btn: m.btn,
            sn: m.sn,
            _time: m._time
        });
    });

    var arg = {
        op2: 30,
        evt: 0,
        streamId: stream.id,
        actions: actions,
        cId: ctrl.cId
    };

    return service.current.newMessage({
        op: 1002,
        memId: stream.owner.id,
        arg: (0, _stringify2.default)(arg),
        _reqOps: [100230]
    });
}

function decodeCtrlMessage(evt) {
    if (typeof evt.arg === 'string') {
        evt.arg = JSON.parse(evt.arg);
    }

    var arg = evt.arg;

    var mouse = [],
        keyboard = [];
    arg && arg.actions && _util.forEach(arg.actions, function (i, m) {
        m.x !== undefined && m.y !== undefined && mouse.push({
            xy: { x: m.x / 10000, y: m.y / 10000 },
            oper: m.oper,
            btn: m.btn,
            sn: m.sn,
            _time: m._time
        });

        (m.x === undefined || m.y === undefined) && keyboard.push({
            oper: m.oper,
            btn: m.btn,
            sn: m.sn,
            _time: m._time
        });
    });

    arg.mouse = mouse;
    arg.keyboard = keyboard;
}

var remoteControlSeqno = 0;
var RemoteControl = _util.prototypeExtend({
    //id:
    //_service:
    //controller:
    //_ctrlStream:
    //_cId:
    //_reqevt:
    __init__: function __init__() {
        this.id = remoteControlSeqno++;
    },
    accept: function accept(mouseTrack, keyboard) {
        var self = this;

        if (self.hasOtherControl()) {
            self.busy();

            _logger.error("Other has been controled.");
            throw "Other has been controled.";
        }

        var preAcpt = false;

        var preRemoteControls = getRemoteControl(this._service, this._ctrlStream, this._controller); // 获取此前的remotecontrol
        preRemoteControls && _util.forEach(preRemoteControls, function (_index, preRC) {
            if (preRC.id < self.id) {
                preRC._free();
            } else {
                preAcpt = true;
            }
        });

        if (preAcpt) {
            //已经同意最新的控制。忽略这个
            self._free();
            return;
        }

        var remoteControls = this._service.current.__remoteControls || (this._service.current.__remoteControls = {});
        remoteControls[self.id] = self;

        controlling(this, mouseTrack, keyboard);

        rspRemoteControl(this._service, this._reqevt, 0);
    },

    controlling: function controlling() {
        var self = this;

        //存在启动人控制
        var controls = [];
        var remoteControls = getRemoteControl(this._service, this._ctrlStream);
        remoteControls && _util.forEach(remoteControls, function (_index, other) {
            if (other._controller.memName === self._controller.memName) {
                controls.push(other);
            }
        });

        return controls && controls.length ? controls : undefined;
    },

    hasOtherControl: function hasOtherControl() {
        var self = this;

        //存在启动人控制
        var hasOtherControl = false;
        var controls = getRemoteControl(this._service, this._ctrlStream);
        controls && _util.forEach(controls, function (_index, other) {
            if (other._controller.memName != self._controller.memName) {
                hasOtherControl = true;
            }
        });

        return hasOtherControl;
    },

    busy: function busy() {
        rspRemoteControl(this._service, this._reqevt, -403);
    },

    reject: function reject() {
        rspRemoteControl(this._service, this._reqevt, -402);
    },

    _free: function _free() {
        _util.removeAttribute(this._service.current.__remoteControls, this.id);
    },

    forceDisconnect: function forceDisconnect() {
        var remoteControls = getRemoteControl(this._service, this._ctrlStream);
        if (remoteControls) {
            _util.forEach(remoteControls, function (_index, remoteControl) {
                remoteControl._free && remoteControl._free();
            });
        }
        _logger.info("remote control force disconnect");
    }
});

function rspRemoteControl(service, evt, result) {
    service.current.message({
        op: 1001,
        tsxId: evt.tsxId,
        memId: evt.memId,
        arg: (0, _stringify2.default)({ cId: evt.arg.cId }),
        result: result
    }).post();
}

function notAllowControl(service, evt) {
    rspRemoteControl(service, evt, -405);
}

function selectRemoteControlByMemId(service, controllerMemId, stream) {
    var remoteControls = [];
    service.current.__remoteControls && _util.forEach(service.current.__remoteControls, function (_remoteControlId, _remoteControl) {
        if ((!stream || _remoteControl._ctrlStream.id === stream.id) && (!controllerMemId || _remoteControl._controller.id === controllerMemId)) {
            remoteControls.push(_remoteControl);
        }
    });

    return remoteControls;
}

function getRemoteControl(service, stream, controller, cId) {
    var remoteControls = [];
    service.current.__remoteControls && _util.forEach(service.current.__remoteControls, function (_remoteControlId, _remoteControl) {
        if ((!stream || _remoteControl._ctrlStream.id === stream.id) && (!controller || _remoteControl._controller.memName === controller.memName) && (!cId || _remoteControl._cId === cId)) {
            remoteControls.push(_remoteControl);
        }
    });

    return remoteControls;
}

function handlePannelRemoteMessage(service, evt, located, callbacks) {
    decodeCtrlMessage(evt);

    var arg = evt.arg;
    var cId = arg.cId;

    var streamId = arg.streamId;

    var member = service.getMemberById(evt.memId);
    var stream = service.getStreamById(streamId);

    function recvRemoteControl() {
        if (!member || !stream) {
            notAllowControl(service, evt);
            return true;
        }

        if (arg.evt === 1) {
            // 控制申请
            var remoteControl = new RemoteControl({
                _service: service,
                _controller: member,
                _ctrlStream: stream,
                _cId: cId,
                _reqevt: evt,
                _callbacks: callbacks
            });

            if (remoteControl.hasOtherControl()) {
                remoteControl.busy();
                return true;
            }

            var ctrls;
            if (ctrls = remoteControl.controlling()) {
                _util.forEach(ctrls, function (_index, ctrl) {
                    ctrl._cId = cId;
                });

                rspRemoteControl(service, evt, 0);
                return true;
            }

            callbacks && callbacks.onHasRemoteControl && callbacks.onHasRemoteControl(stream, member, remoteControl);

            return true;
        }

        if (arg.evt === 2) {
            // 控制释放
            var remoteControls = getRemoteControl(service, stream, member, cId);
            if (remoteControls) {
                _util.forEach(remoteControls, function (_index, remoteControl) {
                    remoteControl._free && remoteControl._free();
                    rspRemoteControl(service, evt, 0);
                });
            }

            callbacks && callbacks.onRemoteFreeControl && callbacks.onRemoteFreeControl(stream, member, cId);

            return true;
        }
    }

    if (!located && recvRemoteControl()) {
        return;
    }

    var remoteControls = getRemoteControl(service, stream, member, cId);
    if (!located && (!remoteControls || remoteControls.length === 0)) {
        notAllowControl(service, evt);
    }

    remoteControls && _util.forEach(remoteControls, function (_index, __ctrl) {
        __ctrl._lastRecvTimestamp = new Date().getTime();
    });

    if (located) {
        var remoteControl = service.current.__remoteControls[stream.id];
        remoteControls = remoteControls || [];

        remoteControl && remoteControls.push(remoteControl);
    }

    _util.forEach(remoteControls, function (_i, ctrl) {
        var maxSN = 0;

        var triggers = arg.mouse;
        if (triggers && triggers.length > 0) {
            try {
                _util.forEach(triggers, function (index, elem) {
                    if (elem.sn > maxSN) {
                        maxSN = elem.sn;
                    }

                    if (elem.oper === MouseTrigger.BTN.MOVE) {
                        ctrl.mouseTrack && ctrl.mouseTrack.track(elem.xy);
                    } else {
                        ctrl.mouseTrack && ctrl.mouseTrack.trigger(new MouseTrigger(elem));
                    }
                });
            } catch (e) {
                _logger.warn(e);
            }
        }

        var triggers = arg.keyboard;
        if (triggers && triggers.length > 0) {
            try {
                _util.forEach(triggers, function (index, elem) {
                    if (elem.sn > maxSN) {
                        maxSN = elem.sn;
                    }

                    if (ctrl.keyboard) if (elem.oper === MouseTrigger.BTN.KEYBOARD_DOWN) {
                        ctrl.keyboard.onKeyDown(elem.btn);
                    } else if (elem.oper === MouseTrigger.BTN.KEYBOARD_UP) {
                        ctrl.keyboard.onKeyUp(elem.btn);
                    }
                });
            } catch (e) {
                _logger.warn(e);
            }
        }

        if (located === true) {
            //自个儿 没通过 session发送
            return;
        }

        function rsp() {
            service.current.message({
                op: 1001,
                tsxId: evt.tsxId,
                memId: evt.memId,
                arg: (0, _stringify2.default)({ sn: maxSN }),
                result: 0
            }).post(function (rsp) {
                _logger.debug("Send remote control response. the result = ", rsp.result, rsp.msg || "");
            });
        }

        try {
            rsp();
        } catch (e) {
            _logger.warn(e);
        }
    });
}

function _onMouseEnter2(service, streamId, videoTarget, _onMouseEnter, onCallbacks) {
    _onMouseEnter && _onMouseEnter();
}

function _onMouseExit2(service, streamId, videoTarget, _onMouseExit, onCallbacks) {
    _onMouseExit && _onMouseExit();
}

function _onMouseMove2(service, streamId, videoTarget, eventXY, lastTrigger, _onMouseMove, onCallbacks) {
    var pos = service.eventXYAtMedia(eventXY, videoTarget);
    if (!pos) {
        return;
    }

    pos = {
        x: pos.x / pos.width,
        y: pos.y / pos.height
    };

    //_logger.info(pos.x, pos.y);

    sendPannelMessage(service, { xy: pos, oper: MouseTrigger.BTN.MOVE, sid: streamId }, onCallbacks);
    _onMouseMove && _onMouseMove(pos, lastTrigger);
}

function _onMouseButton2(service, streamId, videoTarget, trigger, lastTrigger, _onMouseButton, onCallbacks) {
    trigger.xy = service.eventXYAtMedia(trigger.xy, videoTarget);
    if (!trigger.xy) {
        return;
    }

    trigger.xy = {
        x: trigger.xy.x / trigger.xy.width,
        y: trigger.xy.y / trigger.xy.height
    };

    _util.extend(trigger, { sid: streamId });

    sendPannelMessage(service, trigger, onCallbacks);
    _onMouseButton && _onMouseButton(trigger, lastTrigger);
}

function onKeyboard(service, streamId, oper, btn, _onKeyboard, onCallbacks) {
    sendPannelMessage(service, { oper: oper, btn: btn, sid: streamId }, onCallbacks);
    _onKeyboard && _onKeyboard(oper, btn);
}

function maskVideo(videoTarget) {
    var maskDiv = document.createElement("div");
    maskDiv.style = videoTarget.style;
    maskDiv.style.background = "transparent";

    videoTarget.parentNode.appendChild(maskDiv);
}

function sendPannelMessage(service, trigger, onCallbacks) {
    var streamId = trigger.sid;

    var stream = service.getStreamById(streamId);

    var ctrl;
    if (service.current.__remoteControls && (ctrl = service.current.__remoteControls[streamId])) {
        handlePannelRemoteMessage(service, codeCtrlMessage(service, stream, { actions: [trigger] }), true);
    }

    var _buffer = service.current.__pannelBuffers[streamId];

    var preUnclearSize = _buffer.getUnclearSize();
    _buffer.put(trigger);

    if (preUnclearSize < emedia.config.allowSendWhenLessThan) {
        var _getAndSend = function _getAndSend() {
            var evts = _buffer.getUnread();

            var _maxSN = 0;
            for (var i = 0; evts && i < evts.length; i++) {
                var evt = evts[i];
                _util.removeAttribute(evt, "sid");

                _maxSN < evt.sn && (_maxSN = evt.sn);
            }

            if (!evts || evts.length === 0) {
                return;
            }

            _logger.debug(streamId, "buffer remain:", _buffer.getUnclearSize(), ", send evt:", evts.length);

            service.current.postMessage(codeCtrlMessage(service, stream, { actions: evts, cId: _buffer._cId }), function (rsp) {
                if (rsp.result === -402) {
                    //对方 拒绝控制
                    onCallbacks && onCallbacks.onReject && onCallbacks.onReject(stream);
                    return;
                }
                if (rsp.result === -403) {
                    //对方 正被控制，忙
                    onCallbacks && onCallbacks.onBusy && onCallbacks.onBusy(stream);
                    return;
                }
                if (rsp.result === -408) {
                    //超时
                    onCallbacks && onCallbacks.onRemoteControlTimeout && onCallbacks.onRemoteControlTimeout(stream);
                    return;
                }
                if (rsp.result === -507 || rsp.result === -405) {
                    //不被支持
                    _buffer.clearRead(_maxSN);
                    onCallbacks && onCallbacks.onNotAllowRemoteControl && onCallbacks.onNotAllowRemoteControl(stream);
                    return;
                }

                if (rsp.result === 0) {
                    _buffer._lastRspTimestamp = new Date().getTime();
                }

                var arg = rsp.arg;
                if (arg && (arg = JSON.parse(arg)) && !_util.isInt(arg.sn)) {
                    _logger.warn("rsp.sn not a Number.", arg.sn, "for streamId", streamId);
                } else {
                    arg && arg.sn !== undefined && _buffer.clearRead(arg.sn);
                }

                _getAndSend();
            });
        };

        _getAndSend();
    }
}

function disControlled(service, streamId) {
    var buffer;

    var mouse = service.current.__pannelMouses && _util.removeAttribute(service.current.__pannelMouses, streamId);
    var keyboard = service.current.__pannelKeyboards && _util.removeAttribute(service.current.__pannelKeyboards, streamId);
    service.current.__pannelBuffers && (buffer = _util.removeAttribute(service.current.__pannelBuffers, streamId));

    mouse && mouse.ungrab();
    keyboard && keyboard.ungrab();

    resetOnRemoveStream(service);

    if (!buffer) {
        return;
    }

    var stream = service.getStreamById(streamId);
    if (buffer._callbacks && buffer._callbacks.onDisControlled) {
        buffer._callbacks.onDisControlled(stream);
    }

    if (!stream) {
        return;
    }

    var messge = service.current.newMessage({
        op: 1002,
        memId: stream.owner.id,
        arg: (0, _stringify2.default)({
            op2: 30,
            streamId: stream.id,
            evt: 2,
            cId: buffer._cId
        }),
        _reqOps: [100230]
    });

    service.current.postMessage(messge, function (rsp) {
        if (rsp.result === 0) {
            return;
        }

        _logger.warn("Unkown result：", rsp.result);
        return;
    });
}

function mirrorControlled(service, streamId, videoTarget, maskTarget) {
    var onCallbacks = {};
    _util.forEach(arguments, function (_index, _func) {
        if (typeof _func === "function") {
            onCallbacks[_func.name] = _func;
        }
    });

    reqControlled(service, streamId, videoTarget, true, maskTarget, onCallbacks);
}

function controlled(service, streamId, videoTarget, maskTarget) {
    var onCallbacks = {};
    _util.forEach(arguments, function (_index, _func) {
        if (typeof _func === "function") {
            onCallbacks[_func.name] = _func;
        }
    });

    reqControlled(service, streamId, videoTarget, false, maskTarget, onCallbacks);
}

function reqControlled(service, streamId, videoTarget, mirror, maskTarget, onCallbacks) {
    var cId = Math.uuidFast();
    cId = cId.substr(cId.length - 6, 6);

    var stream = service.getStreamById(streamId);

    if (!stream._webrtc) {
        //throw "Not allow control. cause by the stream not sub";
        onCallbacks && onCallbacks.onNotAllowRemoteControl && onCallbacks.onNotAllowRemoteControl(stream);

        _logger.error("Not allow control. cause by the stream not sub");
        throw "Not allow control. cause by the stream not sub";
    }

    var arg = {
        op2: 30,
        streamId: stream.id,
        evt: 1,
        cId: cId
    };

    var messge = service.current.newMessage({
        op: 1002,
        memId: stream.owner.id,
        arg: (0, _stringify2.default)(arg),
        _reqOps: [100230]
    });

    service.current.postMessage(messge, function (rsp) {
        if (rsp.result === -402) {
            //对方 拒绝控制
            onCallbacks && onCallbacks.onReject && onCallbacks.onReject(stream);
            return;
        }
        if (rsp.result === -403) {
            //对方 正被控制，忙
            onCallbacks && onCallbacks.onBusy && onCallbacks.onBusy(stream);
            return;
        }
        if (rsp.result === -408) {
            //超时
            onCallbacks && onCallbacks.onRemoteControlTimeout && onCallbacks.onRemoteControlTimeout(stream);
            return;
        }
        if (rsp.result === -507 || rsp.result === -405) {
            //不被支持
            onCallbacks && onCallbacks.onNotAllowRemoteControl && onCallbacks.onNotAllowRemoteControl(stream);
            return;
        }

        if (rsp.result === 0) {
            _controlled(service, streamId, videoTarget, mirror, maskTarget, onCallbacks, cId, true);
            onCallbacks && onCallbacks.onAccept && onCallbacks.onAccept(stream);
            return;
        }

        _logger.warn("Unkown result：", rsp.result);

        onCallbacks && onCallbacks.onNotAllowRemoteControl && onCallbacks.onNotAllowRemoteControl(stream);
        return;
    });
}

function _controlled(service, streamId, videoTarget, mirror, maskTarget, onCallbacks, cId, openKeyboard) {
    if (maskTarget === undefined) {
        maskTarget = videoTarget;
    }

    var stream = service.getStreamById(streamId);

    var mouse = (service.current.__pannelMouses || (service.current.__pannelMouses = {}))[streamId];
    if (mouse) {
        disControlled(service, streamId);
    }

    if (!stream.located() && !stream.owner.acptOps[1003]) {
        _logger.error("which do not recv remote message, it is ", stream.owner.memName);
        throw stream.owner.memName + " do not recv remote message";
    }

    mouse = new Mouse({
        _target: maskTarget,
        _focused: true,

        onMouseEnter: function onMouseEnter() {
            _onMouseEnter2.call(mouse, service, streamId, videoTarget, onCallbacks && onCallbacks.onMouseEnter, onCallbacks);

            keyboard && keyboard.grab();
        },

        onMouseExit: function onMouseExit() {
            _onMouseExit2.call(mouse, service, streamId, videoTarget, onCallbacks && onCallbacks.onMouseExit, onCallbacks);

            keyboard && keyboard.ungrab();
        },

        onMouseButton: function onMouseButton(trigger, lastTrigger) {
            mirror === true && (trigger.xy.x = -trigger.xy.x);
            _onMouseButton2.call(mouse, service, streamId, videoTarget, trigger, lastTrigger, onCallbacks && onCallbacks.onMouseButton, onCallbacks);
        },

        onMouseMove: function onMouseMove(pos, lastTrigger) {
            //_logger.info(pos.x, pos.y);

            if (!emedia.config.disableTrack) {
                mirror === true && (pos.x = -pos.x);
                _onMouseMove2.call(mouse, service, streamId, videoTarget, pos, lastTrigger, onCallbacks && onCallbacks.onMouseMove, onCallbacks);
            }
        }
    });

    var pannelBuffers = service.current.__pannelBuffers || (service.current.__pannelBuffers = {});
    var _buffer = pannelBuffers[streamId] = new TotalBuffer({
        _cId: cId,
        _callbacks: onCallbacks,
        trackBufferSize: emedia.config.trackBufferSize || 1000
    });

    (service.current.__pannelMouses || (service.current.__pannelMouses = {}))[streamId] = mouse;
    mouse.grab();

    var keyboard;
    if (openKeyboard) {
        keyboard = new Keyboard({
            _target: document,
            _focused: true,
            onKeyPress: function onKeyPress(keyValue, isPressed) {
                var oper = isPressed ? MouseTrigger.BTN.KEYBOARD_DOWN : MouseTrigger.BTN.KEYBOARD_UP;
                var btn = keyValue;

                onKeyboard.call(keyboard, service, streamId, oper, btn, onCallbacks && onCallbacks.onKeyboard, onCallbacks);
            }
        });

        (service.current.__pannelKeyboards || (service.current.__pannelKeyboards = {}))[streamId] = keyboard;
        //keyboard.grab();
    }

    // overrideOnHungup(service);
    // overrideOnRemoveStream(service);
    // overrideOnRemoveMember(service);
}

function graffiti(maskTag, mouseTrack, referenceVideo, mirror) {
    var mouse = new Mouse({
        _target: maskTag,
        _focused: true,

        onMouseEnter: function onMouseEnter() {
            //mouse.grab();
        },

        onMouseExit: function onMouseExit() {
            mouseTrack.releaseTrigger();
        },

        onMouseButton: function onMouseButton(trigger, lastTrigger) {
            trigger.xy = {
                x: trigger.xy.x / trigger.xy.width,
                y: trigger.xy.y / trigger.xy.height
            };

            mirror === true && (trigger.xy.x = -trigger.xy.x);
            referenceVideo && (trigger.xy = emedia.Service.prototype.eventXYAtMedia.call(null, trigger.xy, referenceVideo));
            trigger.xy && mouseTrack.trigger(trigger);
        },

        onMouseMove: function onMouseMove(pos, lastTrigger) {
            pos = {
                x: pos.x / pos.width,
                y: pos.y / pos.height
            };

            mirror === true && (pos.x = -pos.x);
            referenceVideo && (pos = emedia.Service.prototype.eventXYAtMedia.call(null, pos, referenceVideo));
            pos && mouseTrack.track(pos);
        }
    });

    mouse.grab();

    return mouse;
}

function controlling(ctrl, mouseTrack, keyboard) {
    var __mouseTrack = mouseTrack;

    // mouseTrack && (__mouseTrack = new MouseTrack({
    //     _focused: true,
    //
    //     onMouseTrack: function (position, lastPosition, lastTrigger) {
    //         mouseTrack.track(position);
    //     },
    //     onMouseTrigger: function (trigger, _lastTrigger) {
    //         mouseTrack.trigger(trigger);
    //     },
    //     onReleaseTrigger: function (_lastTrigger) {
    //         mouseTrack.releaseTrigger();
    //     }
    // }));

    __mouseTrack && (ctrl.mouseTrack = __mouseTrack);
    ctrl.keyboard = keyboard;
}

function support(service) {
    var onCallbacks = {};
    _util.forEach(arguments, function (_index, _func) {
        if (_index != 0 && typeof _func === "function") {
            onCallbacks[_func.name] = _func;
        }
    });

    overrideOnHungup(service);

    overrideOnRemoveStream(service);
    overrideOnRemoveMember(service);
    overrideOnRemotePannelControl(service, onCallbacks);

    checkTimeout(service);
}

function getController(service, streamId) {
    var stream = service.getStreamById(streamId);

    var controls = getRemoteControl(service, stream);

    if (!controls || controls.length === 0) {
        return;
    }

    return controls[0]._controller.memName;
}

function echoControl(service, streamId, mouseTrack, keyboard) {
    var stream = service.getStreamById(streamId);

    var echoControl = { _ctrlStream: stream, _controller: stream.owner, _service: service };
    controlling(echoControl, mouseTrack, keyboard);

    (service.current.__remoteControls || (service.current.__remoteControls = {}))[streamId] = echoControl;
}

function disEchoControl(service, streamId) {
    _util.removeAttribute(service.current.__remoteControls, streamId);
}

var checkTimeout = function checkTimeout(service) {
    if (checkTimeout.timeoutId) {
        clearTimeout(checkTimeout.timeoutId);
    }

    checkTimeout.timeoutId = setTimeout(function () {
        checkTimeout(service);
    }, emedia.config.ctrlCheckIntervalMillis);

    if (!service.current) {
        return;
    }

    var controls;
    if (controls = service.current.__remoteControls) {
        //受控制端，查看 _lastRecvTimestamp
        //_logger.debug("Will check timeout for remote controller.");

        _util.forEach(controls, function (ctrlId, ctrl) {
            if (ctrl.id !== undefined && ctrlId == ctrl.id) {
                var now = new Date().getTime();
                if (ctrl._lastRecvTimestamp && now - ctrl._lastRecvTimestamp > emedia.config.ctrlTimeoutMillis) {
                    _logger.warn("Timeout for remote controller. it is ", ctrl.id, ctrl._ctrlStream.id, ctrl._controller.memName);

                    ctrl._free(); //超时清空

                    ctrl._callbacks && ctrl._callbacks.onRemoteFreeControl && ctrl._callbacks.onRemoteFreeControl(ctrl._ctrlStream, ctrl._controller, ctrl._cId);
                }
            }
        });
    }

    var buffers;
    if (buffers = service.current.__pannelBuffers) {
        //控制端 根据是否还存在 这个发布流判断，如果 这个pub流被移除，控制 停止。查看 _lastRspTimestamp
        _util.forEach(buffers, function (_streamId, buffer) {
            //控制端发送ping
            var stream = service.getStreamById(_streamId);
            if (stream && !stream.located()) {
                service.current.message({ // 发送ping
                    op: 1002,
                    memId: stream.owner.id,
                    arg: (0, _stringify2.default)({
                        op2: 30,
                        streamId: stream.id,
                        evt: 3,
                        cId: buffer._cId
                    }),
                    _reqOps: [100230]
                }).post(function (rsp) {});
            }
        });
    }
};

module.exports = {
    mirrorControlled: mirrorControlled,
    controlled: controlled,
    disControlled: disControlled,

    controlling: controlling,

    graffiti: graffiti,

    echoControl: echoControl,
    disEchoControl: disEchoControl,

    support: support,

    getController: getController
};

/***/ }),
/* 432 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _util = __webpack_require__(72);
var _logger = _util.tagLogger("Mouse");

var MouseTrigger = __webpack_require__(222);

/**
 * { target:
 *   onMouseButton:
 *   onMouseMove:
 * }
 *
 */

module.exports = _util.prototypeExtend({
    __init__: function __init__() {
        var self = this;

        this._handlers = _util.extend({
            mousedown: this._handleMouseDown.bind(this),
            mouseup: this._handleMouseUp.bind(this),
            mousemove: this._handleMouseMove.bind(this),
            mousewheel: this._handleMouseWheel.bind(this),
            mousedisable: this._handleMouseDisable.bind(this),
            mouseover: this._handleMouseOver.bind(this),
            mouseout: this._handleMouseOut.bind(this)
        }, this._handlers || {});
    },

    //target: n,

    /**
     *
     * @param posX
     * @param posY
     * @param oper 1按下 0up
     * @param button 1左键单击 2滚轮按下 4右键 8滚轮向底端滑 16滚轮向顶端滑
     */
    onMouseButton: function onMouseButton(trigger, lastTrigger) {},

    onMouseMove: function onMouseMove(eventXY, lastTrigger) {},

    onMouseEnter: function onMouseEnter() {},

    onMouseExit: function onMouseExit() {},

    _onMouseButton: function _onMouseButton(eventXY, oper, button) {
        var _time = new Date().getTime();

        var trigger = new MouseTrigger({
            xy: eventXY,
            oper: oper,
            btn: button,
            _time: _time
        });

        this.onMouseButton && this.onMouseButton(trigger, this._lastTrigger);

        this._lastTrigger = trigger;
    },

    _onMouseMove: function _onMouseMove(eventXY) {
        this.onMouseMove && this.onMouseMove(eventXY, this._lastTrigger);
    },

    _captureMouse: function _captureMouse() {
        this._target.setCapture && this._target.setCapture();
        this._mouseCaptured = true;
    },
    _releaseMouse: function _releaseMouse() {
        this._target.releaseCapture && this._target.releaseCapture();
        this._mouseCaptured = false;
    },
    _resetDoubleClickTimer: function _resetDoubleClickTimer() {
        this._doubleClickTimer = null;
    },

    _handleMouseOver: function _handleMouseOver(event) {
        if (this._mouseExit !== false) {
            this._mouseExit = false;
            this.onMouseEnter && this.onMouseEnter();
        }
    },
    _handleMouseOut: function _handleMouseOut(event) {
        if (this._mouseExit !== true) {
            this._mouseExit = true;
            this.onMouseExit && this.onMouseExit();
        }

        this._lastTrigger = undefined;
    },
    _handleMouseDown: function _handleMouseDown(event) {
        this._captureMouse();
        this._handleMouseButton(event, MouseTrigger.BTN.KEY_DOWN);
    },
    _handleMouseUp: function _handleMouseUp(event) {
        this._mouseCaptured && (this._handleMouseButton(event, MouseTrigger.BTN.KEY_UP), this._releaseMouse());
    },

    _handleMouseWheel: function _handleMouseWheel(event) {
        if (!this._focused) {
            return;
        }

        var event = event || window.event,
            eventXY = _util.getEventElementXY(event, this._target, this._scale);

        // 8up 16down
        var wheel = (event.detail ? -1 * event.detail : event.wheelDelta / 40) > 0 ? MouseTrigger.BTN.WHEEL_ROLL_UP : MouseTrigger.BTN.WHEEL_ROLL_DOWN;
        this._onMouseButton(eventXY, MouseTrigger.BTN.KEY_DOWN, wheel);
        _util.stopEvent(event);
    },

    _handleMouseMove: function _handleMouseMove(event) {
        if (!this._focused) {
            return;
        }

        var event = event || window.event,
            eventXY = _util.getEventElementXY(event, this._target, this._scale);
        this._onMouseMove(eventXY);
        _util.stopEvent(event);
    },

    _handleMouseDisable: function _handleMouseDisable(event) {
        if (!this._focused) {
            return;
        }

        var event = event || window.event,
            eventXY = _util.getEventElementXY(event, this._target, this._scale);

        try {
            return !(eventXY.realX >= 0 && eventXY.realY >= 0 && eventXY.realX < this._target.offsetWidth && eventXY.realY < this._target.offsetHeight);
        } finally {
            _util.stopEvent(event);
        }
    },

    /**
     *
     * @param event
     * @param oper 1鼠标按下
     * @private
     */
    _handleMouseButton: function _handleMouseButton(event, oper) {
        if (!this._focused) {
            return;
        }

        var button,
            event = event || window.event,
            eventXY = _util.getEventElementXY(event, this._target, this._scale);
        if (event.touches || event.changedTouches) {
            if (oper == MouseTrigger.BTN.KEY_DOWN) {
                if (this._doubleClickTimer === null) this._lastTouchPos = eventXY;else {
                    clearTimeout(this._doubleClickTimer);
                    var distanceX = this._lastTouchPos.x - eventXY.x,
                        distanceY = this._lastTouchPos.y - eventXY.y;
                    Math.sqrt(distanceX * distanceX + distanceY * distanceY) < 20 * window.devicePixelRatio && (eventXY = this._lastTouchPos);
                }
                this._doubleClickTimer = setTimeout(this._resetDoubleClickTimer.bind(this), 500);
            }
            button = MouseTrigger.BTN.LEFT;
        } else button = event.which ? 1 << event.button : (1 & event.button) + 2 * (2 & event.button) + (4 & event.button) / 2;

        this._onMouseButton(eventXY, oper, button);
        _util.stopEvent(event);
    },

    grab: function grab() {
        var element = this._target;

        _util.addEvent(element, "mouseover", this._handlers.mouseover);
        _util.addEvent(element, "mouseout", this._handlers.mouseout);

        _util.addEvent(element, "touchstart", this._handlers.mousedown);
        //_util.addEvent(window, "touchend", this._handlers.mouseup);
        _util.addEvent(element, "touchend", this._handlers.mouseup);
        _util.addEvent(element, "touchmove", this._handlers.mousemove);
        _util.addEvent(element, "mousedown", this._handlers.mousedown);
        //_util.addEvent(window, "mouseup", this._handlers.mouseup);
        _util.addEvent(element, "mouseup", this._handlers.mouseup);
        _util.addEvent(element, "mousemove", this._handlers.mousemove);
        _util.addEvent(element, _util.layoutEngine.gecko ? "DOMMouseScroll" : "mousewheel", this._handlers.mousewheel);
        _util.addEvent(element, "contextmenu", this._handlers.mousedisable);
        //_util.addEvent(document, "click", this._handlers.mousedisable);
        //_util.addEvent(document.body, "contextmenu", this._handlers.mousedisable);
    },
    ungrab: function ungrab() {
        var element = this._target;

        _util.removeEvent(element, "mouseover", this._handlers.mouseover);
        _util.removeEvent(element, "mouseout", this._handlers.mouseout);

        _util.removeEvent(element, "touchstart", this._handlers.mousedown);
        //_util.removeEvent(window, "touchend", this._handlers.mouseup);
        _util.removeEvent(element, "touchend", this._handlers.mouseup);
        _util.removeEvent(element, "touchmove", this._handlers.mousemove);
        _util.removeEvent(element, "mousedown", this._handlers.mousedown);
        //_util.removeEvent(window, "mouseup", this._handlers.mouseup);
        _util.removeEvent(element, "mouseup", this._handlers.mouseup);
        _util.removeEvent(element, "mousemove", this._handlers.mousemove);
        _util.removeEvent(element, _util.layoutEngine.gecko ? "DOMMouseScroll" : "mousewheel", this._handlers.mousewheel);
        _util.removeEvent(element, "contextmenu", this._handlers.mousedisable);
        //_util.removeEvent(document, "click", this._handlers.mousedisable);
        //_util.removeEvent(document.body, "contextmenu", this._handlers.mousedisable);
    }
});

/***/ }),
/* 433 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _util = __webpack_require__(72);
var _logger = _util.tagLogger("Keyboard");

module.exports = _util.prototypeExtend({

    __init__: function __init__() {
        var self = this;

        this._eventHandlers = {
            keyup: this._handleKeyUp.bind(this),
            keydown: this._handleKeyDown.bind(this),
            keypress: this._handleKeyPress.bind(this),
            blur: this._allKeysUp.bind(this)
        };
    },

    getKey: function getKey(event) {
        return "keyCode" in event && "key" in event ? event.key + ":" + event.keyCode : "keyCode" in event ? event.keyCode : event.key;
    },

    onKeyPress: function onKeyPress(keyValue, isPressed) {},

    _onKeyPress: function _onKeyPress(keyValue, isPressed) {
        this.onKeyPress && this.onKeyPress(keyValue, isPressed);
    },

    _handleRfbEvent: function _handleRfbEvent(event, type) {
        var shift = event.shiftKey,
            ctrl = event.ctrlKey,
            alt = event.altKey,
            ascii = event.keyCode || event.which;

        this._onKeyPress(ascii, "keydown" == type);
    },

    _handleKeyDown: function _handleKeyDown(event) {
        return !this._focused || !this._handleRfbEvent(event, "keydown") || (_util.stopEvent(event), false);
    },
    _handleKeyPress: function _handleKeyPress(event) {
        return !this._focused || (_util.stopEvent(event), false);
        //return !this._focused || !this._handleRfbEvent.keypress(event) || (_util.stopEvent(event), false);
    },
    _handleKeyUp: function _handleKeyUp(event) {
        return !this._focused || !this._handleRfbEvent(event, "keyup") || (_util.stopEvent(event), false);
    },

    _allKeysUp: function _allKeysUp() {},
    sync: function sync(e) {},

    grab: function grab() {
        var element = this._target;

        _util.addEvent(element, "keydown", this._eventHandlers.keydown);
        _util.addEvent(element, "keyup", this._eventHandlers.keyup);
        _util.addEvent(element, "keypress", this._eventHandlers.keypress);
        _util.addEvent(element, "blur", this._eventHandlers.blur);
        //_util.addEvent(window, "blur", this._eventHandlers.blur);

        _logger.info("keyboard grab at element");
    },
    ungrab: function ungrab() {
        var element = this._target;

        _util.removeEvent(element, "keydown", this._eventHandlers.keydown);
        _util.removeEvent(element, "keyup", this._eventHandlers.keyup);
        _util.removeEvent(element, "keypress", this._eventHandlers.keypress);
        _util.removeEvent(element, "blur", this._eventHandlers.blur);
        //_util.removeEvent(window, "blur", this._eventHandlers.blur);

        this._allKeysUp();

        _logger.info("keyboard upgrab at element");
    }
});

/***/ }),
/* 434 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _util = __webpack_require__(72);
var _logger = _util.tagLogger("TotalBuffer");

var EventBuffer = __webpack_require__(435);
var TrackBuffer = __webpack_require__(436);

var MouseTrigger = __webpack_require__(222);

module.exports = _util.prototypeExtend({
    trackBufferSize: 100,
    _trackBufferCompRadio: 0.25,

    _sn: 1,

    __init__: function __init__() {
        this._eventBuffer = new EventBuffer({
            _nextsn: this._nextsn.bind(this)
        });
        this._trackBuffer = new TrackBuffer({
            _nextsn: this._nextsn.bind(this),
            _compRadio: this._trackBufferCompRadio,
            mouseTrackBufferSize: this.trackBufferSize
        });
    },

    _nextsn: function _nextsn() {
        return this._sn++;
    },

    put: function put(event) {
        if (!event || event.oper === undefined) {
            return;
        }

        event.oper === MouseTrigger.BTN.MOVE ? this._trackBuffer.put(event) : this._eventBuffer.put(event);
    },

    getUnread1: function getUnread1(length) {
        function sortby(a, b) {
            return a._time - b.time;
        }

        var result;
        if (!length) {
            var events = this._eventBuffer.getUnread();
            var tracks = this._trackBuffer.getUnread();

            Array.prototype.push.apply(events, tracks);
            result = events;

            result.sort(sortby);
            return result;
        }

        result = [];

        var events = this._eventBuffer._getUnread(length);
        var tracks = this._trackBuffer._getUnread(length);

        Array.prototype.push.apply(result, events);
        Array.prototype.push.apply(result, tracks);

        result.sort(sortby);

        result = result.slice(0, length > result.length ? result.length : length);
        for (var i = 0; i < result.length; i++) {
            if (result[i].oper === MouseTrigger.BTN.MOVE) {
                this._trackBuffer.getUnread(1);
            } else {
                this._eventBuffer.getUnread(1);
            }
        }

        return result;
    },

    getUnread: function getUnread(length) {
        function sortby(a, b) {
            return a.sn - b.sn;
        }

        if (!length) {
            length = this._eventBuffer.getUnreadSize() + this._trackBuffer.getUnreadSize();
        }

        var result = [];
        while (result.length !== length) {
            var event = this._eventBuffer._getUnread(1);
            var track = this._trackBuffer._getUnread(1);

            if (event === undefined && track) {
                result.push(this._trackBuffer.getUnread(1));
            } else if (track === undefined && event) {
                result.push(this._eventBuffer.getUnread(1));
            } else if (track === undefined && event === undefined) {
                return result;
            } else {
                if (event.sn < track.sn) {
                    result.push(this._eventBuffer.getUnread(1));
                } else {
                    result.push(this._trackBuffer.getUnread(1));
                }
            }
        }

        return result;
    },

    getUnreadSize: function getUnreadSize() {
        return this._trackBuffer.getUnreadSize() + this._eventBuffer.getUnreadSize();
    },

    getUnclearSize: function getUnclearSize() {
        return this._trackBuffer.getUnclearSize() + this._eventBuffer.getUnclearSize();
    },

    clearRead: function clearRead(limitSN) {
        // <=
        return this._eventBuffer.clearRead(limitSN) + this._trackBuffer.clearRead(limitSN);
    }
});

/***/ }),
/* 435 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _util = __webpack_require__(72);
var _logger = _util.tagLogger("EventBuffer");

module.exports = _util.prototypeExtend({
    _buffer: [],

    _sn: 1,

    _beginIndex: 0,
    _readIndex: 0,
    _endIndex: 0,

    _nextsn: function _nextsn() {
        return this._sn++;
    },

    put: function put(event) {
        if (!event) {
            return;
        }

        event.sn = this._nextsn();

        this._buffer.push(event);
        this._endIndex++;
    },

    _getUnread: function _getUnread(length) {
        if (this._readIndex === this._endIndex) {
            return length === 1 ? undefined : [];
        }

        return this._buffer[this._readIndex];

        var end = this._readIndex + (length || this._endIndex),
            end = end > this._endIndex ? this._endIndex : end;

        return this._buffer.slice(this._readIndex, end);
    },

    getUnread: function getUnread(length) {
        var result;
        try {
            result = this._getUnread(length);
            return result;
        } finally {
            result && (this._readIndex += length === 1 ? 1 : result.length);
        }
    },

    getUnreadSize: function getUnreadSize() {
        return this._endIndex - this._readIndex;
    },

    getUnclearSize: function getUnclearSize() {
        return this._readIndex - this._beginIndex;
    },

    clearRead: function clearRead(limitSN) {
        // <=
        if (this._readIndex === this._beginIndex) {
            return;
        }

        var count = 0;
        for (var i = this._beginIndex; i < this._readIndex; i++) {
            if (this._buffer[i].sn <= limitSN) {
                count++;
            } else {
                break;
            }
        }

        if (count === 0) {
            return 0;
        }

        for (var i = 0; i < count; i++) {
            this._buffer.shift();
        }

        this._beginIndex = 0;
        this._readIndex -= count;
        this._endIndex -= count;

        return count;
    }
});

/***/ }),
/* 436 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _util = __webpack_require__(72);
var _logger = _util.tagLogger("TrackBuffer");

module.exports = _util.prototypeExtend({
    mouseTrackBufferSize: 1000,

    _sn: 1,
    _compRadio: 0.25,

    _beginIndex: 0,
    _readIndex: 0,
    _endIndex: 0, //不包含end

    __init__: function __init__() {
        this._mouseTrackBuffer = new Array(this.mouseTrackBufferSize);
    },

    _nextsn: function _nextsn() {
        return this._sn++;
    },

    _index: function _index(_index2) {
        return _index2 % this.mouseTrackBufferSize;
    },

    comp1: function comp1(compRadio) {
        //compRadio 压缩原来的compRadio，如0.25，就是删除其中0.25个元素
        if (compRadio >= 1) {
            return;
        }

        var span = Math.floor(1 / compRadio);

        var _nextIndex = this._beginIndex;
        var _currentIndex = _nextIndex + 1;

        while (_nextIndex < this._endIndex) {
            for (var i = 2; i < span && _nextIndex + i < this._endIndex; i++) {
                this._mouseTrackBuffer[this._index(_currentIndex++)] = this._mouseTrackBuffer[this._index(_nextIndex + i)];
            }

            _nextIndex += span;
        }

        this._endIndex = _currentIndex;
    },

    put1: function put1(track) {
        if (!track) {
            return;
        }

        track.sn = this._nextsn();

        if (this._endIndex - this._readIndex === this.mouseTrackBufferSize) {
            //此时 begin = read, buffer）将原有数组(未发送队列)压缩为原先的0.75
            this.comp1(this._compRadio);
            this._readIndex = this._beginIndex;
        }

        var begin = this._index(this._beginIndex),
            read = this._index(this._readIndex),
            end = this._index(this._endIndex);

        var next = end;
        if (next <= begin && next >= 0 && this._endIndex > this._beginIndex) {
            // buffer不足后，首先覆盖已经发送的
            this._beginIndex++;
        }

        this._mouseTrackBuffer[next] = track;
        this._endIndex++;
    },

    compHalfOfUnread: function compHalfOfUnread() {
        //compRadio 压缩原来的compRadio，如0.25，就是删除其中0.25个元素
        var _nextIndex = this._readIndex + 2;
        var _currentIndex = this._readIndex + 1;

        while (_nextIndex < this._endIndex) {
            this._mouseTrackBuffer[this._index(_currentIndex++)] = this._mouseTrackBuffer[this._index(_nextIndex)];

            _nextIndex += 2;
        }

        this._endIndex = _currentIndex;
    },

    put: function put(track) {
        if (!track) {
            return;
        }

        track.sn = this._nextsn();

        if (this._endIndex - this._beginIndex === this.mouseTrackBufferSize) {
            // begin->read 待清除区，read->end 待发送，如果待清除区+待发送区满，压缩待发送区
            this.compHalfOfUnread();
        }

        var end = this._index(this._endIndex);

        this._mouseTrackBuffer[end] = track;
        this._endIndex++;
    },

    _interval: function _interval(startIndex, endIndex) {
        var read = this._index(startIndex),
            end = this._index(endIndex);

        if (read < end) {
            return this._mouseTrackBuffer.slice(read, end);
        }

        var result = this._mouseTrackBuffer.slice(read);
        Array.prototype.push.apply(result, this._mouseTrackBuffer.slice(0, end));

        return result;
    },

    _getUnread: function _getUnread(length) {
        if (this._readIndex === this._endIndex) {
            return length === 1 ? undefined : [];
        }

        return this._mouseTrackBuffer[this._index(this._readIndex)];

        var end = this._readIndex + (length || this._endIndex),
            end = end > this._endIndex ? this._endIndex : end;

        return this._interval(this._readIndex, end);
    },

    getUnread: function getUnread(length) {
        var result;
        try {
            result = this._getUnread(length);
            return result;
        } finally {
            result && (this._readIndex += length === 1 ? 1 : result.length);
        }
    },

    getUnreadSize: function getUnreadSize() {
        return this._endIndex - this._readIndex;
    },

    getUnclearSize: function getUnclearSize() {
        return this._readIndex - this._beginIndex;
    },

    clearRead: function clearRead(limitSN) {
        // <=
        if (this._readIndex === this._beginIndex) {
            return;
        }

        var count = 0;

        for (var i = this._beginIndex; i < this._readIndex; i++) {
            var index = this._index(i);

            if (this._mouseTrackBuffer[index].sn <= limitSN) {
                this._beginIndex++;
                count++;
            } else {
                break;
            }
        }

        return count;
    }
});

/***/ }),
/* 437 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _util = __webpack_require__(72);
var _logger = _util.tagLogger("CompositeCanvas");

function SimpleCanvasRenderingContext2D() {};

for (var key in CanvasRenderingContext2D.prototype) {
    (function (attr) {
        SimpleCanvasRenderingContext2D.prototype[attr] = function () {
            if (typeof this._canvasContext[attr] === "function") {
                this._canvasContext[attr].apply(this._canvasContext, arguments);
            } else {
                var arg = arguments.length >= 1 ? arguments[0] : undefined;
                if (arg) {
                    this._canvasContext[attr] = arg;
                } else {
                    return this._canvasContext[attr];
                }
            }
        };
    })(key);
}

//https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D

var CompositeCanvas = _util.prototypeExtend(SimpleCanvasRenderingContext2D, {
    //compositeCanvasTag:
    //_compositeOperation:
    //_globalAlpha:
    __init__: function __init__() {
        var self = this;

        if (!self.compositeCanvasTag) {
            self.compositeCanvasTag = document.createElement("canvas");
        }

        self._canvasContext = self.compositeCanvasTag.getContext("2d");

        self._canvasContext.globalAlpha = this._globalAlpha !== undefined ? this._globalAlpha : 1;

        self._compositeOperation = self._compositeOperation || operation.source_over;
        self.globalCompositeOperation(self._compositeOperation);
    },

    setCanvas: function setCanvas() {
        var self = this;
        var set;
        for (var i = 0; i < arguments.length; i++) {
            set = arguments[i];

            typeof set === "function" && set(this.compositeCanvasTag, this._canvasContext);
            typeof set !== "function" && _util.isPlainObject(set) && _util.forEach(set, function (key, value) {
                _logger.debug("Canvas set ", key, " = ", value);
                self.compositeCanvasTag.setAttribute(key, value);
            });
        }

        return self;
    },

    getCanvasImageData: function getCanvasImageData(canvas, alpha) {
        var args = [];
        for (var i = 1; i < arguments.length; i++) {
            args.push(arguments[i]);
        }

        var canvasContext = canvas.getContext("2d");
        canvasContext.globalAlpha = alpha || 0;
        return canvasContext.getImageData.apply(canvasContext, args);
    },

    _composite: function _composite(compositeOperation) {
        var self = this;

        return new CompositeCanvas(self, { _compositeOperation: compositeOperation });
    },

    composite: function composite(compositeOperation) {
        var self = this;
        self.globalCompositeOperation(compositeOperation);

        return self;
    },

    requestAnimationFrame: function requestAnimationFrame(time) {
        var self = this;

        self.requestFrame();
        self._requestAnimationFrameStart = window.requestAnimationFrame(function (time) {
            self.requestAnimationFrame(time);
        });

        return self;
    },

    cancelAnimationFrame: function cancelAnimationFrame() {
        var self = this;
        self._requestAnimationFrameStart && window.cancelAnimationFrame(self._requestAnimationFrameStart);

        return self;
    },

    requestFrame: function requestFrame(_frameRate) {
        var self = this;
        if (typeof this.requestOneFrame !== "function") {
            _logger.error("Pleas implement requestOneFrame()");
            throw "Pleas implement requestOneFrame()";
        }

        try {
            this.requestOneFrame();
        } catch (e) {
            _logger.error(e);
        }

        var timeoutMillis;
        if (_frameRate) {
            timeoutMillis = Math.floor(1000 / _frameRate);
        }

        if (!timeoutMillis) {
            return self;
        }

        var requestFrame = this.requestFrame.bind(this);
        this.intervalId = setInterval(function () {
            requestFrame(_frameRate);
        }, timeoutMillis);

        return self;
    },
    stopRequestFrame: function stopRequestFrame() {
        this.intervalId && clearInterval(this.intervalId);
        return this;
    }

    // getImageData: function(x, y, width, height){
    //     x = x || 0,
    //         y = y || 0,
    //         width = width || this.compositeCanvasTag.width,
    //         height = height || this.compositeCanvasTag.height;
    //
    //     var imageData = this._canvasContext.getImageData(x, y, width, height);
    //     return imageData;
    // },

    /**
     * https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/putImageData
     *
     * @param imageData ImageData ，包含像素值的数组对象。
     * @param dx 源图像数据在目标画布中的位置偏移量（x 轴方向的偏移量）。
     * @param dy 源图像数据在目标画布中的位置偏移量（y 轴方向的偏移量）。
     * @param dirtyX 在源图像数据中，矩形区域左上角的位置。默认是整个图像数据的左上角（x 坐标）。
     * @param dirtyY 在源图像数据中，矩形区域左上角的位置。默认是整个图像数据的左上角（y 坐标）。
     * @param dirtyWidth 在源图像数据中，矩形区域的宽度。默认是图像数据的宽度。
     * @param dirtyHeight 在源图像数据中，矩形区域的高度。默认是图像数据的高度。
     * @returns {CompositeCanvas}
     */
    // putImageData: function(imageData, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight){
    //     dx = dx || 0,
    //         dy = dy || 0;
    //
    //     if(arguments.length >= 7){
    //         this._canvasContext.putImageData(imageData, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
    //     }else{
    //         this._canvasContext.putImageData(imageData, dx, dy);
    //     }
    //
    //     return this;
    // },

    /**
     * https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/drawImage
     *
     * @param image 绘制到上下文的元素。允许任何的 canvas 图像源(CanvasImageSource)，例如：HTMLImageElement，HTMLVideoElement，或者 HTMLCanvasElement。
     * @param dx 目标画布的左上角在目标canvas上 X 轴的位置。
     * @param dy 目标画布的左上角在目标canvas上 Y 轴的位置。
     * @param dWidth 在目标画布上绘制图像的宽度。 允许对绘制的图像进行缩放。 如果不说明， 在绘制时图片宽度不会缩放。
     * @param dHeight 在目标画布上绘制图像的高度。 允许对绘制的图像进行缩放。 如果不说明， 在绘制时图片高度不会缩放。
     * @param sx 需要绘制到目标上下文中的，源图像的矩形选择框的左上角 X 坐标。
     * @param sy 需要绘制到目标上下文中的，源图像的矩形选择框的左上角 Y 坐标。
     * @param sWidth 需要绘制到目标上下文中的，源图像的矩形选择框的宽度。如果不说明，整个矩形从坐标的sx和sy开始，到图像的右下角结束。
     * @param sHeight 需要绘制到目标上下文中的，源图像的矩形选择框的高度。
     * @returns {CompositeCanvas}
     */
    // drawImage: function(image, dx, dy, dWidth, dHeight, sx, sy, sWidth, sHeight){
    //     if(arguments.length >= 9){
    //         this._canvasContext.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
    //     }else if(arguments.length >= 5){
    //         this._canvasContext.drawImage(image, dx, dy, dWidth, dHeight);
    //     }else{
    //         dx = dx || 0, dy = dy || 0;
    //         this._canvasContext.drawImage(image, dx, dy);
    //     }
    //
    //     return this;
    // }
});

CompositeCanvas.CompositeOperation = ['source-atop', 'source-in', 'source-out', 'source-over', 'destination-atop', 'destination-in', 'destination-out', 'destination-over', 'lighter', 'darker', 'xor', 'copy'];

var operation = CompositeCanvas.operation = {
    source_atop: 'source-atop',
    source_in: 'source-in',
    source_out: 'source-out',
    source_over: 'source-over',
    destination_atop: 'destination-atop',
    destination_in: 'destination-in',
    destination_out: 'destination-out',
    destination_over: 'destination-over',
    lighter: 'lighter',
    darker: 'darker',
    xor: 'xor',
    copy: 'copy'
};

CompositeCanvas.compositeVideoOverCanvas = function (compositeCanvasTag, video, canvas) {
    var compositeCanvas;
    if (!(compositeCanvas = compositeCanvasTag.compositeCanvas)) {
        compositeCanvas = new CompositeCanvas({
            compositeCanvasTag: compositeCanvasTag,

            requestOneFrame: function requestOneFrame() {
                video && compositeCanvas.drawImage(video, 0, 0, compositeCanvasTag.width, compositeCanvasTag.height);
                canvas && compositeCanvas.drawImage(canvas, 0, 0, compositeCanvasTag.width, compositeCanvasTag.height);
            }
        });

        compositeCanvasTag.compositeCanvas = compositeCanvas;
    }

    return compositeCanvas;
};

module.exports = CompositeCanvas;

/***/ }),
/* 438 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _util = __webpack_require__(72);
var _logger = _util.tagLogger("Keyboard");

module.exports = _util.prototypeExtend({
    onKeyDown: function onKeyDown(btn) {},

    onKeyUp: function onKeyUp(btn) {}
});

/***/ }),
/* 439 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


window.emedia = window.emedia || {};

var _util = __webpack_require__(72);
var _logger = _util.tagLogger("electron");

emedia.electron = window.require('electron');

emedia.chooseElectronDesktopMedia = function (sources, accessApproved, accessDenied) {
    _logger.info("Choose desktop. ", sources[0]);
    accessApproved(sources[0]);
};

/***/ }),
/* 440 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Util = __webpack_require__(70).default;
var RTCIQHandler = __webpack_require__(441);
var API = __webpack_require__(444);
var WebRTC = __webpack_require__(445).default;
var CommonPattern = __webpack_require__(446);
var GetStats = __webpack_require__(447); // 检测通话（peerconnection）数据
var RouteTo = API.RouteTo;
var Api = API.Api;
var _logger = Util.logger;

/**
 * The Call class.
 * @constructor
 * @param {Object} options - 创建连接的初始化参数
 * @param {String} options.connection - WebIM.conn
 * @param {Object} options.mediaStreamConstaints - 开启视频音频{ audio: true, video: true }
 * @param {Object} options.listener - 注册监听
 * @param {function} listener.onAcceptCall -接受呼叫
 * @param {function} listener.onRinging -响铃
 * @param {function} listener.onTermCall -结束/拒绝通话
 * @param {function} listener.onGotLocalStream -获取本地媒体流
 * @param {function} listener.onGotRemoteStream -获取对方媒体流
 * @param {function} listener.onOtherUserOpenVoice -对方打开麦克风
 * @param {function} listener.onOtherUserOpenVideo -对方打开摄像头
 */

var _Call = {
    api: null,
    caller: '',
    connection: null,

    pattern: null,

    watchStats: true, // 是否监听 stats

    listener: {
        onAcceptCall: function onAcceptCall(from, options) {},

        onRinging: function onRinging(caller) {},

        onTermCall: function onTermCall() {},

        onIceConnectionStateChange: function onIceConnectionStateChange(iceState) {},

        onGotLocalStream: function onGotLocalStream() {},

        onGotRemoteStream: function onGotRemoteStream() {},

        onOtherUserOpenVoice: function onOtherUserOpenVoice() {},

        onOtherUserOpenVideo: function onOtherUserOpenVideo() {}
    },

    mediaStreamConstaints: {
        audio: true,
        video: true
    },

    init: function init() {

        var self = this;

        if (typeof self.connection === "undefined") {
            throw "Caller need a instance of Easemob.im.Connection";
        }

        self.api = self.api || new Api({
            imConnection: self.connection,

            rtcHandler: new RTCIQHandler({
                imConnection: self.connection
            })
        });

        self.api.onInitC = function () {
            self._onInitC.apply(self, arguments);
        }, self.api.onInvite = function () {
            self.listener.onInvite.apply(self, arguments);
        }, self.api.onIceConnectionStateChange = function (iceState) {
            self.listener.onIceConnectionStateChange.apply(self, arguments);
        };
    },

    createConference: function createConference(pwd, _callback) {
        var rt = new RouteTo({
            rtKey: ""
        });
        this.api.reqTkt(rt, true, undefined, pwd, function (from, rtcOptions) {
            var ticketStr = rtcOptions.ticket;
            rtcOptions.conferenceId = rtcOptions.confrId;
            _callback && _callback(from, rtcOptions);
        });
    },

    inviteConference: function inviteConference(confrId, pwd, to, gid, _callback) {
        var rt = new RouteTo({
            to: to,
            rtKey: "",
            rtflag: 0
        });
        this.api.invite(rt, confrId, pwd, gid, function (from, rtcOptions) {
            _callback && _callback(from, rtcOptions);
        });
    },

    getConferenceTkt: function getConferenceTkt(confrId, pwd, _callback) {
        var rt = new RouteTo({
            rtKey: ""
        });
        this.api.reqTkt(rt, false, confrId, pwd, function (from, rtcOptions) {
            _callback && _callback(from, rtcOptions);
        });
    },

    /**
     * 发起视频呼叫
     * @method makeVideoCall
     * @param {string} callee -被呼叫人
     * @param {string} accessSid -暂时没有用到
     * @param {boolean} rec -是否录制
     * @param {boolean} recMerge -是否合并
    */
    makeVideoCall: function makeVideoCall(callee, accessSid, rec, recMerge, config) {
        //accessSid 不知道这个有啥用  调用的时候也没有传呀
        var self = this;

        var mediaStreamConstaints = {};
        Util.extend(mediaStreamConstaints, self.mediaStreamConstaints);
        //mediaStreamConstaints.video = true;

        this.call(callee, mediaStreamConstaints, accessSid, rec, recMerge, config);
    },

    /**
     * 发起音频呼叫
     * @method makeVoiceCall
     * @param {string} callee -被呼叫人
     * @param {string} accessSid -暂时没有用到
     * @param {boolean} rec -是否录制
     * @param {boolean} recMerge -是否合并
    */
    makeVoiceCall: function makeVoiceCall(callee, accessSid, rec, recMerge, config) {
        var self = this;

        var mediaStreamConstaints = {};
        Util.extend(mediaStreamConstaints, self.mediaStreamConstaints);
        mediaStreamConstaints.video = false;

        self.call(callee, mediaStreamConstaints, accessSid, rec, recMerge, config);
    },

    /**
     * 接受呼叫
     * @method acceptCall
    */
    acceptCall: function acceptCall() {
        var self = this;
        self.pattern.accept();
    },

    /**
     * 结束/拒绝通话
     * @method endCall
    */
    endCall: function endCall(callee) {
        var self = this;
        self.caller = '';
        self.pattern.termCall();
        self.timer && clearInterval(self.timer);
    },

    call: function call(callee, mediaStreamConstaints, accessSid, rec, recMerge) {
        var config = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : { push: false };

        var self = this;
        self.timer && clearInterval(self.timer);
        if (config.push) {
            var isFirstTime = true;
            var isConnected = false;
            var timeoutTime = config && typeof config.timeoutTime === 'number' && config.timeoutTime || 60000;
            var totalTimes = Number((timeoutTime / 2000).toFixed());
            var currentTime = 0;
        }

        this.callee = this.api.jid(callee);

        var rt = new RouteTo({
            rtKey: "",
            sid: accessSid,
            to: callee,
            success: function success(result) {
                _logger.debug("iq to server success", result);
            },
            fail: function fail(error) {
                _logger.debug("iq to server error", error);
                self.onError(error);
            }
        });

        sendReqP2p();

        function sendReqP2p() {
            self.api.reqP2P(rt, mediaStreamConstaints.video ? 1 : 0, mediaStreamConstaints.audio ? 1 : 0, self.api.jid(callee), rec, recMerge, function (from, rtcOptions) {
                if (rtcOptions.online == "0") {
                    console.warn('callee is not online!');
                    if (!config.push) {
                        return self.listener.onError({ message: "callee is not online!" });
                    }

                    if (isFirstTime) {
                        self.listener.onError({ message: "callee is not online!" });
                        config.push && self.api.senPushMsg(callee, config.txtMsg, config.pushMsg);
                    }
                    isFirstTime = false;
                    isConnected = false;
                    self.timer = !isConnected && currentTime <= totalTimes && setTimeout(function () {
                        currentTime++;
                        sendReqP2p();
                    }, 2000);

                    if (currentTime > totalTimes) {
                        self.listener.onError({ message: "call timeout" });
                    }
                } else {
                    rtcOptions.streamType = mediaStreamConstaints.audio && mediaStreamConstaints.video ? "VIDEO" : "VOICE";

                    self._onGotServerP2PConfig(from, rtcOptions);
                    self.pattern.initC(mediaStreamConstaints, accessSid, rec, recMerge);
                    isConnected = true;
                }
            });

            return isConnected;
        }
    },

    /**
     * 控制媒体流，通知对方打开关闭麦克风摄像头
     * @method controlStream
     * @param {Number} controlType -操作类型 0:打开麦克风；1:关闭麦克风；2:关闭摄像头；3:打开摄像头
     * @param {string} to -接收人
    */
    controlStream: function controlStream(controlType, to) {
        var rt = new RouteTo({
            to: to,
            rtKey: "",
            rtflag: 0
        });
        this.api.streamControl(rt, null, this.rtcId, controlType, this.localStream);
    },

    /**
     * 获取音视频录制的id
     * @method getServerRecordId
    */
    getServerRecordId: function getServerRecordId() {
        var api = this.api;
        var rtcHandler = api.rtcHandler;
        var confrId = rtcHandler.confrId;
        if (confrId) {
            return confrId;
        }
        return null;
    },

    _onInitC: function _onInitC(from, options, rtkey, tsxId, fromSid) {
        var self = this;

        self.callee = from;

        self._rtcCfg = options.rtcCfg;
        self._WebRTCCfg = options.WebRTC;

        self.sessId = options.sessId;
        self.rtcId = options.rtcId;

        self.switchPattern(options.streamType == "VIDEO" ? "VIDEO" : "VOICE");
        options.globalMediaConstaints = self.mediaStreamConstaints;
        self.pattern._onInitC(from, options, rtkey, tsxId, fromSid);
    },

    _onInvite: function _onInvite() {},

    _onGotServerP2PConfig: function _onGotServerP2PConfig(from, rtcOptions) {
        var self = this;

        if (rtcOptions.result == 0) {
            self._p2pConfig = rtcOptions;
            self._rtcCfg = rtcOptions.rtcCfg;
            self._rtcCfg2 = rtcOptions.rtcCfg2;

            self.sessId = rtcOptions.sessId;
            self.rtcId = 'RTCID' + rtcOptions.sessId; //"Channel_webIM";

            self._rtKey = self._rtkey = rtcOptions.rtKey || rtcOptions.rtkey;
            self._rtFlag = self._rtflag = rtcOptions.rtFlag || rtcOptions.rtflag;

            self._WebRTCCfg = rtcOptions.WebRTC;
            self.admtok = rtcOptions.admtok;
            self.tkt = rtcOptions.tkt;

            self.switchPattern(rtcOptions.streamType);
        } else {
            //
        }
    },

    switchPattern: function switchPattern(streamType) {
        var self = this;
        !self._WebRTCCfg && (self.pattern = new CommonPattern({
            callee: self.callee,

            _p2pConfig: self._p2pConfig,
            _rtcCfg: self._rtcCfg,
            _rtcCfg2: self._rtcCfg2,

            _rtKey: self._rtKey || self._rtkey,
            _rtFlag: self._rtFlag || self._rtflag,

            _sessId: self.sessId,
            _rtcId: self.rtcId,

            webRtc: new WebRTC({
                streamType: streamType,
                subArgs: {
                    subSVideo: "VIDEO" === streamType,
                    subSAudio: true
                },
                onGotLocalStream: function onGotLocalStream(localStream, event) {
                    self.listener.onGotLocalStream(localStream, streamType);
                    self.localStream = localStream;
                },
                onGotRemoteStream: function onGotRemoteStream(remoteStream, event) {
                    self.listener.onGotRemoteStream(remoteStream, streamType);
                    self.remoteStream = remoteStream;

                    if (self.watchStats) {
                        // 是否需要 getStats
                        var peerC = self.pattern.webRtc._rtcPeerConnection;
                        self.get_stats = new GetStats(peerC, self); // 开启 stats 监控
                        self.get_stats.start();
                    }
                },
                onError: self.listener.onError
            }),

            api: self.api,

            onAcceptCall: self.listener && self.listener.onAcceptCall || function () {},
            onRinging: self.listener && self.listener.onRinging || function () {},
            onTermCall: function onTermCall(reason) {

                if (self.get_stats) {
                    // 停止数据监控
                    self.get_stats.stop();
                }
                self.listener && self.listener.onTermCall(reason);
            },
            onOtherUserOpenVoice: self.listener && self.listener.onOtherUserOpenVoice || function () {},
            onOtherUserOpenVideo: self.listener && self.listener.onOtherUserOpenVideo || function () {}
        }));
    }
};

module.exports = function (initConfigs) {
    Util.extend(true, this, _Call, initConfigs || {});

    this.init();
};

/***/ }),
/* 441 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _stringify = __webpack_require__(442);

var _stringify2 = _interopRequireDefault(_stringify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * IQ Message，IM -> CMServer --> IM
 */

var _util = __webpack_require__(70).default;
var _logger = _util.logger;
var API = __webpack_require__(444);
var RouteTo = API.RouteTo;
var CONFERENCE_XMLNS = "urn:xmpp:media-conference";
var _RtcHandler = {
    _apiCallbacks: {},
    imConnection: null,
    _connectedSid: '',

    init: function init() {
        var self = this;
        var _conn = self.imConnection;

        _conn.registerConfrIQHandler = function (meta, status, conn) {
            // var handleConferenceIQ = function (meta, status, conn) {
            try {
                self.handleRtcMessage(meta);
            } catch (error) {
                _logger.error(error);
                //throw error;
            }
            //return true;
            //};

            // _conn.addHandler(handleConferenceIQ, CONFERENCE_XMLNS, 'iq', "set");
            // _conn.addHandler(handleConferenceIQ, CONFERENCE_XMLNS, 'iq', "get");
            //_logger.warn("Conference iq handler. registered.");
        };
    },

    handleRtcMessage: function handleRtcMessage(msginfo, status, conn) {
        var self = this;
        if (!msginfo) {
            return;
        }
        var messageBodyMessage = WebIM.conn.context.root.lookup("easemob.pb.ConferenceBody");
        var thirdMessage = messageBodyMessage.decode(msginfo.payload);
        var id = msginfo.id;
        var from = msginfo.from.name || '';
        // remove resource
        from.lastIndexOf("/") >= 0 && (from = from.substring(0, from.lastIndexOf("/")));

        var rtkey = thirdMessage.routeKey;

        var fromSessionId = thirdMessage.sessionId;

        (self._fromSessionID || (self._fromSessionID = {}))[from] = fromSessionId;

        // var contentTags = msginfo.getElementsByTagName('content');
        // var contentString = contentTags[0].innerHTML;

        var content = _util.parseJSON(thirdMessage.content);
        if (content.confrId) {
            this.confrId = content.confrId;
        }
        //this.confrId = this.confrId||content.confrId //开启录制的时候会有这个confrId
        var rtcOptions = content;
        //var mediaType = content.rtcCfg&&JSON.parse(content.rtcCfg).capVideo ? 'VIDEO': 'VOICE';
        var streamType = thirdMessage.type == 1 ? 'VIDEO' : 'VOICE'; //VOICE, VIDEO

        if (streamType == "") {
            streamType = "VOICE";
        }

        rtcOptions.streamType = streamType;

        if (rtcOptions.op == 102) {
            self.singalStreamType = streamType;
        }

        var tsxId = content.tsxId;

        self.ctx = content.ctx;

        _logger.debug("Recv [op = " + rtcOptions.op + "] [tsxId=" + tsxId + "]\r\n json :", msginfo);

        //if a->b already, c->a/b should be termiated with 'busy' reason
        //if (from.indexOf("@") >= 0) {
        if (self._connectedSid == '' && (rtcOptions.result == 0 || rtcOptions.op == 102 || rtcOptions.op == 202)) {
            self._connectedSid = fromSessionId;
        } else {
            if (self._connectedSid != fromSessionId) {
                _logger.debug("Error recv [op = " + rtcOptions.op + "] [tsxId=" + tsxId + "]. caused by _connectedSid != fromSessionId :", self._connectedSid, fromSessionId);

                //onInitC
                if (rtcOptions.op == 102 && fromSessionId && self._connectedSid) {
                    var rt = new RouteTo({
                        to: from,
                        rtKey: rtkey,
                        sid: fromSessionId,
                        success: function success(result) {
                            _logger.debug("iq to server success", result);
                        },
                        fail: function fail(error) {
                            _logger.debug("iq to server error", error);
                            self.onError(error);
                        }
                    });

                    var options = {
                        data: {
                            op: 107,
                            sessId: rtcOptions.sessId,
                            rtcId: rtcOptions.rtcId,
                            reason: 'busy'

                        },
                        reason: 'busy'
                    };
                    self.sendRtcMessage(rt, options);
                }
                return;
            }
        }
        //}

        // not online clear self._connectedSid
        if (rtcOptions.online == 0) {
            self._connectedSid = '';
        }
        //onTermC
        if (rtcOptions.op == 107) {
            self._connectedSid = '';
            self._fromSessionID = {};
            // "ok"      -> 'HANGUP'     "success" -> 'HANGUP'   "timeout"          -> 'NORESPONSE'
            // *               "decline" -> 'REJECT'     "busy"    -> 'BUSY'     "failed-transport" -> 'FAIL'
            var endreasonCode = {
                0: "hangup",
                1: "noresponse",
                2: "reject",
                3: "busy",
                4: "fail",
                5: "unsupported",
                6: "offline"
            };
            var reasonCode = thirdMessage.endReason;
            rtcOptions.reason = reasonCode != undefined && endreasonCode[reasonCode];
        }

        if (rtcOptions.sdp) {
            if (typeof rtcOptions.sdp === 'string') {
                rtcOptions.sdp = _util.parseJSON(rtcOptions.sdp);
            }
            rtcOptions.sdp.type && (rtcOptions.sdp.type = rtcOptions.sdp.type.toLowerCase());
        }
        if (rtcOptions.cands) {
            if (typeof rtcOptions.cands === 'string') {
                rtcOptions.cands = _util.parseJSON(rtcOptions.cands);
            }

            for (var i = 0; i < rtcOptions.cands.length; i++) {
                if (typeof rtcOptions.cands[i] === 'string') {
                    try {
                        rtcOptions.cands[i] = _util.parseJSON(rtcOptions.cands[i]);
                    } catch (e) {
                        rtcOptions.cands[i] = { candidate: rtcOptions.cands[i] };
                    }
                }

                rtcOptions.cands[i].sdpMLineIndex = rtcOptions.cands[i].sdpMLineIndex !== undefined ? rtcOptions.cands[i].sdpMLineIndex : rtcOptions.cands[i].mlineindex;
                rtcOptions.cands[i].sdpMid = rtcOptions.cands[i].sdpMid !== undefined ? rtcOptions.cands[i].sdpMid : rtcOptions.cands[i].mid;

                delete rtcOptions.cands[i].mlineindex;
                delete rtcOptions.cands[i].mid;
            }
        }

        rtcOptions.rtcCfg && typeof rtcOptions.rtcCfg === 'string' && (rtcOptions.rtcCfg = _util.parseJSON(rtcOptions.rtcCfg));
        rtcOptions.rtcCfg2 && typeof rtcOptions.rtcCfg2 === 'string' && (rtcOptions.rtcCfg2 = _util.parseJSON(rtcOptions.rtcCfg2));
        rtcOptions.WebRTC && typeof rtcOptions.WebRTC === 'string' && (rtcOptions.WebRTC = _util.parseJSON(rtcOptions.WebRTC));
        rtcOptions.confrId && (rtcOptions.conferenceId = rtcOptions.confrId);

        if (tsxId && self._apiCallbacks[tsxId]) {
            try {
                self._apiCallbacks[tsxId].callback && self._apiCallbacks[tsxId].callback(from, rtcOptions);
            } catch (err) {
                throw err;
            } finally {
                delete self._apiCallbacks[tsxId];
            }
        } else {
            self.onRecvRtcMessage(from, rtcOptions, rtkey, tsxId, fromSessionId);
        }

        return true;
    },

    onRecvRtcMessage: function onRecvRtcMessage(from, rtcOptions, rtkey, tsxId, fromSessionId) {
        _logger.debug(' form : ' + from + " \r\n json :" + _util.stringifyJSON(rtcJSON));
    },

    convertRtcOptions: function convertRtcOptions(options) {
        var sdp = options.data.sdp;
        if (sdp) {
            var _sdp = {
                type: sdp.type,
                sdp: sdp.sdp
            };

            sdp = _sdp;

            sdp.type = sdp.type.toUpperCase();
            sdp = _util.stringifyJSON(sdp);

            options.data.sdp = sdp;
        }

        var cands = options.data.cands;

        if (cands) {
            if (_util.isArray(cands)) {} else {
                var _cands = [];
                _cands.push(cands);
                cands = _cands;
            }

            for (var i in cands) {
                var cand = cands[i];

                if (cand.candidate !== undefined && cand.sdpMLineIndex !== undefined && cand.sdpMid !== undefined) {
                    var _cand = {
                        type: "candidate",
                        candidate: cand.candidate,
                        mlineindex: cand.sdpMLineIndex,
                        mid: cand.sdpMid
                        // seq: i
                    };

                    cands[i] = _util.stringifyJSON(_cand);
                }
            }

            options.data.cands = cands;
        } else {
            // options.data.cands = [];
        }

        var rtcCfg = options.data.rtcCfg;
        if (rtcCfg) {
            typeof rtcCfg !== 'string' && (options.data.rtcCfg = _util.stringifyJSON(rtcCfg));
        }

        var _webrtc = options.data.WebRTC;
        if (_webrtc) {
            typeof _webrtc !== 'string' && (options.data.WebRTC = _util.stringifyJSON(_webrtc));
        }
    },

    getShortId: function getShortId(jid) {
        var begin;
        if ((begin = jid.indexOf('_') + 1) < 1) {
            begin = 0;
        }

        var end;
        if ((end = jid.indexOf('@', -1)) < 0) {
            end = jid.length;
        }

        return jid.substring(begin, end);
    },

    /**
     * rt: { id: , to: , rtKey: , rtflag: , sid: , tsxId: , type: , }
     * rtcOptions: { data : { op : 'reqP2P', video : 1, audio : 1, peer :
     * curChatUserId, //appKey + "_" + curChatUserId + "@" + this.domain, } }
     */
    sendRtcMessage: function sendRtcMessage(rt, options, callback) {

        var self = this;
        var _conn = self.imConnection;
        var tsxId = _conn.getUniqueId(); //rt.tsxId || _conn.getUniqueId();

        var to = rt.to && rt.to || _conn.domain;
        if (to.indexOf("@") >= 0) {
            var toArr = to.split('_');
            toArr.splice(0, 1);
            to = toArr.join('_').split('@')[0];
            if (self._connectedSid == '' && options.data.op == 102) {
                self._connectedSid = sid;
            }
        }
        var sid = rt.sid || self._fromSessionID && self._fromSessionID[to];
        sid = sid || ((self._fromSessionID || (self._fromSessionID = {}))[to] = _conn.getUniqueId("CONFR_"));

        //sid = sid || _conn.getUniqueId("CONFR_");

        (self._fromSessionID || (self._fromSessionID = {}))[to] = sid;

        var rtKey = rt.rtKey || rt.rtkey;
        // rtKey && delete rt.rtKey;
        rtKey || (rtKey = "");

        var rtflag = rt.rtflag;
        // rtflag && delete rt.rtflag;
        !isNaN(rtflag) || (rtflag = 1);

        options.data || (options.data = {});
        options.data.tsxId = tsxId;

        self.ctx && (options.data.ctx = self.ctx);
        self.convertRtcOptions(options);
        var streamType = options.streamType || self.singalStreamType || "VIDEO"; // "VIDEO"; //VOICE, VIDEO
        if (options.data.op == 102) {
            self.singalStreamType = streamType;
        }

        var id = rt.id || _conn.getUniqueId("CONFR_");

        callback && (self._apiCallbacks[tsxId] = {
            callback: callback
        });

        var sendOptions = {
            id: id,
            to: to,
            from: _conn.context.jid,
            type: streamType == "VIDEO" ? 1 : 0,
            rtflag: rtflag,
            stream_type: streamType,
            sid: sid,
            content: options.data,
            reason: options.reason,
            rtKey: rtKey
        };

        if (options.data.op == 0) {
            sendOptions.rec = options.data.rec;
            sendOptions.recMerge = options.data.recMerge;
            this.rec = options.data.rec;
            this.recMerge = options.data.recMerge;
        }

        if (options.data.op != 202) {
            this._sendMessage(sendOptions, WebIM.conn);
        }

        //onTermC
        if (options.data.op == 107 && self._connectedSid) {
            if (!rt.sid || self._connectedSid == rt.sid) {
                self._connectedSid = '';
                self._fromSessionID = {};
            }
        }

        if (options.data.op == 202) {
            var msg = _util.list("Invite", self.getShortId(to), "join conference:", options.data.confrId).join(" ");
            var id = _conn.getUniqueId("CONFR_INVITE"); // 生成本地消息id
            //msg = '快来加入会议'+' - 13 ' + options.data.confrId
            var inviteMessage = {
                msg: msg,
                id: id,
                to: to,
                from: _conn.context.jid,
                contents: [{
                    contenttype: 'TEXT',
                    text: msg
                }],
                gid: options.data.gid,
                password: options.data.password,
                exts: {
                    key: "conferenceId",
                    type: 7,
                    value: options.data.confrId
                }
            };
            return this._sendGroupInviteMsg(inviteMessage, WebIM.conn);
        }
    },

    _sendGroupInviteMsg: function _sendGroupInviteMsg(messageOption, conn) {
        var emptyMessage = [];
        var contentMessage = conn.context.root.lookup("easemob.pb.MessageBody.Content");
        var fifthMessage = contentMessage.decode(emptyMessage);

        fifthMessage.type = 0;
        fifthMessage.text = messageOption.msg;

        var messageBody = conn.context.root.lookup("easemob.pb.MessageBody");
        var fourthMessage = messageBody.decode(emptyMessage);

        fourthMessage.from = {
            name: messageOption.from.name
        };
        fourthMessage.to = {
            name: messageOption.to
        };

        fourthMessage.contents = [fifthMessage];

        var extMsg = conn.context.root.lookup("easemob.pb.KeyValue");
        var ext = extMsg.decode(emptyMessage);
        var ext2 = extMsg.decode(emptyMessage);
        var ext3 = extMsg.decode(emptyMessage);
        ext.key = 'conferenceId';
        ext.type = 7;
        ext.stringValue = messageOption.exts.value;

        ext2.key = 'msg_extension';
        ext2.type = 7;
        ext2.stringValue = (0, _stringify2.default)({
            "inviter": messageOption.from.name,
            "group_id": messageOption.gid
        });

        ext3.key = 'password';
        ext3.type = 7;
        ext3.stringValue = messageOption.password;

        fourthMessage.ext = [ext, ext2, ext3];
        fourthMessage.type = 1;
        fourthMessage = messageBody.encode(fourthMessage).finish();

        var MetaMessage = conn.context.root.lookup("easemob.pb.Meta");
        var thirdMessage = MetaMessage.decode(emptyMessage);

        thirdMessage.id = messageOption.id;
        thirdMessage.from = messageOption.from;

        thirdMessage.to = {
            appKey: conn.appKey,
            name: messageOption.to,
            domain: "easemob.com"
            // clientResource: conn.clientResource
        };

        thirdMessage.ns = 1;
        thirdMessage.type = 1;
        thirdMessage.payload = fourthMessage;
        var commSyncULMessage = conn.context.root.lookup("easemob.pb.CommSyncUL");
        var secondMessage = commSyncULMessage.decode(emptyMessage);
        secondMessage.meta = thirdMessage;
        secondMessage = commSyncULMessage.encode(secondMessage).finish();
        var msyncMessage = conn.context.root.lookup("easemob.pb.MSync");
        var firstMessage = msyncMessage.decode(emptyMessage);

        firstMessage.version = conn.version;
        firstMessage.encryptType = conn.encryptType;
        firstMessage.command = 0;
        firstMessage.guid = conn.context.jid;
        firstMessage.payload = secondMessage;
        firstMessage = msyncMessage.encode(firstMessage).finish();
        conn.sendMSync(firstMessage);
    },

    _sendMessage: function _sendMessage(messageOption, conn) {
        var self = conn;
        var emptyMessage = [];

        //构造 content
        var contentMessage = conn.context.root.lookup("easemob.pb.ConferenceBody");
        //构造 第一层
        var fifthMessage = contentMessage.decode(emptyMessage);
        var mediaType = messageOption.content.video;
        var content;
        if (messageOption.content.op == 0) {
            content = {
                op: messageOption.content.op,
                callVersion: "2.0.0",
                audio: messageOption.content.audio,
                video: messageOption.content.video,
                //sessId: messageOption.sid,
                tsxId: String(messageOption.content.tsxId),
                peer: messageOption.content.peer + "/",
                push: 0
                // rec: messageOption.rec?1:0,
                // recMerge: messageOption.recMerge?1:0,
            };
            if (messageOption.rec) {
                content.rec = 1;
            }
            if (messageOption.recMerge) {
                content.recMerge = 1;
            }
        } else if (messageOption.content.op == 102) {
            //为了判断是否录制
            content = messageOption.content;
            content.tsxId = String(messageOption.content.tsxId);
            if (this.rec) {
                content.rec = 1;
            }
        } else if (messageOption.content.op == 400) {
            content = messageOption.content;
        } else {
            content = messageOption.content;
            content.tsxId = String(messageOption.content.tsxId);
        }
        var op = messageOption.content.op;
        fifthMessage.content = (0, _stringify2.default)(content);
        fifthMessage.routeFlag = messageOption.rtflag;
        fifthMessage.operation = 7;
        fifthMessage.sessionId = String(messageOption.sid); //和content里的sid不同？ 都是什么
        fifthMessage.type = messageOption.type;

        if (op == 102 || op == 104 || op == 105 || op == 107 || op == 400 || 100) {
            fifthMessage.routeKey = messageOption.rtKey;
            fifthMessage.routeFlag = messageOption.rtflag;
            fifthMessage.peerName = messageOption.from.name;
        }

        if (op == 107) {
            //"ok"      -> 'HANGUP'     "success" -> 'HANGUP'   "timeout"          -> 'NORESPONSE'
            //"decline" -> 'REJECT'     "busy"    -> 'BUSY'     "failed-transport" -> 'FAIL'
            var endreasonCode = {
                success: 0,
                ok: 0,
                timeout: 1,
                decline: 2,
                busy: 3,
                "failed-transport": 4,
                unsupported: 5,
                offline: 6
            };
            fifthMessage.endReason = endreasonCode[messageOption.reason];
        }

        fifthMessage = contentMessage.encode(fifthMessage).finish();
        var MetaMessage = conn.context.root.lookup("easemob.pb.Meta");
        var thirdMessage = MetaMessage.decode(emptyMessage);
        thirdMessage.id = String(messageOption.id);

        thirdMessage.ns = 4;
        thirdMessage.to = {
            appKey: messageOption.from.appKey,
            domain: messageOption.from.domain,
            name: messageOption.to
        };
        if (messageOption.content.op == 102) {
            thirdMessage.from = messageOption.from; //.appKey+'_'+messageOption.from.name+'@'+messageOption.from.domain
        }

        thirdMessage.payload = fifthMessage;
        var commSyncULMessage = conn.context.root.lookup("easemob.pb.CommSyncUL");
        var secondMessage = commSyncULMessage.decode(emptyMessage);
        secondMessage.meta = thirdMessage;

        secondMessage = commSyncULMessage.encode(secondMessage).finish();
        var msyncMessage = conn.context.root.lookup("easemob.pb.MSync");
        var firstMessage = msyncMessage.decode(emptyMessage);

        firstMessage.version = conn.version;
        firstMessage.encryptType = conn.encryptType;
        firstMessage.command = 0;
        firstMessage.guid = conn.context.jid;
        firstMessage.payload = secondMessage;
        firstMessage = msyncMessage.encode(firstMessage).finish();
        conn.sendMSync(firstMessage);
    },

    _sendPushMsg: function _sendPushMsg(to) {
        var msg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
        var pushMsg = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : WebIM.conn.user + '\u6B63\u5728\u547C\u53EB\u4F60...';

        var msgObj = new WebIM.message('txt', WebIM.conn.getUniqueId());
        msgObj.set({
            msg: msg,
            to: to,
            roomType: false,
            chatType: 'singleChat',
            success: function success() {},
            fail: function fail() {
                console.warn('Send push error，Please make sure that you are not blocked');
            },
            ext: {
                em_apns_ext: {
                    em_push_title: pushMsg
                }
            }
        });

        WebIM.conn.send(msgObj.body);
    }
};

var RTCIQHandler = function RTCIQHandler(initConfigs) {
    _util.extend(true, this, _RtcHandler, initConfigs || {});
    this.init();
};

module.exports = RTCIQHandler;

/***/ }),
/* 442 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(443), __esModule: true };

/***/ }),
/* 443 */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(14);
var $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });
module.exports = function stringify(it) { // eslint-disable-line no-unused-vars
  return $JSON.stringify.apply($JSON, arguments);
};


/***/ }),
/* 444 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof2 = __webpack_require__(3);

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * API
 */
var _util = __webpack_require__(70).default;
var _logger = _util.logger;

var _RouteTo = {
    // to : null,
    // rtKey: null,
    rtFlag: 1,

    success: function success(result) {},
    fail: function fail(error) {}
};

var RouteTo = function RouteTo(extendCfg) {
    if (this instanceof RouteTo) {
        var self = this;
        _util.extend(true, self, _RouteTo, extendCfg || {});
    } else {
        var sub = function sub(extendCfg) {
            var self = this;
            _util.extend(true, self, extendCfg || {});
        };

        _util.extend(true, sub.prototype, _RouteTo, extendCfg || {});

        return sub;
    }
};
exports.RouteTo = RouteTo;

var _clazz = {
    imConnection: null,
    // webRtc: null,

    rtcHandler: null,

    events: {
        '0': 'onReqP2P', //use
        '1': 'onNewCfr',
        '2': 'onDelCfr',
        '3': 'onReqTkt',

        '100': 'onPing',
        '101': 'onPong',
        '102': 'onInitC', //use
        '103': 'onReqC', //use
        '104': 'onAcptC', //use
        '105': 'onTcklC', //use
        '106': 'onAnsC', //use
        '107': 'onTermC', //use

        // '200' : 'onEnter',
        // '201' : 'onExit',
        '202': 'onInvite',
        // '203' : 'onGetMems',

        // '205' : 'onSubC',
        // '206' : 'onUsubC',

        '300': 'onEvEnter',
        '301': 'onEvExit',
        '302': 'onEvPub',
        '303': 'onEvUnpub',
        '304': 'onEvMems',
        '204': 'onEvClose',
        '400': 'onStreamControl', //use
        '401': 'onEvJoin',

        'onServerError': 'onServerError'
    },

    register: function register(listener) {
        if ((typeof listener === 'undefined' ? 'undefined' : (0, _typeof3.default)(listener)) === "object") {
            for (var event in listener) {
                this.bind(event, listener[event]);
            }
        }
    },

    bind: function bind(event, func) {
        var self = this;

        var onFunc;
        if (onFunc = self.events[event]) {
            self[onFunc] = func;
        } else {
            onFunc = self.events[event] = 'on_' + event;
            self[onFunc] = func;
        }
    },

    jid: function jid(shortUserName) {
        if (/^.+#.+_.+@.+$/g.test(shortUserName)) {
            return shortUserName;
        }
        // if (shortUserName.indexOf(this.imConnection.context.appKey) >= 0) {
        //     return shortUserName;
        // }
        return this.imConnection.context.appKey + "_" + shortUserName + "@" + this.imConnection.domain;
    },

    /**
     * ReqP2P 0
     *
     * @param rt
     *            {to: , rtKey: , rtflag: , success(result), fail(error)}
     *
     * @param callback(from, rtcOptions)
     *
     *
     * @param video
     *            1 0
     * @param audio
     *            1 0
     * @param peer
     *
     */
    reqP2P: function reqP2P(rt, video, audio, peer, rec, recMerge, callback) {
        _logger.debug("req p2p ...");

        var rtcOptions = {
            data: {
                op: 0,
                video: video,
                audio: audio,
                peer: peer, // appKey + "_" + curChatUserId + "@" + this.domain,
                rec: rec,
                recMerge: recMerge
            }
        };

        rtcOptions.streamType = video && audio ? "VIDEO" : "VOICE";

        this.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);
    },

    senPushMsg: function senPushMsg(to, msg, pushMsg) {
        return this.rtcHandler._sendPushMsg(to, msg, pushMsg);
    },

    /**
     * NewCfr 1
     *
     * @param rt
     *            {to: , rtKey: , rtflag: , success(result), fail(error)}
     *
     * @param callback(from, rtcOptions)
     *
     *
     * @param reqTkt
     *            1 null
     * @param password
     *            string null
     *
     */
    newCfr: function newCfr(rt, reqTkt, password, callback) {
        _logger.debug("newCfr ...");

        var self = this;

        var rtcOptions = {
            data: {
                op: 1
            }
        };

        reqTkt && (rtcOptions.data.reqTkt = reqTkt);
        password && (rtcOptions.data.password = password);

        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);
    },

    /**
     * Enter 200
     *
     * @param rt
     *            {to: , rtKey: , rtflag: , success(result), fail(error)}
     *
     * @param callback(from, rtcOptions)
     *
     *
     * @param WebRTCId
     * @param reqMembers !=
     *            0 members
     * @param tkt
     * @param nonce
     * @param digest
     *
     */
    enter: function enter(rt, WebRTCId, reqMembers, tkt, nonce, digest, callback) {
        _logger.debug("enter ...");

        var self = this;

        var rtcOptions = {
            data: {
                op: 200
            }
        };

        WebRTCId && (rtcOptions.data.WebRTCId = WebRTCId);
        reqMembers && (rtcOptions.data.reqMembers = reqMembers);
        tkt && (rtcOptions.data.tkt = tkt);
        nonce && (rtcOptions.data.nonce = nonce);
        digest && (rtcOptions.data.digest = digest);

        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);
    },

    /**
     * Ping 100
     *
     * @param rt
     *            {to: , rtKey: , rtflag: , success(result), fail(error)}
     *
     * @param callback(from, rtcOptions)
     *
     *
     * @param sessId
     *
     */
    ping: function ping(rt, sessId, callback) {
        _logger.debug("ping ...");

        var self = this;

        var rtcOptions = {
            data: {
                op: 100
            }
        };

        sessId && (rtcOptions.data.sessId = sessId);

        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);
    },

    /**
     * 通知对方 我已经关闭/打开 麦卡，摄像头
     *
     * PAUSE_VOICE(0, 0), RESUME_VOICE(1, 1), PAUSE_VIDEO(2, 2), RESUME_VIDEO(3, 3)
     *
     *
     * @param rt
     * @param sessId
     * @param rtcId
     * @param controlType
     * @param callback
     */
    streamControl: function streamControl(rt, sessId, rtcId, controlType, stream, callback) {
        _logger.debug("streamControl ...");

        var self = this;

        var rtcOptions = {
            data: {
                op: 400
            }
        };
        var enable = controlType == 0 || controlType == 3 ? true : false;
        if (controlType == 0 || controlType == 1) {
            emedia.enableAudioTracks(stream, enable);
        } else {
            emedia.enableVideoTracks(stream, enable);
        }

        sessId && (rtcOptions.data.sessId = sessId);
        rtcId && (rtcOptions.data.rtcId = rtcId);
        typeof controlType !== 'undefined' && controlType != null && (rtcOptions.data.controlType = controlType);

        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);
    },

    /**
     * ReqTkt 3
     *
     * @param rt
     *            {to: , rtKey: , rtflag: , success(result), fail(error)}
     *
     * @param callback(from, rtcOptions)
     *
     *
     * @param WebRTCId
     * @param success(from,
     *            rtcOptions)
     *
     */
    reqTkt: function reqTkt(rt, isCreate, confrId, password, callback) {
        _logger.debug("reqTkt ...");

        var self = this;

        var rtcOptions = {
            data: {
                op: 3
            }
        };

        isCreate && (rtcOptions.data.isCreate = isCreate);
        confrId && (rtcOptions.data.confrId = confrId);
        typeof password === "string" && (rtcOptions.data.password = password);

        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);
    },

    invite: function invite(rt, confrId, password, gid, callback) {
        _logger.debug("reqTkt ...");

        var self = this;

        var rtcOptions = {
            data: {
                op: 202
            }
        };

        confrId && (rtcOptions.data.confrId = confrId); // 格式需要跟雅洁确定
        typeof password === "string" && (rtcOptions.data.password = password);
        gid && (rtcOptions.data.gid = gid);
        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);
    },

    /**
     * InitC 102
     *
     * @param rt
     *            {to: , rtKey: , rtflag: , success(result), fail(error)}
     *
     * @param callback(from, rtcOptions)
     *
     *
     * @param WebRTCId
     * @param tkt
     * @param sessId
     * @param rtcId
     * @param pubS
     *            {name: streamName, video:1, audio:1, type: 0}
     * @param subS
     *            {memId: , rtcId: }
     * @param sdp
     *            sdp:sdpstring
     * @param cands [ ]
     *
     */
    initC: function initC(rt, streamType, WebRTCId, tkt, sessId, rtcId, pubS, subS, sdp, cands, rtcCfg, WebRTC, callback) {
        _logger.debug("initC ...");
        var toArr = rt.to.split('_');
        toArr.splice(0, 1);
        rt.to = toArr.join('_').split('@')[0];

        var rtcOptions = {
            data: {
                op: 102
            }
        };

        rtcOptions.streamType = streamType || "VIDEO";

        WebRTCId && (rtcOptions.data.WebRTCId = WebRTCId);
        tkt && (rtcOptions.data.tkt = tkt);
        sessId && (rtcOptions.data.sessId = sessId);
        rtcId && (rtcOptions.data.rtcId = rtcId);
        pubS && (rtcOptions.data.pubS = pubS);
        subS && (rtcOptions.data.subS = subS);
        sdp && (rtcOptions.data.sdp = sdp);
        cands && (rtcOptions.data.cands = cands);
        rtcCfg && (rtcOptions.data.rtcCfg = rtcCfg);
        WebRTC && (rtcOptions.data.WebRTC = WebRTC);

        rtcOptions.data.expr = !emedia.supportPRAnswer ? 0 : 1; //Firefox 和 Edge不希望sdk回复 pranswer

        this.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);
    },

    /**
     * TcklC 105
     *
     * @param rt
     *            {to: , rtKey: , rtflag: , success(result), fail(error)}
     *
     * @param callback(from, rtcOptions)
     *
     *
     * @param sessId
     * @param rtcId
     * @param cands
     * @param success(from,
     *            rtcOptions)
     *
     */
    tcklC: function tcklC(rt, sessId, rtcId, sdp, cands, callback) {
        _logger.debug("tcklC ...");

        var self = this;

        var rtcOptions = {
            data: {
                op: 105
            }
        };

        sessId && (rtcOptions.data.sessId = sessId);
        rtcId && (rtcOptions.data.rtcId = rtcId);
        sdp && (rtcOptions.data.sdp = sdp);
        cands && (rtcOptions.data.cands = cands);

        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);
    },

    /**
     * AnsC 106
     *
     * @param rt
     *            {to: , rtKey: , rtflag: , success(result), fail(error)}
     *
     * @param callback(from, rtcOptions)
     *
     *
     * @param sessId
     * @param rtcId
     * @param sdp
     * @param cands
     *
     */
    ansC: function ansC(rt, sessId, rtcId, sdp, cands, callback, enableVoice, enableVideo) {
        _logger.debug("ansC ...");

        var self = this;

        var rtcOptions = {
            data: {
                op: 106
            }
        };

        sessId && (rtcOptions.data.sessId = sessId);
        rtcId && (rtcOptions.data.rtcId = rtcId);
        sdp && (rtcOptions.data.sdp = sdp);
        cands && (rtcOptions.data.cands = cands);

        enableVoice === false && (rtcOptions.data.enableVoice = enableVoice);
        enableVideo === false && (rtcOptions.data.enableVideo = enableVideo);

        // rtcOptions.data.enableVoice = false;
        // rtcOptions.data.enableVideo = false;

        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);
    },

    /**
     * AcptC 104
     *
     * @param rt
     *            {to: , rtKey: , rtflag: , success(result), fail(error)}
     *
     * @param callback(from, rtcOptions)
     *
     *
     * @param sessId
     * @param rtcId
     * @param sdp
     * @param ans
     *            1
     *
     */
    acptC: function acptC(rt, sessId, rtcId, sdp, cands, ans, callback, enableVoice, enableVideo) {
        _logger.debug("acptC ...");

        var self = this;

        var rtcOptions = {
            data: {
                op: 104
            }
        };

        sessId && (rtcOptions.data.sessId = sessId);
        rtcId && (rtcOptions.data.rtcId = rtcId);
        sdp && (rtcOptions.data.sdp = sdp);
        cands && (rtcOptions.data.cands = cands);
        ans && (rtcOptions.data.ans = ans);

        enableVoice === false && (rtcOptions.data.enableVoice = enableVoice);
        enableVideo === false && (rtcOptions.data.enableVideo = enableVideo);

        // rtcOptions.data.enableVoice = false;
        // rtcOptions.data.enableVideo = false;

        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);
    },

    /**
     * GetMems 203
     *
     * @param rt
     *            {to: , rtKey: , rtflag: , success(result), fail(error)}
     *
     * @param callback(from, rtcOptions)
     *
     *
     * @param WebRTCId
     * @param sessId
     * @param success(from,
     *            rtcOptions)
     *
     */
    getMems: function getMems(rt, WebRTCId, sessId, callback) {
        _logger.debug("getMems ...");

        var self = this;

        var rtcOptions = {
            data: {
                op: 203
            }
        };

        WebRTCId && (rtcOptions.data.WebRTCId = WebRTCId);
        sessId && (rtcOptions.data.sessId = sessId);

        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);
    },

    /**
     * SubC 205
     *
     * @param rt
     *            {to: , rtKey: , rtflag: , success(result), fail(error)}
     *
     * @param callback(from, rtcOptions)
     *
     *
     * @param sessId
     * @param rtcId
     * @param subS
     *            {memId:m001, rtcId:r001}
     *
     */
    subC: function subC(rt, sessId, rtcId, subS, callback) {
        _logger.debug("subC ...");

        var self = this;

        var rtcOptions = {
            data: {
                op: 205
            }
        };

        sessId && (rtcOptions.data.sessId = sessId);
        rtcId && (rtcOptions.data.rtcId = rtcId);
        subS && (rtcOptions.data.subS = subS);

        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);
    },

    /**
     * UsubC 206
     *
     * @param rt
     *            {to: , rtKey: , rtflag: , success(result), fail(error)}
     *
     * @param callback(from, rtcOptions)
     *
     *
     * @param sessId
     * @param rtcId
     *
     */
    usubC: function usubC(rt, sessId, rtcId, callback) {
        _logger.debug("usubC ...");

        var self = this;

        var rtcOptions = {
            data: {
                op: 206
            }
        };

        sessId && (rtcOptions.data.sessId = sessId);
        rtcId && (rtcOptions.data.rtcId = rtcId);

        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);
    },

    /**
     * TermC 107
     *
     * @param rt
     *            {to: , rtKey: , rtflag: , success(result), fail(error)}
     *
     * @param callback(from, rtcOptions)
     *
     *
     * @param sessId
     * @param rtcId
     * @param reason
     *               "ok"      -> 'HANGUP'     "success" -> 'HANGUP'   "timeout"          -> 'NORESPONSE'
     *               "decline" -> 'REJECT'     "busy"    -> 'BUSY'     "failed-transport" -> 'FAIL'
     *
     */
    termC: function termC(rt, sessId, rtcId, reason, callback) {
        _logger.debug("termC ...");

        var self = this;

        var rtcOptions = {
            data: {
                op: 107,
                reason: reason
            }
        };

        sessId && (rtcOptions.data.sessId = sessId);
        rtcId && (rtcOptions.data.rtcId = rtcId);
        reason && (rtcOptions.reason = reason);

        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);
    },

    /**
     * Exit 201
     *
     * @param rt
     *            {to: , rtKey: , rtflag: , success(result), fail(error)}
     *
     * @param callback(from, rtcOptions)
     *
     *
     * @param WebRTCId
     * @param sessId
     * @param success(from,
     *            rtcOptions)
     *
     */
    exit: function exit(rt, WebRTCId, sessId, callback) {
        _logger.debug("exit ...");

        var self = this;

        var rtcOptions = {
            data: {
                op: 201
            }
        };

        WebRTCId && (rtcOptions.data.WebRTCId = WebRTCId);
        sessId && (rtcOptions.data.sessId = sessId);

        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);
    },

    /**
     * DelCfr 2
     *
     * @param rt
     *            {to: , rtKey: , rtflag: , success(result), fail(error)}
     *
     * @param callback(from, rtcOptions)
     *
     *
     * @param WebRTCId
     * @param admtok
     * @param success(from,
     *            rtcOptions)
     *
     */
    delCfr: function delCfr(rt, WebRTCId, admtok, callback) {
        _logger.debug("delCfr ...");

        var self = this;

        var rtcOptions = {
            data: {
                op: 2
            }
        };

        WebRTCId && (rtcOptions.data.WebRTCId = WebRTCId);
        admtok && (rtcOptions.data.admtok = admtok);

        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);
    }
};

exports.Api = function (initConfigs) {
    var self = this;

    _util.extend(true, this, _clazz, initConfigs || {});

    function _onRecvRtcMessage(from, rtcOptions, rtkey, tsxId, fromSessionId) {
        if (rtcOptions.result != 0 && self['onServerError']) {
            self['onServerError'].call(self, from, rtcOptions, rtkey, tsxId, fromSessionId);
        } else {
            var onFunction;

            if (self.events[rtcOptions.op] && (onFunction = self[self.events[rtcOptions.op]])) {
                onFunction.call(self, from, rtcOptions, rtkey, tsxId, fromSessionId);
            } else {
                _logger.info("can not handle(recvRtcMessage) the op: " + rtcOptions.op, rtcOptions);
            }
        }
    }

    this.rtcHandler.onRecvRtcMessage = _onRecvRtcMessage;
};

/***/ }),
/* 445 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _easemobEmedia = __webpack_require__(71);

_easemobEmedia.Webrtc.prototype.AVPubstream = _easemobEmedia.Service.prototype.AVPubstream;

_easemobEmedia.Webrtc.prototype._openCamera = function () {
    _easemobEmedia.Service.prototype._openCamera.apply(this, arguments);
};
_easemobEmedia.Webrtc.prototype.__getUserMedia = function () {
    _easemobEmedia.Service.prototype.__getUserMedia.apply(this, arguments);
};
_easemobEmedia.Webrtc.prototype.__controlStream = function () {
    _easemobEmedia.Service.prototype.__controlStream.apply(this, arguments);
};
_easemobEmedia.Webrtc.prototype.__sysGetUserMedia = function () {
    _easemobEmedia.Service.prototype.__sysGetUserMedia.apply(this, arguments);
};
_easemobEmedia.Webrtc.prototype._onStreamInactive = function _onStreamInactive(mediaStream, event) {
    _easemobEmedia.util.logger.warn("media stream inactive. it =", mediaStream.id);
};
_easemobEmedia.Webrtc.prototype._onStreamActive = function _onStreamActive(mediaStream, event) {
    _easemobEmedia.util.logger.warn("media stream active. it =", mediaStream.id);
};
//callback (rtc, stream)
_easemobEmedia.Webrtc.prototype.createMedia = function (constaints, callback) {
    var self = this;

    var pubS = new self.AVPubstream({
        constaints: constaints,
        aoff: 0,
        voff: 0
    });

    var openUserMedia = _easemobEmedia.Service.prototype.openUserMedia.bind(this);
    openUserMedia(pubS).then(function (_service, stream) {
        WebIM.__alreadyOpenMedias.push(stream);
        // stream.getTracks().forEach(function (track) {
        //     console.error(track);
        // });
        callback && callback(self, stream);
    }, function fail(evt) {
        _easemobEmedia.util.logger.debug('[WebRTC-API] getUserMedia() error: ', evt);
        self.onError(evt);
    });
};

var _createMedia;
_easemobEmedia.Webrtc.prototype.createMedia = _createMedia = function createMedia(constaints, callback) {
    var self = this;

    var mediaStream = new MediaStream();

    function __callback() {
        if (--__callback.count === 0) {
            WebIM.__alreadyOpenMedias.push(mediaStream);
            callback && callback(self, mediaStream);
        }
    }

    function __cloneTrack(destStream) {
        destStream && destStream.getTracks().forEach(function (track) {
            mediaStream.addTrack(track);
        });
    }

    var audio = !constaints || constaints.audio;
    var video = !constaints || constaints.video;

    if (!audio && !video) {
        __callback.count = 0;
        return __callback();
    }

    if (!!audio && !!video) {
        //两个true
        __callback.count = 2;
        _createMedia.call(this, { video: constaints.video, audio: false }, function (obj, stream) {
            __cloneTrack(stream);
            __callback();
        });
        _createMedia.call(this, { video: false, audio: constaints.audio }, function (obj, stream) {
            __cloneTrack(stream);
            __callback();
        });

        return;
    }

    __callback.count = 1;

    var pubS = new self.AVPubstream({
        constaints: constaints
    });

    var openUserMedia = _easemobEmedia.Service.prototype.openUserMedia.bind(this);
    openUserMedia(pubS).then(function (_service, stream) {
        // stream.getTracks().forEach(function (track) {
        //     console.error(track.getSettings());
        // });
        __cloneTrack(stream);
        __callback();
    }, function fail(evt) {
        __callback();
        _easemobEmedia.util.logger.debug('[WebRTC-API] getUserMedia() error: ', evt);

        if (typeof evt.message === 'function') {
            evt.message = evt.message();
        } else if (typeof evt.message === 'string' && evt.message !== "") {
            evt.message = evt.message;
        } else {
            evt.message = "open media error. " + evt.name;
        }

        evt.message = evt.message + " when get " + (video ? "carma" : "microphone");

        self.onError(evt);
    });
};

_easemobEmedia.Webrtc.prototype.setLocalVideoSrcObject = function (stream) {
    var self = this;

    self._localStream = stream;

    self.onGotLocalStream(stream, this.streamType);
    self.setLocalStream(stream);

    _easemobEmedia.util.logger.debug('[WebRTC-API] you can see yourself !');
};

var _setRemoteDescription = _easemobEmedia.Webrtc.prototype.setRemoteDescription;
_easemobEmedia.Webrtc.prototype.setRemoteDescription = function (desc) {
    var self = this;

    if (self.streamType === "VOICE") {
        //将remote sdp中 video中改为 a=mid:video -》 a=sendrecv|a=sendonly--recvonly
        var videoSectionReplace = function videoSectionReplace(regx, use) {
            var videoSectionIndex = desc.sdp.indexOf("m=video");
            var audioSectionIndex = desc.sdp.indexOf("m=audio");
            var end = audioSectionIndex > videoSectionIndex ? audioSectionIndex : desc.sdp.length;

            desc.sdp = desc.sdp.replace(regx, function (match, offset, string) {
                if (offset >= videoSectionIndex && offset < end) {
                    return use;
                } else {
                    return match;
                }
            });
        };

        videoSectionReplace(/a=sendrecv|a=sendonly/g, "a=inactive");
    }
    return _setRemoteDescription.call(self, desc);
};

exports.default = _easemobEmedia.Webrtc;

/***/ }),
/* 446 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * P2P
 */
var _util = __webpack_require__(70).default;
var RouteTo = __webpack_require__(444).RouteTo;
var _logger = _util.logger;

var P2PRouteTo = RouteTo({
    success: function success(result) {
        _logger.debug("iq to server success", result);
    },
    fail: function fail(error) {
        _logger.debug("iq to server error", error);
    }
});

var CommonPattern = {
    _pingIntervalId: null,
    _p2pConfig: null,
    _rtcCfg: null,
    _rtcCfg2: null,
    _rtKey: null,
    _rtFlag: null,

    webRtc: null,
    api: null,

    callee: null,

    isCaller: false,
    accepted: false,

    setLocalSDP: false,
    setRemoteSDP: false,

    hangup: false,

    init: function init() {
        var self = this;
        self.api.onPing = function () {
            self._onPing.apply(self, arguments);
        };
        self.api.onTcklC = function () {
            self._onTcklC.apply(self, arguments);
        };
        self.api.onAcptC = function () {
            self._onAcptC.apply(self, arguments);
        };
        self.api.onAnsC = function () {
            self._onAnsC.apply(self, arguments);
        };
        self.api.onTermC = function () {
            self._onTermC.apply(self, arguments);
        };
        self.api.onEvJoin = function () {
            self._onEvJoin.apply(self, arguments);
        };
        self.api.onStreamControl = function () {
            self._onStreamControl.apply(self, arguments);
        };
        self.webRtc.onIceCandidate = function () {
            self._onIceCandidate.apply(self, arguments);
        };
        self.webRtc.onIceStateChange = function () {
            self._onIceStateChange.apply(self, arguments);
        };
    },

    _ping: function _ping() {
        var self = this;

        var index = 0;

        function ping() {
            var rt = new P2PRouteTo({
                to: self.callee,
                rtKey: self._rtKey
            });

            self.api.ping(rt, self._sessId, function (from, rtcOptions) {
                _logger.debug("ping result", rtcOptions);
            });
            // self.api.streamControl(rt, self._sessId, "rtcId", (index++) % 4, function (from, rtcOptions) {
            //     _logger.debug("streamControl result", rtcOptions);
            //
            // });
        }

        self._pingIntervalId = window.setInterval(ping, 50000);
    },

    _onPing: function _onPing(from, options, rtkey, tsxId, fromSid) {
        _logger.debug('_onPing from', fromSid);
    },

    initC: function initC(mediaStreamConstaints, accessSid) {
        var self = this;
        self.sid = accessSid;

        self.isCaller = true;
        self.accepted = false;
        self.setLocalSDP = false;
        self.setRemoteSDP = false;
        self.hangup = false;

        self.streamType = mediaStreamConstaints.audio && mediaStreamConstaints.video ? "VIDEO" : "VOICE";

        self.createLocalMedia(mediaStreamConstaints);
    },

    createLocalMedia: function createLocalMedia(mediaStreamConstaints) {
        var self = this;
        this.webRtc.createMedia(mediaStreamConstaints, function (webrtc, stream) {
            self.webRtc.createRtcPeerConnection(self._rtcCfg);

            webrtc.setLocalVideoSrcObject(stream);
            webrtc.localStream = stream;

            self.webRtc.createOffer(function (offer) {
                self._onGotWebRtcOffer(offer);
            });
        });
    },

    _onGotWebRtcOffer: function _onGotWebRtcOffer(offer) {
        var self = this;

        var rt = new P2PRouteTo({
            //sid: self.sid,
            to: self.callee,
            rtKey: self._rtKey
        });

        self.api.initC(rt, self.streamType, null, null, self._sessId, self._rtcId, null, null, offer, null, self._rtcCfg2, null, function (from, rtcOptions) {
            _logger.debug("initc result", rtcOptions);
        });

        self.setLocalSDP = true;

        self._ping();
    },

    _onAcptC: function _onAcptC(from, options) {
        var self = this;
        if (options.ans && options.ans == 1) {
            _logger.info("[WebRTC-API] _onAcptC : 104, ans = 1, it is a answer. will onAcceptCall");
            self.onAcceptCall(from, options, options.enableVoice !== false, options.enableVideo !== false);
            self._onAnsC(from, options);
        } else if (!WebIM.WebRTC.supportPRAnswer) {
            _logger.info("[WebRTC-API] _onAcptC : not supported pranswer. drop it. will onAcceptCall");

            self.setRemoteSDP = false;
            self._handRecvCandsOrSend(from, options);

            self.onAcceptCall(from, options, options.enableVoice !== false, options.enableVideo !== false);
        } else {
            _logger.info("[WebRTC-API] _onAcptC : recv pranswer. ");

            if (options.sdp || options.cands) {
                // options.sdp && (options.sdp.type = "pranswer");
                options.sdp && self.webRtc.setRemoteDescription(options.sdp);

                self.setRemoteSDP = true;
                self._handRecvCandsOrSend(from, options);

                self.onAcceptCall(from, options, options.enableVoice !== false, options.enableVideo !== false);
            }
        }
    },

    _onEvJoin: function _onEvJoin(from, options, rtkey, tsxId, fromSid) {
        var self = this;

        _logger.debug('_onEvJoin from', fromSid, from);

        self.onAcceptCall(from, options, options.enableVoice !== false, options.enableVideo !== false);
    },

    onAcceptCall: function onAcceptCall(from, options, enableVoice, enableVideo) {},

    __onVoiceOrVideo: function __onVoiceOrVideo(from, options, fromSid) {
        var self = this;

        options.enableVoice === false ? self.onOtherUserOpenVoice(from, false) : self.onOtherUserOpenVoice(from, true);
        options.enableVideo === false ? self.onOtherUserOpenVideo(from, false) : self.onOtherUserOpenVideo(from, true);
    },

    /*
     * { verison : MSYNC_V1, compress_algorimth : 0, command : SYNC, payload : { meta : { id : 2326, to : easemob-demo#chatdemoui_xyj002@easemob.com, ns : CONFERENCE, payload : { session_id : xyj0011494320598055, operation : MEDIA_REQUEST, peer_name : xyj001, route_flag : 1, route_key : --X--, content : {"op":400,"callVersion":"2.0.0","sessId":"128542826909667328","rtcId":"Channel1494320598056","tsxId":"1494320622866-6","controlType":0}, control_type : PAUSE_VOICE } } } }
     * PAUSE_VOICE(0, 0), RESUME_VOICE(1, 1), PAUSE_VIDEO(2, 2), RESUME_VIDEO(3, 3)
     *
     */
    _onStreamControl: function _onStreamControl(from, options, rtkey, tsxId, fromSid) {
        var self = this;
        var controlType = options.controlType;

        controlType === 0 && self.onOtherUserOpenVoice(from, false);
        controlType === 1 && self.onOtherUserOpenVoice(from, true);
        controlType === 2 && self.onOtherUserOpenVideo(from, false);
        controlType === 3 && self.onOtherUserOpenVideo(from, true);

        self.onStreamControl(from, options, rtkey, tsxId, fromSid);
    },
    onStreamControl: function onStreamControl(from, options, rtkey, tsxId, fromSid) {},

    onOtherUserOpenVoice: function onOtherUserOpenVoice(from, opened) {
        _logger.debug("from open:", opened, " voice .", from);
    },
    onOtherUserOpenVideo: function onOtherUserOpenVideo(from, opened) {
        _logger.debug("from open:", opened, " voideo .", from);
    },

    _onAnsC: function _onAnsC(from, options) {
        // answer
        var self = this;
        _logger.info("[WebRTC-API] _onAnsC : recv answer. ");

        self.accepted = true;

        options.sdp && self.webRtc.setRemoteDescription(options.sdp);

        self.setRemoteSDP = true;
        self._handRecvCandsOrSend(from, options);

        self.__onVoiceOrVideo(from, options);
    },

    _onInitC: function _onInitC(from, options, rtkey, tsxId, fromSid) {
        var self = this;

        self.isCaller = false;
        self.accepted = false;
        self.setLocalSDP = false;
        self.setRemoteSDP = false;
        self.hangup = false;

        self.callee = from;
        self._rtcCfg2 = options.rtcCfg;
        self._rtKey = rtkey;
        self._tsxId = tsxId;
        self._fromSid = fromSid;

        self._rtcId = options.rtcId;
        self._sessId = options.sessId;

        self.streamType = options.streamType;
        self.globalMediaConstaints = options.globalMediaConstaints;

        self.webRtc.createRtcPeerConnection(self._rtcCfg2);

        self.callerNotPranswer = options.expr === 0;
        _logger.warn("caller not pranswer ", self.callerNotPranswer);

        options.sdp && _logger.debug(options.sdp.sdp);

        options.sdp && self.webRtc.setRemoteDescription(options.sdp).then(function () {

            self.setRemoteSDP = true;
            self._handRecvCandsOrSend(from, options);

            /*
             * chrome 版本 大于 50时，可以使用pranswer。
             * 小于50 不支持pranswer，此时处理逻辑是，直接进入振铃状态
             *
             */
            if (WebIM.WebRTC.supportPRAnswer) {
                self.webRtc.createPRAnswer(function (prAnswer) {
                    self._onGotWebRtcPRAnswer(prAnswer);

                    setTimeout(function () {
                        //由于 chrome 在 pranswer时，ice状态只是 checking，并不能像sdk那样 期待 connected 振铃；所以目前改为 发送完pranswer后，直接振铃
                        _logger.info("[WebRTC-API] onRinging : after send pranswer. ", self.callee);
                        self.onRinging(self.callee, self.streamType);
                    }, 500);
                });
            } else {
                setTimeout(function () {
                    _logger.info("[WebRTC-API] onRinging : After iniC, cause by: not supported pranswer. ", self.callee);
                    self.onRinging(self.callee, self.streamType);
                }, 500);
                self._ping();
            }
        });
    },

    _onGotWebRtcPRAnswer: function _onGotWebRtcPRAnswer(prAnswer) {
        var self = this;

        var rt = new P2PRouteTo({
            //tsxId: self._tsxId,
            to: self.callee,
            rtKey: self._rtKey
        });

        //self.api.acptC(rt, self._sessId, self._rtcId, prAnswer, null, 1);
        self.api.acptC(rt, self._sessId, self._rtcId, prAnswer);

        self.setLocalSDP = true;
        self._handRecvCandsOrSend();

        self._ping();
    },

    onRinging: function onRinging(caller, streamType) {},

    accept: function accept() {
        var self = this;

        function createAndSendAnswer() {
            _logger.info("createAndSendAnswer : ...... ");

            self.webRtc.createAnswer(function (answer) {
                var rt = new P2PRouteTo({
                    //tsxId: self._tsxId,
                    to: self.callee,
                    rtKey: self._rtKey
                });

                if (WebIM.WebRTC.supportPRAnswer) {
                    if (self.webRtc.isConnected() || self.callerNotPranswer) {
                        _logger.info("[WebRTC-API] ice connected or caller not pranswer, may send answer");
                        self.api.ansC(rt, self._sessId, self._rtcId, answer);
                    } else {
                        _logger.info("[WebRTC-API] ice state not connected, send answer waiting.");
                        self.webRtc._hookWhenICEReady = function () {
                            _logger.info("[WebRTC-API] ice connected, send answer");
                            self.api.ansC(rt, self._sessId, self._rtcId, answer);
                        };
                    }
                } else {
                    self.api.acptC(rt, self._sessId, self._rtcId, answer, null, 1);
                }

                if (!WebIM.WebRTC.supportPRAnswer) {
                    self.setLocalSDP = true;
                }
                self._handRecvCandsOrSend();

                self.accepted = true;
            });
        }

        var constaints = {
            audio: self.globalMediaConstaints && self.globalMediaConstaints.audio || true
        };
        if (self.streamType == "VIDEO") {
            constaints.video = self.globalMediaConstaints && self.globalMediaConstaints.video || true;
        }

        self.webRtc.createMedia(constaints, function (webrtc, stream) {
            webrtc.setLocalVideoSrcObject(stream);

            createAndSendAnswer();
        });
    },

    _handRecvCandsOrSend: function _handRecvCandsOrSend(from, options) {
        var self = this;

        setTimeout(function () {
            self._onTcklC(from, options);
        }, 50);

        setTimeout(function () {
            self._onIceCandidate();
        }, 50);
    },

    _onTcklC: function _onTcklC(from, options) {
        // setRemoteSDP，才可以添加 添加 对方 cands
        var self = this;

        // options.sdp && self.webRtc.setRemoteDescription(options.sdp);
        if (self.setRemoteSDP) {
            _logger.info("[WebRTC-API] recv and add cands.");

            self._recvCands && self._recvCands.length > 0 && self.webRtc.addIceCandidate(self._recvCands);
            self._recvCands && self._recvCands.length > 0 && (self._recvCands = []);
            options && options.cands && self.webRtc.addIceCandidate(options.cands);
        } else if (options && options.cands && options.cands.length > 0) {
            for (var i = 0; i < options.cands.length; i++) {
                (self._recvCands || (self._recvCands = [])).push(options.cands[i]);
            }
            _logger.debug("[_onTcklC] temporary memory[recv] ice candidate. util setRemoteSDP = true");
        }
    },

    _onIceStateChange: function _onIceStateChange(iceState) {
        var self = this;
        _logger.debug("[WebRTC-API] ice state is " + iceState);

        if (self.webRtc.isConnected()) {
            //出发hook
            self.webRtc._hookWhenICEReady && self.webRtc._hookWhenICEReady();
            self.webRtc._hookWhenICEReady = undefined;
        }

        if (iceState === "closed") {
            self.setLocalSDP = false;
            self.setRemoteSDP = false;
        }

        self.api.onIceConnectionStateChange(iceState);
    },

    _onIceCandidate: function _onIceCandidate(_candidate) {
        //在本地sdp set 发送完成后，发送 cands
        var self = this;

        if (self.setLocalSDP) {
            var sendIceCandidate = function sendIceCandidate(candidate) {

                _logger.debug("send ice candidate...");

                var rt = new P2PRouteTo({
                    to: self.callee,
                    rtKey: self._rtKey
                });

                if (candidate) {
                    self.api.tcklC(rt, self._sessId, self._rtcId, null, candidate);
                }
            };

            if (self._cands && self._cands.length > 0) {

                sendIceCandidate(self._cands);

                self._cands = [];
            }
            _candidate && sendIceCandidate(_candidate);
        } else {
            _candidate && (self._cands || (self._cands = [])).push(_candidate);
            _logger.debug("[_onIceCandidate] temporary memory[send] ice candidate. util setLocalSDP = true");
        }
    },

    __termCall1: function __termCall1(reason) {
        var self = this;

        self._pingIntervalId && window.clearInterval(self._pingIntervalId);

        var rt = new P2PRouteTo({
            to: self.callee,
            rtKey: self._rtKey
        });

        var sendReason;
        reason || !self.isCaller && !self.accepted && (sendReason = 'decline') || (sendReason = 'success');

        self.hangup || self.api.termC(rt, self._sessId, self._rtcId, sendReason);

        self.webRtc.close();

        self.hangup = true;

        self.setLocalSDP = false;
        self.setRemoteSDP = false;

        self.onTermCall(reason);
    },

    termCall: function termCall(reason) {
        var self = this;
        try {
            self.__termCall1(reason);
        } finally {
            if (WebIM.__alreadyOpenMedias && WebIM.__alreadyOpenMedias.length > 0) {
                for (var index in WebIM.__alreadyOpenMedias) {
                    var stream = WebIM.__alreadyOpenMedias[index];
                    try {
                        emedia.stopTracks(stream);
                    } catch (e) {}
                }

                WebIM.__alreadyOpenMedias = [];
            }
        }
    },

    /**
     *
     * @param from
     * @param options
     * @param options.reason
     *               "ok"      -> 'HANGUP'     "success" -> 'HANGUP'   "timeout"          -> 'NORESPONSE'
     *               "decline" -> 'REJECT'     "busy"    -> 'BUSY'     "failed-transport" -> 'FAIL'
     * @private
     */
    _onTermC: function _onTermC(from, options) {
        _logger.debug("[_onTermC] options.reason = " + options.reason);

        var self = this;

        self.hangup = true;

        self.setLocalSDP = false;
        self.setRemoteSDP = false;

        self.termCall(options.reason);
    },

    onTermCall: function onTermCall() {
        //to be overwrited by call.listener.onTermCall
    }
};

module.exports = function (initConfigs) {
    var self = this;

    _util.extend(true, this, CommonPattern, initConfigs || {});

    self.init();
};

/**
 * TODO: Conference
 */

/***/ }),
/* 447 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _regenerator = __webpack_require__(448);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(451);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _classCallCheck2 = __webpack_require__(474);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(475);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * GetStats 用来获取 peerconnection stats
 * 可以通过 stats 来判断网络状态
 * call 1v1 的通话类， 获取回调函数 必须
 * peerconnection 必须
*/

var GetStats = function () {
    function GetStats(peerconnection, call, interval) {
        (0, _classCallCheck3.default)(this, GetStats);

        this.peerconnection = peerconnection;
        this.interval = interval;
        this.call = call;

        // 临时存储对象，用于计算码率和网络断开
        this.temp_storage_obj = {
            KBps: {
                /**
                 * prev KBps 相关值
                 * audio: {
                 *  local:{bytes, time},
                 *  remote: {bytes, time}
                 * }
                 * video: {
                 *  local:{bytes, time},
                 *  remote: {bytes, time}
                 * }
                */
            },
            network_disconnect: {
                threshold: 3000,
                no_data_time: { // 检测连续多长时间没数据， 达到 threshold，即为断网
                    local: 0,
                    remote: 0
                }
            }
        };

        this.local_nw_dis_Tiped = false; // 断网只提示一次
        this.remote_nw_dis_Tiped = false;
    }

    (0, _createClass3.default)(GetStats, [{
        key: 'start',
        value: function start() {
            var _this = this;
            this.timer = setInterval(function () {
                _this._get();
            }, _this.interval || 2000);
        }
    }, {
        key: '_get',
        value: function () {
            var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
                var stats, format_stats, _this;

                return _regenerator2.default.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                _context.next = 2;
                                return this.peerconnection.getStats(null);

                            case 2:
                                stats = _context.sent;
                                format_stats = this.format_stats(stats);
                                _this = this;

                                ['local', 'remote'].map(function (item) {
                                    // 分别监听 local 和 remote 
                                    var network_disconnect = _this._network_disconnect(item, format_stats);

                                    if (network_disconnect && !_this[item + '_nw_dis_Tiped']) {
                                        var callback = _this.call.listener.onNetWorkDisconnect;
                                        _this[item + '_nw_dis_Tiped'] = true;

                                        if (callback && typeof callback == 'function') {
                                            callback(item);
                                        }
                                    }
                                });

                            case 6:
                            case 'end':
                                return _context.stop();
                        }
                    }
                }, _callee, this);
            }));

            function _get() {
                return _ref.apply(this, arguments);
            }

            return _get;
        }()
    }, {
        key: 'stop',
        value: function stop() {
            if (this.timer) {
                clearInterval(this.timer);
                this.timer = null;
            }
            this.peerconnection = null;
            this.interval = null;

            // 临时存储对象，用于计算码率和网络断开
            this.temp_storage_obj = {
                KBps: {},
                network_disconnect: {
                    threshold: 5000,
                    no_data_time: {
                        local: 0,
                        remote: 0
                    }
                }
            };
        }
    }, {
        key: 'format_stats',
        value: function format_stats(stats) {
            if (!stats) {
                return stats;
            }

            // stats type: Array
            var _this = this;
            var _o = {};
            stats.forEach(function (report) {

                var kind = void 0,
                    end_type = void 0,
                    bytes = void 0,
                    time = void 0;

                if (report.type == 'outbound-rtp') {
                    // 上行
                    kind = report.kind, end_type = 'local', bytes = report.bytesSent, time = Math.round(report.timestamp);
                }
                if (report.type == 'inbound-rtp') {
                    // 下行
                    kind = report.kind, end_type = 'remote', bytes = report.bytesReceived, time = Math.round(report.timestamp);
                }

                // 计算码率 local_audioKBps、local_videoKBps、remote_audioKBps、remote_videoKBps;

                if (kind && end_type && bytes != undefined && time) {
                    _o[end_type + '_' + kind + 'KBps'] = _this._get_KBps(end_type, kind, bytes, time);

                    if (!_this.temp_storage_obj['KBps'][kind]) {
                        _this.temp_storage_obj['KBps'][kind] = {};
                    }

                    _this.temp_storage_obj['KBps'][kind][end_type] = { // 存储临时值
                        bytes: bytes,
                        time: time
                    };
                }
            });
            _o.time = new Date().getTime();
            return _o;
        }
        // 通过和上一次的字节比较 计算码率 通过 sId

    }, {
        key: '_get_KBps',
        value: function _get_KBps(end_type, kind, bytes, time) {

            if (!end_type || !kind || !bytes) {
                return 0;
            }

            var prev_info = this.temp_storage_obj['KBps'][kind];

            if (!prev_info || !prev_info[end_type]) {
                // 首次或者 没有
                return 0;
            }

            var _prev_info$end_type = prev_info[end_type],
                prev_time = _prev_info$end_type.time,
                prev_bytes = _prev_info$end_type.bytes;


            var interval = parseInt(time - prev_time); // 时间间隔 ms

            var increment = bytes - prev_bytes;

            if (increment < 0) {
                // 这种情况出现在 开启摄像头， 直接置为 0 
                increment = 0;
            }

            var bytes_rate = increment / (interval / 1000).toFixed(2); // 以 S 为单位

            return bytes_rate / 1000; // KBps
        }

        // 检测网络连接断开 end_type : local || remote，必须

    }, {
        key: '_network_disconnect',
        value: function _network_disconnect(end_type, _o) {
            if (!end_type) {
                return false;
            }

            var threshold = this.temp_storage_obj['network_disconnect'].threshold,
                no_data_time = this.temp_storage_obj['network_disconnect']['no_data_time'],
                prev_time = no_data_time[end_type];


            var audioKBps = _o[end_type + '_audioKBps'],
                videoKBps = _o[end_type + '_videoKBps'],
                time = _o.time;

            if (audioKBps || videoKBps) {
                no_data_time[end_type] = 0; // 重新开始计算
                return false;
            }

            if (prev_time == 0) {
                // KBps 都为0，而且是第一次 都为0
                no_data_time[end_type] = time;
                return false;
            }

            if (time - prev_time >= threshold) {
                // 已经断网
                no_data_time[end_type] = 0; // 重新开始计算
                return true;
            }

            return false;
        }
    }]);
    return GetStats;
}();

module.exports = GetStats;

/***/ }),
/* 448 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(449);


/***/ }),
/* 449 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() { return this })() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = __webpack_require__(450);

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}


/***/ }),
/* 450 */
/***/ (function(module, exports) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() { return this })() || Function("return this")()
);


/***/ }),
/* 451 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _promise = __webpack_require__(452);

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (fn) {
  return function () {
    var gen = fn.apply(this, arguments);
    return new _promise2.default(function (resolve, reject) {
      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }

        if (info.done) {
          resolve(value);
        } else {
          return _promise2.default.resolve(value).then(function (value) {
            step("next", value);
          }, function (err) {
            step("throw", err);
          });
        }
      }

      return step("next");
    });
  };
};

/***/ }),
/* 452 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(453), __esModule: true };

/***/ }),
/* 453 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(67);
__webpack_require__(6);
__webpack_require__(50);
__webpack_require__(454);
__webpack_require__(472);
__webpack_require__(473);
module.exports = __webpack_require__(14).Promise;


/***/ }),
/* 454 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(11);
var global = __webpack_require__(13);
var ctx = __webpack_require__(15);
var classof = __webpack_require__(455);
var $export = __webpack_require__(12);
var isObject = __webpack_require__(20);
var aFunction = __webpack_require__(16);
var anInstance = __webpack_require__(456);
var forOf = __webpack_require__(457);
var speciesConstructor = __webpack_require__(461);
var task = __webpack_require__(462).set;
var microtask = __webpack_require__(464)();
var newPromiseCapabilityModule = __webpack_require__(465);
var perform = __webpack_require__(466);
var userAgent = __webpack_require__(467);
var promiseResolve = __webpack_require__(468);
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[__webpack_require__(47)('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __webpack_require__(469)($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__webpack_require__(46)($Promise, PROMISE);
__webpack_require__(470)(PROMISE);
Wrapper = __webpack_require__(14)[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(471)(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});


/***/ }),
/* 455 */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(37);
var TAG = __webpack_require__(47)('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),
/* 456 */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),
/* 457 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(15);
var call = __webpack_require__(458);
var isArrayIter = __webpack_require__(459);
var anObject = __webpack_require__(19);
var toLength = __webpack_require__(39);
var getIterFn = __webpack_require__(460);
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),
/* 458 */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(19);
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),
/* 459 */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(29);
var ITERATOR = __webpack_require__(47)('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),
/* 460 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(455);
var ITERATOR = __webpack_require__(47)('iterator');
var Iterators = __webpack_require__(29);
module.exports = __webpack_require__(14).getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),
/* 461 */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(19);
var aFunction = __webpack_require__(16);
var SPECIES = __webpack_require__(47)('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};


/***/ }),
/* 462 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(15);
var invoke = __webpack_require__(463);
var html = __webpack_require__(45);
var cel = __webpack_require__(24);
var global = __webpack_require__(13);
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (__webpack_require__(37)(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};


/***/ }),
/* 463 */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};


/***/ }),
/* 464 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(13);
var macrotask = __webpack_require__(462).set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(37)(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};


/***/ }),
/* 465 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 25.4.1.5 NewPromiseCapability(C)
var aFunction = __webpack_require__(16);

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),
/* 466 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};


/***/ }),
/* 467 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(13);
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';


/***/ }),
/* 468 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(19);
var isObject = __webpack_require__(20);
var newPromiseCapability = __webpack_require__(465);

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),
/* 469 */
/***/ (function(module, exports, __webpack_require__) {

var hide = __webpack_require__(17);
module.exports = function (target, src, safe) {
  for (var key in src) {
    if (safe && target[key]) target[key] = src[key];
    else hide(target, key, src[key]);
  } return target;
};


/***/ }),
/* 470 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(13);
var core = __webpack_require__(14);
var dP = __webpack_require__(18);
var DESCRIPTORS = __webpack_require__(22);
var SPECIES = __webpack_require__(47)('species');

module.exports = function (KEY) {
  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),
/* 471 */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(47)('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),
/* 472 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// https://github.com/tc39/proposal-promise-finally

var $export = __webpack_require__(12);
var core = __webpack_require__(14);
var global = __webpack_require__(13);
var speciesConstructor = __webpack_require__(461);
var promiseResolve = __webpack_require__(468);

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });


/***/ }),
/* 473 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-promise-try
var $export = __webpack_require__(12);
var newPromiseCapability = __webpack_require__(465);
var perform = __webpack_require__(466);

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });


/***/ }),
/* 474 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

/***/ }),
/* 475 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(476);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

/***/ }),
/* 476 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(477), __esModule: true };

/***/ }),
/* 477 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(478);
var $Object = __webpack_require__(14).Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};


/***/ }),
/* 478 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(12);
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(22), 'Object', { defineProperty: __webpack_require__(18).f });


/***/ })
/******/ ]);
});